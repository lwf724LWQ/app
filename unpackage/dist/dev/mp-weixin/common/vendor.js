"use strict";
function _mergeNamespaces(n2, m) {
  for (var i = 0; i < m.length; i++) {
    const e2 = m[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k in e2) {
        if (k !== "default" && !(k in n2)) {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          if (d) {
            Object.defineProperty(n2, k, d.get ? d : {
              enumerable: true,
              get: () => e2[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$3 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$3(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s2 = str ? `on${capitalize$1(str)}` : ``;
  return s2;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns$1 = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject$3(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$3(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$3(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$3(val) && !isArray$1(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;
};
const isObject$2 = (val) => val !== null && typeof val === "object";
const defaultDelimiters = ["{", "}"];
class BaseFormatter {
  constructor() {
    this._caches = /* @__PURE__ */ Object.create(null);
  }
  interpolate(message, values, delimiters = defaultDelimiters) {
    if (!values) {
      return [message];
    }
    let tokens = this._caches[message];
    if (!tokens) {
      tokens = parse$2(message, delimiters);
      this._caches[message] = tokens;
    }
    return compile$1(tokens, values);
  }
}
const RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
const RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;
function parse$2(format, [startDelimiter, endDelimiter]) {
  const tokens = [];
  let position2 = 0;
  let text2 = "";
  while (position2 < format.length) {
    let char = format[position2++];
    if (char === startDelimiter) {
      if (text2) {
        tokens.push({ type: "text", value: text2 });
      }
      text2 = "";
      let sub = "";
      char = format[position2++];
      while (char !== void 0 && char !== endDelimiter) {
        sub += char;
        char = format[position2++];
      }
      const isClosed = char === endDelimiter;
      const type = RE_TOKEN_LIST_VALUE.test(sub) ? "list" : isClosed && RE_TOKEN_NAMED_VALUE.test(sub) ? "named" : "unknown";
      tokens.push({ value: sub, type });
    } else {
      text2 += char;
    }
  }
  text2 && tokens.push({ type: "text", value: text2 });
  return tokens;
}
function compile$1(tokens, values) {
  const compiled = [];
  let index2 = 0;
  const mode2 = Array.isArray(values) ? "list" : isObject$2(values) ? "named" : "unknown";
  if (mode2 === "unknown") {
    return compiled;
  }
  while (index2 < tokens.length) {
    const token = tokens[index2];
    switch (token.type) {
      case "text":
        compiled.push(token.value);
        break;
      case "list":
        compiled.push(values[parseInt(token.value, 10)]);
        break;
      case "named":
        if (mode2 === "named") {
          compiled.push(values[token.value]);
        } else {
          {
            console.warn(`Type of token '${token.type}' and format of value '${mode2}' don't match!`);
          }
        }
        break;
      case "unknown":
        {
          console.warn(`Detect 'unknown' type of token!`);
        }
        break;
    }
    index2++;
  }
  return compiled;
}
const LOCALE_ZH_HANS = "zh-Hans";
const LOCALE_ZH_HANT = "zh-Hant";
const LOCALE_EN = "en";
const LOCALE_FR = "fr";
const LOCALE_ES = "es";
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const defaultFormatter = new BaseFormatter();
function include(str, parts) {
  return !!parts.find((part) => str.indexOf(part) !== -1);
}
function startsWith(str, parts) {
  return parts.find((part) => str.indexOf(part) === 0);
}
function normalizeLocale(locale, messages) {
  if (!locale) {
    return;
  }
  locale = locale.trim().replace(/_/g, "-");
  if (messages && messages[locale]) {
    return locale;
  }
  locale = locale.toLowerCase();
  if (locale === "chinese") {
    return LOCALE_ZH_HANS;
  }
  if (locale.indexOf("zh") === 0) {
    if (locale.indexOf("-hans") > -1) {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf("-hant") > -1) {
      return LOCALE_ZH_HANT;
    }
    if (include(locale, ["-tw", "-hk", "-mo", "-cht"])) {
      return LOCALE_ZH_HANT;
    }
    return LOCALE_ZH_HANS;
  }
  let locales = [LOCALE_EN, LOCALE_FR, LOCALE_ES];
  if (messages && Object.keys(messages).length > 0) {
    locales = Object.keys(messages);
  }
  const lang = startsWith(locale, locales);
  if (lang) {
    return lang;
  }
}
class I18n {
  constructor({ locale, fallbackLocale, messages, watcher, formater: formater2 }) {
    this.locale = LOCALE_EN;
    this.fallbackLocale = LOCALE_EN;
    this.message = {};
    this.messages = {};
    this.watchers = [];
    if (fallbackLocale) {
      this.fallbackLocale = fallbackLocale;
    }
    this.formater = formater2 || defaultFormatter;
    this.messages = messages || {};
    this.setLocale(locale || LOCALE_EN);
    if (watcher) {
      this.watchLocale(watcher);
    }
  }
  setLocale(locale) {
    const oldLocale = this.locale;
    this.locale = normalizeLocale(locale, this.messages) || this.fallbackLocale;
    if (!this.messages[this.locale]) {
      this.messages[this.locale] = {};
    }
    this.message = this.messages[this.locale];
    if (oldLocale !== this.locale) {
      this.watchers.forEach((watcher) => {
        watcher(this.locale, oldLocale);
      });
    }
  }
  getLocale() {
    return this.locale;
  }
  watchLocale(fn) {
    const index2 = this.watchers.push(fn) - 1;
    return () => {
      this.watchers.splice(index2, 1);
    };
  }
  add(locale, message, override = true) {
    const curMessages = this.messages[locale];
    if (curMessages) {
      if (override) {
        Object.assign(curMessages, message);
      } else {
        Object.keys(message).forEach((key) => {
          if (!hasOwn(curMessages, key)) {
            curMessages[key] = message[key];
          }
        });
      }
    } else {
      this.messages[locale] = message;
    }
  }
  f(message, values, delimiters) {
    return this.formater.interpolate(message, values, delimiters).join("");
  }
  t(key, locale, values) {
    let message = this.message;
    if (typeof locale === "string") {
      locale = normalizeLocale(locale, this.messages);
      locale && (message = this.messages[locale]);
    } else {
      values = locale;
    }
    if (!hasOwn(message, key)) {
      console.warn(`Cannot translate the value of keypath ${key}. Use the value of keypath as default.`);
      return key;
    }
    return this.formater.interpolate(message[key], values).join("");
  }
}
function watchAppLocale(appVm, i18n) {
  if (appVm.$watchLocale) {
    appVm.$watchLocale((newLocale) => {
      i18n.setLocale(newLocale);
    });
  } else {
    appVm.$watch(() => appVm.$locale, (newLocale) => {
      i18n.setLocale(newLocale);
    });
  }
}
function getDefaultLocale() {
  if (typeof index$2 !== "undefined" && index$2.getLocale) {
    return index$2.getLocale();
  }
  if (typeof global !== "undefined" && global.getLocale) {
    return global.getLocale();
  }
  return LOCALE_EN;
}
function initVueI18n(locale, messages = {}, fallbackLocale, watcher) {
  if (typeof locale !== "string") {
    const options = [
      messages,
      locale
    ];
    locale = options[0];
    messages = options[1];
  }
  if (typeof locale !== "string") {
    locale = getDefaultLocale();
  }
  if (typeof fallbackLocale !== "string") {
    fallbackLocale = typeof __uniConfig !== "undefined" && __uniConfig.fallbackLocale || LOCALE_EN;
  }
  const i18n = new I18n({
    locale,
    fallbackLocale,
    messages,
    watcher
  });
  let t2 = (key, values) => {
    if (typeof getApp !== "function") {
      t2 = function(key2, values2) {
        return i18n.t(key2, values2);
      };
    } else {
      let isWatchedAppLocale = false;
      t2 = function(key2, values2) {
        const appVm = getApp().$vm;
        if (appVm) {
          appVm.$locale;
          if (!isWatchedAppLocale) {
            isWatchedAppLocale = true;
            watchAppLocale(appVm, i18n);
          }
        }
        return i18n.t(key2, values2);
      };
    }
    return t2(key, values);
  };
  return {
    i18n,
    f(message, values, delimiters) {
      return i18n.f(message, values, delimiters);
    },
    t(key, values) {
      return t2(key, values);
    },
    add(locale2, message, override = true) {
      return i18n.add(locale2, message, override);
    },
    watch(fn) {
      return i18n.watchLocale(fn);
    },
    getLocale() {
      return i18n.getLocale();
    },
    setLocale(newLocale) {
      return i18n.setLocale(newLocale);
    }
  };
}
const SLOT_DEFAULT_NAME = "d";
const ON_SHOW = "onShow";
const ON_HIDE = "onHide";
const ON_LAUNCH = "onLaunch";
const ON_ERROR = "onError";
const ON_THEME_CHANGE = "onThemeChange";
const ON_PAGE_NOT_FOUND = "onPageNotFound";
const ON_UNHANDLE_REJECTION = "onUnhandledRejection";
const ON_EXIT = "onExit";
const ON_LOAD = "onLoad";
const ON_READY = "onReady";
const ON_UNLOAD = "onUnload";
const ON_INIT = "onInit";
const ON_SAVE_EXIT_STATE = "onSaveExitState";
const ON_RESIZE = "onResize";
const ON_BACK_PRESS = "onBackPress";
const ON_PAGE_SCROLL = "onPageScroll";
const ON_TAB_ITEM_TAP = "onTabItemTap";
const ON_REACH_BOTTOM = "onReachBottom";
const ON_PULL_DOWN_REFRESH = "onPullDownRefresh";
const ON_SHARE_TIMELINE = "onShareTimeline";
const ON_SHARE_CHAT = "onShareChat";
const ON_ADD_TO_FAVORITES = "onAddToFavorites";
const ON_SHARE_APP_MESSAGE = "onShareAppMessage";
const ON_NAVIGATION_BAR_BUTTON_TAP = "onNavigationBarButtonTap";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED = "onNavigationBarSearchInputClicked";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED = "onNavigationBarSearchInputChanged";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED = "onNavigationBarSearchInputConfirmed";
const ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED = "onNavigationBarSearchInputFocusChanged";
const VIRTUAL_HOST_STYLE = "virtualHostStyle";
const VIRTUAL_HOST_CLASS = "virtualHostClass";
const VIRTUAL_HOST_HIDDEN = "virtualHostHidden";
const VIRTUAL_HOST_ID = "virtualHostId";
function hasLeadingSlash(str) {
  return str.indexOf("/") === 0;
}
function addLeadingSlash(str) {
  return hasLeadingSlash(str) ? str : "/" + str;
}
const invokeArrayFns = (fns, arg) => {
  let ret;
  for (let i = 0; i < fns.length; i++) {
    ret = fns[i](arg);
  }
  return ret;
};
function once(fn, ctx = null) {
  let res;
  return (...args) => {
    if (fn) {
      res = fn.apply(ctx, args);
      fn = null;
    }
    return res;
  };
}
function getValueByDataPath(obj, path) {
  if (!isString(path)) {
    return;
  }
  path = path.replace(/\[(\d+)\]/g, ".$1");
  const parts = path.split(".");
  let key = parts[0];
  if (!obj) {
    obj = {};
  }
  if (parts.length === 1) {
    return obj[key];
  }
  return getValueByDataPath(obj[key], parts.slice(1).join("."));
}
function sortObject(obj) {
  let sortObj = {};
  if (isPlainObject$2(obj)) {
    Object.keys(obj).sort().forEach((key) => {
      const _key = key;
      sortObj[_key] = obj[_key];
    });
  }
  return !Object.keys(sortObj) ? obj : sortObj;
}
const customizeRE = /:/g;
function customizeEvent(str) {
  return camelize(str.replace(customizeRE, "-"));
}
const encode$1 = encodeURIComponent;
function stringifyQuery(obj, encodeStr = encode$1) {
  const res = obj ? Object.keys(obj).map((key) => {
    let val = obj[key];
    if (typeof val === void 0 || val === null) {
      val = "";
    } else if (isPlainObject$2(val)) {
      val = JSON.stringify(val);
    }
    return encodeStr(key) + "=" + encodeStr(val);
  }).filter((x) => x.length > 0).join("&") : null;
  return res ? `?${res}` : "";
}
const PAGE_HOOKS = [
  ON_INIT,
  ON_LOAD,
  ON_SHOW,
  ON_HIDE,
  ON_UNLOAD,
  ON_BACK_PRESS,
  ON_PAGE_SCROLL,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_SHARE_TIMELINE,
  ON_SHARE_APP_MESSAGE,
  ON_SHARE_CHAT,
  ON_ADD_TO_FAVORITES,
  ON_SAVE_EXIT_STATE,
  ON_NAVIGATION_BAR_BUTTON_TAP,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED
];
function isRootHook(name) {
  return PAGE_HOOKS.indexOf(name) > -1;
}
const UniLifecycleHooks = [
  ON_SHOW,
  ON_HIDE,
  ON_LAUNCH,
  ON_ERROR,
  ON_THEME_CHANGE,
  ON_PAGE_NOT_FOUND,
  ON_UNHANDLE_REJECTION,
  ON_EXIT,
  ON_INIT,
  ON_LOAD,
  ON_READY,
  ON_UNLOAD,
  ON_RESIZE,
  ON_BACK_PRESS,
  ON_PAGE_SCROLL,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_SHARE_TIMELINE,
  ON_ADD_TO_FAVORITES,
  ON_SHARE_APP_MESSAGE,
  ON_SHARE_CHAT,
  ON_SAVE_EXIT_STATE,
  ON_NAVIGATION_BAR_BUTTON_TAP,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED
];
const MINI_PROGRAM_PAGE_RUNTIME_HOOKS = /* @__PURE__ */ (() => {
  return {
    onPageScroll: 1,
    onShareAppMessage: 1 << 1,
    onShareTimeline: 1 << 2
  };
})();
function isUniLifecycleHook(name, value, checkType = true) {
  if (checkType && !isFunction(value)) {
    return false;
  }
  if (UniLifecycleHooks.indexOf(name) > -1) {
    return true;
  } else if (name.indexOf("on") === 0) {
    return true;
  }
  return false;
}
let vueApp;
const createVueAppHooks = [];
function onCreateVueApp(hook) {
  if (vueApp) {
    return hook(vueApp);
  }
  createVueAppHooks.push(hook);
}
function invokeCreateVueAppHook(app) {
  vueApp = app;
  createVueAppHooks.forEach((hook) => hook(app));
}
const invokeCreateErrorHandler = once((app, createErrorHandler2) => {
  return createErrorHandler2(app);
});
const E$1 = function() {
};
E$1.prototype = {
  _id: 1,
  on: function(name, callback, ctx) {
    var e2 = this.e || (this.e = {});
    (e2[name] || (e2[name] = [])).push({
      fn: callback,
      ctx,
      _id: this._id
    });
    return this._id++;
  },
  once: function(name, callback, ctx) {
    var self2 = this;
    function listener() {
      self2.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },
  emit: function(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function(name, event) {
    var e2 = this.e || (this.e = {});
    var evts = e2[name];
    var liveEvents = [];
    if (evts && event) {
      for (var i = evts.length - 1; i >= 0; i--) {
        if (evts[i].fn === event || evts[i].fn._ === event || evts[i]._id === event) {
          evts.splice(i, 1);
          break;
        }
      }
      liveEvents = evts;
    }
    liveEvents.length ? e2[name] = liveEvents : delete e2[name];
    return this;
  }
};
var E$1$1 = E$1;
/**
* @dcloudio/uni-mp-vue v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function warn$2(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else {
      warn$2(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else {
    warn$2(
      `onScopeDispose() is called when there is no active effect scope to be associated with.`
    );
  }
}
let activeEffect;
class ReactiveEffect {
  constructor(fn, trigger2, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i = 0; i < this._depsLength; i++) {
        const dep = this.deps[i];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v) {
    this._dirtyLevel = v ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    var _a;
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      (_a = this.onStop) == null ? void 0 : _a.call(this);
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
      cleanupDepEffect(effect2.deps[i], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  var _a;
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
    {
      (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
    }
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  var _a;
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      {
        (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
      }
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
const createDep = (cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep,
      {
        target,
        type,
        key
      }
    );
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$1(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4,
        {
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        }
      );
    }
  }
  resetScheduling();
}
function getDepFromReactive(object2, key) {
  var _a;
  return (_a = targetMap.get(object2)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$3(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$1(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    {
      warn$2(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    {
      warn$2(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get22 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get22.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get22 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get22 ? get22.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn$2(
        `${capitalize$1(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    warn$2(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$3(target)) {
    {
      warn$2(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
const COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      if (this._warnRecursive) {
        warn$2(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
      }
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v) {
    this.effect.dirty = v;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = () => {
      warn$2("Write operation failed: computed value is readonly");
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
function trackRefValue(ref2) {
  var _a;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      ),
      {
        target: ref2,
        type: "get",
        key: "value"
      }
    );
  }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel,
      {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      }
    );
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, 4, newVal);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object2) {
  if (!isProxy(object2)) {
    warn$2(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray$1(object2) ? new Array(object2.length) : {};
  for (const key in object2) {
    ret[key] = propertyToRef(object2, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$3(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        msg + args.map((a2) => {
          var _a, _b;
          return (_b = (_a = a2.toString) == null ? void 0 : _a.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props2) {
  const res = [];
  const keys = Object.keys(props2);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props2[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = ErrorTypeStrings[type] || type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    const info = ErrorTypeStrings[type] || type;
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      console.error(err);
    } else {
      console.error(err);
    }
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue$1 = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue$1.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue$1[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue$1.length || !queue$1.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function hasQueueJob(job) {
  return queue$1.indexOf(job) > -1;
}
function invalidateJob(job) {
  const i = queue$1.indexOf(job);
  if (i > flushIndex) {
    queue$1.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue$1.length; i++) {
    const cb = queue$1[i];
    if (cb && cb.pre) {
      if (checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue$1.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b) => getId(a2) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b) => {
  const diff2 = getId(a2) - getId(b);
  if (diff2 === 0) {
    if (a2.pre && !b.pre)
      return -1;
    if (b.pre && !a2.pre)
      return 1;
  }
  return diff2;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue$1.sort(comparator);
  const check = (job) => checkRecursiveUpdates(seen, job);
  try {
    for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job && job.active !== false) {
        if (check(job)) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue$1.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue$1.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit$1("app:init", app, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added"
  /* COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:updated"
  /* COMPONENT_UPDATED */
);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed"
  /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component) => {
  if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      // fixed by xxxxxx
      //  0  App parent  Page  App
      component.uid === 0 ? void 0 : component.parent ? component.parent.uid : 0,
      component
    );
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:start"
  /* PERFORMANCE_START */
);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:end"
  /* PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time2) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time2);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1(
    "component:emit",
    component.appContext.app,
    component,
    event,
    params
  );
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props2 = instance.vnode.props || EMPTY_OBJ;
  {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn$1(
            `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`
          );
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid2 = validator(...rawArgs);
          if (!isValid2) {
            warn$1(
              `Invalid event arguments: event validation failed for event "${event}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props2) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim: trim2 } = props2[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a2) => isString(a2) ? a2.trim() : a2);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  {
    devtoolsComponentEmit(instance, event, args);
  }
  {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props2[toHandlerKey(lowerCaseEvent)]) {
      warn$1(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
          event
        )}" instead of "${event}".`
      );
    }
  }
  let handlerName;
  let handler = props2[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props2[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props2[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props2[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$3(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
let currentRenderingInstance = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  instance && instance.type.__scopeId || null;
  return prev;
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component2 = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component2,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component2;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component2[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component2;
    }
    if (warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else {
    warn$1(
      `resolve${capitalize$1(type.slice(0, -1))} can only be used in render() or setup().`
    );
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (!isFunction(cb)) {
    warn$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once: once2,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once2) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      unwatch();
    };
  }
  if (deep !== void 0 && typeof deep === "number") {
    warn$1(
      `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
    );
  }
  if (!cb) {
    if (immediate !== void 0) {
      warn$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once2 !== void 0) {
      warn$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const warnInvalidSource = (s2) => {
    warn$1(
      `Invalid watch source: `,
      s2,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const instance = currentInstance;
  const reactiveGetter = (source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  );
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return reactiveGetter(s2);
      } else if (isFunction(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else {
        warnInvalidSource(s2);
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
    warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect2.onStop = void 0;
    };
  };
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active || !effect2.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect$1(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = () => {
    effect2.stop();
    if (scope) {
      remove(scope.effects, effect2);
    }
  };
  {
    effect2.onTrack = onTrack;
    effect2.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect$1(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments2 = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments2.length && cur; i++) {
      cur = cur[segments2[i]];
    }
    return cur;
  };
}
function traverse(value, depth, currentDepth = 0, seen) {
  if (!isObject$3(value) || value["__v_skip"]) {
    return value;
  }
  if (depth && depth > 0) {
    if (currentDepth >= depth) {
      return value;
    }
    currentDepth++;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, depth, currentDepth, seen);
  } else if (isArray$1(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, currentDepth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, currentDepth, seen);
    });
  } else if (isPlainObject$2(value)) {
    for (const key in value) {
      traverse(value[key], depth, currentDepth, seen);
    }
  }
  return value;
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$3(rootProps)) {
      warn$1(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$2,
      get config() {
        return context.config;
      },
      set config(v) {
        {
          warn$1(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2)) {
          warn$1(`Plugin has already been applied to target app.`);
        } else if (plugin2 && isFunction(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options);
        } else if (isFunction(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options);
        } else {
          warn$1(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          } else {
            warn$1(
              "Mixin has already been applied to target app" + (mixin2.name ? `: ${mixin2.name}` : "")
            );
          }
        }
        return app;
      },
      component(name, component) {
        {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (context.components[name]) {
          warn$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (context.directives[name]) {
          warn$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      // fixed by xxxxxx
      mount() {
      },
      // fixed by xxxxxx
      unmount() {
      },
      provide(key, value) {
        if (key in context.provides) {
          warn$1(
            `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
          );
        }
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) {
    {
      warn$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
    if (currentInstance.type.mpType === "app") {
      currentInstance.appContext.app.provide(key, value);
    }
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    if (isRootHook(type)) {
      target = target.root;
    }
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else {
    const apiName = toHandlerKey(
      (ErrorTypeStrings[type] || type.replace(/^on/, "")).replace(/ hook$/, "")
    );
    warn$1(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`
    );
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
function getComponentInternalInstance(i) {
  return i;
}
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    // fixed by xxxxxx
    $: getComponentInternalInstance,
    // fixed by xxxxxx vue-i18n  dev  $el
    // $el: i => i.vnode.el,
    $el: (i) => i.__$el || (i.__$el = {}),
    $data: (i) => i.data,
    $props: (i) => shallowReadonly(i.props),
    $attrs: (i) => shallowReadonly(i.attrs),
    $slots: (i) => shallowReadonly(i.slots),
    $refs: (i) => shallowReadonly(i.refs),
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      i.effect.dirty = true;
      queueJob(i.update);
    }),
    // $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy!)),// fixed by xxxxxx
    $watch: (i) => instanceWatch.bind(i)
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props: props2, accessCache, type, appContext } = instance;
    if (key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props2[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props2[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      } else if (key === "$slots") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn$1(data, key)) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn$1(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (setupState.__isScriptSetup && hasOwn$1(setupState, key)) {
      warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      warn$1(
        `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
      );
      return false;
    } else {
      if (key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
{
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function normalizePropsOrEmits(props2) {
  return isArray$1(props2) ? props2.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props2;
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions$1(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = createDuplicateChecker();
  {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  function initInjections() {
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
  }
  {
    initInjections();
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        }
        {
          checkDuplicateProperties("Methods", key);
        }
      } else {
        warn$1(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if (!isFunction(dataOptions)) {
      warn$1(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (isPromise$1(data)) {
      warn$1(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!isObject$3(data)) {
      warn$1(`data() should return an object.`);
    } else {
      instance.data = reactive(data);
      {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get22 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (get22 === NOOP) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
        warn$1(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      };
      const c2 = computed({
        get: get22,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v) => c2.value = v
      });
      {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  function initProvides() {
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
  }
  {
    initProvides();
  }
  {
    if (created) {
      callHook$1(created, instance, "c");
    }
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
  if (instance.ctx.$onApplyOptions) {
    instance.ctx.$onApplyOptions(options, instance, publicThis);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$3(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$3(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$3(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
      warn$1(
        `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
      );
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$1(to) && isArray$1(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to[key], from[key]);
  }
  return merged;
}
function initProps$1(instance, rawProps, isStateful, isSSR = false) {
  const props2 = {};
  const attrs = {};
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props2, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props2)) {
      props2[key] = void 0;
    }
  }
  {
    validateProps(rawProps || {}, props2, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props2 : shallowReactive(props2);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props2;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props: props2,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props2);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext() && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props2[camelizedKey] = resolvePropValue$1(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props2, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props2[key] = resolvePropValue$1(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props2[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  {
    validateProps(rawProps || {}, props2, instance);
  }
}
function setFullProps(instance, rawProps, props2, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props2[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props2);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props2[key] = resolvePropValue$1(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue$1(options, props2, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props2
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props2, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props2);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (!isString(raw[i])) {
        warn$1(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (!isObject$3(raw)) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$3(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  } else {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType$1(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function isSameType(a2, b) {
  return getType$1(a2) === getType$1(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$1(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props2, instance) {
  const resolvedValues = toRaw(props2);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp$1(
      key,
      resolvedValues[key],
      opt,
      shallowReadonly(resolvedValues),
      !hasOwn$1(rawProps, key) && !hasOwn$1(rawProps, hyphenate(key))
    );
  }
}
function validateProp$1(name, value, prop, props2, isAbsent) {
  const { type, required, validator, skipCheck } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid2 = false;
    const types = isArray$1(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid2; i++) {
      const { valid, expectedType } = assertType$1(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid2 = valid;
    }
    if (!isValid2) {
      warn$1(getInvalidTypeMessage$1(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value, props2)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType$1 = /* @__PURE__ */ makeMap(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function assertType$1(value, type) {
  let valid;
  const expectedType = getType$1(type);
  if (isSimpleType$1(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$3(value);
  } else if (expectedType === "Array") {
    valid = isArray$1(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage$1(name, value, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize$1).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue$1(value, expectedType);
  const receivedValue = styleValue$1(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable$1(expectedType) && !isBoolean$1(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable$1(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue$1(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable$1(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean$1(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
const queuePostRenderEffect$1 = queuePostFlushCb;
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
const InternalObjectKey = `__vInternal`;
function guardReactiveProps(props2) {
  if (!props2)
    return null;
  return isProxy(props2) || InternalObjectKey in props2 ? extend({}, props2) : props2;
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null,
    // fixed by xxxxxx uni-app
    $uniElements: /* @__PURE__ */ new Map(),
    $templateUniElementRefs: [],
    $templateUniElementStyles: {},
    $eS: {},
    $eA: {}
  };
  {
    instance.ctx = createDevRenderContext(instance);
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  internalSetCurrentInstance = (i) => {
    currentInstance = i;
  };
  setInSSRSetupState = (v) => {
    isInSSRComponentSetup = v;
  };
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const {
    props: props2
    /*, children*/
  } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps$1(instance, props2, isStateful, isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component2 = instance.type;
  {
    if (Component2.name) {
      validateComponentName(Component2.name, instance.appContext.config);
    }
    if (Component2.components) {
      const names = Object.keys(Component2.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component2.directives) {
      const names = Object.keys(Component2.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component2.compilerOptions && isRuntimeOnly()) {
      warn$1(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component2;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        shallowReadonly(instance.props),
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      {
        warn$1(
          `setup() returned a Promise, but the version of Vue you are using does not support it yet.`
        );
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    {
      instance.render = setupResult;
    }
  } else if (isObject$3(setupResult)) {
    if (isVNode(setupResult)) {
      warn$1(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (setupResult !== void 0) {
    warn$1(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component2 = instance.type;
  if (!instance.render) {
    instance.render = Component2.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions$1(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
  if (!Component2.render && instance.render === NOOP && !isSSR) {
    if (Component2.template) {
      warn$1(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      );
    } else {
      warn$1(`Component is missing template or render function.`);
    }
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      },
      set() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      }
    }
  ));
}
function getSlotsProxy(instance) {
  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  }));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    {
      if (instance.exposed) {
        warn$1(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray$1(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn$1(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  };
  {
    return Object.freeze({
      get attrs() {
        return getAttrsProxy(instance);
      },
      get slots() {
        return getSlotsProxy(instance);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        }
        return instance.proxy[key];
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component2, includeInferred = true) {
  return isFunction(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
}
function formatComponentName(instance, Component2, isRoot = false) {
  let name = getComponentName(Component2);
  if (!name && Component2.__file) {
    const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component2) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  {
    const i = getCurrentInstance();
    if (i && i.appContext.config.warnRecursiveComputed) {
      c2._warnRecursive = true;
    }
  }
  return c2;
};
const version$2 = "3.4.21";
const warn = warn$1;
function unwrapper(target) {
  return unref(target);
}
const ARRAYTYPE = "[object Array]";
const OBJECTTYPE = "[object Object]";
function diff(current, pre) {
  const result = {};
  syncKeys(current, pre);
  _diff(current, pre, "", result);
  return result;
}
function syncKeys(current, pre) {
  current = unwrapper(current);
  if (current === pre)
    return;
  const rootCurrentType = toTypeString(current);
  const rootPreType = toTypeString(pre);
  if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {
    for (let key in pre) {
      const currentValue = current[key];
      if (currentValue === void 0) {
        current[key] = null;
      } else {
        syncKeys(currentValue, pre[key]);
      }
    }
  } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {
    if (current.length >= pre.length) {
      pre.forEach((item, index2) => {
        syncKeys(current[index2], item);
      });
    }
  }
}
function _diff(current, pre, path, result) {
  current = unwrapper(current);
  if (current === pre)
    return;
  const rootCurrentType = toTypeString(current);
  const rootPreType = toTypeString(pre);
  if (rootCurrentType == OBJECTTYPE) {
    if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {
      setResult(result, path, current);
    } else {
      for (let key in current) {
        const currentValue = unwrapper(current[key]);
        const preValue = pre[key];
        const currentType = toTypeString(currentValue);
        const preType = toTypeString(preValue);
        if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {
          if (currentValue != preValue) {
            setResult(
              result,
              (path == "" ? "" : path + ".") + key,
              currentValue
            );
          }
        } else if (currentType == ARRAYTYPE) {
          if (preType != ARRAYTYPE) {
            setResult(
              result,
              (path == "" ? "" : path + ".") + key,
              currentValue
            );
          } else {
            if (currentValue.length < preValue.length) {
              setResult(
                result,
                (path == "" ? "" : path + ".") + key,
                currentValue
              );
            } else {
              currentValue.forEach((item, index2) => {
                _diff(
                  item,
                  preValue[index2],
                  (path == "" ? "" : path + ".") + key + "[" + index2 + "]",
                  result
                );
              });
            }
          }
        } else if (currentType == OBJECTTYPE) {
          if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {
            setResult(
              result,
              (path == "" ? "" : path + ".") + key,
              currentValue
            );
          } else {
            for (let subKey in currentValue) {
              _diff(
                currentValue[subKey],
                preValue[subKey],
                (path == "" ? "" : path + ".") + key + "." + subKey,
                result
              );
            }
          }
        }
      }
    }
  } else if (rootCurrentType == ARRAYTYPE) {
    if (rootPreType != ARRAYTYPE) {
      setResult(result, path, current);
    } else {
      if (current.length < pre.length) {
        setResult(result, path, current);
      } else {
        current.forEach((item, index2) => {
          _diff(item, pre[index2], path + "[" + index2 + "]", result);
        });
      }
    }
  } else {
    setResult(result, path, current);
  }
}
function setResult(result, k, v) {
  result[k] = v;
}
function hasComponentEffect(instance) {
  return queue$1.includes(instance.update);
}
function flushCallbacks(instance) {
  const ctx = instance.ctx;
  const callbacks = ctx.__next_tick_callbacks;
  if (callbacks && callbacks.length) {
    const copies = callbacks.slice(0);
    callbacks.length = 0;
    for (let i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }
}
function nextTick(instance, fn) {
  const ctx = instance.ctx;
  if (!ctx.__next_tick_pending && !hasComponentEffect(instance)) {
    return nextTick$1(fn && fn.bind(instance.proxy));
  }
  let _resolve;
  if (!ctx.__next_tick_callbacks) {
    ctx.__next_tick_callbacks = [];
  }
  ctx.__next_tick_callbacks.push(() => {
    if (fn) {
      callWithErrorHandling(
        fn.bind(instance.proxy),
        instance,
        14
      );
    } else if (_resolve) {
      _resolve(instance.proxy);
    }
  });
  return new Promise((resolve2) => {
    _resolve = resolve2;
  });
}
function clone$1(src, seen) {
  src = unwrapper(src);
  const type = typeof src;
  if (type === "object" && src !== null) {
    let copy = seen.get(src);
    if (typeof copy !== "undefined") {
      return copy;
    }
    if (isArray$1(src)) {
      const len = src.length;
      copy = new Array(len);
      seen.set(src, copy);
      for (let i = 0; i < len; i++) {
        copy[i] = clone$1(src[i], seen);
      }
    } else {
      copy = {};
      seen.set(src, copy);
      for (const name in src) {
        if (hasOwn$1(src, name)) {
          copy[name] = clone$1(src[name], seen);
        }
      }
    }
    return copy;
  }
  if (type !== "symbol") {
    return src;
  }
}
function deepCopy$1(src) {
  return clone$1(src, typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map());
}
function getMPInstanceData(instance, keys) {
  const data = instance.data;
  const ret = /* @__PURE__ */ Object.create(null);
  keys.forEach((key) => {
    ret[key] = data[key];
  });
  return ret;
}
function patch(instance, data, oldData) {
  if (!data) {
    return;
  }
  data = deepCopy$1(data);
  data.$eS = instance.$eS || {};
  data.$eA = instance.$eA || {};
  const ctx = instance.ctx;
  const mpType = ctx.mpType;
  if (mpType === "page" || mpType === "component") {
    data.r0 = 1;
    const mpInstance = ctx.$scope;
    const keys = Object.keys(data);
    const diffData = diff(data, oldData || getMPInstanceData(mpInstance, keys));
    if (Object.keys(diffData).length) {
      ctx.__next_tick_pending = true;
      mpInstance.setData(diffData, () => {
        ctx.__next_tick_pending = false;
        flushCallbacks(instance);
      });
      flushPreFlushCbs();
    } else {
      flushCallbacks(instance);
    }
  }
}
function initAppConfig(appConfig) {
  appConfig.globalProperties.$nextTick = function $nextTick(fn) {
    return nextTick(this.$, fn);
  };
}
function onApplyOptions(options, instance, publicThis) {
  instance.appContext.config.globalProperties.$applyOptions(
    options,
    instance,
    publicThis
  );
  const computedOptions = options.computed;
  if (computedOptions) {
    const keys = Object.keys(computedOptions);
    if (keys.length) {
      const ctx = instance.ctx;
      if (!ctx.$computedKeys) {
        ctx.$computedKeys = [];
      }
      ctx.$computedKeys.push(...keys);
    }
  }
  delete instance.ctx.$onApplyOptions;
}
function setRef$1(instance, isUnmount = false) {
  const {
    setupState,
    $templateRefs,
    $templateUniElementRefs,
    ctx: { $scope, $mpPlatform }
  } = instance;
  if ($mpPlatform === "mp-alipay") {
    return;
  }
  if (!$scope || !$templateRefs && !$templateUniElementRefs) {
    return;
  }
  if (isUnmount) {
    $templateRefs && $templateRefs.forEach(
      (templateRef) => setTemplateRef(templateRef, null, setupState)
    );
    $templateUniElementRefs && $templateUniElementRefs.forEach(
      (templateRef) => setTemplateRef(templateRef, null, setupState)
    );
    return;
  }
  const check = $mpPlatform === "mp-baidu" || $mpPlatform === "mp-toutiao";
  const doSetByRefs = (refs) => {
    if (refs.length === 0) {
      return [];
    }
    const mpComponents = (
      //  selectAllComponents  null
      // https://github.com/dcloudio/uni-app/issues/3954
      ($scope.selectAllComponents(".r") || []).concat(
        $scope.selectAllComponents(".r-i-f") || []
      )
    );
    return refs.filter((templateRef) => {
      const refValue = findComponentPublicInstance(mpComponents, templateRef.i);
      if (check && refValue === null) {
        return true;
      }
      setTemplateRef(templateRef, refValue, setupState);
      return false;
    });
  };
  const doSet = () => {
    if ($templateRefs) {
      const refs = doSetByRefs($templateRefs);
      if (refs.length && instance.proxy && instance.proxy.$scope) {
        instance.proxy.$scope.setData({ r1: 1 }, () => {
          doSetByRefs(refs);
        });
      }
    }
  };
  if ($templateUniElementRefs && $templateUniElementRefs.length) {
    nextTick(instance, () => {
      $templateUniElementRefs.forEach((templateRef) => {
        if (isArray$1(templateRef.v)) {
          templateRef.v.forEach((v) => {
            setTemplateRef(templateRef, v, setupState);
          });
        } else {
          setTemplateRef(templateRef, templateRef.v, setupState);
        }
      });
    });
  }
  if ($scope._$setRef) {
    $scope._$setRef(doSet);
  } else {
    nextTick(instance, doSet);
  }
}
function toSkip(value) {
  if (isObject$3(value)) {
    markRaw(value);
  }
  return value;
}
function findComponentPublicInstance(mpComponents, id) {
  const mpInstance = mpComponents.find(
    (com) => com && (com.properties || com.props).uI === id
  );
  if (mpInstance) {
    const vm = mpInstance.$vm;
    if (vm) {
      return getExposeProxy(vm.$) || vm;
    }
    return toSkip(mpInstance);
  }
  return null;
}
function setTemplateRef({ r: r2, f: f2 }, refValue, setupState) {
  if (isFunction(r2)) {
    r2(refValue, {});
  } else {
    const _isString = isString(r2);
    const _isRef = isRef(r2);
    if (_isString || _isRef) {
      if (f2) {
        if (!_isRef) {
          return;
        }
        if (!isArray$1(r2.value)) {
          r2.value = [];
        }
        const existing = r2.value;
        if (existing.indexOf(refValue) === -1) {
          existing.push(refValue);
          if (!refValue) {
            return;
          }
          if (refValue.$) {
            onBeforeUnmount(() => remove(existing, refValue), refValue.$);
          }
        }
      } else if (_isString) {
        if (hasOwn$1(setupState, r2)) {
          setupState[r2] = refValue;
        }
      } else if (isRef(r2)) {
        r2.value = refValue;
      } else {
        warnRef(r2);
      }
    } else {
      warnRef(r2);
    }
  }
}
function warnRef(ref2) {
  warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
}
const queuePostRenderEffect = queuePostFlushCb;
function mountComponent(initialVNode, options) {
  const instance = initialVNode.component = createComponentInstance(initialVNode, options.parentComponent, null);
  instance.renderer = options.mpType ? options.mpType : "component";
  {
    instance.ctx.$onApplyOptions = onApplyOptions;
    instance.ctx.$children = [];
  }
  if (options.mpType === "app") {
    instance.render = NOOP;
  }
  if (options.onBeforeSetup) {
    options.onBeforeSetup(instance, options);
  }
  {
    pushWarningContext(initialVNode);
    startMeasure(instance, `mount`);
  }
  {
    startMeasure(instance, `init`);
  }
  setupComponent(instance);
  {
    endMeasure(instance, `init`);
  }
  {
    if (options.parentComponent && instance.proxy) {
      options.parentComponent.ctx.$children.push(getExposeProxy(instance) || instance.proxy);
    }
  }
  setupRenderEffect(instance);
  {
    popWarningContext();
    endMeasure(instance, `mount`);
  }
  return instance.proxy;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
function renderComponentRoot(instance) {
  const {
    type: Component2,
    vnode,
    proxy,
    withProxy,
    props: props2,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    uid: uid2,
    appContext: {
      app: {
        config: {
          globalProperties: { pruneComponentPropsCache: pruneComponentPropsCache2 }
        }
      }
    },
    inheritAttrs
  } = instance;
  instance.$uniElementIds = /* @__PURE__ */ new Map();
  instance.$templateRefs = [];
  instance.$templateUniElementRefs = [];
  instance.$templateUniElementStyles = {};
  instance.$ei = 0;
  pruneComponentPropsCache2(uid2);
  instance.__counter = instance.__counter === 0 ? 1 : 0;
  let result;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      fallthroughAttrs(inheritAttrs, props2, propsOptions, attrs);
      const proxyToUse = withProxy || proxy;
      result = render2.call(
        proxyToUse,
        proxyToUse,
        renderCache,
        props2,
        setupState,
        data,
        ctx
      );
    } else {
      fallthroughAttrs(
        inheritAttrs,
        props2,
        propsOptions,
        Component2.props ? attrs : getFunctionalFallthrough(attrs)
      );
      const render22 = Component2;
      result = render22.length > 1 ? render22(props2, { attrs, slots, emit: emit2 }) : render22(
        props2,
        null
        /* we know it doesn't need it */
      );
    }
  } catch (err) {
    handleError(err, instance, 1);
    result = false;
  }
  setRef$1(instance);
  setCurrentRenderingInstance(prev);
  return result;
}
function fallthroughAttrs(inheritAttrs, props2, propsOptions, fallthroughAttrs2) {
  if (props2 && fallthroughAttrs2 && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs2).filter(
      (key) => key !== "class" && key !== "style"
    );
    if (!keys.length) {
      return;
    }
    if (propsOptions && keys.some(isModelListener)) {
      keys.forEach((key) => {
        if (!isModelListener(key) || !(key.slice(9) in propsOptions)) {
          props2[key] = fallthroughAttrs2[key];
        }
      });
    } else {
      keys.forEach((key) => props2[key] = fallthroughAttrs2[key]);
    }
  }
}
const updateComponentPreRender = (instance) => {
  pauseTracking();
  flushPreFlushCbs();
  resetTracking();
};
function componentUpdateScopedSlotsFn() {
  const scopedSlotsData = this.$scopedSlotsData;
  if (!scopedSlotsData || scopedSlotsData.length === 0) {
    return;
  }
  const mpInstance = this.ctx.$scope;
  const oldData = mpInstance.data;
  const diffData = /* @__PURE__ */ Object.create(null);
  scopedSlotsData.forEach(({ path, index: index2, data }) => {
    const oldScopedSlotData = getValueByDataPath(oldData, path);
    const diffPath = isString(index2) ? `${path}.${index2}` : `${path}[${index2}]`;
    if (typeof oldScopedSlotData === "undefined" || typeof oldScopedSlotData[index2] === "undefined") {
      diffData[diffPath] = data;
    } else {
      const diffScopedSlotData = diff(
        data,
        oldScopedSlotData[index2]
      );
      Object.keys(diffScopedSlotData).forEach((name) => {
        diffData[diffPath + "." + name] = diffScopedSlotData[name];
      });
    }
  });
  scopedSlotsData.length = 0;
  if (Object.keys(diffData).length) {
    mpInstance.setData(diffData);
  }
}
function toggleRecurse({ effect: effect2, update: update3 }, allowed) {
  effect2.allowRecurse = update3.allowRecurse = allowed;
}
function setupRenderEffect(instance) {
  const updateScopedSlots = componentUpdateScopedSlotsFn.bind(
    instance
  );
  instance.$updateScopedSlots = () => nextTick$1(() => queueJob(updateScopedSlots));
  const componentUpdateFn = () => {
    if (!instance.isMounted) {
      onBeforeUnmount(() => {
        setRef$1(instance, true);
      }, instance);
      {
        startMeasure(instance, `patch`);
      }
      patch(instance, renderComponentRoot(instance));
      {
        endMeasure(instance, `patch`);
      }
      {
        devtoolsComponentAdded(instance);
      }
    } else {
      const { next, bu, u: u2 } = instance;
      {
        pushWarningContext(next || instance.vnode);
      }
      toggleRecurse(instance, false);
      updateComponentPreRender();
      if (bu) {
        invokeArrayFns$1(bu);
      }
      toggleRecurse(instance, true);
      {
        startMeasure(instance, `patch`);
      }
      patch(instance, renderComponentRoot(instance));
      {
        endMeasure(instance, `patch`);
      }
      if (u2) {
        queuePostRenderEffect(u2);
      }
      {
        devtoolsComponentUpdated(instance);
      }
      {
        popWarningContext();
      }
    }
  };
  const effect2 = instance.effect = new ReactiveEffect(
    componentUpdateFn,
    NOOP,
    () => queueJob(update3),
    instance.scope
    // track it in component's effect scope
  );
  const update3 = instance.update = () => {
    if (effect2.dirty) {
      effect2.run();
    }
  };
  update3.id = instance.uid;
  toggleRecurse(instance, true);
  {
    effect2.onTrack = instance.rtc ? (e2) => invokeArrayFns$1(instance.rtc, e2) : void 0;
    effect2.onTrigger = instance.rtg ? (e2) => invokeArrayFns$1(instance.rtg, e2) : void 0;
    update3.ownerInstance = instance;
  }
  {
    update3();
  }
}
function unmountComponent(instance) {
  const { bum, scope, update: update3, um } = instance;
  if (bum) {
    invokeArrayFns$1(bum);
  }
  {
    const parentInstance = instance.parent;
    if (parentInstance) {
      const $children = parentInstance.ctx.$children;
      const target = getExposeProxy(instance) || instance.proxy;
      const index2 = $children.indexOf(target);
      if (index2 > -1) {
        $children.splice(index2, 1);
      }
    }
  }
  scope.stop();
  if (update3) {
    update3.active = false;
  }
  if (um) {
    queuePostRenderEffect(um);
  }
  queuePostRenderEffect(() => {
    instance.isUnmounted = true;
  });
  {
    devtoolsComponentRemoved(instance);
  }
}
const oldCreateApp = createAppAPI();
function getTarget() {
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof my !== "undefined") {
    return my;
  }
}
function createVueApp(rootComponent, rootProps = null) {
  const target = getTarget();
  target.__VUE__ = true;
  {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const app = oldCreateApp(rootComponent, rootProps);
  const appContext = app._context;
  initAppConfig(appContext.config);
  const createVNode2 = (initialVNode) => {
    initialVNode.appContext = appContext;
    initialVNode.shapeFlag = 6;
    return initialVNode;
  };
  const createComponent2 = function createComponent22(initialVNode, options) {
    return mountComponent(createVNode2(initialVNode), options);
  };
  const destroyComponent = function destroyComponent2(component) {
    return component && unmountComponent(component.$);
  };
  app.mount = function mount() {
    rootComponent.render = NOOP;
    const instance = mountComponent(
      createVNode2({ type: rootComponent }),
      {
        mpType: "app",
        mpInstance: null,
        parentComponent: null,
        slots: [],
        props: null
      }
    );
    app._instance = instance.$;
    {
      devtoolsInitApp(app, version$2);
    }
    instance.$app = app;
    instance.$createComponent = createComponent2;
    instance.$destroyComponent = destroyComponent;
    appContext.$appInstance = instance;
    return instance;
  };
  app.unmount = function unmount() {
    warn(`Cannot unmount an app.`);
  };
  return app;
}
function injectLifecycleHook(name, hook, publicThis, instance) {
  if (isFunction(hook)) {
    injectHook(name, hook.bind(publicThis), instance);
  }
}
function initHooks$1(options, instance, publicThis) {
  const mpType = options.mpType || publicThis.$mpType;
  if (!mpType || mpType === "component" || // instance.renderer 
  mpType === "page" && instance.renderer === "component") {
    return;
  }
  Object.keys(options).forEach((name) => {
    if (isUniLifecycleHook(name, options[name], false)) {
      const hooks = options[name];
      if (isArray$1(hooks)) {
        hooks.forEach((hook) => injectLifecycleHook(name, hook, publicThis, instance));
      } else {
        injectLifecycleHook(name, hooks, publicThis, instance);
      }
    }
  });
}
function applyOptions$2(options, instance, publicThis) {
  initHooks$1(options, instance, publicThis);
}
function set$2(target, key, val) {
  return target[key] = val;
}
function $callMethod(method, ...args) {
  const fn = this[method];
  if (fn) {
    return fn(...args);
  }
  console.error(`method ${method} not found`);
  return null;
}
function createErrorHandler(app) {
  const userErrorHandler = app.config.errorHandler;
  return function errorHandler(err, instance, info) {
    if (userErrorHandler) {
      userErrorHandler(err, instance, info);
    }
    const appInstance = app._instance;
    if (!appInstance || !appInstance.proxy) {
      throw err;
    }
    if (appInstance[ON_ERROR]) {
      {
        appInstance.proxy.$callHook(ON_ERROR, err);
      }
    } else {
      logError(err, info, instance ? instance.$.vnode : null, false);
    }
  };
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function initOptionMergeStrategies(optionMergeStrategies) {
  UniLifecycleHooks.forEach((name) => {
    optionMergeStrategies[name] = mergeAsArray;
  });
}
let realAtob;
const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64re = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;
if (typeof atob !== "function") {
  realAtob = function(str) {
    str = String(str).replace(/[\t\n\f\r ]+/g, "");
    if (!b64re.test(str)) {
      throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
    }
    str += "==".slice(2 - (str.length & 3));
    var bitmap;
    var result = "";
    var r1;
    var r2;
    var i = 0;
    for (; i < str.length; ) {
      bitmap = b64.indexOf(str.charAt(i++)) << 18 | b64.indexOf(str.charAt(i++)) << 12 | (r1 = b64.indexOf(str.charAt(i++))) << 6 | (r2 = b64.indexOf(str.charAt(i++)));
      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
    }
    return result;
  };
} else {
  realAtob = atob;
}
function b64DecodeUnicode(str) {
  return decodeURIComponent(realAtob(str).split("").map(function(c2) {
    return "%" + ("00" + c2.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}
function getCurrentUserInfo() {
  const token = index$2.getStorageSync("uni_id_token") || "";
  const tokenArr = token.split(".");
  if (!token || tokenArr.length !== 3) {
    return {
      uid: null,
      role: [],
      permission: [],
      tokenExpired: 0
    };
  }
  let userInfo;
  try {
    userInfo = JSON.parse(b64DecodeUnicode(tokenArr[1]));
  } catch (error2) {
    throw new Error("" + error2.message);
  }
  userInfo.tokenExpired = userInfo.exp * 1e3;
  delete userInfo.exp;
  delete userInfo.iat;
  return userInfo;
}
function uniIdMixin(globalProperties) {
  globalProperties.uniIDHasRole = function(roleId) {
    const { role } = getCurrentUserInfo();
    return role.indexOf(roleId) > -1;
  };
  globalProperties.uniIDHasPermission = function(permissionId) {
    const { permission } = getCurrentUserInfo();
    return this.uniIDHasRole("admin") || permission.indexOf(permissionId) > -1;
  };
  globalProperties.uniIDTokenValid = function() {
    const { tokenExpired } = getCurrentUserInfo();
    return tokenExpired > Date.now();
  };
}
function initApp(app) {
  const appConfig = app.config;
  appConfig.errorHandler = invokeCreateErrorHandler(app, createErrorHandler);
  initOptionMergeStrategies(appConfig.optionMergeStrategies);
  const globalProperties = appConfig.globalProperties;
  {
    uniIdMixin(globalProperties);
  }
  {
    globalProperties.$set = set$2;
    globalProperties.$applyOptions = applyOptions$2;
    globalProperties.$callMethod = $callMethod;
  }
  {
    index$2.invokeCreateVueAppHook(app);
  }
}
const propsCaches = /* @__PURE__ */ Object.create(null);
function renderProps(props2) {
  const { uid: uid2, __counter } = getCurrentInstance();
  const propsId = (propsCaches[uid2] || (propsCaches[uid2] = [])).push(guardReactiveProps(props2)) - 1;
  return uid2 + "," + propsId + "," + __counter;
}
function pruneComponentPropsCache(uid2) {
  delete propsCaches[uid2];
}
function findComponentPropsData(up) {
  if (!up) {
    return;
  }
  const [uid2, propsId] = up.split(",");
  if (!propsCaches[uid2]) {
    return;
  }
  return propsCaches[uid2][parseInt(propsId)];
}
var plugin = {
  install(app) {
    initApp(app);
    app.config.globalProperties.pruneComponentPropsCache = pruneComponentPropsCache;
    const oldMount = app.mount;
    app.mount = function mount(rootContainer) {
      const instance = oldMount.call(app, rootContainer);
      const createApp2 = getCreateApp();
      if (createApp2) {
        createApp2(instance);
      } else {
        if (typeof createMiniProgramApp !== "undefined") {
          createMiniProgramApp(instance);
        }
      }
      return instance;
    };
  }
};
function getCreateApp() {
  const method = "createApp";
  if (typeof global !== "undefined" && typeof global[method] !== "undefined") {
    return global[method];
  } else if (typeof my !== "undefined") {
    return my[method];
  }
}
function stringifyStyle(value) {
  if (isString(value)) {
    return value;
  }
  return stringify(normalizeStyle(value));
}
function stringify(styles) {
  let ret = "";
  if (!styles || isString(styles)) {
    return ret;
  }
  for (const key in styles) {
    ret += `${key.startsWith(`--`) ? key : hyphenate(key)}:${styles[key]};`;
  }
  return ret;
}
function vOn(value, key) {
  const instance = getCurrentInstance();
  const ctx = instance.ctx;
  const extraKey = typeof key !== "undefined" && (ctx.$mpPlatform === "mp-weixin" || ctx.$mpPlatform === "mp-qq" || ctx.$mpPlatform === "mp-xhs") && (isString(key) || typeof key === "number") ? "_" + key : "";
  const name = "e" + instance.$ei++ + extraKey;
  const mpInstance = ctx.$scope;
  if (!value) {
    delete mpInstance[name];
    return name;
  }
  const existingInvoker = mpInstance[name];
  if (existingInvoker) {
    existingInvoker.value = value;
  } else {
    mpInstance[name] = createInvoker(value, instance);
  }
  return name;
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    patchMPEvent(e2);
    let args = [e2];
    if (instance && instance.ctx.$getTriggerEventDetail) {
      if (typeof e2.detail === "number") {
        e2.detail = instance.ctx.$getTriggerEventDetail(e2.detail);
      }
    }
    if (e2.detail && e2.detail.__args__) {
      args = e2.detail.__args__;
    }
    const eventValue = invoker.value;
    const invoke = () => callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, eventValue), instance, 5, args);
    const eventTarget = e2.target;
    const eventSync = eventTarget ? eventTarget.dataset ? String(eventTarget.dataset.eventsync) === "true" : false : false;
    if (bubbles.includes(e2.type) && !eventSync) {
      setTimeout(invoke);
    } else {
      const res = invoke();
      if (e2.type === "input" && (isArray$1(res) || isPromise$1(res))) {
        return;
      }
      return res;
    }
  };
  invoker.value = initialValue;
  return invoker;
}
const bubbles = [
  // touch Android 
  // 'touchstart',
  // 'touchmove',
  // 'touchcancel',
  // 'touchend',
  "tap",
  "longpress",
  "longtap",
  "transitionend",
  "animationstart",
  "animationiteration",
  "animationend",
  "touchforcechange"
];
function patchMPEvent(event, instance) {
  if (event.type && event.target) {
    event.preventDefault = NOOP;
    event.stopPropagation = NOOP;
    event.stopImmediatePropagation = NOOP;
    if (!hasOwn$1(event, "detail")) {
      event.detail = {};
    }
    if (hasOwn$1(event, "markerId")) {
      event.detail = typeof event.detail === "object" ? event.detail : {};
      event.detail.markerId = event.markerId;
    }
    if (isPlainObject$2(event.detail) && hasOwn$1(event.detail, "checked") && !hasOwn$1(event.detail, "value")) {
      event.detail.value = event.detail.checked;
    }
    if (isPlainObject$2(event.detail)) {
      event.target = extend({}, event.target, event.detail);
    }
  }
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$1(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop && originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn(e3));
  } else {
    return value;
  }
}
function vFor(source, renderItem) {
  let ret;
  if (isArray$1(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, i);
    }
  } else if (typeof source === "number") {
    if (!Number.isInteger(source)) {
      warn(`The v-for range expect an integer value but got ${source}.`);
      return [];
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, i);
    }
  } else if (isObject$3(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, i));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function setRef(ref2, id, opts = {}) {
  const { $templateRefs } = getCurrentInstance();
  $templateRefs.push({ i: id, r: ref2, k: opts.k, f: opts.f });
}
const o = (value, key) => vOn(value, key);
const f$1 = (source, renderItem) => vFor(source, renderItem);
const s = (value) => stringifyStyle(value);
const e$1 = (target, ...sources) => extend(target, ...sources);
const n = (value) => normalizeClass(value);
const t = (val) => toDisplayString(val);
const p = (props2) => renderProps(props2);
const sr = (ref2, id, opts) => setRef(ref2, id, opts);
function createApp$1(rootComponent, rootProps = null) {
  rootComponent && (rootComponent.mpType = "app");
  return createVueApp(rootComponent, rootProps).use(plugin);
}
const createSSRApp = createApp$1;
function getLocaleLanguage$1() {
  var _a;
  let localeLanguage = "";
  {
    const appBaseInfo = ((_a = wx.getAppBaseInfo) === null || _a === void 0 ? void 0 : _a.call(wx)) || wx.getSystemInfoSync();
    const language = appBaseInfo && appBaseInfo.language ? appBaseInfo.language : LOCALE_EN;
    localeLanguage = normalizeLocale(language) || LOCALE_EN;
  }
  return localeLanguage;
}
function validateProtocolFail(name, msg) {
  console.warn(`${name}: ${msg}`);
}
function validateProtocol(name, data, protocol, onFail) {
  if (!onFail) {
    onFail = validateProtocolFail;
  }
  for (const key in protocol) {
    const errMsg = validateProp(key, data[key], protocol[key], !hasOwn$1(data, key));
    if (isString(errMsg)) {
      onFail(name, errMsg);
    }
  }
}
function validateProtocols(name, args, protocol, onFail) {
  if (!protocol) {
    return;
  }
  if (!isArray$1(protocol)) {
    return validateProtocol(name, args[0] || /* @__PURE__ */ Object.create(null), protocol, onFail);
  }
  const len = protocol.length;
  const argsLen = args.length;
  for (let i = 0; i < len; i++) {
    const opts = protocol[i];
    const data = /* @__PURE__ */ Object.create(null);
    if (argsLen > i) {
      data[opts.name] = args[i];
    }
    validateProtocol(name, data, { [opts.name]: opts }, onFail);
  }
}
function validateProp(name, value, prop, isAbsent) {
  if (!isPlainObject$2(prop)) {
    prop = { type: prop };
  }
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    return 'Missing required args: "' + name + '"';
  }
  if (value == null && !required) {
    return;
  }
  if (type != null) {
    let isValid2 = false;
    const types = isArray$1(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid2; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid2 = valid;
    }
    if (!isValid2) {
      return getInvalidTypeMessage(name, value, expectedTypes);
    }
  }
  if (validator) {
    return validator(value);
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$3(value);
  } else if (expectedType === "Array") {
    valid = isArray$1(value);
  } else {
    {
      valid = value instanceof type;
    }
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid args: type check failed for args "${name}". Expected ${expectedTypes.map(capitalize$1).join(", ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : "";
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
function tryCatch(fn) {
  return function() {
    try {
      return fn.apply(fn, arguments);
    } catch (e2) {
      console.error(e2);
    }
  };
}
let invokeCallbackId = 1;
const invokeCallbacks = {};
function addInvokeCallback(id, name, callback, keepAlive = false) {
  invokeCallbacks[id] = {
    name,
    keepAlive,
    callback
  };
  return id;
}
function invokeCallback(id, res, extras) {
  if (typeof id === "number") {
    const opts = invokeCallbacks[id];
    if (opts) {
      if (!opts.keepAlive) {
        delete invokeCallbacks[id];
      }
      return opts.callback(res, extras);
    }
  }
  return res;
}
const API_SUCCESS = "success";
const API_FAIL = "fail";
const API_COMPLETE = "complete";
function getApiCallbacks(args) {
  const apiCallbacks = {};
  for (const name in args) {
    const fn = args[name];
    if (isFunction(fn)) {
      apiCallbacks[name] = tryCatch(fn);
      delete args[name];
    }
  }
  return apiCallbacks;
}
function normalizeErrMsg(errMsg, name) {
  if (!errMsg || errMsg.indexOf(":fail") === -1) {
    return name + ":ok";
  }
  return name + errMsg.substring(errMsg.indexOf(":fail"));
}
function createAsyncApiCallback(name, args = {}, { beforeAll, beforeSuccess } = {}) {
  if (!isPlainObject$2(args)) {
    args = {};
  }
  const { success, fail, complete } = getApiCallbacks(args);
  const hasSuccess = isFunction(success);
  const hasFail = isFunction(fail);
  const hasComplete = isFunction(complete);
  const callbackId = invokeCallbackId++;
  addInvokeCallback(callbackId, name, (res) => {
    res = res || {};
    res.errMsg = normalizeErrMsg(res.errMsg, name);
    isFunction(beforeAll) && beforeAll(res);
    if (res.errMsg === name + ":ok") {
      isFunction(beforeSuccess) && beforeSuccess(res, args);
      hasSuccess && success(res);
    } else {
      hasFail && fail(res);
    }
    hasComplete && complete(res);
  });
  return callbackId;
}
const HOOK_SUCCESS = "success";
const HOOK_FAIL = "fail";
const HOOK_COMPLETE = "complete";
const globalInterceptors = {};
const scopedInterceptors = {};
function wrapperHook(hook, params) {
  return function(data) {
    return hook(data, params) || data;
  };
}
function queue(hooks, data, params) {
  let promise2 = false;
  for (let i = 0; i < hooks.length; i++) {
    const hook = hooks[i];
    if (promise2) {
      promise2 = Promise.resolve(wrapperHook(hook, params));
    } else {
      const res = hook(data, params);
      if (isPromise$1(res)) {
        promise2 = Promise.resolve(res);
      }
      if (res === false) {
        return {
          then() {
          },
          catch() {
          }
        };
      }
    }
  }
  return promise2 || {
    then(callback) {
      return callback(data);
    },
    catch() {
    }
  };
}
function wrapperOptions(interceptors2, options = {}) {
  [HOOK_SUCCESS, HOOK_FAIL, HOOK_COMPLETE].forEach((name) => {
    const hooks = interceptors2[name];
    if (!isArray$1(hooks)) {
      return;
    }
    const oldCallback = options[name];
    options[name] = function callbackInterceptor(res) {
      queue(hooks, res, options).then((res2) => {
        return isFunction(oldCallback) && oldCallback(res2) || res2;
      });
    };
  });
  return options;
}
function wrapperReturnValue(method, returnValue) {
  const returnValueHooks = [];
  if (isArray$1(globalInterceptors.returnValue)) {
    returnValueHooks.push(...globalInterceptors.returnValue);
  }
  const interceptor = scopedInterceptors[method];
  if (interceptor && isArray$1(interceptor.returnValue)) {
    returnValueHooks.push(...interceptor.returnValue);
  }
  returnValueHooks.forEach((hook) => {
    returnValue = hook(returnValue) || returnValue;
  });
  return returnValue;
}
function getApiInterceptorHooks(method) {
  const interceptor = /* @__PURE__ */ Object.create(null);
  Object.keys(globalInterceptors).forEach((hook) => {
    if (hook !== "returnValue") {
      interceptor[hook] = globalInterceptors[hook].slice();
    }
  });
  const scopedInterceptor = scopedInterceptors[method];
  if (scopedInterceptor) {
    Object.keys(scopedInterceptor).forEach((hook) => {
      if (hook !== "returnValue") {
        interceptor[hook] = (interceptor[hook] || []).concat(scopedInterceptor[hook]);
      }
    });
  }
  return interceptor;
}
function invokeApi(method, api, options, params) {
  const interceptor = getApiInterceptorHooks(method);
  if (interceptor && Object.keys(interceptor).length) {
    if (isArray$1(interceptor.invoke)) {
      const res = queue(interceptor.invoke, options);
      return res.then((options2) => {
        return api(wrapperOptions(getApiInterceptorHooks(method), options2), ...params);
      });
    } else {
      return api(wrapperOptions(interceptor, options), ...params);
    }
  }
  return api(options, ...params);
}
function hasCallback(args) {
  if (isPlainObject$2(args) && [API_SUCCESS, API_FAIL, API_COMPLETE].find((cb) => isFunction(args[cb]))) {
    return true;
  }
  return false;
}
function handlePromise(promise2) {
  return promise2;
}
function promisify$1(name, fn) {
  return (args = {}, ...rest) => {
    if (hasCallback(args)) {
      return wrapperReturnValue(name, invokeApi(name, fn, extend({}, args), rest));
    }
    return wrapperReturnValue(name, handlePromise(new Promise((resolve2, reject) => {
      invokeApi(name, fn, extend({}, args, { success: resolve2, fail: reject }), rest);
    })));
  };
}
function formatApiArgs(args, options) {
  args[0];
  {
    return;
  }
}
function invokeSuccess(id, name, res) {
  const result = {
    errMsg: name + ":ok"
  };
  return invokeCallback(id, extend(res || {}, result));
}
function invokeFail(id, name, errMsg, errRes = {}) {
  const errMsgPrefix = name + ":fail";
  let apiErrMsg = "";
  if (!errMsg) {
    apiErrMsg = errMsgPrefix;
  } else if (errMsg.indexOf(errMsgPrefix) === 0) {
    apiErrMsg = errMsg;
  } else {
    apiErrMsg = errMsgPrefix + " " + errMsg;
  }
  {
    delete errRes.errCode;
  }
  let res = extend({ errMsg: apiErrMsg }, errRes);
  return invokeCallback(id, res);
}
function beforeInvokeApi(name, args, protocol, options) {
  {
    validateProtocols(name, args, protocol);
  }
  const errMsg = formatApiArgs(args);
  if (errMsg) {
    return errMsg;
  }
}
function parseErrMsg(errMsg) {
  if (!errMsg || isString(errMsg)) {
    return errMsg;
  }
  if (errMsg.stack) {
    if (typeof globalThis === "undefined" || !globalThis.harmonyChannel) {
      console.error(errMsg.message + "\n" + errMsg.stack);
    }
    return errMsg.message;
  }
  return errMsg;
}
function wrapperTaskApi(name, fn, protocol, options) {
  return (args) => {
    const id = createAsyncApiCallback(name, args, options);
    const errMsg = beforeInvokeApi(name, [args], protocol);
    if (errMsg) {
      return invokeFail(id, name, errMsg);
    }
    return fn(args, {
      resolve: (res) => invokeSuccess(id, name, res),
      reject: (errMsg2, errRes) => invokeFail(id, name, parseErrMsg(errMsg2), errRes)
    });
  };
}
function wrapperSyncApi(name, fn, protocol, options) {
  return (...args) => {
    const errMsg = beforeInvokeApi(name, args, protocol);
    if (errMsg) {
      throw new Error(errMsg);
    }
    return fn.apply(null, args);
  };
}
function wrapperAsyncApi(name, fn, protocol, options) {
  return wrapperTaskApi(name, fn, protocol, options);
}
function defineSyncApi(name, fn, protocol, options) {
  return wrapperSyncApi(name, fn, protocol);
}
function defineAsyncApi(name, fn, protocol, options) {
  return promisify$1(name, wrapperAsyncApi(name, fn, protocol, options));
}
const API_UPX2PX = "upx2px";
const Upx2pxProtocol = [
  {
    name: "upx",
    type: [Number, String],
    required: true
  }
];
const EPS = 1e-4;
const BASE_DEVICE_WIDTH = 750;
let isIOS = false;
let deviceWidth = 0;
let deviceDPR = 0;
function checkDeviceWidth() {
  var _a, _b;
  let windowWidth, pixelRatio, platform2;
  {
    const windowInfo = ((_a = wx.getWindowInfo) === null || _a === void 0 ? void 0 : _a.call(wx)) || wx.getSystemInfoSync();
    const deviceInfo = ((_b = wx.getDeviceInfo) === null || _b === void 0 ? void 0 : _b.call(wx)) || wx.getSystemInfoSync();
    windowWidth = windowInfo.windowWidth;
    pixelRatio = windowInfo.pixelRatio;
    platform2 = deviceInfo.platform;
  }
  deviceWidth = windowWidth;
  deviceDPR = pixelRatio;
  isIOS = platform2 === "ios";
}
const upx2px = defineSyncApi(API_UPX2PX, (number2, newDeviceWidth) => {
  if (deviceWidth === 0) {
    checkDeviceWidth();
  }
  number2 = Number(number2);
  if (number2 === 0) {
    return 0;
  }
  let width = newDeviceWidth || deviceWidth;
  let result = number2 / BASE_DEVICE_WIDTH * width;
  if (result < 0) {
    result = -result;
  }
  result = Math.floor(result + EPS);
  if (result === 0) {
    if (deviceDPR === 1 || !isIOS) {
      result = 1;
    } else {
      result = 0.5;
    }
  }
  return number2 < 0 ? -result : result;
}, Upx2pxProtocol);
function __f__(type, filename, ...args) {
  if (filename) {
    args.push(filename);
  }
  console[type].apply(console, args);
}
const API_ADD_INTERCEPTOR = "addInterceptor";
const API_REMOVE_INTERCEPTOR = "removeInterceptor";
const AddInterceptorProtocol = [
  {
    name: "method",
    type: [String, Object],
    required: true
  }
];
const RemoveInterceptorProtocol = AddInterceptorProtocol;
function mergeInterceptorHook(interceptors2, interceptor) {
  Object.keys(interceptor).forEach((hook) => {
    if (isFunction(interceptor[hook])) {
      interceptors2[hook] = mergeHook(interceptors2[hook], interceptor[hook]);
    }
  });
}
function removeInterceptorHook(interceptors2, interceptor) {
  if (!interceptors2 || !interceptor) {
    return;
  }
  Object.keys(interceptor).forEach((name) => {
    const hooks = interceptors2[name];
    const hook = interceptor[name];
    if (isArray$1(hooks) && isFunction(hook)) {
      remove(hooks, hook);
    }
  });
}
function mergeHook(parentVal, childVal) {
  const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray$1(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
  const res = [];
  for (let i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res;
}
const addInterceptor = defineSyncApi(API_ADD_INTERCEPTOR, (method, interceptor) => {
  if (isString(method) && isPlainObject$2(interceptor)) {
    mergeInterceptorHook(scopedInterceptors[method] || (scopedInterceptors[method] = {}), interceptor);
  } else if (isPlainObject$2(method)) {
    mergeInterceptorHook(globalInterceptors, method);
  }
}, AddInterceptorProtocol);
const removeInterceptor = defineSyncApi(API_REMOVE_INTERCEPTOR, (method, interceptor) => {
  if (isString(method)) {
    if (isPlainObject$2(interceptor)) {
      removeInterceptorHook(scopedInterceptors[method], interceptor);
    } else {
      delete scopedInterceptors[method];
    }
  } else if (isPlainObject$2(method)) {
    removeInterceptorHook(globalInterceptors, method);
  }
}, RemoveInterceptorProtocol);
const interceptors = {};
const API_ON = "$on";
const OnProtocol = [
  {
    name: "event",
    type: String,
    required: true
  },
  {
    name: "callback",
    type: Function,
    required: true
  }
];
const API_ONCE = "$once";
const OnceProtocol = OnProtocol;
const API_OFF = "$off";
const OffProtocol = [
  {
    name: "event",
    type: [String, Array]
  },
  {
    name: "callback",
    type: [Function, Number]
  }
];
const API_EMIT = "$emit";
const EmitProtocol = [
  {
    name: "event",
    type: String,
    required: true
  }
];
class EventBus {
  constructor() {
    this.$emitter = new E$1$1();
  }
  on(name, callback) {
    return this.$emitter.on(name, callback);
  }
  once(name, callback) {
    return this.$emitter.once(name, callback);
  }
  off(name, callback) {
    if (!name) {
      this.$emitter.e = {};
      return;
    }
    this.$emitter.off(name, callback);
  }
  emit(name, ...args) {
    this.$emitter.emit(name, ...args);
  }
}
const eventBus = new EventBus();
const $on = defineSyncApi(API_ON, (name, callback) => {
  eventBus.on(name, callback);
  return () => eventBus.off(name, callback);
}, OnProtocol);
const $once = defineSyncApi(API_ONCE, (name, callback) => {
  eventBus.once(name, callback);
  return () => eventBus.off(name, callback);
}, OnceProtocol);
const $off = defineSyncApi(API_OFF, (name, callback) => {
  if (!isArray$1(name))
    name = name ? [name] : [];
  name.forEach((n2) => {
    eventBus.off(n2, callback);
  });
}, OffProtocol);
const $emit = defineSyncApi(API_EMIT, (name, ...args) => {
  eventBus.emit(name, ...args);
}, EmitProtocol);
let cid;
let cidErrMsg;
let enabled;
function normalizePushMessage(message) {
  try {
    return JSON.parse(message);
  } catch (e2) {
  }
  return message;
}
function invokePushCallback(args) {
  if (args.type === "enabled") {
    enabled = true;
  } else if (args.type === "clientId") {
    cid = args.cid;
    cidErrMsg = args.errMsg;
    invokeGetPushCidCallbacks(cid, args.errMsg);
  } else if (args.type === "pushMsg") {
    const message = {
      type: "receive",
      data: normalizePushMessage(args.message)
    };
    for (let i = 0; i < onPushMessageCallbacks.length; i++) {
      const callback = onPushMessageCallbacks[i];
      callback(message);
      if (message.stopped) {
        break;
      }
    }
  } else if (args.type === "click") {
    onPushMessageCallbacks.forEach((callback) => {
      callback({
        type: "click",
        data: normalizePushMessage(args.message)
      });
    });
  }
}
const getPushCidCallbacks = [];
function invokeGetPushCidCallbacks(cid2, errMsg) {
  getPushCidCallbacks.forEach((callback) => {
    callback(cid2, errMsg);
  });
  getPushCidCallbacks.length = 0;
}
const API_GET_PUSH_CLIENT_ID = "getPushClientId";
const getPushClientId = defineAsyncApi(API_GET_PUSH_CLIENT_ID, (_, { resolve: resolve2, reject }) => {
  Promise.resolve().then(() => {
    if (typeof enabled === "undefined") {
      enabled = false;
      cid = "";
      cidErrMsg = "uniPush is not enabled";
    }
    getPushCidCallbacks.push((cid2, errMsg) => {
      if (cid2) {
        resolve2({ cid: cid2 });
      } else {
        reject(errMsg);
      }
    });
    if (typeof cid !== "undefined") {
      invokeGetPushCidCallbacks(cid, cidErrMsg);
    }
  });
});
const onPushMessageCallbacks = [];
const onPushMessage = (fn) => {
  if (onPushMessageCallbacks.indexOf(fn) === -1) {
    onPushMessageCallbacks.push(fn);
  }
};
const offPushMessage = (fn) => {
  if (!fn) {
    onPushMessageCallbacks.length = 0;
  } else {
    const index2 = onPushMessageCallbacks.indexOf(fn);
    if (index2 > -1) {
      onPushMessageCallbacks.splice(index2, 1);
    }
  }
};
const SYNC_API_RE = /^\$|__f__|getLocale|setLocale|sendNativeEvent|restoreGlobal|requireGlobal|getCurrentSubNVue|getMenuButtonBoundingClientRect|^report|interceptors|Interceptor$|getSubNVueById|requireNativePlugin|upx2px|rpx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64|getDeviceInfo|getAppBaseInfo|getWindowInfo|getSystemSetting|getAppAuthorizeSetting/;
const CONTEXT_API_RE = /^create|Manager$/;
const CONTEXT_API_RE_EXC = ["createBLEConnection"];
const TASK_APIS = ["request", "downloadFile", "uploadFile", "connectSocket"];
const ASYNC_API = ["createBLEConnection"];
const CALLBACK_API_RE = /^on|^off/;
function isContextApi(name) {
  return CONTEXT_API_RE.test(name) && CONTEXT_API_RE_EXC.indexOf(name) === -1;
}
function isSyncApi(name) {
  return SYNC_API_RE.test(name) && ASYNC_API.indexOf(name) === -1;
}
function isCallbackApi(name) {
  return CALLBACK_API_RE.test(name) && name !== "onPush";
}
function isTaskApi(name) {
  return TASK_APIS.indexOf(name) !== -1;
}
function shouldPromise(name) {
  if (isContextApi(name) || isSyncApi(name) || isCallbackApi(name)) {
    return false;
  }
  return true;
}
if (!Promise.prototype.finally) {
  Promise.prototype.finally = function(onfinally) {
    const promise2 = this.constructor;
    return this.then((value) => promise2.resolve(onfinally && onfinally()).then(() => value), (reason) => promise2.resolve(onfinally && onfinally()).then(() => {
      throw reason;
    }));
  };
}
function promisify(name, api) {
  if (!shouldPromise(name)) {
    return api;
  }
  if (!isFunction(api)) {
    return api;
  }
  return function promiseApi(options = {}, ...rest) {
    if (isFunction(options.success) || isFunction(options.fail) || isFunction(options.complete)) {
      return wrapperReturnValue(name, invokeApi(name, api, extend({}, options), rest));
    }
    return wrapperReturnValue(name, handlePromise(new Promise((resolve2, reject) => {
      invokeApi(name, api, extend({}, options, {
        success: resolve2,
        fail: reject
      }), rest);
    })));
  };
}
const CALLBACKS = ["success", "fail", "cancel", "complete"];
function initWrapper(protocols2) {
  function processCallback(methodName, method, returnValue) {
    return function(res) {
      return method(processReturnValue(methodName, res, returnValue));
    };
  }
  function processArgs(methodName, fromArgs, argsOption = {}, returnValue = {}, keepFromArgs = false) {
    if (isPlainObject$2(fromArgs)) {
      const toArgs = keepFromArgs === true ? fromArgs : {};
      if (isFunction(argsOption)) {
        argsOption = argsOption(fromArgs, toArgs) || {};
      }
      for (const key in fromArgs) {
        if (hasOwn$1(argsOption, key)) {
          let keyOption = argsOption[key];
          if (isFunction(keyOption)) {
            keyOption = keyOption(fromArgs[key], fromArgs, toArgs);
          }
          if (!keyOption) {
            console.warn(` ${methodName}  ${key}`);
          } else if (isString(keyOption)) {
            toArgs[keyOption] = fromArgs[key];
          } else if (isPlainObject$2(keyOption)) {
            toArgs[keyOption.name ? keyOption.name : key] = keyOption.value;
          }
        } else if (CALLBACKS.indexOf(key) !== -1) {
          const callback = fromArgs[key];
          if (isFunction(callback)) {
            toArgs[key] = processCallback(methodName, callback, returnValue);
          }
        } else {
          if (!keepFromArgs && !hasOwn$1(toArgs, key)) {
            toArgs[key] = fromArgs[key];
          }
        }
      }
      return toArgs;
    } else if (isFunction(fromArgs)) {
      if (isFunction(argsOption)) {
        argsOption(fromArgs, {});
      }
      fromArgs = processCallback(methodName, fromArgs, returnValue);
    }
    return fromArgs;
  }
  function processReturnValue(methodName, res, returnValue, keepReturnValue = false) {
    if (isFunction(protocols2.returnValue)) {
      res = protocols2.returnValue(methodName, res);
    }
    const realKeepReturnValue = keepReturnValue || false;
    return processArgs(methodName, res, returnValue, {}, realKeepReturnValue);
  }
  return function wrapper(methodName, method) {
    const hasProtocol = hasOwn$1(protocols2, methodName);
    if (!hasProtocol && typeof wx[methodName] !== "function") {
      return method;
    }
    const needWrapper = hasProtocol || isFunction(protocols2.returnValue) || isContextApi(methodName) || isTaskApi(methodName);
    const hasMethod = hasProtocol || isFunction(method);
    if (!hasProtocol && !method) {
      return function() {
        console.error(` ${methodName}`);
      };
    }
    if (!needWrapper || !hasMethod) {
      return method;
    }
    const protocol = protocols2[methodName];
    return function(arg1, arg2) {
      let options = protocol || {};
      if (isFunction(protocol)) {
        options = protocol(arg1);
      }
      arg1 = processArgs(methodName, arg1, options.args, options.returnValue);
      const args = [arg1];
      if (typeof arg2 !== "undefined") {
        args.push(arg2);
      }
      const returnValue = wx[options.name || methodName].apply(wx, args);
      if (isContextApi(methodName) || isTaskApi(methodName)) {
        if (returnValue && !returnValue.__v_skip) {
          returnValue.__v_skip = true;
        }
      }
      if (isSyncApi(methodName)) {
        return processReturnValue(methodName, returnValue, options.returnValue, isContextApi(methodName));
      }
      return returnValue;
    };
  };
}
const getLocale = () => {
  const app = isFunction(getApp) && getApp({ allowDefault: true });
  if (app && app.$vm) {
    return app.$vm.$locale;
  }
  return getLocaleLanguage$1();
};
const setLocale = (locale) => {
  const app = isFunction(getApp) && getApp();
  if (!app) {
    return false;
  }
  const oldLocale = app.$vm.$locale;
  if (oldLocale !== locale) {
    app.$vm.$locale = locale;
    onLocaleChangeCallbacks.forEach((fn) => fn({ locale }));
    return true;
  }
  return false;
};
const onLocaleChangeCallbacks = [];
const onLocaleChange = (fn) => {
  if (onLocaleChangeCallbacks.indexOf(fn) === -1) {
    onLocaleChangeCallbacks.push(fn);
  }
};
if (typeof global !== "undefined") {
  global.getLocale = getLocale;
}
const UUID_KEY = "__DC_STAT_UUID";
let deviceId;
function useDeviceId(global2 = wx) {
  return function addDeviceId(_, toRes) {
    deviceId = deviceId || global2.getStorageSync(UUID_KEY);
    if (!deviceId) {
      deviceId = Date.now() + "" + Math.floor(Math.random() * 1e7);
      wx.setStorage({
        key: UUID_KEY,
        data: deviceId
      });
    }
    toRes.deviceId = deviceId;
  };
}
function addSafeAreaInsets(fromRes, toRes) {
  if (fromRes.safeArea) {
    const safeArea = fromRes.safeArea;
    toRes.safeAreaInsets = {
      top: safeArea.top,
      left: safeArea.left,
      right: fromRes.windowWidth - safeArea.right,
      bottom: fromRes.screenHeight - safeArea.bottom
    };
  }
}
function getOSInfo(system, platform2) {
  let osName = "";
  let osVersion = "";
  if (platform2 && false) {
    osName = platform2;
    osVersion = system;
  } else {
    osName = system.split(" ")[0] || platform2;
    osVersion = system.split(" ")[1] || "";
  }
  osName = osName.toLowerCase();
  switch (osName) {
    case "harmony":
    case "ohos":
    case "openharmony":
      osName = "harmonyos";
      break;
    case "iphone os":
      osName = "ios";
      break;
    case "mac":
    case "darwin":
      osName = "macos";
      break;
    case "windows_nt":
      osName = "windows";
      break;
  }
  return {
    osName,
    osVersion
  };
}
function populateParameters(fromRes, toRes) {
  const { brand = "", model = "", system = "", language = "", theme, version: version2, platform: platform2, fontSizeSetting, SDKVersion, pixelRatio, deviceOrientation } = fromRes;
  const { osName, osVersion } = getOSInfo(system, platform2);
  let hostVersion = version2;
  let deviceType = getGetDeviceType(fromRes, model);
  let deviceBrand = getDeviceBrand(brand);
  let _hostName = getHostName(fromRes);
  let _deviceOrientation = deviceOrientation;
  let _devicePixelRatio = pixelRatio;
  let _SDKVersion = SDKVersion;
  const hostLanguage = (language || "").replace(/_/g, "-");
  const parameters = {
    appId: "__UNI__3BB98A2",
    appName: "caimi",
    appVersion: "1.0.0",
    appVersionCode: "100",
    appLanguage: getAppLanguage(hostLanguage),
    uniCompileVersion: "4.76",
    uniCompilerVersion: "4.76",
    uniRuntimeVersion: "4.76",
    uniPlatform: "mp-weixin",
    deviceBrand,
    deviceModel: model,
    deviceType,
    devicePixelRatio: _devicePixelRatio,
    deviceOrientation: _deviceOrientation,
    osName,
    osVersion,
    hostTheme: theme,
    hostVersion,
    hostLanguage,
    hostName: _hostName,
    hostSDKVersion: _SDKVersion,
    hostFontSizeSetting: fontSizeSetting,
    windowTop: 0,
    windowBottom: 0,
    // TODO
    osLanguage: void 0,
    osTheme: void 0,
    ua: void 0,
    hostPackageName: void 0,
    browserName: void 0,
    browserVersion: void 0,
    isUniAppX: false
  };
  extend(toRes, parameters);
}
function getGetDeviceType(fromRes, model) {
  let deviceType = fromRes.deviceType || "phone";
  {
    const deviceTypeMaps = {
      ipad: "pad",
      windows: "pc",
      mac: "pc"
    };
    const deviceTypeMapsKeys = Object.keys(deviceTypeMaps);
    const _model = model.toLowerCase();
    for (let index2 = 0; index2 < deviceTypeMapsKeys.length; index2++) {
      const _m = deviceTypeMapsKeys[index2];
      if (_model.indexOf(_m) !== -1) {
        deviceType = deviceTypeMaps[_m];
        break;
      }
    }
  }
  return deviceType;
}
function getDeviceBrand(brand) {
  let deviceBrand = brand;
  if (deviceBrand) {
    deviceBrand = deviceBrand.toLowerCase();
  }
  return deviceBrand;
}
function getAppLanguage(defaultLanguage) {
  return getLocale ? getLocale() : defaultLanguage;
}
function getHostName(fromRes) {
  const _platform = "WeChat";
  let _hostName = fromRes.hostName || _platform;
  {
    if (fromRes.environment) {
      _hostName = fromRes.environment;
    } else if (fromRes.host && fromRes.host.env) {
      _hostName = fromRes.host.env;
    }
  }
  return _hostName;
}
const getSystemInfo = {
  returnValue: (fromRes, toRes) => {
    addSafeAreaInsets(fromRes, toRes);
    useDeviceId()(fromRes, toRes);
    populateParameters(fromRes, toRes);
  }
};
const getSystemInfoSync = getSystemInfo;
const redirectTo = {};
const previewImage = {
  args(fromArgs, toArgs) {
    let currentIndex = parseInt(fromArgs.current);
    if (isNaN(currentIndex)) {
      return;
    }
    const urls = fromArgs.urls;
    if (!isArray$1(urls)) {
      return;
    }
    const len = urls.length;
    if (!len) {
      return;
    }
    if (currentIndex < 0) {
      currentIndex = 0;
    } else if (currentIndex >= len) {
      currentIndex = len - 1;
    }
    if (currentIndex > 0) {
      toArgs.current = urls[currentIndex];
      toArgs.urls = urls.filter((item, index2) => index2 < currentIndex ? item !== urls[currentIndex] : true);
    } else {
      toArgs.current = urls[0];
    }
    return {
      indicator: false,
      loop: false
    };
  }
};
const showActionSheet = {
  args(fromArgs, toArgs) {
    toArgs.alertText = fromArgs.title;
  }
};
const getDeviceInfo = {
  returnValue: (fromRes, toRes) => {
    const { brand, model, system = "", platform: platform2 = "" } = fromRes;
    let deviceType = getGetDeviceType(fromRes, model);
    let deviceBrand = getDeviceBrand(brand);
    useDeviceId()(fromRes, toRes);
    const { osName, osVersion } = getOSInfo(system, platform2);
    toRes = sortObject(extend(toRes, {
      deviceType,
      deviceBrand,
      deviceModel: model,
      osName,
      osVersion
    }));
  }
};
const getAppBaseInfo = {
  returnValue: (fromRes, toRes) => {
    const { version: version2, language, SDKVersion, theme } = fromRes;
    let _hostName = getHostName(fromRes);
    let hostLanguage = (language || "").replace(/_/g, "-");
    const parameters = {
      hostVersion: version2,
      hostLanguage,
      hostName: _hostName,
      hostSDKVersion: SDKVersion,
      hostTheme: theme,
      appId: "__UNI__3BB98A2",
      appName: "caimi",
      appVersion: "1.0.0",
      appVersionCode: "100",
      appLanguage: getAppLanguage(hostLanguage),
      isUniAppX: false,
      uniPlatform: "mp-weixin",
      uniCompileVersion: "4.76",
      uniCompilerVersion: "4.76",
      uniRuntimeVersion: "4.76"
    };
    extend(toRes, parameters);
  }
};
const getWindowInfo = {
  returnValue: (fromRes, toRes) => {
    addSafeAreaInsets(fromRes, toRes);
    toRes = sortObject(extend(toRes, {
      windowTop: 0,
      windowBottom: 0
    }));
  }
};
const getAppAuthorizeSetting = {
  returnValue: function(fromRes, toRes) {
    const { locationReducedAccuracy } = fromRes;
    toRes.locationAccuracy = "unsupported";
    if (locationReducedAccuracy === true) {
      toRes.locationAccuracy = "reduced";
    } else if (locationReducedAccuracy === false) {
      toRes.locationAccuracy = "full";
    }
  }
};
const onError = {
  args(fromArgs) {
    const app = getApp({ allowDefault: true }) || {};
    if (!app.$vm) {
      if (!wx.$onErrorHandlers) {
        wx.$onErrorHandlers = [];
      }
      wx.$onErrorHandlers.push(fromArgs);
    } else {
      injectHook(ON_ERROR, fromArgs, app.$vm.$);
    }
  }
};
const offError = {
  args(fromArgs) {
    const app = getApp({ allowDefault: true }) || {};
    if (!app.$vm) {
      if (!wx.$onErrorHandlers) {
        return;
      }
      const index2 = wx.$onErrorHandlers.findIndex((fn) => fn === fromArgs);
      if (index2 !== -1) {
        wx.$onErrorHandlers.splice(index2, 1);
      }
    } else if (fromArgs.__weh) {
      const onErrors = app.$vm.$[ON_ERROR];
      if (onErrors) {
        const index2 = onErrors.indexOf(fromArgs.__weh);
        if (index2 > -1) {
          onErrors.splice(index2, 1);
        }
      }
    }
  }
};
const onSocketOpen = {
  args() {
    if (wx.__uni_console__) {
      if (wx.__uni_console_warned__) {
        return;
      }
      wx.__uni_console_warned__ = true;
      console.warn(` socket  SocketTask  WebSocket [](https://uniapp.dcloud.net.cn/tutorial/run/mp-log.html)`);
    }
  }
};
const onSocketMessage = onSocketOpen;
const baseApis = {
  $on,
  $off,
  $once,
  $emit,
  upx2px,
  rpx2px: upx2px,
  interceptors,
  addInterceptor,
  removeInterceptor,
  onCreateVueApp,
  invokeCreateVueAppHook,
  getLocale,
  setLocale,
  onLocaleChange,
  getPushClientId,
  onPushMessage,
  offPushMessage,
  invokePushCallback,
  __f__
};
function initUni(api, protocols2, platform2 = wx) {
  const wrapper = initWrapper(protocols2);
  const UniProxyHandlers = {
    get(target, key) {
      if (hasOwn$1(target, key)) {
        return target[key];
      }
      if (hasOwn$1(api, key)) {
        return promisify(key, api[key]);
      }
      if (hasOwn$1(baseApis, key)) {
        return promisify(key, baseApis[key]);
      }
      return promisify(key, wrapper(key, platform2[key]));
    }
  };
  return new Proxy({}, UniProxyHandlers);
}
function initGetProvider(providers) {
  return function getProvider2({ service, success, fail, complete }) {
    let res;
    if (providers[service]) {
      res = {
        errMsg: "getProvider:ok",
        service,
        provider: providers[service]
      };
      isFunction(success) && success(res);
    } else {
      res = {
        errMsg: "getProvider:fail:[" + service + "]"
      };
      isFunction(fail) && fail(res);
    }
    isFunction(complete) && complete(res);
  };
}
const objectKeys = [
  "qy",
  "env",
  "error",
  "version",
  "lanDebug",
  "cloud",
  "serviceMarket",
  "router",
  "worklet",
  "__webpack_require_UNI_MP_PLUGIN__"
];
const singlePageDisableKey = ["lanDebug", "router", "worklet"];
const launchOption = wx.getLaunchOptionsSync ? wx.getLaunchOptionsSync() : null;
function isWxKey(key) {
  if (launchOption && launchOption.scene === 1154 && singlePageDisableKey.includes(key)) {
    return false;
  }
  return objectKeys.indexOf(key) > -1 || typeof wx[key] === "function";
}
function initWx() {
  const newWx = {};
  for (const key in wx) {
    if (isWxKey(key)) {
      newWx[key] = wx[key];
    }
  }
  if (typeof globalThis !== "undefined" && typeof requireMiniProgram === "undefined") {
    globalThis.wx = newWx;
  }
  return newWx;
}
const mocks$1 = ["__route__", "__wxExparserNodeId__", "__wxWebviewId__"];
const getProvider = initGetProvider({
  oauth: ["weixin"],
  share: ["weixin"],
  payment: ["wxpay"],
  push: ["weixin"]
});
function initComponentMocks(component) {
  const res = /* @__PURE__ */ Object.create(null);
  mocks$1.forEach((name) => {
    res[name] = component[name];
  });
  return res;
}
function createSelectorQuery() {
  const query = wx$2.createSelectorQuery();
  const oldIn = query.in;
  query.in = function newIn(component) {
    if (component.$scope) {
      return oldIn.call(this, component.$scope);
    }
    return oldIn.call(this, initComponentMocks(component));
  };
  return query;
}
const wx$2 = initWx();
if (!wx$2.canIUse("getAppBaseInfo")) {
  wx$2.getAppBaseInfo = wx$2.getSystemInfoSync;
}
if (!wx$2.canIUse("getWindowInfo")) {
  wx$2.getWindowInfo = wx$2.getSystemInfoSync;
}
if (!wx$2.canIUse("getDeviceInfo")) {
  wx$2.getDeviceInfo = wx$2.getSystemInfoSync;
}
let baseInfo = wx$2.getAppBaseInfo && wx$2.getAppBaseInfo();
if (!baseInfo) {
  baseInfo = wx$2.getSystemInfoSync();
}
const host = baseInfo ? baseInfo.host : null;
const shareVideoMessage = host && host.env === "SAAASDK" ? wx$2.miniapp.shareVideoMessage : wx$2.shareVideoMessage;
var shims = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createSelectorQuery,
  getProvider,
  shareVideoMessage
});
const compressImage = {
  args(fromArgs, toArgs) {
    if (fromArgs.compressedHeight && !toArgs.compressHeight) {
      toArgs.compressHeight = fromArgs.compressedHeight;
    }
    if (fromArgs.compressedWidth && !toArgs.compressWidth) {
      toArgs.compressWidth = fromArgs.compressedWidth;
    }
  }
};
var protocols = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  compressImage,
  getAppAuthorizeSetting,
  getAppBaseInfo,
  getDeviceInfo,
  getSystemInfo,
  getSystemInfoSync,
  getWindowInfo,
  offError,
  onError,
  onSocketMessage,
  onSocketOpen,
  previewImage,
  redirectTo,
  showActionSheet
});
const wx$1 = initWx();
var index$2 = initUni(shims, protocols, wx$1);
function initRuntimeSocket(hosts, port, id) {
  if (hosts == "" || port == "" || id == "")
    return Promise.resolve(null);
  return hosts.split(",").reduce((promise2, host2) => {
    return promise2.then((socket) => {
      if (socket != null)
        return Promise.resolve(socket);
      return tryConnectSocket(host2, port, id);
    });
  }, Promise.resolve(null));
}
const SOCKET_TIMEOUT = 500;
function tryConnectSocket(host2, port, id) {
  return new Promise((resolve2, reject) => {
    const socket = index$2.connectSocket({
      url: `ws://${host2}:${port}/${id}`,
      multiple: true,
      //  
      fail() {
        resolve2(null);
      }
    });
    const timer = setTimeout(() => {
      socket.close({
        code: 1006,
        reason: "connect timeout"
      });
      resolve2(null);
    }, SOCKET_TIMEOUT);
    socket.onOpen((e2) => {
      clearTimeout(timer);
      resolve2(socket);
    });
    socket.onClose((e2) => {
      clearTimeout(timer);
      resolve2(null);
    });
    socket.onError((e2) => {
      clearTimeout(timer);
      resolve2(null);
    });
  });
}
const CONSOLE_TYPES = ["log", "warn", "error", "info", "debug"];
const originalConsole = /* @__PURE__ */ CONSOLE_TYPES.reduce((methods, type) => {
  methods[type] = console[type].bind(console);
  return methods;
}, {});
let sendError = null;
const errorQueue = /* @__PURE__ */ new Set();
const errorExtra = {};
function sendErrorMessages(errors) {
  if (sendError == null) {
    errors.forEach((error2) => {
      errorQueue.add(error2);
    });
    return;
  }
  const data = errors.map((err) => {
    if (typeof err === "string") {
      return err;
    }
    const isPromiseRejection = err && "promise" in err && "reason" in err;
    const prefix = isPromiseRejection ? "UnhandledPromiseRejection: " : "";
    if (isPromiseRejection) {
      err = err.reason;
    }
    if (err instanceof Error && err.stack) {
      if (err.message && !err.stack.includes(err.message)) {
        return `${prefix}${err.message}
${err.stack}`;
      }
      return `${prefix}${err.stack}`;
    }
    if (typeof err === "object" && err !== null) {
      try {
        return prefix + JSON.stringify(err);
      } catch (err2) {
        return prefix + String(err2);
      }
    }
    return prefix + String(err);
  }).filter(Boolean);
  if (data.length > 0) {
    sendError(JSON.stringify(Object.assign({
      type: "error",
      data
    }, errorExtra)));
  }
}
function setSendError(value, extra = {}) {
  sendError = value;
  Object.assign(errorExtra, extra);
  if (value != null && errorQueue.size > 0) {
    const errors = Array.from(errorQueue);
    errorQueue.clear();
    sendErrorMessages(errors);
  }
}
function initOnError() {
  function onError2(error2) {
    try {
      if (typeof PromiseRejectionEvent !== "undefined" && error2 instanceof PromiseRejectionEvent && error2.reason instanceof Error && error2.reason.message && error2.reason.message.includes(`Cannot create property 'errMsg' on string 'taskId`)) {
        return;
      }
      if (true) {
        originalConsole.error(error2);
      }
      sendErrorMessages([error2]);
    } catch (err) {
      originalConsole.error(err);
    }
  }
  if (typeof index$2.onError === "function") {
    index$2.onError(onError2);
  }
  if (typeof index$2.onUnhandledRejection === "function") {
    index$2.onUnhandledRejection(onError2);
  }
  return function offError2() {
    if (typeof index$2.offError === "function") {
      index$2.offError(onError2);
    }
    if (typeof index$2.offUnhandledRejection === "function") {
      index$2.offUnhandledRejection(onError2);
    }
  };
}
function formatMessage(type, args) {
  try {
    return {
      type,
      args: formatArgs(args)
    };
  } catch (e2) {
  }
  return {
    type,
    args: []
  };
}
function formatArgs(args) {
  return args.map((arg) => formatArg(arg));
}
function formatArg(arg, depth = 0) {
  if (depth >= 7) {
    return {
      type: "object",
      value: "[Maximum depth reached]"
    };
  }
  const type = typeof arg;
  switch (type) {
    case "string":
      return formatString(arg);
    case "number":
      return formatNumber(arg);
    case "boolean":
      return formatBoolean(arg);
    case "object":
      try {
        return formatObject(arg, depth);
      } catch (e2) {
        return {
          type: "object",
          value: {
            properties: []
          }
        };
      }
    case "undefined":
      return formatUndefined();
    case "function":
      return formatFunction(arg);
    case "symbol": {
      return formatSymbol(arg);
    }
    case "bigint":
      return formatBigInt(arg);
  }
}
function formatFunction(value) {
  return {
    type: "function",
    value: `function ${value.name}() {}`
  };
}
function formatUndefined() {
  return {
    type: "undefined"
  };
}
function formatBoolean(value) {
  return {
    type: "boolean",
    value: String(value)
  };
}
function formatNumber(value) {
  return {
    type: "number",
    value: String(value)
  };
}
function formatBigInt(value) {
  return {
    type: "bigint",
    value: String(value)
  };
}
function formatString(value) {
  return {
    type: "string",
    value
  };
}
function formatSymbol(value) {
  return {
    type: "symbol",
    value: value.description
  };
}
function formatObject(value, depth) {
  if (value === null) {
    return {
      type: "null"
    };
  }
  {
    if (isComponentPublicInstance(value)) {
      return formatComponentPublicInstance(value, depth);
    }
    if (isComponentInternalInstance(value)) {
      return formatComponentInternalInstance(value, depth);
    }
    if (isUniElement(value)) {
      return formatUniElement(value, depth);
    }
    if (isCSSStyleDeclaration(value)) {
      return formatCSSStyleDeclaration(value, depth);
    }
  }
  if (Array.isArray(value)) {
    return {
      type: "object",
      subType: "array",
      value: {
        properties: value.map((v, i) => formatArrayElement(v, i, depth + 1))
      }
    };
  }
  if (value instanceof Set) {
    return {
      type: "object",
      subType: "set",
      className: "Set",
      description: `Set(${value.size})`,
      value: {
        entries: Array.from(value).map((v) => formatSetEntry(v, depth + 1))
      }
    };
  }
  if (value instanceof Map) {
    return {
      type: "object",
      subType: "map",
      className: "Map",
      description: `Map(${value.size})`,
      value: {
        entries: Array.from(value.entries()).map((v) => formatMapEntry(v, depth + 1))
      }
    };
  }
  if (value instanceof Promise) {
    return {
      type: "object",
      subType: "promise",
      value: {
        properties: []
      }
    };
  }
  if (value instanceof RegExp) {
    return {
      type: "object",
      subType: "regexp",
      value: String(value),
      className: "Regexp"
    };
  }
  if (value instanceof Date) {
    return {
      type: "object",
      subType: "date",
      value: String(value),
      className: "Date"
    };
  }
  if (value instanceof Error) {
    return {
      type: "object",
      subType: "error",
      value: value.message || String(value),
      className: value.name || "Error"
    };
  }
  let className = void 0;
  {
    const constructor = value.constructor;
    if (constructor) {
      if (constructor.get$UTSMetadata$) {
        className = constructor.get$UTSMetadata$().name;
      }
    }
  }
  let entries = Object.entries(value);
  if (isHarmonyBuilderParams(value)) {
    entries = entries.filter(([key]) => key !== "modifier" && key !== "nodeContent");
  }
  return {
    type: "object",
    className,
    value: {
      properties: entries.map((entry) => formatObjectProperty(entry[0], entry[1], depth + 1))
    }
  };
}
function isHarmonyBuilderParams(value) {
  return value.modifier && value.modifier._attribute && value.nodeContent;
}
function isComponentPublicInstance(value) {
  return value.$ && isComponentInternalInstance(value.$);
}
function isComponentInternalInstance(value) {
  return value.type && value.uid != null && value.appContext;
}
function formatComponentPublicInstance(value, depth) {
  return {
    type: "object",
    className: "ComponentPublicInstance",
    value: {
      properties: Object.entries(value.$.type).map(([name, value2]) => formatObjectProperty(name, value2, depth + 1))
    }
  };
}
function formatComponentInternalInstance(value, depth) {
  return {
    type: "object",
    className: "ComponentInternalInstance",
    value: {
      properties: Object.entries(value.type).map(([name, value2]) => formatObjectProperty(name, value2, depth + 1))
    }
  };
}
function isUniElement(value) {
  return value.style && value.tagName != null && value.nodeName != null;
}
function formatUniElement(value, depth) {
  return {
    type: "object",
    //  x  UniElement 
    // className: 'UniElement',
    value: {
      properties: Object.entries(value).filter(([name]) => [
        "id",
        "tagName",
        "nodeName",
        "dataset",
        "offsetTop",
        "offsetLeft",
        "style"
      ].includes(name)).map(([name, value2]) => formatObjectProperty(name, value2, depth + 1))
    }
  };
}
function isCSSStyleDeclaration(value) {
  return typeof value.getPropertyValue === "function" && typeof value.setProperty === "function" && value.$styles;
}
function formatCSSStyleDeclaration(style, depth) {
  return {
    type: "object",
    value: {
      properties: Object.entries(style.$styles).map(([name, value]) => formatObjectProperty(name, value, depth + 1))
    }
  };
}
function formatObjectProperty(name, value, depth) {
  const result = formatArg(value, depth);
  result.name = name;
  return result;
}
function formatArrayElement(value, index2, depth) {
  const result = formatArg(value, depth);
  result.name = `${index2}`;
  return result;
}
function formatSetEntry(value, depth) {
  return {
    value: formatArg(value, depth)
  };
}
function formatMapEntry(value, depth) {
  return {
    key: formatArg(value[0], depth),
    value: formatArg(value[1], depth)
  };
}
let sendConsole = null;
const messageQueue = [];
const messageExtra = {};
const EXCEPTION_BEGIN_MARK = "---BEGIN:EXCEPTION---";
const EXCEPTION_END_MARK = "---END:EXCEPTION---";
function sendConsoleMessages(messages) {
  if (sendConsole == null) {
    messageQueue.push(...messages);
    return;
  }
  sendConsole(JSON.stringify(Object.assign({
    type: "console",
    data: messages
  }, messageExtra)));
}
function setSendConsole(value, extra = {}) {
  sendConsole = value;
  Object.assign(messageExtra, extra);
  if (value != null && messageQueue.length > 0) {
    const messages = messageQueue.slice();
    messageQueue.length = 0;
    sendConsoleMessages(messages);
  }
}
const atFileRegex = /^\s*at\s+[\w/./-]+:\d+$/;
function rewriteConsole() {
  function wrapConsole(type) {
    return function(...args) {
      {
        const originalArgs = [...args];
        if (originalArgs.length) {
          const maybeAtFile = originalArgs[originalArgs.length - 1];
          if (typeof maybeAtFile === "string" && atFileRegex.test(maybeAtFile)) {
            originalArgs.pop();
          }
        }
        originalConsole[type](...originalArgs);
      }
      if (type === "error" && args.length === 1) {
        const arg = args[0];
        if (typeof arg === "string" && arg.startsWith(EXCEPTION_BEGIN_MARK)) {
          const startIndex = EXCEPTION_BEGIN_MARK.length;
          const endIndex = arg.length - EXCEPTION_END_MARK.length;
          sendErrorMessages([arg.slice(startIndex, endIndex)]);
          return;
        } else if (arg instanceof Error) {
          sendErrorMessages([arg]);
          return;
        }
      }
      sendConsoleMessages([formatMessage(type, args)]);
    };
  }
  if (isConsoleWritable()) {
    CONSOLE_TYPES.forEach((type) => {
      console[type] = wrapConsole(type);
    });
    return function restoreConsole() {
      CONSOLE_TYPES.forEach((type) => {
        console[type] = originalConsole[type];
      });
    };
  } else {
    {
      if (typeof index$2 !== "undefined" && index$2.__f__) {
        const oldLog = index$2.__f__;
        if (oldLog) {
          index$2.__f__ = function(...args) {
            const [type, filename, ...rest] = args;
            oldLog(type, "", ...rest);
            sendConsoleMessages([formatMessage(type, [...rest, filename])]);
          };
          return function restoreConsole() {
            index$2.__f__ = oldLog;
          };
        }
      }
    }
  }
  return function restoreConsole() {
  };
}
function isConsoleWritable() {
  const value = console.log;
  const sym = Symbol();
  try {
    console.log = sym;
  } catch (ex) {
    return false;
  }
  const isWritable = console.log === sym;
  console.log = value;
  return isWritable;
}
function initRuntimeSocketService() {
  const hosts = "192.168.31.181,192.168.122.1,192.168.140.1,127.0.0.1";
  const port = "8090";
  const id = "mp-weixin_WDJdxz";
  const lazy = typeof swan !== "undefined";
  let restoreError = lazy ? () => {
  } : initOnError();
  let restoreConsole = lazy ? () => {
  } : rewriteConsole();
  return Promise.resolve().then(() => {
    if (lazy) {
      restoreError = initOnError();
      restoreConsole = rewriteConsole();
    }
    return initRuntimeSocket(hosts, port, id).then((socket) => {
      if (!socket) {
        restoreError();
        restoreConsole();
        originalConsole.error(wrapError(" socket "));
        {
          originalConsole.error(wrapError(""));
        }
        originalConsole.error(wrapError(""));
        return false;
      }
      {
        initMiniProgramGlobalFlag();
      }
      socket.onClose(() => {
        {
          originalConsole.error(wrapError(" socket  HBuilderX "));
        }
        restoreError();
        restoreConsole();
      });
      setSendConsole((data) => {
        socket.send({
          data
        });
      });
      setSendError((data) => {
        socket.send({
          data
        });
      });
      return true;
    });
  });
}
const ERROR_CHAR = "";
function wrapError(error2) {
  return `${ERROR_CHAR}${error2}${ERROR_CHAR}`;
}
function initMiniProgramGlobalFlag() {
  if (typeof wx$1 !== "undefined") {
    wx$1.__uni_console__ = true;
  } else if (typeof my !== "undefined") {
    my.__uni_console__ = true;
  } else if (typeof tt !== "undefined") {
    tt.__uni_console__ = true;
  } else if (typeof swan !== "undefined") {
    swan.__uni_console__ = true;
  } else if (typeof qq !== "undefined") {
    qq.__uni_console__ = true;
  } else if (typeof ks !== "undefined") {
    ks.__uni_console__ = true;
  } else if (typeof jd !== "undefined") {
    jd.__uni_console__ = true;
  } else if (typeof xhs !== "undefined") {
    xhs.__uni_console__ = true;
  } else if (typeof has !== "undefined") {
    has.__uni_console__ = true;
  } else if (typeof qa !== "undefined") {
    qa.__uni_console__ = true;
  }
}
initRuntimeSocketService();
const _export_sfc = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props2) {
    target[key] = val;
  }
  return target;
};
function initVueIds(vueIds, mpInstance) {
  if (!vueIds) {
    return;
  }
  const ids = vueIds.split(",");
  const len = ids.length;
  if (len === 1) {
    mpInstance._$vueId = ids[0];
  } else if (len === 2) {
    mpInstance._$vueId = ids[0];
    mpInstance._$vuePid = ids[1];
  }
}
const EXTRAS = ["externalClasses"];
function initExtraOptions(miniProgramComponentOptions, vueOptions) {
  EXTRAS.forEach((name) => {
    if (hasOwn$1(vueOptions, name)) {
      miniProgramComponentOptions[name] = vueOptions[name];
    }
  });
}
const WORKLET_RE = /_(.*)_worklet_factory_/;
function initWorkletMethods(mpMethods, vueMethods) {
  if (vueMethods) {
    Object.keys(vueMethods).forEach((name) => {
      const matches = name.match(WORKLET_RE);
      if (matches) {
        const workletName = matches[1];
        mpMethods[name] = vueMethods[name];
        mpMethods[workletName] = vueMethods[workletName];
      }
    });
  }
}
function initWxsCallMethods(methods, wxsCallMethods) {
  if (!isArray$1(wxsCallMethods)) {
    return;
  }
  wxsCallMethods.forEach((callMethod) => {
    methods[callMethod] = function(args) {
      return this.$vm[callMethod](args);
    };
  });
}
function selectAllComponents(mpInstance, selector, $refs) {
  const components = mpInstance.selectAllComponents(selector);
  components.forEach((component) => {
    const ref2 = component.properties.uR;
    $refs[ref2] = component.$vm || component;
  });
}
function initRefs(instance, mpInstance) {
  Object.defineProperty(instance, "refs", {
    get() {
      const $refs = {};
      selectAllComponents(mpInstance, ".r", $refs);
      const forComponents = mpInstance.selectAllComponents(".r-i-f");
      forComponents.forEach((component) => {
        const ref2 = component.properties.uR;
        if (!ref2) {
          return;
        }
        if (!$refs[ref2]) {
          $refs[ref2] = [];
        }
        $refs[ref2].push(component.$vm || component);
      });
      return $refs;
    }
  });
}
function findVmByVueId(instance, vuePid) {
  const $children = instance.$children;
  for (let i = $children.length - 1; i >= 0; i--) {
    const childVm = $children[i];
    if (childVm.$scope._$vueId === vuePid) {
      return childVm;
    }
  }
  let parentVm;
  for (let i = $children.length - 1; i >= 0; i--) {
    parentVm = findVmByVueId($children[i], vuePid);
    if (parentVm) {
      return parentVm;
    }
  }
}
function getLocaleLanguage() {
  var _a;
  let localeLanguage = "";
  {
    const appBaseInfo = ((_a = wx.getAppBaseInfo) === null || _a === void 0 ? void 0 : _a.call(wx)) || wx.getSystemInfoSync();
    const language = appBaseInfo && appBaseInfo.language ? appBaseInfo.language : LOCALE_EN;
    localeLanguage = normalizeLocale(language) || LOCALE_EN;
  }
  return localeLanguage;
}
const MP_METHODS = [
  "createSelectorQuery",
  "createIntersectionObserver",
  "selectAllComponents",
  "selectComponent"
];
function createEmitFn(oldEmit, ctx) {
  return function emit2(event, ...args) {
    const scope = ctx.$scope;
    if (scope && event) {
      const detail = { __args__: args };
      {
        scope.triggerEvent(event, detail);
      }
    }
    return oldEmit.apply(this, [event, ...args]);
  };
}
function initBaseInstance(instance, options) {
  const ctx = instance.ctx;
  ctx.mpType = options.mpType;
  ctx.$mpType = options.mpType;
  ctx.$mpPlatform = "mp-weixin";
  ctx.$scope = options.mpInstance;
  {
    Object.defineProperties(ctx, {
      // only id
      [VIRTUAL_HOST_ID]: {
        get() {
          const id = this.$scope.data[VIRTUAL_HOST_ID];
          return id === void 0 ? "" : id;
        }
      }
    });
  }
  ctx.$mp = {};
  {
    ctx._self = {};
  }
  instance.slots = {};
  if (isArray$1(options.slots) && options.slots.length) {
    options.slots.forEach((name) => {
      instance.slots[name] = true;
    });
    if (instance.slots[SLOT_DEFAULT_NAME]) {
      instance.slots.default = true;
    }
  }
  ctx.getOpenerEventChannel = function() {
    {
      return options.mpInstance.getOpenerEventChannel();
    }
  };
  ctx.$hasHook = hasHook;
  ctx.$callHook = callHook;
  instance.emit = createEmitFn(instance.emit, ctx);
}
function initComponentInstance(instance, options) {
  initBaseInstance(instance, options);
  const ctx = instance.ctx;
  MP_METHODS.forEach((method) => {
    ctx[method] = function(...args) {
      const mpInstance = ctx.$scope;
      if (mpInstance && mpInstance[method]) {
        return mpInstance[method].apply(mpInstance, args);
      }
    };
  });
}
function initMocks(instance, mpInstance, mocks2) {
  const ctx = instance.ctx;
  mocks2.forEach((mock) => {
    if (hasOwn$1(mpInstance, mock)) {
      instance[mock] = ctx[mock] = mpInstance[mock];
    }
  });
}
function hasHook(name) {
  const hooks = this.$[name];
  if (hooks && hooks.length) {
    return true;
  }
  return false;
}
function callHook(name, args) {
  if (name === "mounted") {
    callHook.call(this, "bm");
    this.$.isMounted = true;
    name = "m";
  }
  const hooks = this.$[name];
  return hooks && invokeArrayFns(hooks, args);
}
const PAGE_INIT_HOOKS = [
  ON_LOAD,
  ON_SHOW,
  ON_HIDE,
  ON_UNLOAD,
  ON_RESIZE,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_ADD_TO_FAVORITES
  // 'onReady', // lifetimes.ready
  // 'onPageScroll', // 
  // 'onShareTimeline', // 
  // 'onShareAppMessage' // 
];
function findHooks(vueOptions, hooks = /* @__PURE__ */ new Set()) {
  if (vueOptions) {
    Object.keys(vueOptions).forEach((name) => {
      if (isUniLifecycleHook(name, vueOptions[name])) {
        hooks.add(name);
      }
    });
    {
      const { extends: extendsOptions, mixins } = vueOptions;
      if (mixins) {
        mixins.forEach((mixin2) => findHooks(mixin2, hooks));
      }
      if (extendsOptions) {
        findHooks(extendsOptions, hooks);
      }
    }
  }
  return hooks;
}
function initHook(mpOptions, hook, excludes) {
  if (excludes.indexOf(hook) === -1 && !hasOwn$1(mpOptions, hook)) {
    mpOptions[hook] = function(args) {
      return this.$vm && this.$vm.$callHook(hook, args);
    };
  }
}
const EXCLUDE_HOOKS = [ON_READY];
function initHooks(mpOptions, hooks, excludes = EXCLUDE_HOOKS) {
  hooks.forEach((hook) => initHook(mpOptions, hook, excludes));
}
function initUnknownHooks(mpOptions, vueOptions, excludes = EXCLUDE_HOOKS) {
  findHooks(vueOptions).forEach((hook) => initHook(mpOptions, hook, excludes));
}
function initRuntimeHooks(mpOptions, runtimeHooks) {
  if (!runtimeHooks) {
    return;
  }
  const hooks = Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);
  hooks.forEach((hook) => {
    if (runtimeHooks & MINI_PROGRAM_PAGE_RUNTIME_HOOKS[hook]) {
      initHook(mpOptions, hook, []);
    }
  });
}
const findMixinRuntimeHooks = /* @__PURE__ */ once(() => {
  const runtimeHooks = [];
  const app = isFunction(getApp) && getApp({ allowDefault: true });
  if (app && app.$vm && app.$vm.$) {
    const mixins = app.$vm.$.appContext.mixins;
    if (isArray$1(mixins)) {
      const hooks = Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);
      mixins.forEach((mixin2) => {
        hooks.forEach((hook) => {
          if (hasOwn$1(mixin2, hook) && !runtimeHooks.includes(hook)) {
            runtimeHooks.push(hook);
          }
        });
      });
    }
  }
  return runtimeHooks;
});
function initMixinRuntimeHooks(mpOptions) {
  initHooks(mpOptions, findMixinRuntimeHooks());
}
const HOOKS = [
  ON_SHOW,
  ON_HIDE,
  ON_ERROR,
  ON_THEME_CHANGE,
  ON_PAGE_NOT_FOUND,
  ON_UNHANDLE_REJECTION
];
function parseApp(instance, parseAppOptions) {
  const internalInstance = instance.$;
  const appOptions = {
    globalData: instance.$options && instance.$options.globalData || {},
    $vm: instance,
    // mp-alipay  data  onLaunch 
    onLaunch(options) {
      this.$vm = instance;
      const ctx = internalInstance.ctx;
      if (this.$vm && ctx.$scope && ctx.$callHook) {
        return;
      }
      initBaseInstance(internalInstance, {
        mpType: "app",
        mpInstance: this,
        slots: []
      });
      ctx.globalData = this.globalData;
      instance.$callHook(ON_LAUNCH, options);
    }
  };
  const onErrorHandlers = wx.$onErrorHandlers;
  if (onErrorHandlers) {
    onErrorHandlers.forEach((fn) => {
      injectHook(ON_ERROR, fn, internalInstance);
    });
    onErrorHandlers.length = 0;
  }
  initLocale(instance);
  const vueOptions = instance.$.type;
  initHooks(appOptions, HOOKS);
  initUnknownHooks(appOptions, vueOptions);
  {
    const methods = vueOptions.methods;
    methods && extend(appOptions, methods);
  }
  return appOptions;
}
function initCreateApp(parseAppOptions) {
  return function createApp2(vm) {
    return App(parseApp(vm));
  };
}
function initCreateSubpackageApp(parseAppOptions) {
  return function createApp2(vm) {
    const appOptions = parseApp(vm);
    const app = isFunction(getApp) && getApp({
      allowDefault: true
    });
    if (!app)
      return;
    vm.$.ctx.$scope = app;
    const globalData = app.globalData;
    if (globalData) {
      Object.keys(appOptions.globalData).forEach((name) => {
        if (!hasOwn$1(globalData, name)) {
          globalData[name] = appOptions.globalData[name];
        }
      });
    }
    Object.keys(appOptions).forEach((name) => {
      if (!hasOwn$1(app, name)) {
        app[name] = appOptions[name];
      }
    });
    initAppLifecycle(appOptions, vm);
  };
}
function initAppLifecycle(appOptions, vm) {
  if (isFunction(appOptions.onLaunch)) {
    const args = wx.getLaunchOptionsSync && wx.getLaunchOptionsSync();
    appOptions.onLaunch(args);
  }
  if (isFunction(appOptions.onShow) && wx.onAppShow) {
    wx.onAppShow((args) => {
      vm.$callHook("onShow", args);
    });
  }
  if (isFunction(appOptions.onHide) && wx.onAppHide) {
    wx.onAppHide((args) => {
      vm.$callHook("onHide", args);
    });
  }
}
function initLocale(appVm) {
  const locale = ref(getLocaleLanguage());
  Object.defineProperty(appVm, "$locale", {
    get() {
      return locale.value;
    },
    set(v) {
      locale.value = v;
    }
  });
}
const builtInProps = [
  // ,datasetprops
  // event-opts
  "eO",
  //  ref
  "uR",
  //  ref-in-for
  "uRIF",
  //  id
  "uI",
  //  m: 
  "uT",
  //  props
  "uP",
  //  $slots  props vueSlots  $slots
  "uS"
];
function initDefaultProps(options, isBehavior = false) {
  const properties = {};
  if (!isBehavior) {
    let observerSlots = function(newVal) {
      const $slots = /* @__PURE__ */ Object.create(null);
      newVal && newVal.forEach((slotName) => {
        $slots[slotName] = true;
      });
      this.setData({
        $slots
      });
    };
    builtInProps.forEach((name) => {
      properties[name] = {
        type: null,
        value: ""
      };
    });
    properties.uS = {
      type: null,
      value: []
    };
    {
      properties.uS.observer = observerSlots;
    }
  }
  if (options.behaviors) {
    if (options.behaviors.includes("wx://form-field")) {
      if (!options.properties || !options.properties.name) {
        properties.name = {
          type: null,
          value: ""
        };
      }
      if (!options.properties || !options.properties.value) {
        properties.value = {
          type: null,
          value: ""
        };
      }
    }
  }
  return properties;
}
function initVirtualHostProps(options) {
  const properties = {};
  {
    if (options && options.virtualHost) {
      properties[VIRTUAL_HOST_STYLE] = {
        type: null,
        value: ""
      };
      properties[VIRTUAL_HOST_CLASS] = {
        type: null,
        value: ""
      };
      properties[VIRTUAL_HOST_HIDDEN] = {
        type: null,
        value: ""
      };
      properties[VIRTUAL_HOST_ID] = {
        type: null,
        value: ""
      };
    }
  }
  return properties;
}
function initProps(mpComponentOptions) {
  if (!mpComponentOptions.properties) {
    mpComponentOptions.properties = {};
  }
  extend(mpComponentOptions.properties, initDefaultProps(mpComponentOptions), initVirtualHostProps(mpComponentOptions.options));
}
const PROP_TYPES = [String, Number, Boolean, Object, Array, null];
function parsePropType(type, defaultValue) {
  if (isArray$1(type) && type.length === 1) {
    return type[0];
  }
  return type;
}
function normalizePropType(type, defaultValue) {
  const res = parsePropType(type);
  return PROP_TYPES.indexOf(res) !== -1 ? res : null;
}
function initPageProps({ properties }, rawProps) {
  if (isArray$1(rawProps)) {
    rawProps.forEach((key) => {
      properties[key] = {
        type: String,
        value: ""
      };
    });
  } else if (isPlainObject$2(rawProps)) {
    Object.keys(rawProps).forEach((key) => {
      const opts = rawProps[key];
      if (isPlainObject$2(opts)) {
        let value = opts.default;
        if (isFunction(value)) {
          value = value();
        }
        const type = opts.type;
        opts.type = normalizePropType(type);
        properties[key] = {
          type: opts.type,
          value
        };
      } else {
        properties[key] = {
          type: normalizePropType(opts)
        };
      }
    });
  }
}
function findPropsData(properties, isPage2) {
  return (isPage2 ? findPagePropsData(properties) : findComponentPropsData(resolvePropValue(properties.uP))) || {};
}
function findPagePropsData(properties) {
  const propsData = {};
  if (isPlainObject$2(properties)) {
    Object.keys(properties).forEach((name) => {
      if (builtInProps.indexOf(name) === -1) {
        propsData[name] = resolvePropValue(properties[name]);
      }
    });
  }
  return propsData;
}
function initFormField(vm) {
  const vueOptions = vm.$options;
  if (isArray$1(vueOptions.behaviors) && vueOptions.behaviors.includes("uni://form-field")) {
    vm.$watch("modelValue", () => {
      vm.$scope && vm.$scope.setData({
        name: vm.name,
        value: vm.modelValue
      });
    }, {
      immediate: true
    });
  }
}
function resolvePropValue(prop) {
  return prop;
}
function initData(_) {
  return {};
}
function initPropsObserver(componentOptions) {
  const observe = function observe2() {
    const up = this.properties.uP;
    if (!up) {
      return;
    }
    if (this.$vm) {
      updateComponentProps(resolvePropValue(up), this.$vm.$);
    } else if (resolvePropValue(this.properties.uT) === "m") {
      updateMiniProgramComponentProperties(resolvePropValue(up), this);
    }
  };
  {
    if (!componentOptions.observers) {
      componentOptions.observers = {};
    }
    componentOptions.observers.uP = observe;
  }
}
function updateMiniProgramComponentProperties(up, mpInstance) {
  const prevProps = mpInstance.properties;
  const nextProps = findComponentPropsData(up) || {};
  if (hasPropsChanged(prevProps, nextProps, false)) {
    mpInstance.setData(nextProps);
  }
}
function updateComponentProps(up, instance) {
  const prevProps = toRaw(instance.props);
  const nextProps = findComponentPropsData(up) || {};
  if (hasPropsChanged(prevProps, nextProps)) {
    updateProps(instance, nextProps, prevProps, false);
    if (hasQueueJob(instance.update)) {
      invalidateJob(instance.update);
    }
    {
      instance.update();
    }
  }
}
function hasPropsChanged(prevProps, nextProps, checkLen = true) {
  const nextKeys = Object.keys(nextProps);
  if (checkLen && nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key]) {
      return true;
    }
  }
  return false;
}
function initBehaviors(vueOptions) {
  const vueBehaviors = vueOptions.behaviors;
  let vueProps = vueOptions.props;
  if (!vueProps) {
    vueOptions.props = vueProps = [];
  }
  const behaviors = [];
  if (isArray$1(vueBehaviors)) {
    vueBehaviors.forEach((behavior) => {
      behaviors.push(behavior.replace("uni://", "wx://"));
      if (behavior === "uni://form-field") {
        if (isArray$1(vueProps)) {
          vueProps.push("name");
          vueProps.push("modelValue");
        } else {
          vueProps.name = {
            type: String,
            default: ""
          };
          vueProps.modelValue = {
            type: [String, Number, Boolean, Array, Object, Date],
            default: ""
          };
        }
      }
    });
  }
  return behaviors;
}
function applyOptions(componentOptions, vueOptions) {
  componentOptions.data = initData();
  componentOptions.behaviors = initBehaviors(vueOptions);
}
function parseComponent(vueOptions, { parse: parse2, mocks: mocks2, isPage: isPage2, isPageInProject, initRelation: initRelation2, handleLink: handleLink2, initLifetimes: initLifetimes2 }) {
  vueOptions = vueOptions.default || vueOptions;
  const options = {
    multipleSlots: true,
    // styleIsolation: 'apply-shared',
    addGlobalClass: true,
    pureDataPattern: /^uP$/
  };
  if (isArray$1(vueOptions.mixins)) {
    vueOptions.mixins.forEach((item) => {
      if (isObject$3(item.options)) {
        extend(options, item.options);
      }
    });
  }
  if (vueOptions.options) {
    extend(options, vueOptions.options);
  }
  const mpComponentOptions = {
    options,
    lifetimes: initLifetimes2({ mocks: mocks2, isPage: isPage2, initRelation: initRelation2, vueOptions }),
    pageLifetimes: {
      show() {
        this.$vm && this.$vm.$callHook("onPageShow");
      },
      hide() {
        this.$vm && this.$vm.$callHook("onPageHide");
      },
      resize(size2) {
        this.$vm && this.$vm.$callHook("onPageResize", size2);
      }
    },
    methods: {
      __l: handleLink2
    }
  };
  {
    applyOptions(mpComponentOptions, vueOptions);
  }
  initProps(mpComponentOptions);
  initPropsObserver(mpComponentOptions);
  initExtraOptions(mpComponentOptions, vueOptions);
  initWxsCallMethods(mpComponentOptions.methods, vueOptions.wxsCallMethods);
  {
    initWorkletMethods(mpComponentOptions.methods, vueOptions.methods);
  }
  if (parse2) {
    parse2(mpComponentOptions, { handleLink: handleLink2 });
  }
  return mpComponentOptions;
}
function initCreateComponent(parseOptions2) {
  return function createComponent2(vueComponentOptions) {
    return Component(parseComponent(vueComponentOptions, parseOptions2));
  };
}
let $createComponentFn;
let $destroyComponentFn;
function getAppVm() {
  return getApp().$vm;
}
function $createComponent(initialVNode, options) {
  if (!$createComponentFn) {
    $createComponentFn = getAppVm().$createComponent;
  }
  const proxy = $createComponentFn(initialVNode, options);
  return getExposeProxy(proxy.$) || proxy;
}
function $destroyComponent(instance) {
  if (!$destroyComponentFn) {
    $destroyComponentFn = getAppVm().$destroyComponent;
  }
  return $destroyComponentFn(instance);
}
function parsePage(vueOptions, parseOptions2) {
  const { parse: parse2, mocks: mocks2, isPage: isPage2, initRelation: initRelation2, handleLink: handleLink2, initLifetimes: initLifetimes2 } = parseOptions2;
  const miniProgramPageOptions = parseComponent(vueOptions, {
    mocks: mocks2,
    isPage: isPage2,
    isPageInProject: true,
    initRelation: initRelation2,
    handleLink: handleLink2,
    initLifetimes: initLifetimes2
  });
  initPageProps(miniProgramPageOptions, (vueOptions.default || vueOptions).props);
  const methods = miniProgramPageOptions.methods;
  methods.onLoad = function(query) {
    {
      this.options = query;
    }
    this.$page = {
      fullPath: addLeadingSlash(this.route + stringifyQuery(query))
    };
    return this.$vm && this.$vm.$callHook(ON_LOAD, query);
  };
  initHooks(methods, PAGE_INIT_HOOKS);
  {
    initUnknownHooks(methods, vueOptions);
  }
  initRuntimeHooks(methods, vueOptions.__runtimeHooks);
  initMixinRuntimeHooks(methods);
  parse2 && parse2(miniProgramPageOptions, { handleLink: handleLink2 });
  return miniProgramPageOptions;
}
function initCreatePage(parseOptions2) {
  return function createPage2(vuePageOptions) {
    return Component(parsePage(vuePageOptions, parseOptions2));
  };
}
function initCreatePluginApp(parseAppOptions) {
  return function createApp2(vm) {
    initAppLifecycle(parseApp(vm), vm);
  };
}
const MPPage = Page;
const MPComponent = Component;
function initTriggerEvent(mpInstance) {
  const oldTriggerEvent = mpInstance.triggerEvent;
  const newTriggerEvent = function(event, ...args) {
    return oldTriggerEvent.apply(mpInstance, [
      customizeEvent(event),
      ...args
    ]);
  };
  try {
    mpInstance.triggerEvent = newTriggerEvent;
  } catch (error2) {
    mpInstance._triggerEvent = newTriggerEvent;
  }
}
function initMiniProgramHook(name, options, isComponent) {
  const oldHook = options[name];
  if (!oldHook) {
    options[name] = function() {
      initTriggerEvent(this);
    };
  } else {
    options[name] = function(...args) {
      initTriggerEvent(this);
      return oldHook.apply(this, args);
    };
  }
}
Page = function(options) {
  initMiniProgramHook(ON_LOAD, options);
  return MPPage(options);
};
Component = function(options) {
  initMiniProgramHook("created", options);
  const isVueComponent = options.properties && options.properties.uP;
  if (!isVueComponent) {
    initProps(options);
    initPropsObserver(options);
  }
  return MPComponent(options);
};
function initLifetimes({ mocks: mocks2, isPage: isPage2, initRelation: initRelation2, vueOptions }) {
  return {
    attached() {
      let properties = this.properties;
      initVueIds(properties.uI, this);
      const relationOptions = {
        vuePid: this._$vuePid
      };
      initRelation2(this, relationOptions);
      const mpInstance = this;
      const isMiniProgramPage = isPage2(mpInstance);
      let propsData = properties;
      this.$vm = $createComponent({
        type: vueOptions,
        props: findPropsData(propsData, isMiniProgramPage)
      }, {
        mpType: isMiniProgramPage ? "page" : "component",
        mpInstance,
        slots: properties.uS || {},
        // vueSlots
        parentComponent: relationOptions.parent && relationOptions.parent.$,
        onBeforeSetup(instance, options) {
          initRefs(instance, mpInstance);
          initMocks(instance, mpInstance, mocks2);
          initComponentInstance(instance, options);
        }
      });
      if (!isMiniProgramPage) {
        initFormField(this.$vm);
      }
    },
    ready() {
      if (this.$vm) {
        {
          this.$vm.$callHook("mounted");
          this.$vm.$callHook(ON_READY);
        }
      }
    },
    detached() {
      if (this.$vm) {
        pruneComponentPropsCache(this.$vm.$.uid);
        $destroyComponent(this.$vm);
      }
    }
  };
}
const mocks = ["__route__", "__wxExparserNodeId__", "__wxWebviewId__"];
function isPage(mpInstance) {
  return !!mpInstance.route;
}
function initRelation(mpInstance, detail) {
  mpInstance.triggerEvent("__l", detail);
}
function handleLink(event) {
  const detail = event.detail || event.value;
  const vuePid = detail.vuePid;
  let parentVm;
  if (vuePid) {
    parentVm = findVmByVueId(this.$vm, vuePid);
  }
  if (!parentVm) {
    parentVm = this.$vm;
  }
  detail.parent = parentVm;
}
var parseOptions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  handleLink,
  initLifetimes,
  initRelation,
  isPage,
  mocks
});
const createApp = initCreateApp();
const createPage = initCreatePage(parseOptions);
const createComponent = initCreateComponent(parseOptions);
const createPluginApp = initCreatePluginApp();
const createSubpackageApp = initCreateSubpackageApp();
{
  wx.createApp = global.createApp = createApp;
  wx.createPage = createPage;
  wx.createComponent = createComponent;
  wx.createPluginApp = global.createPluginApp = createPluginApp;
  wx.createSubpackageApp = global.createSubpackageApp = createSubpackageApp;
}
/*!
 * vuex v4.1.0
 * (c) 2022 Evan You
 * @license MIT
 */
var storeKey = "store";
function useStore(key) {
  if (key === void 0)
    key = null;
  return inject(key !== null ? key : storeKey);
}
function find(list2, f2) {
  return list2.filter(f2)[0];
}
function deepCopy(obj, cache) {
  if (cache === void 0)
    cache = [];
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  var hit = find(cache, function(c) {
    return c.original === obj;
  });
  if (hit) {
    return hit.copy;
  }
  var copy = Array.isArray(obj) ? [] : {};
  cache.push({
    original: obj,
    copy
  });
  Object.keys(obj).forEach(function(key) {
    copy[key] = deepCopy(obj[key], cache);
  });
  return copy;
}
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function(key) {
    return fn(obj[key], key);
  });
}
function isObject$1(obj) {
  return obj !== null && typeof obj === "object";
}
function isPromise(val) {
  return val && typeof val.then === "function";
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}
function partial(fn, arg) {
  return function() {
    return fn(arg);
  };
}
function genericSubscribe(fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
  }
  return function() {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}
function resetStore(store, hot) {
  store._actions = /* @__PURE__ */ Object.create(null);
  store._mutations = /* @__PURE__ */ Object.create(null);
  store._wrappedGetters = /* @__PURE__ */ Object.create(null);
  store._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var state = store.state;
  installModule(store, state, [], store._modules.root, true);
  resetStoreState(store, state, hot);
}
function resetStoreState(store, state, hot) {
  var oldState = store._state;
  var oldScope = store._scope;
  store.getters = {};
  store._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computedObj = {};
  var computedCache = {};
  var scope = effectScope(true);
  scope.run(function() {
    forEachValue(wrappedGetters, function(fn, key) {
      computedObj[key] = partial(fn, store);
      computedCache[key] = computed(function() {
        return computedObj[key]();
      });
      Object.defineProperty(store.getters, key, {
        get: function() {
          return computedCache[key].value;
        },
        enumerable: true
        // for local getters
      });
    });
  });
  store._state = reactive({
    data: state
  });
  store._scope = scope;
  if (store.strict) {
    enableStrictMode(store);
  }
  if (oldState) {
    if (hot) {
      store._withCommit(function() {
        oldState.data = null;
      });
    }
  }
  if (oldScope) {
    oldScope.stop();
  }
}
function installModule(store, rootState, path, module2, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);
  if (module2.namespaced) {
    if (store._modulesNamespaceMap[namespace] && true) {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
    }
    store._modulesNamespaceMap[namespace] = module2;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function() {
      {
        if (moduleName in parentState) {
          console.warn(
            '[vuex] state field "' + moduleName + '" was overridden by a module with the same name at "' + path.join(".") + '"'
          );
        }
      }
      parentState[moduleName] = module2.state;
    });
  }
  var local = module2.context = makeLocalContext(store, namespace, path);
  module2.forEachMutation(function(mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });
  module2.forEachAction(function(action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });
  module2.forEachGetter(function(getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });
  module2.forEachChild(function(child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}
function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === "";
  var local = {
    dispatch: noNamespace ? store.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
        if (!store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }
      return store.dispatch(type, payload);
    },
    commit: noNamespace ? store.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
        if (!store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }
      store.commit(type, payload, options);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store.getters;
      } : function() {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function() {
        return getNestedState(store.state, path);
      }
    }
  });
  return local;
}
function makeLocalGetters(store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function(type) {
      if (type.slice(0, splitPos) !== namespace) {
        return;
      }
      var localType = type.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store.getters[type];
        },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }
  return store._makeLocalGettersCache[namespace];
}
function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}
function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function(err) {
        store._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  });
}
function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    {
      console.error("[vuex] duplicate getter key: " + type);
    }
    return;
  }
  store._wrappedGetters[type] = function wrappedGetter(store2) {
    return rawGetter(
      local.state,
      // local state
      local.getters,
      // local getters
      store2.state,
      // root state
      store2.getters
      // root getters
    );
  };
}
function enableStrictMode(store) {
  watch(function() {
    return store._state.data;
  }, function() {
    {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, flush: "sync" });
}
function getNestedState(state, path) {
  return path.reduce(function(state2, key) {
    return state2[key];
  }, state);
}
function unifyObjectStyle(type, payload, options) {
  if (isObject$1(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }
  {
    assert(typeof type === "string", "expects string as the type, but found " + typeof type + ".");
  }
  return { type, payload, options };
}
var Module = function Module2(rawModule, runtime) {
  this.runtime = runtime;
  this._children = /* @__PURE__ */ Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
};
var prototypeAccessors$1 = { namespaced: { configurable: true } };
prototypeAccessors$1.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = function addChild(key, module2) {
  this._children[key] = module2;
};
Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};
Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};
Module.prototype.hasChild = function hasChild(key) {
  return key in this._children;
};
Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};
Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};
Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};
Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};
Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};
Object.defineProperties(Module.prototype, prototypeAccessors$1);
var ModuleCollection = function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
};
ModuleCollection.prototype.get = function get2(path) {
  return path.reduce(function(module2, key) {
    return module2.getChild(key);
  }, this.root);
};
ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module2 = this.root;
  return path.reduce(function(namespace, key) {
    module2 = module2.getChild(key);
    return namespace + (module2.namespaced ? key + "/" : "");
  }, "");
};
ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update2([], this.root, rawRootModule);
};
ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1$1 = this;
  if (runtime === void 0)
    runtime = true;
  {
    assertRawModule(path, rawModule);
  }
  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};
ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);
  if (!child) {
    {
      console.warn(
        "[vuex] trying to unregister module '" + key + "', which is not registered"
      );
    }
    return;
  }
  if (!child.runtime) {
    return;
  }
  parent.removeChild(key);
};
ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (parent) {
    return parent.hasChild(key);
  }
  return false;
};
function update2(path, targetModule, newModule) {
  {
    assertRawModule(path, newModule);
  }
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, manual reload is needed"
          );
        }
        return;
      }
      update2(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}
var functionAssert = {
  assert: function(value) {
    return typeof value === "function";
  },
  expected: "function"
};
var objectAssert = {
  assert: function(value) {
    return typeof value === "function" || typeof value === "object" && typeof value.handler === "function";
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};
function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function(key) {
    if (!rawModule[key]) {
      return;
    }
    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function(value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}
function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + ' but "' + key + "." + type + '"';
  if (path.length > 0) {
    buf += ' in module "' + path.join(".") + '"';
  }
  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}
function createStore(options) {
  return new Store(options);
}
var Store = function Store2(options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  {
    assert(typeof Promise !== "undefined", "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store2, "store must be called with the new operator.");
  }
  var plugins = options.plugins;
  if (plugins === void 0)
    plugins = [];
  var strict = options.strict;
  if (strict === void 0)
    strict = false;
  var devtools2 = options.devtools;
  this._committing = false;
  this._actions = /* @__PURE__ */ Object.create(null);
  this._actionSubscribers = [];
  this._mutations = /* @__PURE__ */ Object.create(null);
  this._wrappedGetters = /* @__PURE__ */ Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  this._scope = null;
  this._devtools = devtools2;
  var store = this;
  var ref2 = this;
  var dispatch2 = ref2.dispatch;
  var commit2 = ref2.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch2.call(store, type, payload);
  };
  this.commit = function boundCommit(type, payload, options2) {
    return commit2.call(store, type, payload, options2);
  };
  this.strict = strict;
  var state = this._modules.root.state;
  installModule(this, state, [], this._modules.root);
  resetStoreState(this, state);
  plugins.forEach(function(plugin2) {
    return plugin2(this$1$1);
  });
};
var prototypeAccessors = { state: { configurable: true } };
Store.prototype.install = function install(app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;
  this._devtools !== void 0 ? this._devtools : true;
};
prototypeAccessors.state.get = function() {
  return this._state.data;
};
prototypeAccessors.state.set = function(v) {
  {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};
Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload, _options);
  var type = ref2.type;
  var payload = ref2.payload;
  var options = ref2.options;
  var mutation = { type, payload };
  var entry = this._mutations[type];
  if (!entry) {
    {
      console.error("[vuex] unknown mutation type: " + type);
    }
    return;
  }
  this._withCommit(function() {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.slice().forEach(function(sub) {
    return sub(mutation, this$1$1.state);
  });
  if (options && options.silent) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. Use the filter functionality in the vue-devtools"
    );
  }
};
Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload);
  var type = ref2.type;
  var payload = ref2.payload;
  var action = { type, payload };
  var entry = this._actions[type];
  if (!entry) {
    {
      console.error("[vuex] unknown action type: " + type);
    }
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub) {
      return sub.before;
    }).forEach(function(sub) {
      return sub.before(action, this$1$1.state);
    });
  } catch (e2) {
    {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e2);
    }
  }
  var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve2, reject) {
    result.then(function(res) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.after;
        }).forEach(function(sub) {
          return sub.after(action, this$1$1.state);
        });
      } catch (e2) {
        {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e2);
        }
      }
      resolve2(res);
    }, function(error2) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.error;
        }).forEach(function(sub) {
          return sub.error(action, this$1$1.state, error2);
        });
      } catch (e2) {
        {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e2);
        }
      }
      reject(error2);
    });
  });
};
Store.prototype.subscribe = function subscribe(fn, options) {
  return genericSubscribe(fn, this._subscribers, options);
};
Store.prototype.subscribeAction = function subscribeAction(fn, options) {
  var subs = typeof fn === "function" ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options);
};
Store.prototype.watch = function watch$1(getter, cb, options) {
  var this$1$1 = this;
  {
    assert(typeof getter === "function", "store.watch only accepts a function.");
  }
  return watch(function() {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb, Object.assign({}, options));
};
Store.prototype.replaceState = function replaceState(state) {
  var this$1$1 = this;
  this._withCommit(function() {
    this$1$1._state.data = state;
  });
};
Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0)
    options = {};
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, "cannot register the root module by using registerModule.");
  }
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  resetStoreState(this, this.state);
};
Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1$1 = this;
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }
  this._modules.unregister(path);
  this._withCommit(function() {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};
Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }
  return this._modules.isRegistered(path);
};
Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};
Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};
Object.defineProperties(Store.prototype, prototypeAccessors);
var mapState$1 = normalizeNamespace(function(namespace, states) {
  var res = {};
  if (!isValidMap(states)) {
    console.error("[vuex] mapState: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(states).forEach(function(ref2) {
    var key = ref2.key;
    var val = ref2.val;
    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module2 = getModuleByNamespace(this.$store, "mapState", namespace);
        if (!module2) {
          return;
        }
        state = module2.context.state;
        getters = module2.context.getters;
      }
      return typeof val === "function" ? val.call(this, state, getters) : state[val];
    };
    res[key].vuex = true;
  });
  return res;
});
var mapMutations = normalizeNamespace(function(namespace, mutations) {
  var res = {};
  if (!isValidMap(mutations)) {
    console.error("[vuex] mapMutations: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(mutations).forEach(function(ref2) {
    var key = ref2.key;
    var val = ref2.val;
    res[key] = function mappedMutation() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var commit2 = this.$store.commit;
      if (namespace) {
        var module2 = getModuleByNamespace(this.$store, "mapMutations", namespace);
        if (!module2) {
          return;
        }
        commit2 = module2.context.commit;
      }
      return typeof val === "function" ? val.apply(this, [commit2].concat(args)) : commit2.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
var mapGetters$1 = normalizeNamespace(function(namespace, getters) {
  var res = {};
  if (!isValidMap(getters)) {
    console.error("[vuex] mapGetters: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(getters).forEach(function(ref2) {
    var key = ref2.key;
    var val = ref2.val;
    val = namespace + val;
    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, "mapGetters", namespace)) {
        return;
      }
      if (!(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }
      return this.$store.getters[val];
    };
    res[key].vuex = true;
  });
  return res;
});
var mapActions$1 = normalizeNamespace(function(namespace, actions) {
  var res = {};
  if (!isValidMap(actions)) {
    console.error("[vuex] mapActions: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(actions).forEach(function(ref2) {
    var key = ref2.key;
    var val = ref2.val;
    res[key] = function mappedAction() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var dispatch2 = this.$store.dispatch;
      if (namespace) {
        var module2 = getModuleByNamespace(this.$store, "mapActions", namespace);
        if (!module2) {
          return;
        }
        dispatch2 = module2.context.dispatch;
      }
      return typeof val === "function" ? val.apply(this, [dispatch2].concat(args)) : dispatch2.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
var createNamespacedHelpers = function(namespace) {
  return {
    mapState: mapState$1.bind(null, namespace),
    mapGetters: mapGetters$1.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions$1.bind(null, namespace)
  };
};
function normalizeMap(map) {
  if (!isValidMap(map)) {
    return [];
  }
  return Array.isArray(map) ? map.map(function(key) {
    return { key, val: key };
  }) : Object.keys(map).map(function(key) {
    return { key, val: map[key] };
  });
}
function isValidMap(map) {
  return Array.isArray(map) || isObject$1(map);
}
function normalizeNamespace(fn) {
  return function(namespace, map) {
    if (typeof namespace !== "string") {
      map = namespace;
      namespace = "";
    } else if (namespace.charAt(namespace.length - 1) !== "/") {
      namespace += "/";
    }
    return fn(namespace, map);
  };
}
function getModuleByNamespace(store, helper, namespace) {
  var module2 = store._modulesNamespaceMap[namespace];
  if (!module2) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }
  return module2;
}
function createLogger(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var collapsed = ref2.collapsed;
  if (collapsed === void 0)
    collapsed = true;
  var filter = ref2.filter;
  if (filter === void 0)
    filter = function(mutation, stateBefore, stateAfter) {
      return true;
    };
  var transformer = ref2.transformer;
  if (transformer === void 0)
    transformer = function(state) {
      return state;
    };
  var mutationTransformer = ref2.mutationTransformer;
  if (mutationTransformer === void 0)
    mutationTransformer = function(mut) {
      return mut;
    };
  var actionFilter = ref2.actionFilter;
  if (actionFilter === void 0)
    actionFilter = function(action, state) {
      return true;
    };
  var actionTransformer = ref2.actionTransformer;
  if (actionTransformer === void 0)
    actionTransformer = function(act) {
      return act;
    };
  var logMutations = ref2.logMutations;
  if (logMutations === void 0)
    logMutations = true;
  var logActions = ref2.logActions;
  if (logActions === void 0)
    logActions = true;
  var logger = ref2.logger;
  if (logger === void 0)
    logger = console;
  return function(store) {
    var prevState = deepCopy(store.state);
    if (typeof logger === "undefined") {
      return;
    }
    if (logMutations) {
      store.subscribe(function(mutation, state) {
        var nextState = deepCopy(state);
        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + mutation.type + formattedTime;
          startMessage(logger, message, collapsed);
          logger.log("%c prev state", "color: #9E9E9E; font-weight: bold", transformer(prevState));
          logger.log("%c mutation", "color: #03A9F4; font-weight: bold", formattedMutation);
          logger.log("%c next state", "color: #4CAF50; font-weight: bold", transformer(nextState));
          endMessage(logger);
        }
        prevState = nextState;
      });
    }
    if (logActions) {
      store.subscribeAction(function(action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + action.type + formattedTime;
          startMessage(logger, message, collapsed);
          logger.log("%c action", "color: #03A9F4; font-weight: bold", formattedAction);
          endMessage(logger);
        }
      });
    }
  };
}
function startMessage(logger, message, collapsed) {
  var startMessage2 = collapsed ? logger.groupCollapsed : logger.group;
  try {
    startMessage2.call(logger, message);
  } catch (e2) {
    logger.log(message);
  }
}
function endMessage(logger) {
  try {
    logger.groupEnd();
  } catch (e2) {
    logger.log(" log end ");
  }
}
function getFormattedTime() {
  var time2 = /* @__PURE__ */ new Date();
  return " @ " + pad(time2.getHours(), 2) + ":" + pad(time2.getMinutes(), 2) + ":" + pad(time2.getSeconds(), 2) + "." + pad(time2.getMilliseconds(), 3);
}
function repeat(str, times2) {
  return new Array(times2 + 1).join(str);
}
function pad(num, maxLength) {
  return repeat("0", maxLength - num.toString().length) + num;
}
var index$1 = {
  version: "4.1.0",
  Store,
  storeKey,
  createStore,
  useStore,
  mapState: mapState$1,
  mapMutations,
  mapGetters: mapGetters$1,
  mapActions: mapActions$1,
  createNamespacedHelpers,
  createLogger
};
var isVue2 = false;
function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  target[key] = val;
  return val;
}
function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1);
    return;
  }
  delete target[key];
}
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const getActivePinia = () => hasInjectionContext() && inject(piniaSymbol) || activePinia;
const piniaSymbol = Symbol("pinia");
function isPlainObject$1(o2) {
  return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
const IS_CLIENT = typeof window !== "undefined";
const USE_DEVTOOLS = IS_CLIENT;
const componentStateTypes = [];
const getStoreType = (id) => " " + id;
function registerPiniaDevtools(app, pinia) {
}
function addStoreToDevtools(app, store) {
  if (!componentStateTypes.includes(getStoreType(store.$id))) {
    componentStateTypes.push(getStoreType(store.$id));
  }
}
function patchActionForGrouping(store, actionNames, wrapWithProxy) {
  const actions = actionNames.reduce((storeActions, actionName) => {
    storeActions[actionName] = toRaw(store)[actionName];
    return storeActions;
  }, {});
  for (const actionName in actions) {
    store[actionName] = function() {
      const trackedStore = wrapWithProxy ? new Proxy(store, {
        get(...args) {
          return Reflect.get(...args);
        },
        set(...args) {
          return Reflect.set(...args);
        }
      }) : store;
      const retValue = actions[actionName].apply(trackedStore, arguments);
      return retValue;
    };
  }
}
function devtoolsPlugin({ app, store, options }) {
  if (store.$id.startsWith("__hot:")) {
    return;
  }
  store._isOptionsAPI = !!options.state;
  patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
  const originalHotUpdate = store._hotUpdate;
  toRaw(store)._hotUpdate = function(newStore) {
    originalHotUpdate.apply(this, arguments);
    patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
  };
  addStoreToDevtools(
    app,
    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
    store
  );
}
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      setActivePinia(pinia);
      {
        pinia._a = app;
        app.provide(piniaSymbol, pinia);
        app.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin2) => _p.push(plugin2));
        toBeInstalled = [];
      }
    },
    use(plugin2) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin2);
      } else {
        _p.push(plugin2);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
    pinia.use(devtoolsPlugin);
  }
  return pinia;
}
const isUseStore = (fn) => {
  return typeof fn === "function" && typeof fn.$id === "string";
};
function patchObject(newState, oldState) {
  for (const key in oldState) {
    const subPatch = oldState[key];
    if (!(key in newState)) {
      continue;
    }
    const targetValue = newState[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      newState[key] = patchObject(targetValue, subPatch);
    } else {
      {
        newState[key] = subPatch;
      }
    }
  }
  return newState;
}
function acceptHMRUpdate(initialUseStore, hot) {
  return (newModule) => {
    const pinia = hot.data.pinia || initialUseStore._pinia;
    if (!pinia) {
      return;
    }
    hot.data.pinia = pinia;
    for (const exportName in newModule) {
      const useStore2 = newModule[exportName];
      if (isUseStore(useStore2) && pinia._s.has(useStore2.$id)) {
        const id = useStore2.$id;
        if (id !== initialUseStore.$id) {
          console.warn(`The id of the store changed from "${initialUseStore.$id}" to "${id}". Reloading.`);
          return hot.invalidate();
        }
        const existingStore = pinia._s.get(id);
        if (!existingStore) {
          console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);
          return;
        }
        useStore2(pinia, existingStore);
      }
    }
  };
}
const noop = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  }
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = Symbol("pinia:skipHydration");
function skipHydrate(obj) {
  return Object.defineProperty(obj, skipHydrateSymbol, {});
}
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign } = Object;
function isComputed(o2) {
  return !!(isRef(o2) && o2.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup() {
    if (!initialState && !hot) {
      {
        pinia.state.value[id] = state ? state() : {};
      }
    }
    const localState = hot ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      toRefs(ref(state ? state() : {}).value)
    ) : toRefs(pinia.state.value[id]);
    return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      if (name in localState) {
        console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
      }
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup, options, pinia, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign({ actions: {} }, options);
  if (!pinia._e.active) {
    throw new Error("Pinia destroyed");
  }
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  {
    $subscribeOptions.onTrigger = (event) => {
      if (isListening) {
        debuggerEvents = event;
      } else if (isListening == false && !store._hotUpdating) {
        if (Array.isArray(debuggerEvents)) {
          debuggerEvents.push(event);
        } else {
          console.error(" debuggerEvents should be an array. This is most likely an internal Pinia bug.");
        }
      }
    };
  }
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && !hot) {
    {
      pinia.state.value[$id] = {};
    }
  }
  const hotState = ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    {
      debuggerEvents = [];
    }
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick$1().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign($state, newState);
    });
  } : (
    /* istanbul ignore next */
    () => {
      throw new Error(`: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
    }
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError2(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError: onError2
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error2) {
        triggerSubscriptions(onErrorCallbackList, error2);
        throw error2;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error2) => {
          triggerSubscriptions(onErrorCallbackList, error2);
          return Promise.reject(error2);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const _hmrPayload = /* @__PURE__ */ markRaw({
    actions: {},
    getters: {},
    state: [],
    hotState
  });
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(assign(
    {
      _hmrPayload,
      _customProperties: markRaw(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    partialStore
    // must be added later
    // setupStore
  ));
  pinia._s.set($id, store);
  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(setup)));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (hot) {
        set(hotState.value, key, toRef(setupStore, key));
      } else if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
      {
        _hmrPayload.state.push(key);
      }
    } else if (typeof prop === "function") {
      const actionValue = hot ? prop : wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      {
        _hmrPayload.actions[key] = prop;
      }
      optionsForPlugin.actions[key] = prop;
    } else {
      if (isComputed(prop)) {
        _hmrPayload.getters[key] = isOptionsStore ? (
          // @ts-expect-error
          options.getters[key]
        ) : prop;
        if (IS_CLIENT) {
          const getters = setupStore._getters || // @ts-expect-error: same
          (setupStore._getters = markRaw([]));
          getters.push(key);
        }
      }
    }
  }
  {
    assign(store, setupStore);
    assign(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => hot ? hotState.value : pinia.state.value[$id],
    set: (state) => {
      if (hot) {
        throw new Error("cannot set hotState");
      }
      $patch(($state) => {
        assign($state, state);
      });
    }
  });
  {
    store._hotUpdate = markRaw((newStore) => {
      store._hotUpdating = true;
      newStore._hmrPayload.state.forEach((stateKey) => {
        if (stateKey in store.$state) {
          const newStateTarget = newStore.$state[stateKey];
          const oldStateSource = store.$state[stateKey];
          if (typeof newStateTarget === "object" && isPlainObject$1(newStateTarget) && isPlainObject$1(oldStateSource)) {
            patchObject(newStateTarget, oldStateSource);
          } else {
            newStore.$state[stateKey] = oldStateSource;
          }
        }
        set(store, stateKey, toRef(newStore.$state, stateKey));
      });
      Object.keys(store.$state).forEach((stateKey) => {
        if (!(stateKey in newStore.$state)) {
          del(store, stateKey);
        }
      });
      isListening = false;
      isSyncListening = false;
      pinia.state.value[$id] = toRef(newStore._hmrPayload, "hotState");
      isSyncListening = true;
      nextTick$1().then(() => {
        isListening = true;
      });
      for (const actionName in newStore._hmrPayload.actions) {
        const action = newStore[actionName];
        set(store, actionName, wrapAction(actionName, action));
      }
      for (const getterName in newStore._hmrPayload.getters) {
        const getter = newStore._hmrPayload.getters[getterName];
        const getterValue = isOptionsStore ? (
          // special handling of options api
          computed(() => {
            setActivePinia(pinia);
            return getter.call(store, store);
          })
        ) : getter;
        set(store, getterName, getterValue);
      }
      Object.keys(store._hmrPayload.getters).forEach((key) => {
        if (!(key in newStore._hmrPayload.getters)) {
          del(store, key);
        }
      });
      Object.keys(store._hmrPayload.actions).forEach((key) => {
        if (!(key in newStore._hmrPayload.actions)) {
          del(store, key);
        }
      });
      store._hmrPayload = newStore._hmrPayload;
      store._getters = newStore._getters;
      store._hotUpdating = false;
    });
  }
  if (USE_DEVTOOLS) {
    const nonEnumerable = {
      writable: true,
      configurable: true,
      // avoid warning on devtools trying to display this property
      enumerable: false
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
      Object.defineProperty(store, p2, assign({ value: store[p2] }, nonEnumerable));
    });
  }
  pinia._p.forEach((extender) => {
    if (USE_DEVTOOLS) {
      const extensions = scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      }));
      Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
      assign(store, extensions);
    } else {
      assign(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
    console.warn(`[]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
  }
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id = idOrOptions.id;
    if (typeof id !== "string") {
      throw new Error(`[]: "defineStore()" must be passed a store id as its first argument.`);
    }
  }
  function useStore2(pinia, hot) {
    const hasContext = hasInjectionContext();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia)
      setActivePinia(pinia);
    if (!activePinia) {
      throw new Error(`[]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
    }
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
      {
        useStore2._pinia = pinia;
      }
    }
    const store = pinia._s.get(id);
    if (hot) {
      const hotId = "__hot:" + id;
      const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);
      hot._hotUpdate(newStore);
      delete pinia.state.value[hotId];
      pinia._s.delete(hotId);
    }
    if (IS_CLIENT) {
      const currentInstance2 = getCurrentInstance();
      if (currentInstance2 && currentInstance2.proxy && // avoid adding stores that are just built for hot module replacement
      !hot) {
        const vm = currentInstance2.proxy;
        const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
        cache[id] = store;
      }
    }
    return store;
  }
  useStore2.$id = id;
  return useStore2;
}
let mapStoreSuffix = "Store";
function setMapStoreSuffix(suffix) {
  mapStoreSuffix = suffix;
}
function mapStores(...stores) {
  if (Array.isArray(stores[0])) {
    console.warn(`[]: Directly pass all stores to "mapStores()" without putting them in an array:
Replace
	mapStores([useAuthStore, useCartStore])
with
	mapStores(useAuthStore, useCartStore)
This will fail in production if not fixed.`);
    stores = stores[0];
  }
  return stores.reduce((reduced, useStore2) => {
    reduced[useStore2.$id + mapStoreSuffix] = function() {
      return useStore2(this.$pinia);
    };
    return reduced;
  }, {});
}
function mapState(useStore2, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function() {
      return useStore2(this.$pinia)[key];
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function() {
      const store = useStore2(this.$pinia);
      const storeKey2 = keysOrMapper[key];
      return typeof storeKey2 === "function" ? storeKey2.call(this, store) : store[storeKey2];
    };
    return reduced;
  }, {});
}
const mapGetters = mapState;
function mapActions(useStore2, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return useStore2(this.$pinia)[key](...args);
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = function(...args) {
      return useStore2(this.$pinia)[keysOrMapper[key]](...args);
    };
    return reduced;
  }, {});
}
function mapWritableState(useStore2, keysOrMapper) {
  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return useStore2(this.$pinia)[key];
      },
      set(value) {
        return useStore2(this.$pinia)[key] = value;
      }
    };
    return reduced;
  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
    reduced[key] = {
      get() {
        return useStore2(this.$pinia)[keysOrMapper[key]];
      },
      set(value) {
        return useStore2(this.$pinia)[keysOrMapper[key]] = value;
      }
    };
    return reduced;
  }, {});
}
function storeToRefs(store) {
  {
    store = toRaw(store);
    const refs = {};
    for (const key in store) {
      const value = store[key];
      if (isRef(value) || isReactive(value)) {
        refs[key] = // ---
        toRef(store, key);
      }
    }
    return refs;
  }
}
const PiniaVuePlugin = function(_Vue) {
  _Vue.mixin({
    beforeCreate() {
      const options = this.$options;
      if (options.pinia) {
        const pinia = options.pinia;
        if (!this._provided) {
          const provideCache = {};
          Object.defineProperty(this, "_provided", {
            get: () => provideCache,
            set: (v) => Object.assign(provideCache, v)
          });
        }
        this._provided[piniaSymbol] = pinia;
        if (!this.$pinia) {
          this.$pinia = pinia;
        }
        pinia._a = this;
        if (IS_CLIENT) {
          setActivePinia(pinia);
        }
        if (USE_DEVTOOLS) {
          registerPiniaDevtools(pinia._a);
        }
      } else if (!this.$pinia && options.parent && options.parent.$pinia) {
        this.$pinia = options.parent.$pinia;
      }
    },
    destroyed() {
      delete this._pStores;
    }
  });
};
const Pinia = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get MutationType() {
    return MutationType;
  },
  PiniaVuePlugin,
  acceptHMRUpdate,
  createPinia,
  defineStore,
  getActivePinia,
  mapActions,
  mapGetters,
  mapState,
  mapStores,
  mapWritableState,
  setActivePinia,
  setMapStoreSuffix,
  skipHydrate,
  storeToRefs
}, Symbol.toStringTag, { value: "Module" }));
const createLifeCycleHook = (lifecycle, flag2 = 0) => (hook, target = getCurrentInstance()) => {
  !isInSSRComponentSetup && injectHook(lifecycle, hook, target);
};
const onShow = /* @__PURE__ */ createLifeCycleHook(
  ON_SHOW,
  1 | 2
  /* HookFlags.PAGE */
);
const onLoad = /* @__PURE__ */ createLifeCycleHook(
  ON_LOAD,
  2
  /* HookFlags.PAGE */
);
const onUnload = /* @__PURE__ */ createLifeCycleHook(
  ON_UNLOAD,
  2
  /* HookFlags.PAGE */
);
const onReachBottom = /* @__PURE__ */ createLifeCycleHook(
  ON_REACH_BOTTOM,
  2
  /* HookFlags.PAGE */
);
const onPullDownRefresh = /* @__PURE__ */ createLifeCycleHook(
  ON_PULL_DOWN_REFRESH,
  2
  /* HookFlags.PAGE */
);
const onShareTimeline = /* @__PURE__ */ createLifeCycleHook(
  ON_SHARE_TIMELINE,
  2
  /* HookFlags.PAGE */
);
const onShareAppMessage = /* @__PURE__ */ createLifeCycleHook(
  ON_SHARE_APP_MESSAGE,
  2
  /* HookFlags.PAGE */
);
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || from);
}
var Bounds = (
  /** @class */
  function() {
    function Bounds2(left, top, width, height) {
      this.left = left;
      this.top = top;
      this.width = width;
      this.height = height;
    }
    Bounds2.prototype.add = function(x, y, w, h) {
      return new Bounds2(this.left + x, this.top + y, this.width + w, this.height + h);
    };
    Bounds2.fromClientRect = function(context, clientRect) {
      return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
    };
    Bounds2.fromDOMRectList = function(context, domRectList) {
      var domRect = Array.from(domRectList).find(function(rect) {
        return rect.width !== 0;
      });
      return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
    };
    Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
    return Bounds2;
  }()
);
var parseBounds = function(context, node) {
  return Bounds.fromClientRect(context, node.getBoundingClientRect());
};
var parseDocumentSize = function(document2) {
  var body = document2.body;
  var documentElement = document2.documentElement;
  if (!body || !documentElement) {
    throw new Error("Unable to get document size");
  }
  var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  return new Bounds(0, 0, width, height);
};
var toCodePoints$1 = function(str) {
  var codePoints = [];
  var i = 0;
  var length = str.length;
  while (i < length) {
    var value = str.charCodeAt(i++);
    if (value >= 55296 && value <= 56319 && i < length) {
      var extra = str.charCodeAt(i++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint$1 = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
  lookup$2[chars$2.charCodeAt(i$2)] = i$2;
}
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
}
var decode$1 = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer2 = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer2) ? buffer2 : new Uint8Array(buffer2);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1$1[base642.charCodeAt(i)];
    encoded2 = lookup$1$1[base642.charCodeAt(i + 1)];
    encoded3 = lookup$1$1[base642.charCodeAt(i + 2)];
    encoded4 = lookup$1$1[base642.charCodeAt(i + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer2;
};
var polyUint16Array$1 = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i = 0; i < length; i += 2) {
    bytes.push(buffer2[i + 1] << 8 | buffer2[i]);
  }
  return bytes;
};
var polyUint32Array$1 = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i = 0; i < length; i += 4) {
    bytes.push(buffer2[i + 3] << 24 | buffer2[i + 2] << 16 | buffer2[i + 1] << 8 | buffer2[i]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2$1 = 5;
var UTRIE2_SHIFT_1$1 = 6 + 5;
var UTRIE2_INDEX_SHIFT$1 = 2;
var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
var slice16$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64$1 = function(base642, _byteLength) {
  var buffer2 = decode$1(base642);
  var view32 = Array.isArray(buffer2) ? polyUint32Array$1(buffer2) : new Uint32Array(buffer2);
  var view16 = Array.isArray(buffer2) ? polyUint16Array$1(buffer2) : new Uint16Array(buffer2);
  var headerLength = 24;
  var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data);
};
var Trie$1 = (
  /** @class */
  function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index2;
      this.data = data;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  }()
);
var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
}
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var LETTER_NUMBER_MODIFIER = 50;
var BK = 1;
var CR$1 = 2;
var LF$1 = 3;
var CM = 4;
var NL = 5;
var WJ = 7;
var ZW = 8;
var GL = 9;
var SP = 10;
var ZWJ$1 = 11;
var B2 = 12;
var BA = 13;
var BB = 14;
var HY = 15;
var CB = 16;
var CL = 17;
var CP = 18;
var EX = 19;
var IN = 20;
var NS = 21;
var OP = 22;
var QU = 23;
var IS = 24;
var NU = 25;
var PO = 26;
var PR = 27;
var SY = 28;
var AI = 29;
var AL = 30;
var CJ = 31;
var EB = 32;
var EM = 33;
var H2 = 34;
var H3 = 35;
var HL = 36;
var ID = 37;
var JL = 38;
var JV = 39;
var JT = 40;
var RI$1 = 41;
var SA = 42;
var XX = 43;
var ea_OP = [9001, 65288];
var BREAK_MANDATORY = "!";
var BREAK_NOT_ALLOWED$1 = "";
var BREAK_ALLOWED$1 = "";
var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
var SPACE$1 = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];
var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
  if (lineBreak2 === void 0) {
    lineBreak2 = "strict";
  }
  var types = [];
  var indices = [];
  var categories = [];
  codePoints.forEach(function(codePoint, index2) {
    var classType = UnicodeTrie$1.get(codePoint);
    if (classType > LETTER_NUMBER_MODIFIER) {
      categories.push(true);
      classType -= LETTER_NUMBER_MODIFIER;
    } else {
      categories.push(false);
    }
    if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
        indices.push(index2);
        return types.push(CB);
      }
    }
    if (classType === CM || classType === ZWJ$1) {
      if (index2 === 0) {
        indices.push(index2);
        return types.push(AL);
      }
      var prev = types[index2 - 1];
      if (LINE_BREAKS.indexOf(prev) === -1) {
        indices.push(indices[index2 - 1]);
        return types.push(prev);
      }
      indices.push(index2);
      return types.push(AL);
    }
    indices.push(index2);
    if (classType === CJ) {
      return types.push(lineBreak2 === "strict" ? NS : ID);
    }
    if (classType === SA) {
      return types.push(AL);
    }
    if (classType === AI) {
      return types.push(AL);
    }
    if (classType === XX) {
      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
        return types.push(ID);
      } else {
        return types.push(AL);
      }
    }
    types.push(classType);
  });
  return [indices, types, categories];
};
var isAdjacentWithSpaceIgnored = function(a2, b, currentIndex, classTypes) {
  var current = classTypes[currentIndex];
  if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
    var i = currentIndex;
    while (i <= classTypes.length) {
      i++;
      var next = classTypes[i];
      if (next === b) {
        return true;
      }
      if (next !== SP) {
        break;
      }
    }
  }
  if (current === SP) {
    var i = currentIndex;
    while (i > 0) {
      i--;
      var prev = classTypes[i];
      if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
        var n2 = currentIndex;
        while (n2 <= classTypes.length) {
          n2++;
          var next = classTypes[n2];
          if (next === b) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (prev !== SP) {
        break;
      }
    }
  }
  return false;
};
var previousNonSpaceClassType = function(currentIndex, classTypes) {
  var i = currentIndex;
  while (i >= 0) {
    var type = classTypes[i];
    if (type === SP) {
      i--;
    } else {
      return type;
    }
  }
  return 0;
};
var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
  if (indicies[index2] === 0) {
    return BREAK_NOT_ALLOWED$1;
  }
  var currentIndex = index2 - 1;
  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
    return BREAK_NOT_ALLOWED$1;
  }
  var beforeIndex = currentIndex - 1;
  var afterIndex = currentIndex + 1;
  var current = classTypes[currentIndex];
  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  var next = classTypes[afterIndex];
  if (current === CR$1 && next === LF$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
    return BREAK_MANDATORY;
  }
  if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (SPACE$1.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
    return BREAK_ALLOWED$1;
  }
  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === WJ || next === WJ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SP) {
    return BREAK_ALLOWED$1;
  }
  if (current === QU || next === QU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === CB || current === CB) {
    return BREAK_ALLOWED$1;
  }
  if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (before === HL && HYPHEN.indexOf(current) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SY && next === HL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === IN) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (
    // (PR | PO)  ( OP | HY )? NU
    [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY )  NU
    [OP, HY].indexOf(current) !== -1 && next === NU || // NU 	(NU | SY | IS)
    current === NU && [NU, SY, IS].indexOf(next) !== -1
  ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
    var prevIndex = currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if ([PR, PO].indexOf(next) !== -1) {
    var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === RI$1 && next === RI$1) {
    var i = indicies[currentIndex];
    var count = 1;
    while (i > 0) {
      i--;
      if (classTypes[i] === RI$1) {
        count++;
      } else {
        break;
      }
    }
    if (count % 2 !== 0) {
      return BREAK_NOT_ALLOWED$1;
    }
  }
  if (current === EB && next === EM) {
    return BREAK_NOT_ALLOWED$1;
  }
  return BREAK_ALLOWED$1;
};
var cssFormattedClasses = function(codePoints, options) {
  if (!options) {
    options = { lineBreak: "normal", wordBreak: "normal" };
  }
  var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
  if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
    classTypes = classTypes.map(function(type) {
      return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
    });
  }
  var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i) {
    return letterNumber && codePoints[i] >= 19968 && codePoints[i] <= 40959;
  }) : void 0;
  return [indicies, classTypes, forbiddenBreakpoints];
};
var Break = (
  /** @class */
  function() {
    function Break2(codePoints, lineBreak2, start, end) {
      this.codePoints = codePoints;
      this.required = lineBreak2 === BREAK_MANDATORY;
      this.start = start;
      this.end = end;
    }
    Break2.prototype.slice = function() {
      return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
    };
    return Break2;
  }()
);
var LineBreaker = function(str, options) {
  var codePoints = toCodePoints$1(str);
  var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
  var length = codePoints.length;
  var lastEnd = 0;
  var nextIndex = 0;
  return {
    next: function() {
      if (nextIndex >= length) {
        return { done: true, value: null };
      }
      var lineBreak2 = BREAK_NOT_ALLOWED$1;
      while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
      }
      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
        var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
        lastEnd = nextIndex;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var FLAG_UNRESTRICTED = 1 << 0;
var FLAG_ID = 1 << 1;
var FLAG_INTEGER = 1 << 2;
var FLAG_NUMBER = 1 << 3;
var LINE_FEED = 10;
var SOLIDUS = 47;
var REVERSE_SOLIDUS = 92;
var CHARACTER_TABULATION = 9;
var SPACE = 32;
var QUOTATION_MARK = 34;
var EQUALS_SIGN = 61;
var NUMBER_SIGN = 35;
var DOLLAR_SIGN = 36;
var PERCENTAGE_SIGN = 37;
var APOSTROPHE = 39;
var LEFT_PARENTHESIS = 40;
var RIGHT_PARENTHESIS = 41;
var LOW_LINE = 95;
var HYPHEN_MINUS = 45;
var EXCLAMATION_MARK = 33;
var LESS_THAN_SIGN = 60;
var GREATER_THAN_SIGN = 62;
var COMMERCIAL_AT = 64;
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var CIRCUMFLEX_ACCENT = 61;
var LEFT_CURLY_BRACKET = 123;
var QUESTION_MARK = 63;
var RIGHT_CURLY_BRACKET = 125;
var VERTICAL_LINE = 124;
var TILDE = 126;
var CONTROL = 128;
var REPLACEMENT_CHARACTER = 65533;
var ASTERISK = 42;
var PLUS_SIGN = 43;
var COMMA = 44;
var COLON = 58;
var SEMICOLON = 59;
var FULL_STOP = 46;
var NULL = 0;
var BACKSPACE = 8;
var LINE_TABULATION = 11;
var SHIFT_OUT = 14;
var INFORMATION_SEPARATOR_ONE = 31;
var DELETE = 127;
var EOF = -1;
var ZERO = 48;
var a = 97;
var e = 101;
var f = 102;
var u = 117;
var z = 122;
var A = 65;
var E = 69;
var F = 70;
var U = 85;
var Z = 90;
var isDigit = function(codePoint) {
  return codePoint >= ZERO && codePoint <= 57;
};
var isSurrogateCodePoint = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 57343;
};
var isHex = function(codePoint) {
  return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a && codePoint <= f;
};
var isLowerCaseLetter = function(codePoint) {
  return codePoint >= a && codePoint <= z;
};
var isUpperCaseLetter = function(codePoint) {
  return codePoint >= A && codePoint <= Z;
};
var isLetter = function(codePoint) {
  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
};
var isNonASCIICodePoint = function(codePoint) {
  return codePoint >= CONTROL;
};
var isWhiteSpace = function(codePoint) {
  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
};
var isNameStartCodePoint = function(codePoint) {
  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
};
var isNameCodePoint = function(codePoint) {
  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
};
var isNonPrintableCodePoint = function(codePoint) {
  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
};
var isValidEscape = function(c1, c2) {
  if (c1 !== REVERSE_SOLIDUS) {
    return false;
  }
  return c2 !== LINE_FEED;
};
var isIdentifierStart = function(c1, c2, c3) {
  if (c1 === HYPHEN_MINUS) {
    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  } else if (isNameStartCodePoint(c1)) {
    return true;
  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
    return true;
  }
  return false;
};
var isNumberStart = function(c1, c2, c3) {
  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
    if (isDigit(c2)) {
      return true;
    }
    return c2 === FULL_STOP && isDigit(c3);
  }
  if (c1 === FULL_STOP) {
    return isDigit(c2);
  }
  return isDigit(c1);
};
var stringToNumber = function(codePoints) {
  var c = 0;
  var sign = 1;
  if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
    if (codePoints[c] === HYPHEN_MINUS) {
      sign = -1;
    }
    c++;
  }
  var integers = [];
  while (isDigit(codePoints[c])) {
    integers.push(codePoints[c++]);
  }
  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  if (codePoints[c] === FULL_STOP) {
    c++;
  }
  var fraction = [];
  while (isDigit(codePoints[c])) {
    fraction.push(codePoints[c++]);
  }
  var fracd = fraction.length;
  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  if (codePoints[c] === E || codePoints[c] === e) {
    c++;
  }
  var expsign = 1;
  if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
    if (codePoints[c] === HYPHEN_MINUS) {
      expsign = -1;
    }
    c++;
  }
  var exponent = [];
  while (isDigit(codePoints[c])) {
    exponent.push(codePoints[c++]);
  }
  var exp2 = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp2);
};
var LEFT_PARENTHESIS_TOKEN = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
};
var RIGHT_PARENTHESIS_TOKEN = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
};
var COMMA_TOKEN = {
  type: 4
  /* COMMA_TOKEN */
};
var SUFFIX_MATCH_TOKEN = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
};
var PREFIX_MATCH_TOKEN = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
};
var COLUMN_TOKEN = {
  type: 21
  /* COLUMN_TOKEN */
};
var DASH_MATCH_TOKEN = {
  type: 9
  /* DASH_MATCH_TOKEN */
};
var INCLUDE_MATCH_TOKEN = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
};
var LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
};
var RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
};
var SUBSTRING_MATCH_TOKEN = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
};
var BAD_URL_TOKEN = {
  type: 23
  /* BAD_URL_TOKEN */
};
var BAD_STRING_TOKEN = {
  type: 1
  /* BAD_STRING_TOKEN */
};
var CDO_TOKEN = {
  type: 25
  /* CDO_TOKEN */
};
var CDC_TOKEN = {
  type: 24
  /* CDC_TOKEN */
};
var COLON_TOKEN = {
  type: 26
  /* COLON_TOKEN */
};
var SEMICOLON_TOKEN = {
  type: 27
  /* SEMICOLON_TOKEN */
};
var LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
};
var RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
};
var WHITESPACE_TOKEN = {
  type: 31
  /* WHITESPACE_TOKEN */
};
var EOF_TOKEN = {
  type: 32
  /* EOF_TOKEN */
};
var Tokenizer = (
  /** @class */
  function() {
    function Tokenizer2() {
      this._value = [];
    }
    Tokenizer2.prototype.write = function(chunk) {
      this._value = this._value.concat(toCodePoints$1(chunk));
    };
    Tokenizer2.prototype.read = function() {
      var tokens = [];
      var token = this.consumeToken();
      while (token !== EOF_TOKEN) {
        tokens.push(token);
        token = this.consumeToken();
      }
      return tokens;
    };
    Tokenizer2.prototype.consumeToken = function() {
      var codePoint = this.consumeCodePoint();
      switch (codePoint) {
        case QUOTATION_MARK:
          return this.consumeStringToken(QUOTATION_MARK);
        case NUMBER_SIGN:
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
            var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
            var value = this.consumeName();
            return { type: 5, value, flags };
          }
          break;
        case DOLLAR_SIGN:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUFFIX_MATCH_TOKEN;
          }
          break;
        case APOSTROPHE:
          return this.consumeStringToken(APOSTROPHE);
        case LEFT_PARENTHESIS:
          return LEFT_PARENTHESIS_TOKEN;
        case RIGHT_PARENTHESIS:
          return RIGHT_PARENTHESIS_TOKEN;
        case ASTERISK:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUBSTRING_MATCH_TOKEN;
          }
          break;
        case PLUS_SIGN:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case COMMA:
          return COMMA_TOKEN;
        case HYPHEN_MINUS:
          var e1 = codePoint;
          var e2 = this.peekCodePoint(0);
          var e3 = this.peekCodePoint(1);
          if (isNumberStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          if (isIdentifierStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDC_TOKEN;
          }
          break;
        case FULL_STOP:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case SOLIDUS:
          if (this.peekCodePoint(0) === ASTERISK) {
            this.consumeCodePoint();
            while (true) {
              var c = this.consumeCodePoint();
              if (c === ASTERISK) {
                c = this.consumeCodePoint();
                if (c === SOLIDUS) {
                  return this.consumeToken();
                }
              }
              if (c === EOF) {
                return this.consumeToken();
              }
            }
          }
          break;
        case COLON:
          return COLON_TOKEN;
        case SEMICOLON:
          return SEMICOLON_TOKEN;
        case LESS_THAN_SIGN:
          if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDO_TOKEN;
          }
          break;
        case COMMERCIAL_AT:
          var a1 = this.peekCodePoint(0);
          var a2 = this.peekCodePoint(1);
          var a3 = this.peekCodePoint(2);
          if (isIdentifierStart(a1, a2, a3)) {
            var value = this.consumeName();
            return { type: 7, value };
          }
          break;
        case LEFT_SQUARE_BRACKET:
          return LEFT_SQUARE_BRACKET_TOKEN;
        case REVERSE_SOLIDUS:
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          break;
        case RIGHT_SQUARE_BRACKET:
          return RIGHT_SQUARE_BRACKET_TOKEN;
        case CIRCUMFLEX_ACCENT:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return PREFIX_MATCH_TOKEN;
          }
          break;
        case LEFT_CURLY_BRACKET:
          return LEFT_CURLY_BRACKET_TOKEN;
        case RIGHT_CURLY_BRACKET:
          return RIGHT_CURLY_BRACKET_TOKEN;
        case u:
        case U:
          var u1 = this.peekCodePoint(0);
          var u2 = this.peekCodePoint(1);
          if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
            this.consumeCodePoint();
            this.consumeUnicodeRangeToken();
          }
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        case VERTICAL_LINE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return DASH_MATCH_TOKEN;
          }
          if (this.peekCodePoint(0) === VERTICAL_LINE) {
            this.consumeCodePoint();
            return COLUMN_TOKEN;
          }
          break;
        case TILDE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return INCLUDE_MATCH_TOKEN;
          }
          break;
        case EOF:
          return EOF_TOKEN;
      }
      if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        return WHITESPACE_TOKEN;
      }
      if (isDigit(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeNumericToken();
      }
      if (isNameStartCodePoint(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      }
      return { type: 6, value: fromCodePoint$1(codePoint) };
    };
    Tokenizer2.prototype.consumeCodePoint = function() {
      var value = this._value.shift();
      return typeof value === "undefined" ? -1 : value;
    };
    Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
      this._value.unshift(codePoint);
    };
    Tokenizer2.prototype.peekCodePoint = function(delta) {
      if (delta >= this._value.length) {
        return -1;
      }
      return this._value[delta];
    };
    Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
      var digits2 = [];
      var codePoint = this.consumeCodePoint();
      while (isHex(codePoint) && digits2.length < 6) {
        digits2.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var questionMarks = false;
      while (codePoint === QUESTION_MARK && digits2.length < 6) {
        digits2.push(codePoint);
        codePoint = this.consumeCodePoint();
        questionMarks = true;
      }
      if (questionMarks) {
        var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits2.map(function(digit) {
          return digit === QUESTION_MARK ? ZERO : digit;
        })), 16);
        var end = parseInt(fromCodePoint$1.apply(void 0, digits2.map(function(digit) {
          return digit === QUESTION_MARK ? F : digit;
        })), 16);
        return { type: 30, start: start_1, end };
      }
      var start = parseInt(fromCodePoint$1.apply(void 0, digits2), 16);
      if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
        this.consumeCodePoint();
        codePoint = this.consumeCodePoint();
        var endDigits = [];
        while (isHex(codePoint) && endDigits.length < 6) {
          endDigits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
        return { type: 30, start, end };
      } else {
        return { type: 30, start, end: start };
      }
    };
    Tokenizer2.prototype.consumeIdentLikeToken = function() {
      var value = this.consumeName();
      if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return this.consumeUrlToken();
      } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return { type: 19, value };
      }
      return { type: 20, value };
    };
    Tokenizer2.prototype.consumeUrlToken = function() {
      var value = [];
      this.consumeWhiteSpace();
      if (this.peekCodePoint(0) === EOF) {
        return { type: 22, value: "" };
      }
      var next = this.peekCodePoint(0);
      if (next === APOSTROPHE || next === QUOTATION_MARK) {
        var stringToken = this.consumeStringToken(this.consumeCodePoint());
        if (stringToken.type === 0) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: stringToken.value };
          }
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      }
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
          return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
        } else if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === REVERSE_SOLIDUS) {
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            value.push(this.consumeEscapedCodePoint());
          } else {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          }
        } else {
          value.push(codePoint);
        }
      }
    };
    Tokenizer2.prototype.consumeWhiteSpace = function() {
      while (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
    };
    Tokenizer2.prototype.consumeBadUrlRemnants = function() {
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
          return;
        }
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.consumeEscapedCodePoint();
        }
      }
    };
    Tokenizer2.prototype.consumeStringSlice = function(count) {
      var SLICE_STACK_SIZE = 5e4;
      var value = "";
      while (count > 0) {
        var amount2 = Math.min(SLICE_STACK_SIZE, count);
        value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount2));
        count -= amount2;
      }
      this._value.shift();
      return value;
    };
    Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
      var value = "";
      var i = 0;
      do {
        var codePoint = this._value[i];
        if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
          value += this.consumeStringSlice(i);
          return { type: 0, value };
        }
        if (codePoint === LINE_FEED) {
          this._value.splice(0, i);
          return BAD_STRING_TOKEN;
        }
        if (codePoint === REVERSE_SOLIDUS) {
          var next = this._value[i + 1];
          if (next !== EOF && next !== void 0) {
            if (next === LINE_FEED) {
              value += this.consumeStringSlice(i);
              i = -1;
              this._value.shift();
            } else if (isValidEscape(codePoint, next)) {
              value += this.consumeStringSlice(i);
              value += fromCodePoint$1(this.consumeEscapedCodePoint());
              i = -1;
            }
          }
        }
        i++;
      } while (true);
    };
    Tokenizer2.prototype.consumeNumber = function() {
      var repr = [];
      var type = FLAG_INTEGER;
      var c1 = this.peekCodePoint(0);
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        repr.push(this.consumeCodePoint());
      }
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
      c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      if (c1 === FULL_STOP && isDigit(c2)) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      c1 = this.peekCodePoint(0);
      c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if ((c1 === E || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      return [stringToNumber(repr), type];
    };
    Tokenizer2.prototype.consumeNumericToken = function() {
      var _a = this.consumeNumber(), number2 = _a[0], flags = _a[1];
      var c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if (isIdentifierStart(c1, c2, c3)) {
        var unit = this.consumeName();
        return { type: 15, number: number2, flags, unit };
      }
      if (c1 === PERCENTAGE_SIGN) {
        this.consumeCodePoint();
        return { type: 16, number: number2, flags };
      }
      return { type: 17, number: number2, flags };
    };
    Tokenizer2.prototype.consumeEscapedCodePoint = function() {
      var codePoint = this.consumeCodePoint();
      if (isHex(codePoint)) {
        var hex = fromCodePoint$1(codePoint);
        while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
          hex += fromCodePoint$1(this.consumeCodePoint());
        }
        if (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
        var hexCodePoint = parseInt(hex, 16);
        if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
          return REPLACEMENT_CHARACTER;
        }
        return hexCodePoint;
      }
      if (codePoint === EOF) {
        return REPLACEMENT_CHARACTER;
      }
      return codePoint;
    };
    Tokenizer2.prototype.consumeName = function() {
      var result = "";
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (isNameCodePoint(codePoint)) {
          result += fromCodePoint$1(codePoint);
        } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          result += fromCodePoint$1(this.consumeEscapedCodePoint());
        } else {
          this.reconsumeCodePoint(codePoint);
          return result;
        }
      }
    };
    return Tokenizer2;
  }()
);
var Parser = (
  /** @class */
  function() {
    function Parser2(tokens) {
      this._tokens = tokens;
    }
    Parser2.create = function(value) {
      var tokenizer = new Tokenizer();
      tokenizer.write(value);
      return new Parser2(tokenizer.read());
    };
    Parser2.parseValue = function(value) {
      return Parser2.create(value).parseComponentValue();
    };
    Parser2.parseValues = function(value) {
      return Parser2.create(value).parseComponentValues();
    };
    Parser2.prototype.parseComponentValue = function() {
      var token = this.consumeToken();
      while (token.type === 31) {
        token = this.consumeToken();
      }
      if (token.type === 32) {
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      }
      this.reconsumeToken(token);
      var value = this.consumeComponentValue();
      do {
        token = this.consumeToken();
      } while (token.type === 31);
      if (token.type === 32) {
        return value;
      }
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    };
    Parser2.prototype.parseComponentValues = function() {
      var values = [];
      while (true) {
        var value = this.consumeComponentValue();
        if (value.type === 32) {
          return values;
        }
        values.push(value);
        values.push();
      }
    };
    Parser2.prototype.consumeComponentValue = function() {
      var token = this.consumeToken();
      switch (token.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(token.type);
        case 19:
          return this.consumeFunction(token);
      }
      return token;
    };
    Parser2.prototype.consumeSimpleBlock = function(type) {
      var block = { type, values: [] };
      var token = this.consumeToken();
      while (true) {
        if (token.type === 32 || isEndingTokenFor(token, type)) {
          return block;
        }
        this.reconsumeToken(token);
        block.values.push(this.consumeComponentValue());
        token = this.consumeToken();
      }
    };
    Parser2.prototype.consumeFunction = function(functionToken) {
      var cssFunction = {
        name: functionToken.value,
        values: [],
        type: 18
        /* FUNCTION */
      };
      while (true) {
        var token = this.consumeToken();
        if (token.type === 32 || token.type === 3) {
          return cssFunction;
        }
        this.reconsumeToken(token);
        cssFunction.values.push(this.consumeComponentValue());
      }
    };
    Parser2.prototype.consumeToken = function() {
      var token = this._tokens.shift();
      return typeof token === "undefined" ? EOF_TOKEN : token;
    };
    Parser2.prototype.reconsumeToken = function(token) {
      this._tokens.unshift(token);
    };
    return Parser2;
  }()
);
var isDimensionToken = function(token) {
  return token.type === 15;
};
var isNumberToken = function(token) {
  return token.type === 17;
};
var isIdentToken = function(token) {
  return token.type === 20;
};
var isStringToken = function(token) {
  return token.type === 0;
};
var isIdentWithValue = function(token, value) {
  return isIdentToken(token) && token.value === value;
};
var nonWhiteSpace = function(token) {
  return token.type !== 31;
};
var nonFunctionArgSeparator = function(token) {
  return token.type !== 31 && token.type !== 4;
};
var parseFunctionArgs = function(tokens) {
  var args = [];
  var arg = [];
  tokens.forEach(function(token) {
    if (token.type === 4) {
      if (arg.length === 0) {
        throw new Error("Error parsing function args, zero tokens for arg");
      }
      args.push(arg);
      arg = [];
      return;
    }
    if (token.type !== 31) {
      arg.push(token);
    }
  });
  if (arg.length) {
    args.push(arg);
  }
  return args;
};
var isEndingTokenFor = function(token, type) {
  if (type === 11 && token.type === 12) {
    return true;
  }
  if (type === 28 && token.type === 29) {
    return true;
  }
  return type === 2 && token.type === 3;
};
var isLength = function(token) {
  return token.type === 17 || token.type === 15;
};
var isLengthPercentage = function(token) {
  return token.type === 16 || isLength(token);
};
var parseLengthPercentageTuple = function(tokens) {
  return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
};
var ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
};
var FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
};
var getAbsoluteValueForTuple = function(tuple, width, height) {
  var x = tuple[0], y = tuple[1];
  return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== "undefined" ? y : x, height)];
};
var getAbsoluteValue = function(token, parent) {
  if (token.type === 16) {
    return token.number / 100 * parent;
  }
  if (isDimensionToken(token)) {
    switch (token.unit) {
      case "rem":
      case "em":
        return 16 * token.number;
      case "px":
      default:
        return token.number;
    }
  }
  return token.number;
};
var DEG = "deg";
var GRAD = "grad";
var RAD = "rad";
var TURN = "turn";
var angle = {
  name: "angle",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit) {
        case DEG:
          return Math.PI * value.number / 180;
        case GRAD:
          return Math.PI / 200 * value.number;
        case RAD:
          return value.number;
        case TURN:
          return Math.PI * 2 * value.number;
      }
    }
    throw new Error("Unsupported angle type");
  }
};
var isAngle = function(value) {
  if (value.type === 15) {
    if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
      return true;
    }
  }
  return false;
};
var parseNamedSide = function(tokens) {
  var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
    return ident.value;
  }).join(" ");
  switch (sideOrCorner) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg(270);
  }
  return 0;
};
var deg = function(deg2) {
  return Math.PI * deg2 / 180;
};
var color$1$1 = {
  name: "color",
  parse: function(context, value) {
    if (value.type === 18) {
      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
      if (typeof colorFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
      }
      return colorFunction(context, value.values);
    }
    if (value.type === 5) {
      if (value.value.length === 3) {
        var r = value.value.substring(0, 1);
        var g = value.value.substring(1, 2);
        var b = value.value.substring(2, 3);
        return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
      }
      if (value.value.length === 4) {
        var r = value.value.substring(0, 1);
        var g = value.value.substring(1, 2);
        var b = value.value.substring(2, 3);
        var a2 = value.value.substring(3, 4);
        return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a2 + a2, 16) / 255);
      }
      if (value.value.length === 6) {
        var r = value.value.substring(0, 2);
        var g = value.value.substring(2, 4);
        var b = value.value.substring(4, 6);
        return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
      }
      if (value.value.length === 8) {
        var r = value.value.substring(0, 2);
        var g = value.value.substring(2, 4);
        var b = value.value.substring(4, 6);
        var a2 = value.value.substring(6, 8);
        return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a2, 16) / 255);
      }
    }
    if (value.type === 20) {
      var namedColor = COLORS[value.value.toUpperCase()];
      if (typeof namedColor !== "undefined") {
        return namedColor;
      }
    }
    return COLORS.TRANSPARENT;
  }
};
var isTransparent = function(color2) {
  return (255 & color2) === 0;
};
var asString = function(color2) {
  var alpha = 255 & color2;
  var blue = 255 & color2 >> 8;
  var green = 255 & color2 >> 16;
  var red = 255 & color2 >> 24;
  return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
};
var pack = function(r, g, b, a2) {
  return (r << 24 | g << 16 | b << 8 | Math.round(a2 * 255) << 0) >>> 0;
};
var getTokenColorValue = function(token, i) {
  if (token.type === 17) {
    return token.number;
  }
  if (token.type === 16) {
    var max = i === 3 ? 1 : 255;
    return i === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
  }
  return 0;
};
var rgb = function(_context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  if (tokens.length === 3) {
    var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
    return pack(r, g, b, 1);
  }
  if (tokens.length === 4) {
    var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a2 = _b[3];
    return pack(r, g, b, a2);
  }
  return 0;
};
function hue2rgb(t1, t2, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t2 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t2;
  } else if (hue < 2 / 3) {
    return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
var hsl = function(context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
  var h = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
  var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
  if (s2 === 0) {
    return pack(l * 255, l * 255, l * 255, 1);
  }
  var t2 = l <= 0.5 ? l * (s2 + 1) : l + s2 - l * s2;
  var t1 = l * 2 - t2;
  var r = hue2rgb(t1, t2, h + 1 / 3);
  var g = hue2rgb(t1, t2, h);
  var b = hue2rgb(t1, t2, h - 1 / 3);
  return pack(r * 255, g * 255, b * 255, a2);
};
var SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
};
var parseColor = function(context, value) {
  return color$1$1.parse(context, Parser.create(value).parseComponentValue());
};
var COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var parseColorStop = function(context, args) {
  var color2 = color$1$1.parse(context, args[0]);
  var stop = args[1];
  return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
};
var processColorStops = function(stops, lineLength) {
  var first = stops[0];
  var last = stops[stops.length - 1];
  if (first.stop === null) {
    first.stop = ZERO_LENGTH;
  }
  if (last.stop === null) {
    last.stop = HUNDRED_PERCENT;
  }
  var processStops = [];
  var previous = 0;
  for (var i = 0; i < stops.length; i++) {
    var stop_1 = stops[i].stop;
    if (stop_1 !== null) {
      var absoluteValue = getAbsoluteValue(stop_1, lineLength);
      if (absoluteValue > previous) {
        processStops.push(absoluteValue);
      } else {
        processStops.push(previous);
      }
      previous = absoluteValue;
    } else {
      processStops.push(null);
    }
  }
  var gapBegin = null;
  for (var i = 0; i < processStops.length; i++) {
    var stop_2 = processStops[i];
    if (stop_2 === null) {
      if (gapBegin === null) {
        gapBegin = i;
      }
    } else if (gapBegin !== null) {
      var gapLength = i - gapBegin;
      var beforeGap = processStops[gapBegin - 1];
      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
      for (var g = 1; g <= gapLength; g++) {
        processStops[gapBegin + g - 1] = gapValue * g;
      }
      gapBegin = null;
    }
  }
  return stops.map(function(_a, i2) {
    var color2 = _a.color;
    return { color: color2, stop: Math.max(Math.min(1, processStops[i2] / lineLength), 0) };
  });
};
var getAngleFromCorner = function(corner, width, height) {
  var centerX = width / 2;
  var centerY = height / 2;
  var x = getAbsoluteValue(corner[0], width) - centerX;
  var y = centerY - getAbsoluteValue(corner[1], height);
  return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
};
var calculateGradientDirection = function(angle2, width, height) {
  var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var halfLineLength = lineLength / 2;
  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
};
var distance = function(a2, b) {
  return Math.sqrt(a2 * a2 + b * b);
};
var findCorner = function(width, height, x, y, closest) {
  var corners = [
    [0, 0],
    [0, height],
    [width, 0],
    [width, height]
  ];
  return corners.reduce(function(stat, corner) {
    var cx = corner[0], cy = corner[1];
    var d = distance(x - cx, y - cy);
    if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d
      };
    }
    return stat;
  }, {
    optimumDistance: closest ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};
var calculateRadius = function(gradient, x, y, width, height) {
  var rx = 0;
  var ry = 0;
  switch (gradient.size) {
    case 0:
      if (gradient.shape === 0) {
        rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
      } else if (gradient.shape === 1) {
        rx = Math.min(Math.abs(x), Math.abs(x - width));
        ry = Math.min(Math.abs(y), Math.abs(y - height));
      }
      break;
    case 2:
      if (gradient.shape === 0) {
        rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
      } else if (gradient.shape === 1) {
        var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
        var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
        rx = distance(cx - x, (cy - y) / c);
        ry = c * rx;
      }
      break;
    case 1:
      if (gradient.shape === 0) {
        rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
      } else if (gradient.shape === 1) {
        rx = Math.max(Math.abs(x), Math.abs(x - width));
        ry = Math.max(Math.abs(y), Math.abs(y - height));
      }
      break;
    case 3:
      if (gradient.shape === 0) {
        rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
      } else if (gradient.shape === 1) {
        var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
        var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
        rx = distance(cx - x, (cy - y) / c);
        ry = c * rx;
      }
      break;
  }
  if (Array.isArray(gradient.size)) {
    rx = getAbsoluteValue(gradient.size[0], width);
    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
  }
  return [rx, ry];
};
var linearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    if (i === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && firstToken.value === "to") {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = angle.parse(context, firstToken);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var prefixLinearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    if (i === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var webkitGradient = function(context, tokens) {
  var angle2 = deg(180);
  var stops = [];
  var type = 1;
  var shape = 0;
  var size2 = 3;
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var firstToken = arg[0];
    if (i === 0) {
      if (isIdentToken(firstToken) && firstToken.value === "linear") {
        type = 1;
        return;
      } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
        type = 2;
        return;
      }
    }
    if (firstToken.type === 18) {
      if (firstToken.name === "from") {
        var color2 = color$1$1.parse(context, firstToken.values[0]);
        stops.push({ stop: ZERO_LENGTH, color: color2 });
      } else if (firstToken.name === "to") {
        var color2 = color$1$1.parse(context, firstToken.values[0]);
        stops.push({ stop: HUNDRED_PERCENT, color: color2 });
      } else if (firstToken.name === "color-stop") {
        var values = firstToken.values.filter(nonFunctionArgSeparator);
        if (values.length === 2) {
          var color2 = color$1$1.parse(context, values[1]);
          var stop_1 = values[0];
          if (isNumberToken(stop_1)) {
            stops.push({
              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
              color: color2
            });
          }
        }
      }
    }
  });
  return type === 1 ? {
    angle: (angle2 + deg(180)) % deg(360),
    stops,
    type
  } : { size: size2, shape, stops, position: position2, type };
};
var CLOSEST_SIDE = "closest-side";
var FARTHEST_SIDE = "farthest-side";
var CLOSEST_CORNER = "closest-corner";
var FARTHEST_CORNER = "farthest-corner";
var CIRCLE = "circle";
var ELLIPSE = "ellipse";
var COVER = "cover";
var CONTAIN = "contain";
var radialGradient = function(context, tokens) {
  var shape = 0;
  var size2 = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var isColorStop = true;
    if (i === 0) {
      var isAtPosition_1 = false;
      isColorStop = arg.reduce(function(acc, token) {
        if (isAtPosition_1) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return acc;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return acc;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return acc;
            }
          } else if (isLengthPercentage(token) || isLength(token)) {
            position2.push(token);
          }
        } else if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case "at":
              isAtPosition_1 = true;
              return false;
            case CLOSEST_SIDE:
              size2 = 0;
              return false;
            case COVER:
            case FARTHEST_SIDE:
              size2 = 1;
              return false;
            case CONTAIN:
            case CLOSEST_CORNER:
              size2 = 2;
              return false;
            case FARTHEST_CORNER:
              size2 = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size2)) {
            size2 = [];
          }
          size2.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size: size2,
    shape,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var prefixRadialGradient = function(context, tokens) {
  var shape = 0;
  var size2 = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var isColorStop = true;
    if (i === 0) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case "center":
              position2.push(FIFTY_PERCENT);
              return false;
            case "top":
            case "left":
              position2.push(ZERO_LENGTH);
              return false;
            case "right":
            case "bottom":
              position2.push(HUNDRED_PERCENT);
              return false;
          }
        } else if (isLengthPercentage(token) || isLength(token)) {
          position2.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    } else if (i === 1) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case CONTAIN:
            case CLOSEST_SIDE:
              size2 = 0;
              return false;
            case FARTHEST_SIDE:
              size2 = 1;
              return false;
            case CLOSEST_CORNER:
              size2 = 2;
              return false;
            case COVER:
            case FARTHEST_CORNER:
              size2 = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size2)) {
            size2 = [];
          }
          size2.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size: size2,
    shape,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var isLinearGradient = function(background) {
  return background.type === 1;
};
var isRadialGradient = function(background) {
  return background.type === 2;
};
var image$2 = {
  name: "image",
  parse: function(context, value) {
    if (value.type === 22) {
      var image_1 = {
        url: value.value,
        type: 0
        /* URL */
      };
      context.cache.addImage(value.value);
      return image_1;
    }
    if (value.type === 18) {
      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
      if (typeof imageFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
      }
      return imageFunction(context, value.values);
    }
    throw new Error("Unsupported image type " + value.type);
  }
};
function isSupportedImage(value) {
  return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
};
var backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens.filter(function(value) {
      return nonFunctionArgSeparator(value) && isSupportedImage(value);
    }).map(function(value) {
      return image$2.parse(context, value);
    });
  }
};
var backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
};
var backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isIdentToken).map(function(token) {
        return token.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
};
var parseBackgroundRepeat = function(value) {
  switch (value) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var BACKGROUND_SIZE;
(function(BACKGROUND_SIZE2) {
  BACKGROUND_SIZE2["AUTO"] = "auto";
  BACKGROUND_SIZE2["CONTAIN"] = "contain";
  BACKGROUND_SIZE2["COVER"] = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isBackgroundSizeInfoToken);
    });
  }
};
var isBackgroundSizeInfoToken = function(value) {
  return isIdentToken(value) || isLengthPercentage(value);
};
var borderColorForSide = function(side) {
  return {
    name: "border-" + side + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var borderTopColor = borderColorForSide("top");
var borderRightColor = borderColorForSide("right");
var borderBottomColor = borderColorForSide("bottom");
var borderLeftColor = borderColorForSide("left");
var borderRadiusForSide = function(side) {
  return {
    name: "border-radius-" + side,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
    }
  };
};
var borderTopLeftRadius = borderRadiusForSide("top-left");
var borderTopRightRadius = borderRadiusForSide("top-right");
var borderBottomRightRadius = borderRadiusForSide("bottom-right");
var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
var borderStyleForSide = function(side) {
  return {
    name: "border-" + side + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(_context, style) {
      switch (style) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var borderTopStyle = borderStyleForSide("top");
var borderRightStyle = borderStyleForSide("right");
var borderBottomStyle = borderStyleForSide("bottom");
var borderLeftStyle = borderStyleForSide("left");
var borderWidthForSide = function(side) {
  return {
    name: "border-" + side + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isDimensionToken(token)) {
        return token.number;
      }
      return 0;
    }
  };
};
var borderTopWidth = borderWidthForSide("top");
var borderRightWidth = borderWidthForSide("right");
var borderBottomWidth = borderWidthForSide("bottom");
var borderLeftWidth = borderWidthForSide("left");
var color$4 = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var direction = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(_context, direction2) {
    switch (direction2) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var display = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).reduce(
      function(bit, token) {
        return bit | parseDisplayValue(token.value);
      },
      0
      /* NONE */
    );
  }
};
var parseDisplayValue = function(display2) {
  switch (display2) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var float = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, float2) {
    switch (float2) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "normal") {
      return 0;
    }
    if (token.type === 17) {
      return token.number;
    }
    if (token.type === 15) {
      return token.number;
    }
    return 0;
  }
};
var LINE_BREAK;
(function(LINE_BREAK2) {
  LINE_BREAK2["NORMAL"] = "normal";
  LINE_BREAK2["STRICT"] = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, lineBreak2) {
    switch (lineBreak2) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
};
var lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
  /* TOKEN_VALUE */
};
var computeLineHeight = function(token, fontSize2) {
  if (isIdentToken(token) && token.value === "normal") {
    return 1.2 * fontSize2;
  } else if (token.type === 17) {
    return fontSize2 * token.number;
  } else if (isLengthPercentage(token)) {
    return getAbsoluteValue(token, fontSize2);
  }
  return fontSize2;
};
var listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    return image$2.parse(context, token);
  }
};
var listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, type) {
    switch (type) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var marginForSide = function(side) {
  return {
    name: "margin-" + side,
    initialValue: "0",
    prefix: false,
    type: 4
    /* TOKEN_VALUE */
  };
};
var marginTop = marginForSide("top");
var marginRight = marginForSide("right");
var marginBottom = marginForSide("bottom");
var marginLeft = marginForSide("left");
var overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(overflow2) {
      switch (overflow2.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var paddingForSide = function(side) {
  return {
    name: "padding-" + side,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var paddingTop = paddingForSide("top");
var paddingRight = paddingForSide("right");
var paddingBottom = paddingForSide("bottom");
var paddingLeft = paddingForSide("left");
var textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(_context, textAlign2) {
    switch (textAlign2) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var position = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values) {
      var shadow = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      };
      var c = 0;
      for (var i = 0; i < values.length; i++) {
        var token = values[i];
        if (isLength(token)) {
          if (c === 0) {
            shadow.offsetX = token;
          } else if (c === 1) {
            shadow.offsetY = token;
          } else {
            shadow.blur = token;
          }
          c++;
        } else {
          shadow.color = color$1$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, textTransform2) {
    switch (textTransform2) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    if (token.type === 18) {
      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
      if (typeof transformFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
      }
      return transformFunction(token.values);
    }
    return null;
  }
};
var matrix = function(args) {
  var values = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  return values.length === 6 ? values : null;
};
var matrix3d = function(args) {
  var values = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  var a1 = values[0], b1 = values[1];
  values[2];
  values[3];
  var a2 = values[4], b2 = values[5];
  values[6];
  values[7];
  values[8];
  values[9];
  values[10];
  values[11];
  var a4 = values[12], b4 = values[13];
  values[14];
  values[15];
  return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
};
var SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix,
  matrix3d
};
var DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
var transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    var origins = tokens.filter(isLengthPercentage);
    if (origins.length !== 2) {
      return DEFAULT;
    }
    return [origins[0], origins[1]];
  }
};
var visibility = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, visibility2) {
    switch (visibility2) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var WORD_BREAK;
(function(WORD_BREAK2) {
  WORD_BREAK2["NORMAL"] = "normal";
  WORD_BREAK2["BREAK_ALL"] = "break-all";
  WORD_BREAK2["KEEP_ALL"] = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, wordBreak2) {
    switch (wordBreak2) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
};
var zIndex$1 = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20) {
      return { auto: true, order: 0 };
    }
    if (isNumberToken(token)) {
      return { auto: false, order: token.number };
    }
    throw new Error("Invalid z-index number parsed");
  }
};
var time = {
  name: "time",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit.toLowerCase()) {
        case "s":
          return 1e3 * value.number;
        case "ms":
          return value.number;
      }
    }
    throw new Error("Unsupported time type");
  }
};
var opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    return 1;
  }
};
var textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      switch (token.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(line2) {
      return line2 !== 0;
    });
  }
};
var fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var accumulator = [];
    var results = [];
    tokens.forEach(function(token) {
      switch (token.type) {
        case 20:
        case 0:
          accumulator.push(token.value);
          break;
        case 17:
          accumulator.push(token.number.toString());
          break;
        case 4:
          results.push(accumulator.join(" "));
          accumulator.length = 0;
          break;
      }
    });
    if (accumulator.length) {
      results.push(accumulator.join(" "));
    }
    return results.map(function(result) {
      return result.indexOf(" ") === -1 ? result : "'" + result + "'";
    });
  }
};
var fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    if (isIdentToken(token)) {
      switch (token.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    }
    return 400;
  }
};
var fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      return token.value;
    });
  }
};
var fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var contains$1 = function(bit, value) {
  return (bit & value) !== 0;
};
var content = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens;
  }
};
var counterIncrement = {
  name: "counter-increment",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var increments = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i = 0; i < filtered.length; i++) {
      var counter = filtered[i];
      var next = filtered[i + 1];
      if (counter.type === 20) {
        var increment = next && isNumberToken(next) ? next.number : 1;
        increments.push({ counter: counter.value, increment });
      }
    }
    return increments;
  }
};
var counterReset = {
  name: "counter-reset",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var resets = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i = 0; i < filtered.length; i++) {
      var counter = filtered[i];
      var next = filtered[i + 1];
      if (isIdentToken(counter) && counter.value !== "none") {
        var reset = next && isNumberToken(next) ? next.number : 0;
        resets.push({ counter: counter.value, reset });
      }
    }
    return resets;
  }
};
var duration = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(context, tokens) {
    return tokens.filter(isDimensionToken).map(function(token) {
      return time.parse(context, token);
    });
  }
};
var quotes = {
  name: "quotes",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var quotes2 = [];
    var filtered = tokens.filter(isStringToken);
    if (filtered.length % 2 !== 0) {
      return null;
    }
    for (var i = 0; i < filtered.length; i += 2) {
      var open_1 = filtered[i].value;
      var close_1 = filtered[i + 1].value;
      quotes2.push({ open: open_1, close: close_1 });
    }
    return quotes2;
  }
};
var getQuote = function(quotes2, depth, open) {
  if (!quotes2) {
    return "";
  }
  var quote = quotes2[Math.min(depth, quotes2.length - 1)];
  if (!quote) {
    return "";
  }
  return open ? quote.open : quote.close;
};
var boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values) {
      var shadow = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: false
      };
      var c = 0;
      for (var i = 0; i < values.length; i++) {
        var token = values[i];
        if (isIdentWithValue(token, "inset")) {
          shadow.inset = true;
        } else if (isLength(token)) {
          if (c === 0) {
            shadow.offsetX = token;
          } else if (c === 1) {
            shadow.offsetY = token;
          } else if (c === 2) {
            shadow.blur = token;
          } else {
            shadow.spread = token;
          }
          c++;
        } else {
          shadow.color = color$1$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var DEFAULT_VALUE2 = [
      0,
      1,
      2
      /* MARKERS */
    ];
    var layers = [];
    tokens.filter(isIdentToken).forEach(function(token) {
      switch (token.value) {
        case "stroke":
          layers.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          layers.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          layers.push(
            2
            /* MARKERS */
          );
          break;
      }
    });
    DEFAULT_VALUE2.forEach(function(value) {
      if (layers.indexOf(value) === -1) {
        layers.push(value);
      }
    });
    return layers;
  }
};
var webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isDimensionToken(token)) {
      return token.number;
    }
    return 0;
  }
};
var CSSParsedDeclaration = (
  /** @class */
  function() {
    function CSSParsedDeclaration2(context, declaration) {
      var _a, _b;
      this.animationDuration = parse$1(context, duration, declaration.animationDuration);
      this.backgroundClip = parse$1(context, backgroundClip, declaration.backgroundClip);
      this.backgroundColor = parse$1(context, backgroundColor, declaration.backgroundColor);
      this.backgroundImage = parse$1(context, backgroundImage, declaration.backgroundImage);
      this.backgroundOrigin = parse$1(context, backgroundOrigin, declaration.backgroundOrigin);
      this.backgroundPosition = parse$1(context, backgroundPosition, declaration.backgroundPosition);
      this.backgroundRepeat = parse$1(context, backgroundRepeat, declaration.backgroundRepeat);
      this.backgroundSize = parse$1(context, backgroundSize, declaration.backgroundSize);
      this.borderTopColor = parse$1(context, borderTopColor, declaration.borderTopColor);
      this.borderRightColor = parse$1(context, borderRightColor, declaration.borderRightColor);
      this.borderBottomColor = parse$1(context, borderBottomColor, declaration.borderBottomColor);
      this.borderLeftColor = parse$1(context, borderLeftColor, declaration.borderLeftColor);
      this.borderTopLeftRadius = parse$1(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
      this.borderTopRightRadius = parse$1(context, borderTopRightRadius, declaration.borderTopRightRadius);
      this.borderBottomRightRadius = parse$1(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
      this.borderBottomLeftRadius = parse$1(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
      this.borderTopStyle = parse$1(context, borderTopStyle, declaration.borderTopStyle);
      this.borderRightStyle = parse$1(context, borderRightStyle, declaration.borderRightStyle);
      this.borderBottomStyle = parse$1(context, borderBottomStyle, declaration.borderBottomStyle);
      this.borderLeftStyle = parse$1(context, borderLeftStyle, declaration.borderLeftStyle);
      this.borderTopWidth = parse$1(context, borderTopWidth, declaration.borderTopWidth);
      this.borderRightWidth = parse$1(context, borderRightWidth, declaration.borderRightWidth);
      this.borderBottomWidth = parse$1(context, borderBottomWidth, declaration.borderBottomWidth);
      this.borderLeftWidth = parse$1(context, borderLeftWidth, declaration.borderLeftWidth);
      this.boxShadow = parse$1(context, boxShadow, declaration.boxShadow);
      this.color = parse$1(context, color$4, declaration.color);
      this.direction = parse$1(context, direction, declaration.direction);
      this.display = parse$1(context, display, declaration.display);
      this.float = parse$1(context, float, declaration.cssFloat);
      this.fontFamily = parse$1(context, fontFamily, declaration.fontFamily);
      this.fontSize = parse$1(context, fontSize, declaration.fontSize);
      this.fontStyle = parse$1(context, fontStyle, declaration.fontStyle);
      this.fontVariant = parse$1(context, fontVariant, declaration.fontVariant);
      this.fontWeight = parse$1(context, fontWeight, declaration.fontWeight);
      this.letterSpacing = parse$1(context, letterSpacing, declaration.letterSpacing);
      this.lineBreak = parse$1(context, lineBreak, declaration.lineBreak);
      this.lineHeight = parse$1(context, lineHeight, declaration.lineHeight);
      this.listStyleImage = parse$1(context, listStyleImage, declaration.listStyleImage);
      this.listStylePosition = parse$1(context, listStylePosition, declaration.listStylePosition);
      this.listStyleType = parse$1(context, listStyleType, declaration.listStyleType);
      this.marginTop = parse$1(context, marginTop, declaration.marginTop);
      this.marginRight = parse$1(context, marginRight, declaration.marginRight);
      this.marginBottom = parse$1(context, marginBottom, declaration.marginBottom);
      this.marginLeft = parse$1(context, marginLeft, declaration.marginLeft);
      this.opacity = parse$1(context, opacity, declaration.opacity);
      var overflowTuple = parse$1(context, overflow, declaration.overflow);
      this.overflowX = overflowTuple[0];
      this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
      this.overflowWrap = parse$1(context, overflowWrap, declaration.overflowWrap);
      this.paddingTop = parse$1(context, paddingTop, declaration.paddingTop);
      this.paddingRight = parse$1(context, paddingRight, declaration.paddingRight);
      this.paddingBottom = parse$1(context, paddingBottom, declaration.paddingBottom);
      this.paddingLeft = parse$1(context, paddingLeft, declaration.paddingLeft);
      this.paintOrder = parse$1(context, paintOrder, declaration.paintOrder);
      this.position = parse$1(context, position, declaration.position);
      this.textAlign = parse$1(context, textAlign, declaration.textAlign);
      this.textDecorationColor = parse$1(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
      this.textDecorationLine = parse$1(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
      this.textShadow = parse$1(context, textShadow, declaration.textShadow);
      this.textTransform = parse$1(context, textTransform, declaration.textTransform);
      this.transform = parse$1(context, transform$1, declaration.transform);
      this.transformOrigin = parse$1(context, transformOrigin, declaration.transformOrigin);
      this.visibility = parse$1(context, visibility, declaration.visibility);
      this.webkitTextStrokeColor = parse$1(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
      this.webkitTextStrokeWidth = parse$1(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
      this.wordBreak = parse$1(context, wordBreak, declaration.wordBreak);
      this.zIndex = parse$1(context, zIndex$1, declaration.zIndex);
    }
    CSSParsedDeclaration2.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    };
    CSSParsedDeclaration2.prototype.isTransparent = function() {
      return isTransparent(this.backgroundColor);
    };
    CSSParsedDeclaration2.prototype.isTransformed = function() {
      return this.transform !== null;
    };
    CSSParsedDeclaration2.prototype.isPositioned = function() {
      return this.position !== 0;
    };
    CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    };
    CSSParsedDeclaration2.prototype.isFloating = function() {
      return this.float !== 0;
    };
    CSSParsedDeclaration2.prototype.isInlineLevel = function() {
      return contains$1(
        this.display,
        4
        /* INLINE */
      ) || contains$1(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || contains$1(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || contains$1(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || contains$1(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || contains$1(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    };
    return CSSParsedDeclaration2;
  }()
);
var CSSParsedPseudoDeclaration = (
  /** @class */
  /* @__PURE__ */ function() {
    function CSSParsedPseudoDeclaration2(context, declaration) {
      this.content = parse$1(context, content, declaration.content);
      this.quotes = parse$1(context, quotes, declaration.quotes);
    }
    return CSSParsedPseudoDeclaration2;
  }()
);
var CSSParsedCounterDeclaration = (
  /** @class */
  /* @__PURE__ */ function() {
    function CSSParsedCounterDeclaration2(context, declaration) {
      this.counterIncrement = parse$1(context, counterIncrement, declaration.counterIncrement);
      this.counterReset = parse$1(context, counterReset, declaration.counterReset);
    }
    return CSSParsedCounterDeclaration2;
  }()
);
var parse$1 = function(context, descriptor, style) {
  var tokenizer = new Tokenizer();
  var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
  tokenizer.write(value);
  var parser = new Parser(tokenizer.read());
  switch (descriptor.type) {
    case 2:
      var token = parser.parseComponentValue();
      return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
    case 0:
      return descriptor.parse(context, parser.parseComponentValue());
    case 1:
      return descriptor.parse(context, parser.parseComponentValues());
    case 4:
      return parser.parseComponentValue();
    case 3:
      switch (descriptor.format) {
        case "angle":
          return angle.parse(context, parser.parseComponentValue());
        case "color":
          return color$1$1.parse(context, parser.parseComponentValue());
        case "image":
          return image$2.parse(context, parser.parseComponentValue());
        case "length":
          var length_1 = parser.parseComponentValue();
          return isLength(length_1) ? length_1 : ZERO_LENGTH;
        case "length-percentage":
          var value_1 = parser.parseComponentValue();
          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
        case "time":
          return time.parse(context, parser.parseComponentValue());
      }
      break;
  }
};
var elementDebuggerAttribute = "data-html2canvas-debug";
var getElementDebugType = function(element) {
  var attribute = element.getAttribute(elementDebuggerAttribute);
  switch (attribute) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var isDebugging = function(element, type) {
  var elementType = getElementDebugType(element);
  return elementType === 1 || type === elementType;
};
var ElementContainer = (
  /** @class */
  /* @__PURE__ */ function() {
    function ElementContainer2(context, element) {
      this.context = context;
      this.textNodes = [];
      this.elements = [];
      this.flags = 0;
      if (isDebugging(
        element,
        3
        /* PARSE */
      )) {
        debugger;
      }
      this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
      if (isHTMLElementNode(element)) {
        if (this.styles.animationDuration.some(function(duration2) {
          return duration2 > 0;
        })) {
          element.style.animationDuration = "0s";
        }
        if (this.styles.transform !== null) {
          element.style.transform = "none";
        }
      }
      this.bounds = parseBounds(this.context, element);
      if (isDebugging(
        element,
        4
        /* RENDER */
      )) {
        this.flags |= 16;
      }
    }
    return ElementContainer2;
  }()
);
var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
  lookup$1[chars$1.charCodeAt(i$1)] = i$1;
}
var decode = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer2 = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer2) ? buffer2 : new Uint8Array(buffer2);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i)];
    encoded2 = lookup$1[base642.charCodeAt(i + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer2;
};
var polyUint16Array = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i = 0; i < length; i += 2) {
    bytes.push(buffer2[i + 1] << 8 | buffer2[i]);
  }
  return bytes;
};
var polyUint32Array = function(buffer2) {
  var length = buffer2.length;
  var bytes = [];
  for (var i = 0; i < length; i += 4) {
    bytes.push(buffer2[i + 3] << 24 | buffer2[i + 2] << 16 | buffer2[i + 1] << 8 | buffer2[i]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2 = 5;
var UTRIE2_SHIFT_1 = 6 + 5;
var UTRIE2_INDEX_SHIFT = 2;
var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
var slice16 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64 = function(base642, _byteLength) {
  var buffer2 = decode(base642);
  var view32 = Array.isArray(buffer2) ? polyUint32Array(buffer2) : new Uint32Array(buffer2);
  var view16 = Array.isArray(buffer2) ? polyUint16Array(buffer2) : new Uint16Array(buffer2);
  var headerLength = 24;
  var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data);
};
var Trie = (
  /** @class */
  function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index2;
      this.data = data;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  }()
);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
var Prepend = 1;
var CR = 2;
var LF = 3;
var Control = 4;
var Extend = 5;
var SpacingMark = 7;
var L = 8;
var V = 9;
var T = 10;
var LV = 11;
var LVT = 12;
var ZWJ = 13;
var Extended_Pictographic = 14;
var RI = 15;
var toCodePoints = function(str) {
  var codePoints = [];
  var i = 0;
  var length = str.length;
  while (i < length) {
    var value = str.charCodeAt(i++);
    if (value >= 55296 && value <= 56319 && i < length) {
      var extra = str.charCodeAt(i++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var UnicodeTrie = createTrieFromBase64(base64);
var BREAK_NOT_ALLOWED = "";
var BREAK_ALLOWED = "";
var codePointToClass = function(codePoint) {
  return UnicodeTrie.get(codePoint);
};
var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
  var prevIndex = index2 - 2;
  var prev = classTypes[prevIndex];
  var current = classTypes[index2 - 1];
  var next = classTypes[index2];
  if (current === CR && next === LF) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === CR || current === LF || current === Control) {
    return BREAK_ALLOWED;
  }
  if (next === CR || next === LF || next === Control) {
    return BREAK_ALLOWED;
  }
  if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LV || current === V) && (next === V || next === T)) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LVT || current === T) && next === T) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === ZWJ || next === Extend) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === SpacingMark) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === Prepend) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === ZWJ && next === Extended_Pictographic) {
    while (prev === Extend) {
      prev = classTypes[--prevIndex];
    }
    if (prev === Extended_Pictographic) {
      return BREAK_NOT_ALLOWED;
    }
  }
  if (current === RI && next === RI) {
    var countRI = 0;
    while (prev === RI) {
      countRI++;
      prev = classTypes[--prevIndex];
    }
    if (countRI % 2 === 0) {
      return BREAK_NOT_ALLOWED;
    }
  }
  return BREAK_ALLOWED;
};
var GraphemeBreaker = function(str) {
  var codePoints = toCodePoints(str);
  var length = codePoints.length;
  var index2 = 0;
  var lastEnd = 0;
  var classTypes = codePoints.map(codePointToClass);
  return {
    next: function() {
      if (index2 >= length) {
        return { done: true, value: null };
      }
      var graphemeBreak = BREAK_NOT_ALLOWED;
      while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
      }
      if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
        var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
        lastEnd = index2;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var splitGraphemes = function(str) {
  var breaker = GraphemeBreaker(str);
  var graphemes = [];
  var bk;
  while (!(bk = breaker.next()).done) {
    if (bk.value) {
      graphemes.push(bk.value.slice());
    }
  }
  return graphemes;
};
var testRangeBounds = function(document2) {
  var TEST_HEIGHT = 123;
  if (document2.createRange) {
    var range2 = document2.createRange();
    if (range2.getBoundingClientRect) {
      var testElement = document2.createElement("boundtest");
      testElement.style.height = TEST_HEIGHT + "px";
      testElement.style.display = "block";
      document2.body.appendChild(testElement);
      range2.selectNode(testElement);
      var rangeBounds = range2.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document2.body.removeChild(testElement);
      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }
  return false;
};
var testIOSLineBreak = function(document2) {
  var testElement = document2.createElement("boundtest");
  testElement.style.width = "50px";
  testElement.style.display = "block";
  testElement.style.fontSize = "12px";
  testElement.style.letterSpacing = "0px";
  testElement.style.wordSpacing = "0px";
  document2.body.appendChild(testElement);
  var range2 = document2.createRange();
  testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
  var node = testElement.firstChild;
  var textList = toCodePoints$1(node.data).map(function(i) {
    return fromCodePoint$1(i);
  });
  var offset = 0;
  var prev = {};
  var supports = textList.every(function(text2, i) {
    range2.setStart(node, offset);
    range2.setEnd(node, offset + text2.length);
    var rect = range2.getBoundingClientRect();
    offset += text2.length;
    var boundAhead = rect.x > prev.x || rect.y > prev.y;
    prev = rect;
    if (i === 0) {
      return true;
    }
    return boundAhead;
  });
  document2.body.removeChild(testElement);
  return supports;
};
var testCORS = function() {
  return typeof new Image().crossOrigin !== "undefined";
};
var testResponseType = function() {
  return typeof new XMLHttpRequest().responseType === "string";
};
var testSVG = function(document2) {
  var img = new Image();
  var canvas2 = document2.createElement("canvas");
  var ctx = canvas2.getContext("2d");
  if (!ctx) {
    return false;
  }
  img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    ctx.drawImage(img, 0, 0);
    canvas2.toDataURL();
  } catch (e2) {
    return false;
  }
  return true;
};
var isGreenPixel = function(data) {
  return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
};
var testForeignObject = function(document2) {
  var canvas2 = document2.createElement("canvas");
  var size2 = 100;
  canvas2.width = size2;
  canvas2.height = size2;
  var ctx = canvas2.getContext("2d");
  if (!ctx) {
    return Promise.reject(false);
  }
  ctx.fillStyle = "rgb(0, 255, 0)";
  ctx.fillRect(0, 0, size2, size2);
  var img = new Image();
  var greenImageSrc = canvas2.toDataURL();
  img.src = greenImageSrc;
  var svg = createForeignObjectSVG(size2, size2, 0, 0, img);
  ctx.fillStyle = "red";
  ctx.fillRect(0, 0, size2, size2);
  return loadSerializedSVG$1(svg).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    var data = ctx.getImageData(0, 0, size2, size2).data;
    ctx.fillStyle = "red";
    ctx.fillRect(0, 0, size2, size2);
    var node = document2.createElement("div");
    node.style.backgroundImage = "url(" + greenImageSrc + ")";
    node.style.height = size2 + "px";
    return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size2, size2, 0, 0, node)) : Promise.reject(false);
  }).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    return isGreenPixel(ctx.getImageData(0, 0, size2, size2).data);
  }).catch(function() {
    return false;
  });
};
var createForeignObjectSVG = function(width, height, x, y, node) {
  var xmlns = "http://www.w3.org/2000/svg";
  var svg = document.createElementNS(xmlns, "svg");
  var foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg.setAttributeNS(null, "width", width.toString());
  svg.setAttributeNS(null, "height", height.toString());
  foreignObject.setAttributeNS(null, "width", "100%");
  foreignObject.setAttributeNS(null, "height", "100%");
  foreignObject.setAttributeNS(null, "x", x.toString());
  foreignObject.setAttributeNS(null, "y", y.toString());
  foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svg;
};
var loadSerializedSVG$1 = function(svg) {
  return new Promise(function(resolve2, reject) {
    var img = new Image();
    img.onload = function() {
      return resolve2(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
var FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var value = testRangeBounds(document);
    Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
    return value;
  },
  get SUPPORT_WORD_BREAKING() {
    var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
    return value;
  },
  get SUPPORT_SVG_DRAWING() {
    var value = testSVG(document);
    Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
    return value;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
    return value;
  },
  get SUPPORT_CORS_IMAGES() {
    var value = testCORS();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
    return value;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var value = testResponseType();
    Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
    return value;
  },
  get SUPPORT_CORS_XHR() {
    var value = "withCredentials" in new XMLHttpRequest();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
    return value;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
    Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
    return value;
  }
};
var TextBounds = (
  /** @class */
  /* @__PURE__ */ function() {
    function TextBounds2(text2, bounds) {
      this.text = text2;
      this.bounds = bounds;
    }
    return TextBounds2;
  }()
);
var parseTextBounds = function(context, value, styles, node) {
  var textList = breakText(value, styles);
  var textBounds = [];
  var offset = 0;
  textList.forEach(function(text2) {
    if (styles.textDecorationLine.length || text2.trim().length > 0) {
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var clientRects = createRange(node, offset, text2.length).getClientRects();
        if (clientRects.length > 1) {
          var subSegments = segmentGraphemes(text2);
          var subOffset_1 = 0;
          subSegments.forEach(function(subSegment) {
            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
            subOffset_1 += subSegment.length;
          });
        } else {
          textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context, clientRects)));
        }
      } else {
        var replacementNode = node.splitText(text2.length);
        textBounds.push(new TextBounds(text2, getWrapperBounds(context, node)));
        node = replacementNode;
      }
    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
      node = node.splitText(text2.length);
    }
    offset += text2.length;
  });
  return textBounds;
};
var getWrapperBounds = function(context, node) {
  var ownerDocument = node.ownerDocument;
  if (ownerDocument) {
    var wrapper = ownerDocument.createElement("html2canvaswrapper");
    wrapper.appendChild(node.cloneNode(true));
    var parentNode = node.parentNode;
    if (parentNode) {
      parentNode.replaceChild(wrapper, node);
      var bounds = parseBounds(context, wrapper);
      if (wrapper.firstChild) {
        parentNode.replaceChild(wrapper.firstChild, wrapper);
      }
      return bounds;
    }
  }
  return Bounds.EMPTY;
};
var createRange = function(node, offset, length) {
  var ownerDocument = node.ownerDocument;
  if (!ownerDocument) {
    throw new Error("Node has no owner document");
  }
  var range2 = ownerDocument.createRange();
  range2.setStart(node, offset);
  range2.setEnd(node, offset + length);
  return range2;
};
var segmentGraphemes = function(value) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return splitGraphemes(value);
};
var segmentWords = function(value, styles) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return breakWords(value, styles);
};
var breakText = function(value, styles) {
  return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
};
var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
var breakWords = function(str, styles) {
  var breaker = LineBreaker(str, {
    lineBreak: styles.lineBreak,
    wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
  });
  var words = [];
  var bk;
  var _loop_1 = function() {
    if (bk.value) {
      var value = bk.value.slice();
      var codePoints = toCodePoints$1(value);
      var word_1 = "";
      codePoints.forEach(function(codePoint) {
        if (wordSeparators.indexOf(codePoint) === -1) {
          word_1 += fromCodePoint$1(codePoint);
        } else {
          if (word_1.length) {
            words.push(word_1);
          }
          words.push(fromCodePoint$1(codePoint));
          word_1 = "";
        }
      });
      if (word_1.length) {
        words.push(word_1);
      }
    }
  };
  while (!(bk = breaker.next()).done) {
    _loop_1();
  }
  return words;
};
var TextContainer = (
  /** @class */
  /* @__PURE__ */ function() {
    function TextContainer2(context, node, styles) {
      this.text = transform(node.data, styles.textTransform);
      this.textBounds = parseTextBounds(context, this.text, styles, node);
    }
    return TextContainer2;
  }()
);
var transform = function(text2, transform2) {
  switch (transform2) {
    case 1:
      return text2.toLowerCase();
    case 3:
      return text2.replace(CAPITALIZE, capitalize);
    case 2:
      return text2.toUpperCase();
    default:
      return text2;
  }
};
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
var capitalize = function(m, p1, p2) {
  if (m.length > 0) {
    return p1 + p2.toUpperCase();
  }
  return m;
};
var ImageElementContainer = (
  /** @class */
  function(_super) {
    __extends(ImageElementContainer2, _super);
    function ImageElementContainer2(context, img) {
      var _this = _super.call(this, context, img) || this;
      _this.src = img.currentSrc || img.src;
      _this.intrinsicWidth = img.naturalWidth;
      _this.intrinsicHeight = img.naturalHeight;
      _this.context.cache.addImage(_this.src);
      return _this;
    }
    return ImageElementContainer2;
  }(ElementContainer)
);
var CanvasElementContainer = (
  /** @class */
  function(_super) {
    __extends(CanvasElementContainer2, _super);
    function CanvasElementContainer2(context, canvas2) {
      var _this = _super.call(this, context, canvas2) || this;
      _this.canvas = canvas2;
      _this.intrinsicWidth = canvas2.width;
      _this.intrinsicHeight = canvas2.height;
      return _this;
    }
    return CanvasElementContainer2;
  }(ElementContainer)
);
var SVGElementContainer = (
  /** @class */
  function(_super) {
    __extends(SVGElementContainer2, _super);
    function SVGElementContainer2(context, img) {
      var _this = _super.call(this, context, img) || this;
      var s2 = new XMLSerializer();
      var bounds = parseBounds(context, img);
      img.setAttribute("width", bounds.width + "px");
      img.setAttribute("height", bounds.height + "px");
      _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
      _this.intrinsicWidth = img.width.baseVal.value;
      _this.intrinsicHeight = img.height.baseVal.value;
      _this.context.cache.addImage(_this.svg);
      return _this;
    }
    return SVGElementContainer2;
  }(ElementContainer)
);
var LIElementContainer = (
  /** @class */
  function(_super) {
    __extends(LIElementContainer2, _super);
    function LIElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return LIElementContainer2;
  }(ElementContainer)
);
var OLElementContainer = (
  /** @class */
  function(_super) {
    __extends(OLElementContainer2, _super);
    function OLElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.start = element.start;
      _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
      return _this;
    }
    return OLElementContainer2;
  }(ElementContainer)
);
var CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
];
var RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
];
var reformatInputBounds = function(bounds) {
  if (bounds.width > bounds.height) {
    return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  } else if (bounds.width < bounds.height) {
    return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  }
  return bounds;
};
var getInputValue = function(node) {
  var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("") : node.value;
  return value.length === 0 ? node.placeholder || "" : value;
};
var CHECKBOX = "checkbox";
var RADIO = "radio";
var PASSWORD = "password";
var INPUT_COLOR = 707406591;
var InputElementContainer = (
  /** @class */
  function(_super) {
    __extends(InputElementContainer2, _super);
    function InputElementContainer2(context, input2) {
      var _this = _super.call(this, context, input2) || this;
      _this.type = input2.type.toLowerCase();
      _this.checked = input2.checked;
      _this.value = getInputValue(input2);
      if (_this.type === CHECKBOX || _this.type === RADIO) {
        _this.styles.backgroundColor = 3739148031;
        _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
        _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
        _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
        _this.styles.backgroundClip = [
          0
          /* BORDER_BOX */
        ];
        _this.styles.backgroundOrigin = [
          0
          /* BORDER_BOX */
        ];
        _this.bounds = reformatInputBounds(_this.bounds);
      }
      switch (_this.type) {
        case CHECKBOX:
          _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
          break;
        case RADIO:
          _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
          break;
      }
      return _this;
    }
    return InputElementContainer2;
  }(ElementContainer)
);
var SelectElementContainer = (
  /** @class */
  function(_super) {
    __extends(SelectElementContainer2, _super);
    function SelectElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      var option = element.options[element.selectedIndex || 0];
      _this.value = option ? option.text || "" : "";
      return _this;
    }
    return SelectElementContainer2;
  }(ElementContainer)
);
var TextareaElementContainer = (
  /** @class */
  function(_super) {
    __extends(TextareaElementContainer2, _super);
    function TextareaElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return TextareaElementContainer2;
  }(ElementContainer)
);
var IFrameElementContainer = (
  /** @class */
  function(_super) {
    __extends(IFrameElementContainer2, _super);
    function IFrameElementContainer2(context, iframe) {
      var _this = _super.call(this, context, iframe) || this;
      _this.src = iframe.src;
      _this.width = parseInt(iframe.width, 10) || 0;
      _this.height = parseInt(iframe.height, 10) || 0;
      _this.backgroundColor = _this.styles.backgroundColor;
      try {
        if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
          _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
          var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
          var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
          _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
        }
      } catch (e2) {
      }
      return _this;
    }
    return IFrameElementContainer2;
  }(ElementContainer)
);
var LIST_OWNERS = ["OL", "UL", "MENU"];
var parseNodeTree = function(context, node, parent, root) {
  for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    if (isTextNode(childNode) && childNode.data.trim().length > 0) {
      parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
    } else if (isElementNode(childNode)) {
      if (isSlotElement(childNode) && childNode.assignedNodes) {
        childNode.assignedNodes().forEach(function(childNode2) {
          return parseNodeTree(context, childNode2, parent, root);
        });
      } else {
        var container = createContainer(context, childNode);
        if (container.styles.isVisible()) {
          if (createsRealStackingContext(childNode, container, root)) {
            container.flags |= 4;
          } else if (createsStackingContext(container.styles)) {
            container.flags |= 2;
          }
          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
            container.flags |= 8;
          }
          parent.elements.push(container);
          childNode.slot;
          if (childNode.shadowRoot) {
            parseNodeTree(context, childNode.shadowRoot, container, root);
          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
            parseNodeTree(context, childNode, container, root);
          }
        }
      }
    }
  }
};
var createContainer = function(context, element) {
  if (isImageElement(element)) {
    return new ImageElementContainer(context, element);
  }
  if (isCanvasElement(element)) {
    return new CanvasElementContainer(context, element);
  }
  if (isSVGElement(element)) {
    return new SVGElementContainer(context, element);
  }
  if (isLIElement(element)) {
    return new LIElementContainer(context, element);
  }
  if (isOLElement(element)) {
    return new OLElementContainer(context, element);
  }
  if (isInputElement(element)) {
    return new InputElementContainer(context, element);
  }
  if (isSelectElement(element)) {
    return new SelectElementContainer(context, element);
  }
  if (isTextareaElement(element)) {
    return new TextareaElementContainer(context, element);
  }
  if (isIFrameElement(element)) {
    return new IFrameElementContainer(context, element);
  }
  return new ElementContainer(context, element);
};
var parseTree = function(context, element) {
  var container = createContainer(context, element);
  container.flags |= 4;
  parseNodeTree(context, element, container, container);
  return container;
};
var createsRealStackingContext = function(node, container, root) {
  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root.styles.isTransparent();
};
var createsStackingContext = function(styles) {
  return styles.isPositioned() || styles.isFloating();
};
var isTextNode = function(node) {
  return node.nodeType === Node.TEXT_NODE;
};
var isElementNode = function(node) {
  return node.nodeType === Node.ELEMENT_NODE;
};
var isHTMLElementNode = function(node) {
  return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
};
var isSVGElementNode = function(element) {
  return typeof element.className === "object";
};
var isLIElement = function(node) {
  return node.tagName === "LI";
};
var isOLElement = function(node) {
  return node.tagName === "OL";
};
var isInputElement = function(node) {
  return node.tagName === "INPUT";
};
var isHTMLElement = function(node) {
  return node.tagName === "HTML";
};
var isSVGElement = function(node) {
  return node.tagName === "svg";
};
var isBodyElement = function(node) {
  return node.tagName === "BODY";
};
var isCanvasElement = function(node) {
  return node.tagName === "CANVAS";
};
var isVideoElement = function(node) {
  return node.tagName === "VIDEO";
};
var isImageElement = function(node) {
  return node.tagName === "IMG";
};
var isIFrameElement = function(node) {
  return node.tagName === "IFRAME";
};
var isStyleElement = function(node) {
  return node.tagName === "STYLE";
};
var isScriptElement = function(node) {
  return node.tagName === "SCRIPT";
};
var isTextareaElement = function(node) {
  return node.tagName === "TEXTAREA";
};
var isSelectElement = function(node) {
  return node.tagName === "SELECT";
};
var isSlotElement = function(node) {
  return node.tagName === "SLOT";
};
var isCustomElement = function(node) {
  return node.tagName.indexOf("-") > 0;
};
var CounterState = (
  /** @class */
  function() {
    function CounterState2() {
      this.counters = {};
    }
    CounterState2.prototype.getCounterValue = function(name) {
      var counter = this.counters[name];
      if (counter && counter.length) {
        return counter[counter.length - 1];
      }
      return 1;
    };
    CounterState2.prototype.getCounterValues = function(name) {
      var counter = this.counters[name];
      return counter ? counter : [];
    };
    CounterState2.prototype.pop = function(counters) {
      var _this = this;
      counters.forEach(function(counter) {
        return _this.counters[counter].pop();
      });
    };
    CounterState2.prototype.parse = function(style) {
      var _this = this;
      var counterIncrement2 = style.counterIncrement;
      var counterReset2 = style.counterReset;
      var canReset = true;
      if (counterIncrement2 !== null) {
        counterIncrement2.forEach(function(entry) {
          var counter = _this.counters[entry.counter];
          if (counter && entry.increment !== 0) {
            canReset = false;
            if (!counter.length) {
              counter.push(1);
            }
            counter[Math.max(0, counter.length - 1)] += entry.increment;
          }
        });
      }
      var counterNames = [];
      if (canReset) {
        counterReset2.forEach(function(entry) {
          var counter = _this.counters[entry.counter];
          counterNames.push(entry.counter);
          if (!counter) {
            counter = _this.counters[entry.counter] = [];
          }
          counter.push(entry.reset);
        });
      }
      return counterNames;
    };
    return CounterState2;
  }()
);
var ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
var HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
var GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
};
var createAdditiveCounter = function(value, min, max, symbols, fallback, suffix) {
  if (value < min || value > max) {
    return createCounterText(value, fallback, suffix.length > 0);
  }
  return symbols.integers.reduce(function(string2, integer, index2) {
    while (value >= integer) {
      value -= integer;
      string2 += symbols.values[index2];
    }
    return string2;
  }, "") + suffix;
};
var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
  var string2 = "";
  do {
    if (!isNumeric) {
      value--;
    }
    string2 = resolver(value) + string2;
    value /= codePointRangeLength;
  } while (value * codePointRangeLength >= codePointRangeLength);
  return string2;
};
var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix);
};
var createCounterStyleFromSymbols = function(value, symbols, suffix) {
  if (suffix === void 0) {
    suffix = ". ";
  }
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix;
};
var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
  if (value < -9999 || value > 9999) {
    return createCounterText(value, 4, suffix.length > 0);
  }
  var tmp = Math.abs(value);
  var string2 = suffix;
  if (tmp === 0) {
    return numbers[0] + string2;
  }
  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
    var coefficient = tmp % 10;
    if (coefficient === 0 && contains$1(flags, CJK_ZEROS) && string2 !== "") {
      string2 = numbers[coefficient] + string2;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains$1(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains$1(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains$1(flags, CJK_HUNDRED_COEFFICIENTS)) {
      string2 = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string2;
    } else if (coefficient === 1 && digit > 0) {
      string2 = multipliers[digit - 1] + string2;
    }
    tmp = Math.floor(tmp / 10);
  }
  return (value < 0 ? negativeSign : "") + string2;
};
var CHINESE_INFORMAL_MULTIPLIERS = "";
var CHINESE_FORMAL_MULTIPLIERS = "";
var JAPANESE_NEGATIVE = "";
var KOREAN_NEGATIVE = "";
var createCounterText = function(value, type, appendSuffix) {
  var defaultSuffix = appendSuffix ? ". " : "";
  var cjkSuffix = appendSuffix ? "" : "";
  var koreanSuffix = appendSuffix ? ", " : "";
  var spaceSuffix = appendSuffix ? " " : "";
  switch (type) {
    case 0:
      return "" + spaceSuffix;
    case 1:
      return "" + spaceSuffix;
    case 2:
      return "" + spaceSuffix;
    case 5:
      var string2 = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      return string2.length < 4 ? "0" + string2 : string2;
    case 4:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 6:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
    case 7:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
    case 8:
      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
    case 9:
      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
    case 10:
      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
    case 11:
      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
    case 12:
    case 49:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
    case 35:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
    case 13:
      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
    case 14:
    case 30:
      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
    case 15:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 16:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 17:
    case 48:
      return createCJKCounter(value, "", CHINESE_INFORMAL_MULTIPLIERS, "", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(value, "", CHINESE_FORMAL_MULTIPLIERS, "", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(value, "", CHINESE_INFORMAL_MULTIPLIERS, "", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(value, "", CHINESE_FORMAL_MULTIPLIERS, "", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(value, "", "", JAPANESE_NEGATIVE, cjkSuffix, 0);
    case 25:
      return createCJKCounter(value, "", "", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, 0);
    case 32:
      return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
    case 20:
      return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
    case 21:
      return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
    case 22:
      return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
    case 22:
      return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
    case 23:
      return createCounterStyleFromSymbols(value, "");
    case 24:
      return createCounterStyleFromSymbols(value, "");
    case 27:
      return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
    case 28:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 29:
      return createCounterStyleFromSymbols(value, "", cjkSuffix);
    case 34:
      return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
    case 37:
      return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
    case 38:
      return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
    case 39:
      return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
    case 40:
      return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
    case 43:
      return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
    case 44:
      return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
    case 45:
      return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
    case 46:
      return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
    case 3:
    default:
      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  }
};
var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
var DocumentCloner = (
  /** @class */
  function() {
    function DocumentCloner2(context, element, options) {
      this.context = context;
      this.options = options;
      this.scrolledElements = [];
      this.referenceElement = element;
      this.counters = new CounterState();
      this.quoteDepth = 0;
      if (!element.ownerDocument) {
        throw new Error("Cloned element does not have an owner document");
      }
      this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
    }
    DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
      var _this = this;
      var iframe = createIFrameContainer(ownerDocument, windowSize);
      if (!iframe.contentWindow) {
        return Promise.reject("Unable to find iframe window");
      }
      var scrollX = ownerDocument.defaultView.pageXOffset;
      var scrollY = ownerDocument.defaultView.pageYOffset;
      var cloneWindow = iframe.contentWindow;
      var documentClone = cloneWindow.document;
      var iframeLoad = iframeLoader(iframe).then(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var onclone, referenceElement;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.scrolledElements.forEach(restoreNodeScroll);
                if (cloneWindow) {
                  cloneWindow.scrollTo(windowSize.left, windowSize.top);
                  if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                    this.context.logger.warn("Unable to restore scroll position for cloned document");
                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                  }
                }
                onclone = this.options.onclone;
                referenceElement = this.clonedReferenceElement;
                if (typeof referenceElement === "undefined") {
                  return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                }
                if (!(documentClone.fonts && documentClone.fonts.ready))
                  return [3, 2];
                return [4, documentClone.fonts.ready];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                if (!/(AppleWebKit)/g.test(navigator.userAgent))
                  return [3, 4];
                return [4, imagesReady(documentClone)];
              case 3:
                _a.sent();
                _a.label = 4;
              case 4:
                if (typeof onclone === "function") {
                  return [2, Promise.resolve().then(function() {
                    return onclone(documentClone, referenceElement);
                  }).then(function() {
                    return iframe;
                  })];
                }
                return [2, iframe];
            }
          });
        });
      });
      documentClone.open();
      documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
      restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
      documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
      documentClone.close();
      return iframeLoad;
    };
    DocumentCloner2.prototype.createElementClone = function(node) {
      if (isDebugging(
        node,
        2
        /* CLONE */
      )) {
        debugger;
      }
      if (isCanvasElement(node)) {
        return this.createCanvasClone(node);
      }
      if (isVideoElement(node)) {
        return this.createVideoClone(node);
      }
      if (isStyleElement(node)) {
        return this.createStyleClone(node);
      }
      var clone2 = node.cloneNode(false);
      if (isImageElement(clone2)) {
        if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
          clone2.src = node.currentSrc;
          clone2.srcset = "";
        }
        if (clone2.loading === "lazy") {
          clone2.loading = "eager";
        }
      }
      if (isCustomElement(clone2)) {
        return this.createCustomElementClone(clone2);
      }
      return clone2;
    };
    DocumentCloner2.prototype.createCustomElementClone = function(node) {
      var clone2 = document.createElement("html2canvascustomelement");
      copyCSSStyles(node.style, clone2);
      return clone2;
    };
    DocumentCloner2.prototype.createStyleClone = function(node) {
      try {
        var sheet = node.sheet;
        if (sheet && sheet.cssRules) {
          var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
            if (rule && typeof rule.cssText === "string") {
              return css2 + rule.cssText;
            }
            return css2;
          }, "");
          var style = node.cloneNode(false);
          style.textContent = css;
          return style;
        }
      } catch (e2) {
        this.context.logger.error("Unable to access cssRules property", e2);
        if (e2.name !== "SecurityError") {
          throw e2;
        }
      }
      return node.cloneNode(false);
    };
    DocumentCloner2.prototype.createCanvasClone = function(canvas2) {
      var _a;
      if (this.options.inlineImages && canvas2.ownerDocument) {
        var img = canvas2.ownerDocument.createElement("img");
        try {
          img.src = canvas2.toDataURL();
          return img;
        } catch (e2) {
          this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas2);
        }
      }
      var clonedCanvas = canvas2.cloneNode(false);
      try {
        clonedCanvas.width = canvas2.width;
        clonedCanvas.height = canvas2.height;
        var ctx = canvas2.getContext("2d");
        var clonedCtx = clonedCanvas.getContext("2d");
        if (clonedCtx) {
          if (!this.options.allowTaint && ctx) {
            clonedCtx.putImageData(ctx.getImageData(0, 0, canvas2.width, canvas2.height), 0, 0);
          } else {
            var gl = (_a = canvas2.getContext("webgl2")) !== null && _a !== void 0 ? _a : canvas2.getContext("webgl");
            if (gl) {
              var attribs = gl.getContextAttributes();
              if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas2);
              }
            }
            clonedCtx.drawImage(canvas2, 0, 0);
          }
        }
        return clonedCanvas;
      } catch (e2) {
        this.context.logger.info("Unable to clone canvas as it is tainted", canvas2);
      }
      return clonedCanvas;
    };
    DocumentCloner2.prototype.createVideoClone = function(video2) {
      var canvas2 = video2.ownerDocument.createElement("canvas");
      canvas2.width = video2.offsetWidth;
      canvas2.height = video2.offsetHeight;
      var ctx = canvas2.getContext("2d");
      try {
        if (ctx) {
          ctx.drawImage(video2, 0, 0, canvas2.width, canvas2.height);
          if (!this.options.allowTaint) {
            ctx.getImageData(0, 0, canvas2.width, canvas2.height);
          }
        }
        return canvas2;
      } catch (e2) {
        this.context.logger.info("Unable to clone video as it is tainted", video2);
      }
      var blankCanvas = video2.ownerDocument.createElement("canvas");
      blankCanvas.width = video2.offsetWidth;
      blankCanvas.height = video2.offsetHeight;
      return blankCanvas;
    };
    DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {
      if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
        if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
          clone2.appendChild(this.cloneNode(child, copyStyles));
        }
      }
    };
    DocumentCloner2.prototype.cloneChildNodes = function(node, clone2, copyStyles) {
      var _this = this;
      for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
        if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
          var assignedNodes = child.assignedNodes();
          if (assignedNodes.length) {
            assignedNodes.forEach(function(assignedNode) {
              return _this.appendChildNode(clone2, assignedNode, copyStyles);
            });
          }
        } else {
          this.appendChildNode(clone2, child, copyStyles);
        }
      }
    };
    DocumentCloner2.prototype.cloneNode = function(node, copyStyles) {
      if (isTextNode(node)) {
        return document.createTextNode(node.data);
      }
      if (!node.ownerDocument) {
        return node.cloneNode(false);
      }
      var window2 = node.ownerDocument.defaultView;
      if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
        var clone2 = this.createElementClone(node);
        clone2.style.transitionProperty = "none";
        var style = window2.getComputedStyle(node);
        var styleBefore = window2.getComputedStyle(node, ":before");
        var styleAfter = window2.getComputedStyle(node, ":after");
        if (this.referenceElement === node && isHTMLElementNode(clone2)) {
          this.clonedReferenceElement = clone2;
        }
        if (isBodyElement(clone2)) {
          createPseudoHideStyles(clone2);
        }
        var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
        var before = this.resolvePseudoContent(node, clone2, styleBefore, PseudoElementType.BEFORE);
        if (isCustomElement(node)) {
          copyStyles = true;
        }
        if (!isVideoElement(node)) {
          this.cloneChildNodes(node, clone2, copyStyles);
        }
        if (before) {
          clone2.insertBefore(before, clone2.firstChild);
        }
        var after = this.resolvePseudoContent(node, clone2, styleAfter, PseudoElementType.AFTER);
        if (after) {
          clone2.appendChild(after);
        }
        this.counters.pop(counters);
        if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node) || copyStyles) {
          copyCSSStyles(style, clone2);
        }
        if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
          this.scrolledElements.push([clone2, node.scrollLeft, node.scrollTop]);
        }
        if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
          clone2.value = node.value;
        }
        return clone2;
      }
      return node.cloneNode(false);
    };
    DocumentCloner2.prototype.resolvePseudoContent = function(node, clone2, style, pseudoElt) {
      var _this = this;
      if (!style) {
        return;
      }
      var value = style.content;
      var document2 = clone2.ownerDocument;
      if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
        return;
      }
      this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
      var declaration = new CSSParsedPseudoDeclaration(this.context, style);
      var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
      copyCSSStyles(style, anonymousReplacedElement);
      declaration.content.forEach(function(token) {
        if (token.type === 0) {
          anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
        } else if (token.type === 22) {
          var img = document2.createElement("img");
          img.src = token.value;
          img.style.opacity = "1";
          anonymousReplacedElement.appendChild(img);
        } else if (token.type === 18) {
          if (token.name === "attr") {
            var attr = token.values.filter(isIdentToken);
            if (attr.length) {
              anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr[0].value) || ""));
            }
          } else if (token.name === "counter") {
            var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
            if (counter && isIdentToken(counter)) {
              var counterState = _this.counters.getCounterValue(counter.value);
              var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
              anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
            }
          } else if (token.name === "counters") {
            var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
            if (counter && isIdentToken(counter)) {
              var counterStates = _this.counters.getCounterValues(counter.value);
              var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
              var separator = delim && delim.type === 0 ? delim.value : "";
              var text2 = counterStates.map(function(value2) {
                return createCounterText(value2, counterType_1, false);
              }).join(separator);
              anonymousReplacedElement.appendChild(document2.createTextNode(text2));
            }
          } else
            ;
        } else if (token.type === 20) {
          switch (token.value) {
            case "open-quote":
              anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
              break;
            case "close-quote":
              anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
              break;
            default:
              anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
          }
        }
      });
      anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      if (isSVGElementNode(clone2)) {
        clone2.className.baseValue += newClassName;
      } else {
        clone2.className += newClassName;
      }
      return anonymousReplacedElement;
    };
    DocumentCloner2.destroy = function(container) {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
        return true;
      }
      return false;
    };
    return DocumentCloner2;
  }()
);
var PseudoElementType;
(function(PseudoElementType2) {
  PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
  PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var createIFrameContainer = function(ownerDocument, bounds) {
  var cloneIframeContainer = ownerDocument.createElement("iframe");
  cloneIframeContainer.className = "html2canvas-container";
  cloneIframeContainer.style.visibility = "hidden";
  cloneIframeContainer.style.position = "fixed";
  cloneIframeContainer.style.left = "-10000px";
  cloneIframeContainer.style.top = "0px";
  cloneIframeContainer.style.border = "0";
  cloneIframeContainer.width = bounds.width.toString();
  cloneIframeContainer.height = bounds.height.toString();
  cloneIframeContainer.scrolling = "no";
  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
  ownerDocument.body.appendChild(cloneIframeContainer);
  return cloneIframeContainer;
};
var imageReady = function(img) {
  return new Promise(function(resolve2) {
    if (img.complete) {
      resolve2();
      return;
    }
    if (!img.src) {
      resolve2();
      return;
    }
    img.onload = resolve2;
    img.onerror = resolve2;
  });
};
var imagesReady = function(document2) {
  return Promise.all([].slice.call(document2.images, 0).map(imageReady));
};
var iframeLoader = function(iframe) {
  return new Promise(function(resolve2, reject) {
    var cloneWindow = iframe.contentWindow;
    if (!cloneWindow) {
      return reject("No window assigned for iframe");
    }
    var documentClone = cloneWindow.document;
    cloneWindow.onload = iframe.onload = function() {
      cloneWindow.onload = iframe.onload = null;
      var interval = setInterval(function() {
        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
          clearInterval(interval);
          resolve2(iframe);
        }
      }, 50);
    };
  });
};
var ignoredStyleProperties = [
  "all",
  "d",
  "content"
  // Safari shows pseudoelements if content is set
];
var copyCSSStyles = function(style, target) {
  for (var i = style.length - 1; i >= 0; i--) {
    var property = style.item(i);
    if (ignoredStyleProperties.indexOf(property) === -1) {
      target.style.setProperty(property, style.getPropertyValue(property));
    }
  }
  return target;
};
var serializeDoctype = function(doctype) {
  var str = "";
  if (doctype) {
    str += "<!DOCTYPE ";
    if (doctype.name) {
      str += doctype.name;
    }
    if (doctype.internalSubset) {
      str += doctype.internalSubset;
    }
    if (doctype.publicId) {
      str += '"' + doctype.publicId + '"';
    }
    if (doctype.systemId) {
      str += '"' + doctype.systemId + '"';
    }
    str += ">";
  }
  return str;
};
var restoreOwnerScroll = function(ownerDocument, x, y) {
  if (ownerDocument && ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
    ownerDocument.defaultView.scrollTo(x, y);
  }
};
var restoreNodeScroll = function(_a) {
  var element = _a[0], x = _a[1], y = _a[2];
  element.scrollLeft = x;
  element.scrollTop = y;
};
var PSEUDO_BEFORE = ":before";
var PSEUDO_AFTER = ":after";
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
var createPseudoHideStyles = function(body) {
  createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};
var createStyles = function(body, styles) {
  var document2 = body.ownerDocument;
  if (document2) {
    var style = document2.createElement("style");
    style.textContent = styles;
    body.appendChild(style);
  }
};
var CacheStorage = (
  /** @class */
  function() {
    function CacheStorage2() {
    }
    CacheStorage2.getOrigin = function(url2) {
      var link2 = CacheStorage2._link;
      if (!link2) {
        return "about:blank";
      }
      link2.href = url2;
      link2.href = link2.href;
      return link2.protocol + link2.hostname + link2.port;
    };
    CacheStorage2.isSameOrigin = function(src) {
      return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
    };
    CacheStorage2.setContext = function(window2) {
      CacheStorage2._link = window2.document.createElement("a");
      CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
    };
    CacheStorage2._origin = "about:blank";
    return CacheStorage2;
  }()
);
var Cache = (
  /** @class */
  function() {
    function Cache2(context, _options) {
      this.context = context;
      this._options = _options;
      this._cache = {};
    }
    Cache2.prototype.addImage = function(src) {
      var result = Promise.resolve();
      if (this.has(src)) {
        return result;
      }
      if (isBlobImage(src) || isRenderable(src)) {
        (this._cache[src] = this.loadImage(src)).catch(function() {
        });
        return result;
      }
      return result;
    };
    Cache2.prototype.match = function(src) {
      return this._cache[src];
    };
    Cache2.prototype.loadImage = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var isSameOrigin, useCORS, useProxy, src;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              isSameOrigin = CacheStorage.isSameOrigin(key);
              useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
              useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
              if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                return [
                  2
                  /*return*/
                ];
              }
              src = key;
              if (!useProxy)
                return [3, 2];
              return [4, this.proxy(src)];
            case 1:
              src = _a.sent();
              _a.label = 2;
            case 2:
              this.context.logger.debug("Added image " + key.substring(0, 256));
              return [4, new Promise(function(resolve2, reject) {
                var img = new Image();
                img.onload = function() {
                  return resolve2(img);
                };
                img.onerror = reject;
                if (isInlineBase64Image(src) || useCORS) {
                  img.crossOrigin = "anonymous";
                }
                img.src = src;
                if (img.complete === true) {
                  setTimeout(function() {
                    return resolve2(img);
                  }, 500);
                }
                if (_this._options.imageTimeout > 0) {
                  setTimeout(function() {
                    return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                  }, _this._options.imageTimeout);
                }
              })];
            case 3:
              return [2, _a.sent()];
          }
        });
      });
    };
    Cache2.prototype.has = function(key) {
      return typeof this._cache[key] !== "undefined";
    };
    Cache2.prototype.keys = function() {
      return Promise.resolve(Object.keys(this._cache));
    };
    Cache2.prototype.proxy = function(src) {
      var _this = this;
      var proxy = this._options.proxy;
      if (!proxy) {
        throw new Error("No proxy defined");
      }
      var key = src.substring(0, 256);
      return new Promise(function(resolve2, reject) {
        var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
          if (xhr.status === 200) {
            if (responseType === "text") {
              resolve2(xhr.response);
            } else {
              var reader_1 = new FileReader();
              reader_1.addEventListener("load", function() {
                return resolve2(reader_1.result);
              }, false);
              reader_1.addEventListener("error", function(e2) {
                return reject(e2);
              }, false);
              reader_1.readAsDataURL(xhr.response);
            }
          } else {
            reject("Failed to proxy resource " + key + " with status code " + xhr.status);
          }
        };
        xhr.onerror = reject;
        var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
        xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
        if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
          xhr.responseType = responseType;
        }
        if (_this._options.imageTimeout) {
          var timeout_1 = _this._options.imageTimeout;
          xhr.timeout = timeout_1;
          xhr.ontimeout = function() {
            return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
          };
        }
        xhr.send();
      });
    };
    return Cache2;
  }()
);
var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;
var isRenderable = function(src) {
  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
};
var isInlineImage = function(src) {
  return INLINE_IMG.test(src);
};
var isInlineBase64Image = function(src) {
  return INLINE_BASE64.test(src);
};
var isBlobImage = function(src) {
  return src.substr(0, 4) === "blob";
};
var isSVG = function(src) {
  return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
};
var Vector = (
  /** @class */
  function() {
    function Vector2(x, y) {
      this.type = 0;
      this.x = x;
      this.y = y;
    }
    Vector2.prototype.add = function(deltaX, deltaY) {
      return new Vector2(this.x + deltaX, this.y + deltaY);
    };
    return Vector2;
  }()
);
var lerp = function(a2, b, t2) {
  return new Vector(a2.x + (b.x - a2.x) * t2, a2.y + (b.y - a2.y) * t2);
};
var BezierCurve = (
  /** @class */
  function() {
    function BezierCurve2(start, startControl, endControl, end) {
      this.type = 1;
      this.start = start;
      this.startControl = startControl;
      this.endControl = endControl;
      this.end = end;
    }
    BezierCurve2.prototype.subdivide = function(t2, firstHalf) {
      var ab = lerp(this.start, this.startControl, t2);
      var bc = lerp(this.startControl, this.endControl, t2);
      var cd = lerp(this.endControl, this.end, t2);
      var abbc = lerp(ab, bc, t2);
      var bccd = lerp(bc, cd, t2);
      var dest = lerp(abbc, bccd, t2);
      return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
    };
    BezierCurve2.prototype.add = function(deltaX, deltaY) {
      return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
    };
    BezierCurve2.prototype.reverse = function() {
      return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
    };
    return BezierCurve2;
  }()
);
var isBezierCurve = function(path) {
  return path.type === 1;
};
var BoundCurves = (
  /** @class */
  /* @__PURE__ */ function() {
    function BoundCurves2(element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
      var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
      var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
      var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
      var factors = [];
      factors.push((tlh + trh) / bounds.width);
      factors.push((blh + brh) / bounds.width);
      factors.push((tlv + blv) / bounds.height);
      factors.push((trv + brv) / bounds.height);
      var maxFactor = Math.max.apply(Math, factors);
      if (maxFactor > 1) {
        tlh /= maxFactor;
        tlv /= maxFactor;
        trh /= maxFactor;
        trv /= maxFactor;
        brh /= maxFactor;
        brv /= maxFactor;
        blh /= maxFactor;
        blv /= maxFactor;
      }
      var topWidth = bounds.width - trh;
      var rightHeight = bounds.height - brv;
      var bottomWidth = bounds.width - brh;
      var leftHeight = bounds.height - blv;
      var borderTopWidth2 = styles.borderTopWidth;
      var borderRightWidth2 = styles.borderRightWidth;
      var borderBottomWidth2 = styles.borderBottomWidth;
      var borderLeftWidth2 = styles.borderLeftWidth;
      var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
      var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
      var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
      var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
      this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
      this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
      this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
      this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
      this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
      this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
      this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
      this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
      this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
      this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
    }
    return BoundCurves2;
  }()
);
var CORNER;
(function(CORNER2) {
  CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
  CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(x, y, r1, r2, position2) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa;
  var oy = r2 * kappa;
  var xm = x + r1;
  var ym = y + r2;
  switch (position2) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
  }
};
var calculateBorderBoxPath = function(curves) {
  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
};
var calculateContentBoxPath = function(curves) {
  return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox
  ];
};
var calculatePaddingBoxPath = function(curves) {
  return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox
  ];
};
var TransformEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function TransformEffect2(offsetX, offsetY, matrix2) {
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.matrix = matrix2;
      this.type = 0;
      this.target = 2 | 4;
    }
    return TransformEffect2;
  }()
);
var ClipEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function ClipEffect2(path, target) {
      this.path = path;
      this.target = target;
      this.type = 1;
    }
    return ClipEffect2;
  }()
);
var OpacityEffect = (
  /** @class */
  /* @__PURE__ */ function() {
    function OpacityEffect2(opacity2) {
      this.opacity = opacity2;
      this.type = 2;
      this.target = 2 | 4;
    }
    return OpacityEffect2;
  }()
);
var isTransformEffect = function(effect) {
  return effect.type === 0;
};
var isClipEffect = function(effect) {
  return effect.type === 1;
};
var isOpacityEffect = function(effect) {
  return effect.type === 2;
};
var equalPath = function(a2, b) {
  if (a2.length === b.length) {
    return a2.some(function(v, i) {
      return v === b[i];
    });
  }
  return false;
};
var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
  return path.map(function(point, index2) {
    switch (index2) {
      case 0:
        return point.add(deltaX, deltaY);
      case 1:
        return point.add(deltaX + deltaW, deltaY);
      case 2:
        return point.add(deltaX + deltaW, deltaY + deltaH);
      case 3:
        return point.add(deltaX, deltaY + deltaH);
    }
    return point;
  });
};
var StackingContext = (
  /** @class */
  /* @__PURE__ */ function() {
    function StackingContext2(container) {
      this.element = container;
      this.inlineLevel = [];
      this.nonInlineLevel = [];
      this.negativeZIndex = [];
      this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
      this.positiveZIndex = [];
      this.nonPositionedFloats = [];
      this.nonPositionedInlineLevel = [];
    }
    return StackingContext2;
  }()
);
var ElementPaint = (
  /** @class */
  function() {
    function ElementPaint2(container, parent) {
      this.container = container;
      this.parent = parent;
      this.effects = [];
      this.curves = new BoundCurves(this.container);
      if (this.container.styles.opacity < 1) {
        this.effects.push(new OpacityEffect(this.container.styles.opacity));
      }
      if (this.container.styles.transform !== null) {
        var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
        var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
        var matrix2 = this.container.styles.transform;
        this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
      }
      if (this.container.styles.overflowX !== 0) {
        var borderBox = calculateBorderBoxPath(this.curves);
        var paddingBox2 = calculatePaddingBoxPath(this.curves);
        if (equalPath(borderBox, paddingBox2)) {
          this.effects.push(new ClipEffect(
            borderBox,
            2 | 4
            /* CONTENT */
          ));
        } else {
          this.effects.push(new ClipEffect(
            borderBox,
            2
            /* BACKGROUND_BORDERS */
          ));
          this.effects.push(new ClipEffect(
            paddingBox2,
            4
            /* CONTENT */
          ));
        }
      }
    }
    ElementPaint2.prototype.getEffects = function(target) {
      var inFlow = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1;
      var parent = this.parent;
      var effects = this.effects.slice(0);
      while (parent) {
        var croplessEffects = parent.effects.filter(function(effect) {
          return !isClipEffect(effect);
        });
        if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
          effects.unshift.apply(effects, croplessEffects);
          inFlow = [
            2,
            3
            /* FIXED */
          ].indexOf(parent.container.styles.position) === -1;
          if (parent.container.styles.overflowX !== 0) {
            var borderBox = calculateBorderBoxPath(parent.curves);
            var paddingBox2 = calculatePaddingBoxPath(parent.curves);
            if (!equalPath(borderBox, paddingBox2)) {
              effects.unshift(new ClipEffect(
                paddingBox2,
                2 | 4
                /* CONTENT */
              ));
            }
          }
        } else {
          effects.unshift.apply(effects, croplessEffects);
        }
        parent = parent.parent;
      }
      return effects.filter(function(effect) {
        return contains$1(effect.target, target);
      });
    };
    return ElementPaint2;
  }()
);
var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
  parent.container.elements.forEach(function(child) {
    var treatAsRealStackingContext = contains$1(
      child.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    );
    var createsStackingContext2 = contains$1(
      child.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    );
    var paintContainer = new ElementPaint(child, parent);
    if (contains$1(
      child.styles.display,
      2048
      /* LIST_ITEM */
    )) {
      listItems.push(paintContainer);
    }
    var listOwnerItems = contains$1(
      child.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : listItems;
    if (treatAsRealStackingContext || createsStackingContext2) {
      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
      var stack2 = new StackingContext(paintContainer);
      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
        var order_1 = child.styles.zIndex.order;
        if (order_1 < 0) {
          var index_1 = 0;
          parentStack.negativeZIndex.some(function(current, i) {
            if (order_1 > current.element.container.styles.zIndex.order) {
              index_1 = i;
              return false;
            } else if (index_1 > 0) {
              return true;
            }
            return false;
          });
          parentStack.negativeZIndex.splice(index_1, 0, stack2);
        } else if (order_1 > 0) {
          var index_2 = 0;
          parentStack.positiveZIndex.some(function(current, i) {
            if (order_1 >= current.element.container.styles.zIndex.order) {
              index_2 = i + 1;
              return false;
            } else if (index_2 > 0) {
              return true;
            }
            return false;
          });
          parentStack.positiveZIndex.splice(index_2, 0, stack2);
        } else {
          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack2);
        }
      } else {
        if (child.styles.isFloating()) {
          parentStack.nonPositionedFloats.push(stack2);
        } else {
          parentStack.nonPositionedInlineLevel.push(stack2);
        }
      }
      parseStackTree(paintContainer, stack2, treatAsRealStackingContext ? stack2 : realStackingContext, listOwnerItems);
    } else {
      if (child.styles.isInlineLevel()) {
        stackingContext.inlineLevel.push(paintContainer);
      } else {
        stackingContext.nonInlineLevel.push(paintContainer);
      }
      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
    }
    if (contains$1(
      child.flags,
      8
      /* IS_LIST_OWNER */
    )) {
      processListItems(child, listOwnerItems);
    }
  });
};
var processListItems = function(owner, elements) {
  var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  for (var i = 0; i < elements.length; i++) {
    var item = elements[i];
    if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
      numbering = item.container.value;
    }
    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
    numbering += reversed ? -1 : 1;
  }
};
var parseStackingContexts = function(container) {
  var paintContainer = new ElementPaint(container, null);
  var root = new StackingContext(paintContainer);
  var listItems = [];
  parseStackTree(paintContainer, root, root, listItems);
  processListItems(paintContainer.container, listItems);
  return root;
};
var parsePathForBorder = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderDoubleOuter = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  }
};
var parsePathForBorderDoubleInner = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderStroke = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  }
};
var createStrokePathFromCurves = function(outer1, outer2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  return path;
};
var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  if (isBezierCurve(inner2)) {
    path.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path.push(inner2);
  }
  if (isBezierCurve(inner1)) {
    path.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path.push(inner1);
  }
  return path;
};
var paddingBox = function(element) {
  var bounds = element.bounds;
  var styles = element.styles;
  return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
};
var contentBox = function(element) {
  var styles = element.styles;
  var bounds = element.bounds;
  var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
  var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
  var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
  var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
  return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
};
var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
  if (backgroundOrigin2 === 0) {
    return element.bounds;
  }
  if (backgroundOrigin2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
  if (backgroundClip2 === 0) {
    return element.bounds;
  }
  if (backgroundClip2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
  return [path, offsetX, offsetY, sizeWidth, sizeHeight];
};
var isAuto = function(token) {
  return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
};
var hasIntrinsicValue = function(value) {
  return typeof value === "number";
};
var calculateBackgroundSize = function(size2, _a, bounds) {
  var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
  var first = size2[0], second = size2[1];
  if (!first) {
    return [0, 0];
  }
  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  }
  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(intrinsicProportion)) {
      var targetRatio = bounds.width / bounds.height;
      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
    }
    return [bounds.width, bounds.height];
  }
  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  if (isAuto(first) && (!second || isAuto(second))) {
    if (hasIntrinsicWidth && hasIntrinsicHeight) {
      return [intrinsicWidth, intrinsicHeight];
    }
    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
      return [bounds.width, bounds.height];
    }
    if (hasIntrinsicDimensions && hasIntrinsicProportion) {
      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
      return [width_1, height_1];
    }
    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
    return [width_2, height_2];
  }
  if (hasIntrinsicProportion) {
    var width_3 = 0;
    var height_3 = 0;
    if (isLengthPercentage(first)) {
      width_3 = getAbsoluteValue(first, bounds.width);
    } else if (isLengthPercentage(second)) {
      height_3 = getAbsoluteValue(second, bounds.height);
    }
    if (isAuto(first)) {
      width_3 = height_3 * intrinsicProportion;
    } else if (!second || isAuto(second)) {
      height_3 = width_3 / intrinsicProportion;
    }
    return [width_3, height_3];
  }
  var width = null;
  var height = null;
  if (isLengthPercentage(first)) {
    width = getAbsoluteValue(first, bounds.width);
  } else if (second && isLengthPercentage(second)) {
    height = getAbsoluteValue(second, bounds.height);
  }
  if (width !== null && (!second || isAuto(second))) {
    height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
  }
  if (height !== null && isAuto(first)) {
    width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
  }
  if (width !== null && height !== null) {
    return [width, height];
  }
  throw new Error("Unable to calculate background-size for element");
};
var getBackgroundValueForIndex = function(values, index2) {
  var value = values[index2];
  if (typeof value === "undefined") {
    return values[0];
  }
  return value;
};
var calculateBackgroundRepeatPath = function(repeat2, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
  var x = _a[0], y = _a[1];
  var width = _b[0], height = _b[1];
  switch (repeat2) {
    case 2:
      return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
      ];
    case 3:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
      ];
    case 1:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
      ];
    default:
      return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
      ];
  }
};
var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var SAMPLE_TEXT = "Hidden Text";
var FontMetrics = (
  /** @class */
  function() {
    function FontMetrics2(document2) {
      this._data = {};
      this._document = document2;
    }
    FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
      var container = this._document.createElement("div");
      var img = this._document.createElement("img");
      var span = this._document.createElement("span");
      var body = this._document.body;
      container.style.visibility = "hidden";
      container.style.fontFamily = fontFamily2;
      container.style.fontSize = fontSize2;
      container.style.margin = "0";
      container.style.padding = "0";
      container.style.whiteSpace = "nowrap";
      body.appendChild(container);
      img.src = SMALL_IMAGE;
      img.width = 1;
      img.height = 1;
      img.style.margin = "0";
      img.style.padding = "0";
      img.style.verticalAlign = "baseline";
      span.style.fontFamily = fontFamily2;
      span.style.fontSize = fontSize2;
      span.style.margin = "0";
      span.style.padding = "0";
      span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.appendChild(span);
      container.appendChild(img);
      var baseline = img.offsetTop - span.offsetTop + 2;
      container.removeChild(span);
      container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.style.lineHeight = "normal";
      img.style.verticalAlign = "super";
      var middle = img.offsetTop - container.offsetTop + 2;
      body.removeChild(container);
      return { baseline, middle };
    };
    FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
      var key = fontFamily2 + " " + fontSize2;
      if (typeof this._data[key] === "undefined") {
        this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
      }
      return this._data[key];
    };
    return FontMetrics2;
  }()
);
var Renderer = (
  /** @class */
  /* @__PURE__ */ function() {
    function Renderer2(context, options) {
      this.context = context;
      this.options = options;
    }
    return Renderer2;
  }()
);
var MASK_OFFSET = 1e4;
var CanvasRenderer$1 = (
  /** @class */
  function(_super) {
    __extends(CanvasRenderer2, _super);
    function CanvasRenderer2(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this._activeEffects = [];
      _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
      _this.ctx = _this.canvas.getContext("2d");
      if (!options.canvas) {
        _this.canvas.width = Math.floor(options.width * options.scale);
        _this.canvas.height = Math.floor(options.height * options.scale);
        _this.canvas.style.width = options.width + "px";
        _this.canvas.style.height = options.height + "px";
      }
      _this.fontMetrics = new FontMetrics(document);
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.ctx.textBaseline = "bottom";
      _this._activeEffects = [];
      _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
      return _this;
    }
    CanvasRenderer2.prototype.applyEffects = function(effects) {
      var _this = this;
      while (this._activeEffects.length) {
        this.popEffect();
      }
      effects.forEach(function(effect) {
        return _this.applyEffect(effect);
      });
    };
    CanvasRenderer2.prototype.applyEffect = function(effect) {
      this.ctx.save();
      if (isOpacityEffect(effect)) {
        this.ctx.globalAlpha = effect.opacity;
      }
      if (isTransformEffect(effect)) {
        this.ctx.translate(effect.offsetX, effect.offsetY);
        this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
        this.ctx.translate(-effect.offsetX, -effect.offsetY);
      }
      if (isClipEffect(effect)) {
        this.path(effect.path);
        this.ctx.clip();
      }
      this._activeEffects.push(effect);
    };
    CanvasRenderer2.prototype.popEffect = function() {
      this._activeEffects.pop();
      this.ctx.restore();
    };
    CanvasRenderer2.prototype.renderStack = function(stack2) {
      return __awaiter(this, void 0, void 0, function() {
        var styles;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              styles = stack2.element.container.styles;
              if (!styles.isVisible())
                return [3, 2];
              return [4, this.renderStackContent(stack2)];
            case 1:
              _a.sent();
              _a.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderNode = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (contains$1(
                paint.container.flags,
                16
                /* DEBUG_RENDER */
              )) {
                debugger;
              }
              if (!paint.container.styles.isVisible())
                return [3, 3];
              return [4, this.renderNodeBackgroundAndBorders(paint)];
            case 1:
              _a.sent();
              return [4, this.renderNodeContent(paint)];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {
      var _this = this;
      if (letterSpacing2 === 0) {
        this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
      } else {
        var letters = segmentGraphemes(text2.text);
        letters.reduce(function(left, letter2) {
          _this.ctx.fillText(letter2, left, text2.bounds.top + baseline);
          return left + _this.ctx.measureText(letter2).width;
        }, text2.bounds.left);
      }
    };
    CanvasRenderer2.prototype.createFontStyle = function(styles) {
      var fontVariant2 = styles.fontVariant.filter(function(variant) {
        return variant === "normal" || variant === "small-caps";
      }).join("");
      var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
      var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
      return [
        [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
        fontFamily2,
        fontSize2
      ];
    };
    CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {
      return __awaiter(this, void 0, void 0, function() {
        var _a, font, fontFamily2, fontSize2, _b, baseline, middle, paintOrder2;
        var _this = this;
        return __generator(this, function(_c) {
          _a = this.createFontStyle(styles), font = _a[0], fontFamily2 = _a[1], fontSize2 = _a[2];
          this.ctx.font = font;
          this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "alphabetic";
          _b = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b.baseline, middle = _b.middle;
          paintOrder2 = styles.paintOrder;
          text2.textBounds.forEach(function(text3) {
            paintOrder2.forEach(function(paintOrderLayer) {
              switch (paintOrderLayer) {
                case 0:
                  _this.ctx.fillStyle = asString(styles.color);
                  _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                  var textShadows = styles.textShadow;
                  if (textShadows.length && text3.text.trim().length) {
                    textShadows.slice(0).reverse().forEach(function(textShadow2) {
                      _this.ctx.shadowColor = asString(textShadow2.color);
                      _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                      _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                      _this.ctx.shadowBlur = textShadow2.blur.number;
                      _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                    });
                    _this.ctx.shadowColor = "";
                    _this.ctx.shadowOffsetX = 0;
                    _this.ctx.shadowOffsetY = 0;
                    _this.ctx.shadowBlur = 0;
                  }
                  if (styles.textDecorationLine.length) {
                    _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                    styles.textDecorationLine.forEach(function(textDecorationLine2) {
                      switch (textDecorationLine2) {
                        case 1:
                          _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);
                          break;
                        case 2:
                          _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);
                          break;
                        case 3:
                          _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);
                          break;
                      }
                    });
                  }
                  break;
                case 1:
                  if (styles.webkitTextStrokeWidth && text3.text.trim().length) {
                    _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                    _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                    _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                    _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);
                  }
                  _this.ctx.strokeStyle = "";
                  _this.ctx.lineWidth = 0;
                  _this.ctx.lineJoin = "miter";
                  break;
              }
            });
          });
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
      if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
        var box = contentBox(container);
        var path = calculatePaddingBoxPath(curves);
        this.path(path);
        this.ctx.save();
        this.ctx.clip();
        this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
        this.ctx.restore();
      }
    };
    CanvasRenderer2.prototype.renderNodeContent = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        var container, curves, styles, _i, _a, child, image2, image2, iframeRenderer, canvas2, size2, _b, fontFamily2, fontSize2, baseline, bounds, x, textBounds, img, image2, url2, fontFamily2, bounds;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              this.applyEffects(paint.getEffects(
                4
                /* CONTENT */
              ));
              container = paint.container;
              curves = paint.curves;
              styles = container.styles;
              _i = 0, _a = container.textNodes;
              _c.label = 1;
            case 1:
              if (!(_i < _a.length))
                return [3, 4];
              child = _a[_i];
              return [4, this.renderTextNode(child, styles)];
            case 2:
              _c.sent();
              _c.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              if (!(container instanceof ImageElementContainer))
                return [3, 8];
              _c.label = 5;
            case 5:
              _c.trys.push([5, 7, , 8]);
              return [4, this.context.cache.match(container.src)];
            case 6:
              image2 = _c.sent();
              this.renderReplacedElement(container, curves, image2);
              return [3, 8];
            case 7:
              _c.sent();
              this.context.logger.error("Error loading image " + container.src);
              return [3, 8];
            case 8:
              if (container instanceof CanvasElementContainer) {
                this.renderReplacedElement(container, curves, container.canvas);
              }
              if (!(container instanceof SVGElementContainer))
                return [3, 12];
              _c.label = 9;
            case 9:
              _c.trys.push([9, 11, , 12]);
              return [4, this.context.cache.match(container.svg)];
            case 10:
              image2 = _c.sent();
              this.renderReplacedElement(container, curves, image2);
              return [3, 12];
            case 11:
              _c.sent();
              this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
              return [3, 12];
            case 12:
              if (!(container instanceof IFrameElementContainer && container.tree))
                return [3, 14];
              iframeRenderer = new CanvasRenderer2(this.context, {
                scale: this.options.scale,
                backgroundColor: container.backgroundColor,
                x: 0,
                y: 0,
                width: container.width,
                height: container.height
              });
              return [4, iframeRenderer.render(container.tree)];
            case 13:
              canvas2 = _c.sent();
              if (container.width && container.height) {
                this.ctx.drawImage(canvas2, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
              }
              _c.label = 14;
            case 14:
              if (container instanceof InputElementContainer) {
                size2 = Math.min(container.bounds.width, container.bounds.height);
                if (container.type === CHECKBOX) {
                  if (container.checked) {
                    this.ctx.save();
                    this.path([
                      new Vector(container.bounds.left + size2 * 0.39363, container.bounds.top + size2 * 0.79),
                      new Vector(container.bounds.left + size2 * 0.16, container.bounds.top + size2 * 0.5549),
                      new Vector(container.bounds.left + size2 * 0.27347, container.bounds.top + size2 * 0.44071),
                      new Vector(container.bounds.left + size2 * 0.39694, container.bounds.top + size2 * 0.5649),
                      new Vector(container.bounds.left + size2 * 0.72983, container.bounds.top + size2 * 0.23),
                      new Vector(container.bounds.left + size2 * 0.84, container.bounds.top + size2 * 0.34085),
                      new Vector(container.bounds.left + size2 * 0.39363, container.bounds.top + size2 * 0.79)
                    ]);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                } else if (container.type === RADIO) {
                  if (container.checked) {
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(container.bounds.left + size2 / 2, container.bounds.top + size2 / 2, size2 / 4, 0, Math.PI * 2, true);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                }
              }
              if (isTextInputElement(container) && container.value.length) {
                _b = this.createFontStyle(styles), fontFamily2 = _b[0], fontSize2 = _b[1];
                baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                this.ctx.font = fontFamily2;
                this.ctx.fillStyle = asString(styles.color);
                this.ctx.textBaseline = "alphabetic";
                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                bounds = contentBox(container);
                x = 0;
                switch (container.styles.textAlign) {
                  case 1:
                    x += bounds.width / 2;
                    break;
                  case 2:
                    x += bounds.width;
                    break;
                }
                textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                this.ctx.save();
                this.path([
                  new Vector(bounds.left, bounds.top),
                  new Vector(bounds.left + bounds.width, bounds.top),
                  new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                  new Vector(bounds.left, bounds.top + bounds.height)
                ]);
                this.ctx.clip();
                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                this.ctx.restore();
                this.ctx.textBaseline = "alphabetic";
                this.ctx.textAlign = "left";
              }
              if (!contains$1(
                container.styles.display,
                2048
                /* LIST_ITEM */
              ))
                return [3, 20];
              if (!(container.styles.listStyleImage !== null))
                return [3, 19];
              img = container.styles.listStyleImage;
              if (!(img.type === 0))
                return [3, 18];
              image2 = void 0;
              url2 = img.url;
              _c.label = 15;
            case 15:
              _c.trys.push([15, 17, , 18]);
              return [4, this.context.cache.match(url2)];
            case 16:
              image2 = _c.sent();
              this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
              return [3, 18];
            case 17:
              _c.sent();
              this.context.logger.error("Error loading list-style-image " + url2);
              return [3, 18];
            case 18:
              return [3, 20];
            case 19:
              if (paint.listValue && container.styles.listStyleType !== -1) {
                fontFamily2 = this.createFontStyle(styles)[0];
                this.ctx.font = fontFamily2;
                this.ctx.fillStyle = asString(styles.color);
                this.ctx.textBaseline = "middle";
                this.ctx.textAlign = "right";
                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                this.ctx.textBaseline = "bottom";
                this.ctx.textAlign = "left";
              }
              _c.label = 20;
            case 20:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderStackContent = function(stack2) {
      return __awaiter(this, void 0, void 0, function() {
        var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
        return __generator(this, function(_p) {
          switch (_p.label) {
            case 0:
              if (contains$1(
                stack2.element.container.flags,
                16
                /* DEBUG_RENDER */
              )) {
                debugger;
              }
              return [4, this.renderNodeBackgroundAndBorders(stack2.element)];
            case 1:
              _p.sent();
              _i = 0, _a = stack2.negativeZIndex;
              _p.label = 2;
            case 2:
              if (!(_i < _a.length))
                return [3, 5];
              child = _a[_i];
              return [4, this.renderStack(child)];
            case 3:
              _p.sent();
              _p.label = 4;
            case 4:
              _i++;
              return [3, 2];
            case 5:
              return [4, this.renderNodeContent(stack2.element)];
            case 6:
              _p.sent();
              _b = 0, _c = stack2.nonInlineLevel;
              _p.label = 7;
            case 7:
              if (!(_b < _c.length))
                return [3, 10];
              child = _c[_b];
              return [4, this.renderNode(child)];
            case 8:
              _p.sent();
              _p.label = 9;
            case 9:
              _b++;
              return [3, 7];
            case 10:
              _d = 0, _e = stack2.nonPositionedFloats;
              _p.label = 11;
            case 11:
              if (!(_d < _e.length))
                return [3, 14];
              child = _e[_d];
              return [4, this.renderStack(child)];
            case 12:
              _p.sent();
              _p.label = 13;
            case 13:
              _d++;
              return [3, 11];
            case 14:
              _f = 0, _g = stack2.nonPositionedInlineLevel;
              _p.label = 15;
            case 15:
              if (!(_f < _g.length))
                return [3, 18];
              child = _g[_f];
              return [4, this.renderStack(child)];
            case 16:
              _p.sent();
              _p.label = 17;
            case 17:
              _f++;
              return [3, 15];
            case 18:
              _h = 0, _j = stack2.inlineLevel;
              _p.label = 19;
            case 19:
              if (!(_h < _j.length))
                return [3, 22];
              child = _j[_h];
              return [4, this.renderNode(child)];
            case 20:
              _p.sent();
              _p.label = 21;
            case 21:
              _h++;
              return [3, 19];
            case 22:
              _k = 0, _l = stack2.zeroOrAutoZIndexOrTransformedOrOpacity;
              _p.label = 23;
            case 23:
              if (!(_k < _l.length))
                return [3, 26];
              child = _l[_k];
              return [4, this.renderStack(child)];
            case 24:
              _p.sent();
              _p.label = 25;
            case 25:
              _k++;
              return [3, 23];
            case 26:
              _m = 0, _o = stack2.positiveZIndex;
              _p.label = 27;
            case 27:
              if (!(_m < _o.length))
                return [3, 30];
              child = _o[_m];
              return [4, this.renderStack(child)];
            case 28:
              _p.sent();
              _p.label = 29;
            case 29:
              _m++;
              return [3, 27];
            case 30:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.mask = function(paths) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0);
      this.ctx.lineTo(this.canvas.width, 0);
      this.ctx.lineTo(this.canvas.width, this.canvas.height);
      this.ctx.lineTo(0, this.canvas.height);
      this.ctx.lineTo(0, 0);
      this.formatPath(paths.slice(0).reverse());
      this.ctx.closePath();
    };
    CanvasRenderer2.prototype.path = function(paths) {
      this.ctx.beginPath();
      this.formatPath(paths);
      this.ctx.closePath();
    };
    CanvasRenderer2.prototype.formatPath = function(paths) {
      var _this = this;
      paths.forEach(function(point, index2) {
        var start = isBezierCurve(point) ? point.start : point;
        if (index2 === 0) {
          _this.ctx.moveTo(start.x, start.y);
        } else {
          _this.ctx.lineTo(start.x, start.y);
        }
        if (isBezierCurve(point)) {
          _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
        }
      });
    };
    CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
      this.path(path);
      this.ctx.fillStyle = pattern;
      this.ctx.translate(offsetX, offsetY);
      this.ctx.fill();
      this.ctx.translate(-offsetX, -offsetY);
    };
    CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
      var _a;
      if (image2.width === width && image2.height === height) {
        return image2;
      }
      var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
      var canvas2 = ownerDocument.createElement("canvas");
      canvas2.width = Math.max(1, width);
      canvas2.height = Math.max(1, height);
      var ctx = canvas2.getContext("2d");
      ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
      return canvas2;
    };
    CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
      return __awaiter(this, void 0, void 0, function() {
        var index2, _loop_1, this_1, _i, _a, backgroundImage2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              index2 = container.styles.backgroundImage.length - 1;
              _loop_1 = function(backgroundImage3) {
                var image2, url2, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas2, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x, y, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                return __generator(this, function(_h) {
                  switch (_h.label) {
                    case 0:
                      if (!(backgroundImage3.type === 0))
                        return [3, 5];
                      image2 = void 0;
                      url2 = backgroundImage3.url;
                      _h.label = 1;
                    case 1:
                      _h.trys.push([1, 3, , 4]);
                      return [4, this_1.context.cache.match(url2)];
                    case 2:
                      image2 = _h.sent();
                      return [3, 4];
                    case 3:
                      _h.sent();
                      this_1.context.logger.error("Error loading background-image " + url2);
                      return [3, 4];
                    case 4:
                      if (image2) {
                        _c = calculateBackgroundRendering(container, index2, [
                          image2.width,
                          image2.height,
                          image2.width / image2.height
                        ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                        pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                        this_1.renderRepeat(path, pattern, x, y);
                      }
                      return [3, 6];
                    case 5:
                      if (isLinearGradient(backgroundImage3)) {
                        _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                        _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                        canvas2 = document.createElement("canvas");
                        canvas2.width = width;
                        canvas2.height = height;
                        ctx = canvas2.getContext("2d");
                        gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                        processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                          return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        ctx.fillStyle = gradient_1;
                        ctx.fillRect(0, 0, width, height);
                        if (width > 0 && height > 0) {
                          pattern = this_1.ctx.createPattern(canvas2, "repeat");
                          this_1.renderRepeat(path, pattern, x, y);
                        }
                      } else if (isRadialGradient(backgroundImage3)) {
                        _f = calculateBackgroundRendering(container, index2, [
                          null,
                          null,
                          null
                        ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                        position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                        x = getAbsoluteValue(position2[0], width);
                        y = getAbsoluteValue(position2[position2.length - 1], height);
                        _g = calculateRadius(backgroundImage3, x, y, width, height), rx = _g[0], ry = _g[1];
                        if (rx > 0 && ry > 0) {
                          radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                          processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                            return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                          });
                          this_1.path(path);
                          this_1.ctx.fillStyle = radialGradient_1;
                          if (rx !== ry) {
                            midX = container.bounds.left + 0.5 * container.bounds.width;
                            midY = container.bounds.top + 0.5 * container.bounds.height;
                            f2 = ry / rx;
                            invF = 1 / f2;
                            this_1.ctx.save();
                            this_1.ctx.translate(midX, midY);
                            this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                            this_1.ctx.translate(-midX, -midY);
                            this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                            this_1.ctx.restore();
                          } else {
                            this_1.ctx.fill();
                          }
                        }
                      }
                      _h.label = 6;
                    case 6:
                      index2--;
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              };
              this_1 = this;
              _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
              _b.label = 1;
            case 1:
              if (!(_i < _a.length))
                return [3, 4];
              backgroundImage2 = _a[_i];
              return [5, _loop_1(backgroundImage2)];
            case 2:
              _b.sent();
              _b.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          this.path(parsePathForBorder(curvePoints, side));
          this.ctx.fillStyle = asString(color2);
          this.ctx.fill();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function() {
        var outerPaths, innerPaths;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!(width < 3))
                return [3, 2];
              return [4, this.renderSolidBorder(color2, side, curvePoints)];
            case 1:
              _a.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
              this.path(outerPaths);
              this.ctx.fillStyle = asString(color2);
              this.ctx.fill();
              innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
              this.path(innerPaths);
              this.ctx.fill();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this.applyEffects(paint.getEffects(
                2
                /* BACKGROUND_BORDERS */
              ));
              styles = paint.container.styles;
              hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
              borders = [
                { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
              ];
              backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
              if (!(hasBackground || styles.boxShadow.length))
                return [3, 2];
              this.ctx.save();
              this.path(backgroundPaintingArea);
              this.ctx.clip();
              if (!isTransparent(styles.backgroundColor)) {
                this.ctx.fillStyle = asString(styles.backgroundColor);
                this.ctx.fill();
              }
              return [4, this.renderBackgroundImage(paint.container)];
            case 1:
              _a.sent();
              this.ctx.restore();
              styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                _this.ctx.save();
                var borderBoxArea = calculateBorderBoxPath(paint.curves);
                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                if (shadow.inset) {
                  _this.path(borderBoxArea);
                  _this.ctx.clip();
                  _this.mask(shadowPaintingArea);
                } else {
                  _this.mask(borderBoxArea);
                  _this.ctx.clip();
                  _this.path(shadowPaintingArea);
                }
                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                _this.ctx.shadowOffsetY = shadow.offsetY.number;
                _this.ctx.shadowColor = asString(shadow.color);
                _this.ctx.shadowBlur = shadow.blur.number;
                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                _this.ctx.fill();
                _this.ctx.restore();
              });
              _a.label = 2;
            case 2:
              side = 0;
              _i = 0, borders_1 = borders;
              _a.label = 3;
            case 3:
              if (!(_i < borders_1.length))
                return [3, 13];
              border = borders_1[_i];
              if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
                return [3, 11];
              if (!(border.style === 2))
                return [3, 5];
              return [4, this.renderDashedDottedBorder(
                border.color,
                border.width,
                side,
                paint.curves,
                2
                /* DASHED */
              )];
            case 4:
              _a.sent();
              return [3, 11];
            case 5:
              if (!(border.style === 3))
                return [3, 7];
              return [4, this.renderDashedDottedBorder(
                border.color,
                border.width,
                side,
                paint.curves,
                3
                /* DOTTED */
              )];
            case 6:
              _a.sent();
              return [3, 11];
            case 7:
              if (!(border.style === 4))
                return [3, 9];
              return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
            case 8:
              _a.sent();
              return [3, 11];
            case 9:
              return [4, this.renderSolidBorder(border.color, side, paint.curves)];
            case 10:
              _a.sent();
              _a.label = 11;
            case 11:
              side++;
              _a.label = 12;
            case 12:
              _i++;
              return [3, 3];
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
      return __awaiter(this, void 0, void 0, function() {
        var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
        return __generator(this, function(_a) {
          this.ctx.save();
          strokePaths = parsePathForBorderStroke(curvePoints, side);
          boxPaths = parsePathForBorder(curvePoints, side);
          if (style === 2) {
            this.path(boxPaths);
            this.ctx.clip();
          }
          if (isBezierCurve(boxPaths[0])) {
            startX = boxPaths[0].start.x;
            startY = boxPaths[0].start.y;
          } else {
            startX = boxPaths[0].x;
            startY = boxPaths[0].y;
          }
          if (isBezierCurve(boxPaths[1])) {
            endX = boxPaths[1].end.x;
            endY = boxPaths[1].end.y;
          } else {
            endX = boxPaths[1].x;
            endY = boxPaths[1].y;
          }
          if (side === 0 || side === 2) {
            length = Math.abs(startX - endX);
          } else {
            length = Math.abs(startY - endY);
          }
          this.ctx.beginPath();
          if (style === 3) {
            this.formatPath(strokePaths);
          } else {
            this.formatPath(boxPaths.slice(0, 2));
          }
          dashLength = width < 3 ? width * 3 : width * 2;
          spaceLength = width < 3 ? width * 2 : width;
          if (style === 3) {
            dashLength = width;
            spaceLength = width;
          }
          useLineDash = true;
          if (length <= dashLength * 2) {
            useLineDash = false;
          } else if (length <= dashLength * 2 + spaceLength) {
            multiplier = length / (2 * dashLength + spaceLength);
            dashLength *= multiplier;
            spaceLength *= multiplier;
          } else {
            numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
            minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
            maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
            spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
          }
          if (useLineDash) {
            if (style === 3) {
              this.ctx.setLineDash([0, dashLength + spaceLength]);
            } else {
              this.ctx.setLineDash([dashLength, spaceLength]);
            }
          }
          if (style === 3) {
            this.ctx.lineCap = "round";
            this.ctx.lineWidth = width;
          } else {
            this.ctx.lineWidth = width * 2 + 1.1;
          }
          this.ctx.strokeStyle = asString(color2);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
          if (style === 2) {
            if (isBezierCurve(boxPaths[0])) {
              path1 = boxPaths[3];
              path2 = boxPaths[0];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
            if (isBezierCurve(boxPaths[1])) {
              path1 = boxPaths[1];
              path2 = boxPaths[2];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
          }
          this.ctx.restore();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.render = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var stack2;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
              }
              stack2 = parseStackingContexts(element);
              return [4, this.renderStack(stack2)];
            case 1:
              _a.sent();
              this.applyEffects([]);
              return [2, this.canvas];
          }
        });
      });
    };
    return CanvasRenderer2;
  }(Renderer)
);
var isTextInputElement = function(container) {
  if (container instanceof TextareaElementContainer) {
    return true;
  } else if (container instanceof SelectElementContainer) {
    return true;
  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
    return true;
  }
  return false;
};
var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
  switch (clip) {
    case 0:
      return calculateBorderBoxPath(curves);
    case 2:
      return calculateContentBoxPath(curves);
    case 1:
    default:
      return calculatePaddingBoxPath(curves);
  }
};
var canvasTextAlign = function(textAlign2) {
  switch (textAlign2) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var iOSBrokenFonts = ["-apple-system", "system-ui"];
var fixIOSSystemFonts = function(fontFamilies) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
    return iOSBrokenFonts.indexOf(fontFamily2) === -1;
  }) : fontFamilies;
};
var ForeignObjectRenderer = (
  /** @class */
  function(_super) {
    __extends(ForeignObjectRenderer2, _super);
    function ForeignObjectRenderer2(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
      _this.ctx = _this.canvas.getContext("2d");
      _this.options = options;
      _this.canvas.width = Math.floor(options.width * options.scale);
      _this.canvas.height = Math.floor(options.height * options.scale);
      _this.canvas.style.width = options.width + "px";
      _this.canvas.style.height = options.height + "px";
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
      return _this;
    }
    ForeignObjectRenderer2.prototype.render = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var svg, img;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
              return [4, loadSerializedSVG(svg)];
            case 1:
              img = _a.sent();
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
              }
              this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
              return [2, this.canvas];
          }
        });
      });
    };
    return ForeignObjectRenderer2;
  }(Renderer)
);
var loadSerializedSVG = function(svg) {
  return new Promise(function(resolve2, reject) {
    var img = new Image();
    img.onload = function() {
      resolve2(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
var Logger = (
  /** @class */
  function() {
    function Logger2(_a) {
      var id = _a.id, enabled2 = _a.enabled;
      this.id = id;
      this.enabled = enabled2;
      this.start = Date.now();
    }
    Logger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
          console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.prototype.getTime = function() {
      return Date.now() - this.start;
    };
    Logger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
          console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        }
      }
    };
    Logger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
          console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
          console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.instances = {};
    return Logger2;
  }()
);
var Context = (
  /** @class */
  function() {
    function Context2(options, windowBounds) {
      var _a;
      this.windowBounds = windowBounds;
      this.instanceName = "#" + Context2.instanceCount++;
      this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
      this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);
    }
    Context2.instanceCount = 1;
    return Context2;
  }()
);
var html2canvas = function(element, options) {
  if (options === void 0) {
    options = {};
  }
  return renderElement(element, options);
};
if (typeof window !== "undefined") {
  CacheStorage.setContext(window);
}
var renderElement = function(element, opts) {
  return __awaiter(void 0, void 0, void 0, function() {
    var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor2, renderOptions, canvas2, renderer, root, renderer;
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    return __generator(this, function(_u) {
      switch (_u.label) {
        case 0:
          if (!element || typeof element !== "object") {
            return [2, Promise.reject("Invalid element provided as first argument")];
          }
          ownerDocument = element.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Element is not attached to a Document");
          }
          defaultView = ownerDocument.defaultView;
          if (!defaultView) {
            throw new Error("Document is not attached to a Window");
          }
          resourceOptions = {
            allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
            imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
            proxy: opts.proxy,
            useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
          };
          contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
          windowOptions = {
            windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
            windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
            scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
            scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
          };
          windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
          context = new Context(contextOptions, windowBounds);
          foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
          cloneOptions = {
            allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
            onclone: opts.onclone,
            ignoreElements: opts.ignoreElements,
            inlineImages: foreignObjectRendering,
            copyStyles: foreignObjectRendering
          };
          context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
          documentCloner = new DocumentCloner(context, element, cloneOptions);
          clonedElement = documentCloner.clonedReferenceElement;
          if (!clonedElement) {
            return [2, Promise.reject("Unable to find element in cloned iframe")];
          }
          return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
        case 1:
          container = _u.sent();
          _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
          backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
          renderOptions = {
            canvas: opts.canvas,
            backgroundColor: backgroundColor2,
            scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
            x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
            y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
            width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
            height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
          };
          if (!foreignObjectRendering)
            return [3, 3];
          context.logger.debug("Document cloned, using foreign object rendering");
          renderer = new ForeignObjectRenderer(context, renderOptions);
          return [4, renderer.render(clonedElement)];
        case 2:
          canvas2 = _u.sent();
          return [3, 5];
        case 3:
          context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
          context.logger.debug("Starting DOM parsing");
          root = parseTree(context, clonedElement);
          if (backgroundColor2 === root.styles.backgroundColor) {
            root.styles.backgroundColor = COLORS.TRANSPARENT;
          }
          context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
          renderer = new CanvasRenderer$1(context, renderOptions);
          return [4, renderer.render(root)];
        case 4:
          canvas2 = _u.sent();
          _u.label = 5;
        case 5:
          if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
            if (!DocumentCloner.destroy(container)) {
              context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
            }
          }
          context.logger.debug("Finished rendering");
          return [2, canvas2];
      }
    });
  });
};
var parseBackgroundColor = function(context, element, backgroundColorOverride) {
  var ownerDocument = element.ownerDocument;
  var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
  var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
  var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
  return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var mixin = {
  // 
  props: {
    // 
    customStyle: {
      type: [Object, String],
      default: () => ({})
    },
    customClass: {
      type: String,
      default: ""
    },
    // 
    url: {
      type: String,
      default: ""
    },
    // 
    linkType: {
      type: String,
      default: "navigateTo"
    }
  },
  data() {
    return {};
  },
  onLoad() {
    this.$u.getRect = this.$uGetRect;
  },
  created() {
    this.$u.getRect = this.$uGetRect;
  },
  computed: {
    // 2.x$uuniuni.$u.xxx
    // computedthis.$ujsuni.$u.xxx
    // nvue$unvueprops
    $u() {
      return index$2.$u.deepMerge(index$2.$u, {
        props: void 0,
        http: void 0,
        mixin: void 0
      });
    },
    /**
     * bem
     * H5nvueclass:class="[bem()]"
     * ['a', 'b', 'c']'a b c'
     * @param {String} name 
     * @param {Array} fixed 
     * @param {Array} change truefalse
     * @returns {Array|string}
     */
    bem() {
      return function(name, fixed, change) {
        const prefix = `u-${name}--`;
        const classes = {};
        if (fixed) {
          fixed.map((item) => {
            classes[prefix + this[item]] = true;
          });
        }
        if (change) {
          change.map((item) => {
            this[item] ? classes[prefix + item] = this[item] : delete classes[prefix + item];
          });
        }
        return Object.keys(classes);
      };
    }
  },
  methods: {
    // 
    openPage(urlKey = "url") {
      const url2 = this[urlKey];
      if (url2) {
        index$2[this.linkType]({
          url: url2
        });
      }
    },
    // 
    // bug(2020-07-21)
    // view
    $uGetRect(selector, all) {
      return new Promise((resolve2) => {
        index$2.createSelectorQuery().in(this)[all ? "selectAll" : "select"](selector).boundingClientRect((rect) => {
          if (all && Array.isArray(rect) && rect.length) {
            resolve2(rect);
          }
          if (!all && rect) {
            resolve2(rect);
          }
        }).exec();
      });
    },
    getParentData(parentName = "") {
      if (!this.parent)
        this.parent = {};
      this.parent = index$2.$u.$parent.call(this, parentName);
      if (this.parent.children) {
        this.parent.children.indexOf(this) === -1 && this.parent.children.push(this);
      }
      if (this.parent && this.parentData) {
        Object.keys(this.parentData).map((key) => {
          this.parentData[key] = this.parent[key];
        });
      }
    },
    // 
    preventEvent(e2) {
      e2 && typeof e2.stopPropagation === "function" && e2.stopPropagation();
    },
    // 
    noop(e2) {
      this.preventEvent(e2);
    }
  },
  onReachBottom() {
    index$2.$emit("uOnReachBottom");
  },
  beforeDestroy() {
    if (this.parent && index$2.$u.test.array(this.parent.children)) {
      const childrenList = this.parent.children;
      childrenList.map((child, index2) => {
        if (child === this) {
          childrenList.splice(index2, 1);
        }
      });
    }
  }
};
const mixin$1 = /* @__PURE__ */ getDefaultExportFromCjs(mixin);
const mpMixin = {
  // Vueflex
  options: {
    virtualHost: true
  }
};
const { toString: toString$1 } = Object.prototype;
function isArray(val) {
  return toString$1.call(val) === "[object Array]";
}
function isObject(val) {
  return val !== null && typeof val === "object";
}
function isDate(val) {
  return toString$1.call(val) === "[object Date]";
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function deepMerge$1() {
  const result = {};
  function assignValue(val, key) {
    if (typeof result[key] === "object" && typeof val === "object") {
      result[key] = deepMerge$1(result[key], val);
    } else if (typeof val === "object") {
      result[key] = deepMerge$1({}, val);
    } else {
      result[key] = val;
    }
  }
  for (let i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params) {
  if (!params) {
    return url2;
  }
  let serializedParams;
  if (isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    const parts = [];
    forEach(params, (val, key) => {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (isArray(val)) {
        key = `${key}[]`;
      } else {
        val = [val];
      }
      forEach(val, (v) => {
        if (isDate(v)) {
          v = v.toISOString();
        } else if (isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(`${encode(key)}=${encode(v)}`);
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? `${baseURL.replace(/\/+$/, "")}/${relativeURL.replace(/^\/+/, "")}` : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
function settle(resolve2, reject, response) {
  const { validateStatus: validateStatus2 } = response.config;
  const status = response.statusCode;
  if (status && (!validateStatus2 || validateStatus2(status))) {
    resolve2(response);
  } else {
    reject(response);
  }
}
const mergeKeys$1 = (keys, config2) => {
  const config3 = {};
  keys.forEach((prop) => {
    if (!isUndefined(config2[prop])) {
      config3[prop] = config2[prop];
    }
  });
  return config3;
};
const adapter = (config2) => new Promise((resolve2, reject) => {
  const fullPath = buildURL(buildFullPath(config2.baseURL, config2.url), config2.params);
  const _config = {
    url: fullPath,
    header: config2.header,
    complete: (response) => {
      config2.fullPath = fullPath;
      response.config = config2;
      try {
        if (typeof response.data === "string") {
          response.data = JSON.parse(response.data);
        }
      } catch (e2) {
      }
      settle(resolve2, reject, response);
    }
  };
  let requestTask;
  if (config2.method === "UPLOAD") {
    delete _config.header["content-type"];
    delete _config.header["Content-Type"];
    const otherConfig = {
      filePath: config2.filePath,
      name: config2.name
    };
    const optionalKeys = [
      "formData"
    ];
    requestTask = index$2.uploadFile({ ..._config, ...otherConfig, ...mergeKeys$1(optionalKeys, config2) });
  } else if (config2.method === "DOWNLOAD") {
    requestTask = index$2.downloadFile(_config);
  } else {
    const optionalKeys = [
      "data",
      "method",
      "timeout",
      "dataType",
      "responseType"
    ];
    requestTask = index$2.request({ ..._config, ...mergeKeys$1(optionalKeys, config2) });
  }
  if (config2.getTask) {
    config2.getTask(requestTask, config2);
  }
});
const dispatchRequest = (config2) => adapter(config2);
function InterceptorManager() {
  this.handlers = [];
}
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled,
    rejected
  });
  return this.handlers.length - 1;
};
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager.prototype.forEach = function forEach2(fn) {
  this.handlers.forEach((h) => {
    if (h !== null) {
      fn(h);
    }
  });
};
const mergeKeys = (keys, globalsConfig, config2) => {
  const config3 = {};
  keys.forEach((prop) => {
    if (!isUndefined(config2[prop])) {
      config3[prop] = config2[prop];
    } else if (!isUndefined(globalsConfig[prop])) {
      config3[prop] = globalsConfig[prop];
    }
  });
  return config3;
};
const mergeConfig = (globalsConfig, config2 = {}) => {
  const method = config2.method || globalsConfig.method || "GET";
  let config3 = {
    baseURL: globalsConfig.baseURL || "",
    method,
    url: config2.url || "",
    params: config2.params || {},
    custom: { ...globalsConfig.custom || {}, ...config2.custom || {} },
    header: deepMerge$1(globalsConfig.header || {}, config2.header || {})
  };
  const defaultToConfig2Keys = ["getTask", "validateStatus"];
  config3 = { ...config3, ...mergeKeys(defaultToConfig2Keys, globalsConfig, config2) };
  if (method === "DOWNLOAD")
    ;
  else if (method === "UPLOAD") {
    delete config3.header["content-type"];
    delete config3.header["Content-Type"];
    const uploadKeys = [
      "filePath",
      "name",
      "formData"
    ];
    uploadKeys.forEach((prop) => {
      if (!isUndefined(config2[prop])) {
        config3[prop] = config2[prop];
      }
    });
  } else {
    const defaultsKeys = [
      "data",
      "timeout",
      "dataType",
      "responseType"
    ];
    config3 = { ...config3, ...mergeKeys(defaultsKeys, globalsConfig, config2) };
  }
  return config3;
};
const defaults = {
  baseURL: "",
  header: {},
  method: "GET",
  dataType: "json",
  responseType: "text",
  custom: {},
  timeout: 6e4,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
var clone = function() {
  function _instanceof(obj, type) {
    return type != null && obj instanceof type;
  }
  var nativeMap;
  try {
    nativeMap = Map;
  } catch (_) {
    nativeMap = function() {
    };
  }
  var nativeSet;
  try {
    nativeSet = Set;
  } catch (_) {
    nativeSet = function() {
    };
  }
  var nativePromise;
  try {
    nativePromise = Promise;
  } catch (_) {
    nativePromise = function() {
    };
  }
  function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
    if (typeof circular === "object") {
      depth = circular.depth;
      prototype = circular.prototype;
      includeNonEnumerable = circular.includeNonEnumerable;
      circular = circular.circular;
    }
    var allParents = [];
    var allChildren = [];
    var useBuffer = typeof Buffer != "undefined";
    if (typeof circular == "undefined")
      circular = true;
    if (typeof depth == "undefined")
      depth = Infinity;
    function _clone(parent2, depth2) {
      if (parent2 === null)
        return null;
      if (depth2 === 0)
        return parent2;
      var child;
      var proto;
      if (typeof parent2 != "object") {
        return parent2;
      }
      if (_instanceof(parent2, nativeMap)) {
        child = new nativeMap();
      } else if (_instanceof(parent2, nativeSet)) {
        child = new nativeSet();
      } else if (_instanceof(parent2, nativePromise)) {
        child = new nativePromise(function(resolve2, reject) {
          parent2.then(function(value) {
            resolve2(_clone(value, depth2 - 1));
          }, function(err) {
            reject(_clone(err, depth2 - 1));
          });
        });
      } else if (clone2.__isArray(parent2)) {
        child = [];
      } else if (clone2.__isRegExp(parent2)) {
        child = new RegExp(parent2.source, __getRegExpFlags(parent2));
        if (parent2.lastIndex)
          child.lastIndex = parent2.lastIndex;
      } else if (clone2.__isDate(parent2)) {
        child = new Date(parent2.getTime());
      } else if (useBuffer && Buffer.isBuffer(parent2)) {
        if (Buffer.from) {
          child = Buffer.from(parent2);
        } else {
          child = new Buffer(parent2.length);
          parent2.copy(child);
        }
        return child;
      } else if (_instanceof(parent2, Error)) {
        child = Object.create(parent2);
      } else {
        if (typeof prototype == "undefined") {
          proto = Object.getPrototypeOf(parent2);
          child = Object.create(proto);
        } else {
          child = Object.create(prototype);
          proto = prototype;
        }
      }
      if (circular) {
        var index2 = allParents.indexOf(parent2);
        if (index2 != -1) {
          return allChildren[index2];
        }
        allParents.push(parent2);
        allChildren.push(child);
      }
      if (_instanceof(parent2, nativeMap)) {
        parent2.forEach(function(value, key) {
          var keyChild = _clone(key, depth2 - 1);
          var valueChild = _clone(value, depth2 - 1);
          child.set(keyChild, valueChild);
        });
      }
      if (_instanceof(parent2, nativeSet)) {
        parent2.forEach(function(value) {
          var entryChild = _clone(value, depth2 - 1);
          child.add(entryChild);
        });
      }
      for (var i in parent2) {
        var attrs = Object.getOwnPropertyDescriptor(parent2, i);
        if (attrs) {
          child[i] = _clone(parent2[i], depth2 - 1);
        }
        try {
          var objProperty = Object.getOwnPropertyDescriptor(parent2, i);
          if (objProperty.set === "undefined") {
            continue;
          }
          child[i] = _clone(parent2[i], depth2 - 1);
        } catch (e2) {
          if (e2 instanceof TypeError) {
            continue;
          } else if (e2 instanceof ReferenceError) {
            continue;
          }
        }
      }
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(parent2);
        for (var i = 0; i < symbols.length; i++) {
          var symbol = symbols[i];
          var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
          if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
            continue;
          }
          child[symbol] = _clone(parent2[symbol], depth2 - 1);
          Object.defineProperty(child, symbol, descriptor);
        }
      }
      if (includeNonEnumerable) {
        var allPropertyNames = Object.getOwnPropertyNames(parent2);
        for (var i = 0; i < allPropertyNames.length; i++) {
          var propertyName = allPropertyNames[i];
          var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
          if (descriptor && descriptor.enumerable) {
            continue;
          }
          child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
          Object.defineProperty(child, propertyName, descriptor);
        }
      }
      return child;
    }
    return _clone(parent, depth);
  }
  clone2.clonePrototype = function clonePrototype(parent) {
    if (parent === null)
      return null;
    var c = function() {
    };
    c.prototype = parent;
    return new c();
  };
  function __objToStr(o2) {
    return Object.prototype.toString.call(o2);
  }
  clone2.__objToStr = __objToStr;
  function __isDate(o2) {
    return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
  }
  clone2.__isDate = __isDate;
  function __isArray(o2) {
    return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
  }
  clone2.__isArray = __isArray;
  function __isRegExp(o2) {
    return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
  }
  clone2.__isRegExp = __isRegExp;
  function __getRegExpFlags(re) {
    var flags = "";
    if (re.global)
      flags += "g";
    if (re.ignoreCase)
      flags += "i";
    if (re.multiline)
      flags += "m";
    return flags;
  }
  clone2.__getRegExpFlags = __getRegExpFlags;
  return clone2;
}();
class Request {
  /**
  * @param {Object} arg - 
  * @param {String} arg.baseURL - 
  * @param {Object} arg.header - header
  * @param {String} arg.method = [GET|POST|PUT|DELETE|CONNECT|HEAD|OPTIONS|TRACE] - 
  * @param {String} arg.dataType = [json] - dataType
  * @param {String} arg.responseType = [text|arraybuffer] - responseType
  * @param {Object} arg.custom - 
  * @param {Number} arg.timeout -  ms60000H5(HBuilderX 2.9.9+)APP(HBuilderX 2.9.9+)2.10.0
  * @param {Boolean} arg.sslVerify -  ssl true.AppHBuilderX 2.3.3+
  * @param {Boolean} arg.withCredentials - cookiesfalseH5HBuilderX 2.6.15+
  * @param {Boolean} arg.firstIpv4 - DNSipv4false App-Android  (HBuilderX 2.8.0+)
  * @param {Function(statusCode):Boolean} arg.validateStatus - statusCode >= 200 && statusCode < 300
  */
  constructor(arg = {}) {
    if (!isPlainObject(arg)) {
      arg = {};
      index$2.__f__("warn", "at node_modules/uview-ui/libs/luch-request/core/Request.js:39", "Object");
    }
    this.config = clone({ ...defaults, ...arg });
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
  * @Function
  * @param {Request~setConfigCallback} f - 
  */
  setConfig(f2) {
    this.config = f2(this.config);
  }
  middleware(config2) {
    config2 = mergeConfig(this.config, config2);
    const chain = [dispatchRequest, void 0];
    let promise2 = Promise.resolve(config2);
    this.interceptors.request.forEach((interceptor) => {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach((interceptor) => {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });
    while (chain.length) {
      promise2 = promise2.then(chain.shift(), chain.shift());
    }
    return promise2;
  }
  /**
  * @Function
  * @param {Object} config - 
  * @prop {String} options.url - 
  * @prop {Object} options.data - 
  * @prop {Object} [options.responseType = config.responseType] [text|arraybuffer] - 
  * @prop {Object} [options.dataType = config.dataType] -  json JSON.parse
  * @prop {Object} [options.header = config.header] - header
  * @prop {Object} [options.method = config.method] - 
  * @returns {Promise<unknown>}
  */
  request(config2 = {}) {
    return this.middleware(config2);
  }
  get(url2, options = {}) {
    return this.middleware({
      url: url2,
      method: "GET",
      ...options
    });
  }
  post(url2, data, options = {}) {
    return this.middleware({
      url: url2,
      data,
      method: "POST",
      ...options
    });
  }
  put(url2, data, options = {}) {
    return this.middleware({
      url: url2,
      data,
      method: "PUT",
      ...options
    });
  }
  delete(url2, data, options = {}) {
    return this.middleware({
      url: url2,
      data,
      method: "DELETE",
      ...options
    });
  }
  connect(url2, data, options = {}) {
    return this.middleware({
      url: url2,
      data,
      method: "CONNECT",
      ...options
    });
  }
  head(url2, data, options = {}) {
    return this.middleware({
      url: url2,
      data,
      method: "HEAD",
      ...options
    });
  }
  options(url2, data, options = {}) {
    return this.middleware({
      url: url2,
      data,
      method: "OPTIONS",
      ...options
    });
  }
  trace(url2, data, options = {}) {
    return this.middleware({
      url: url2,
      data,
      method: "TRACE",
      ...options
    });
  }
  upload(url2, config2 = {}) {
    config2.url = url2;
    config2.method = "UPLOAD";
    return this.middleware(config2);
  }
  download(url2, config2 = {}) {
    config2.url = url2;
    config2.method = "DOWNLOAD";
    return this.middleware(config2);
  }
}
class Router {
  constructor() {
    this.config = {
      type: "navigateTo",
      url: "",
      delta: 1,
      // navigateBack,
      params: {},
      // 
      animationType: "pop-in",
      // ,APP
      animationDuration: 300,
      // ,,APP
      intercept: false
      // 
    };
    this.route = this.route.bind(this);
  }
  // url"/"
  addRootPath(url2) {
    return url2[0] === "/" ? url2 : `/${url2}`;
  }
  // 
  mixinParam(url2, params) {
    url2 = url2 && this.addRootPath(url2);
    let query = "";
    if (/.*\/.*\?.*=.*/.test(url2)) {
      query = index$2.$u.queryParams(params, false);
      return url2 += `&${query}`;
    }
    query = index$2.$u.queryParams(params);
    return url2 += query;
  }
  // 
  async route(options = {}, params = {}) {
    let mergeConfig2 = {};
    if (typeof options === "string") {
      mergeConfig2.url = this.mixinParam(options, params);
      mergeConfig2.type = "navigateTo";
    } else {
      mergeConfig2 = index$2.$u.deepMerge(this.config, options);
      mergeConfig2.url = this.mixinParam(options.url, options.params);
    }
    if (mergeConfig2.url === index$2.$u.page())
      return;
    if (params.intercept) {
      this.config.intercept = params.intercept;
    }
    mergeConfig2.params = params;
    mergeConfig2 = index$2.$u.deepMerge(this.config, mergeConfig2);
    if (typeof index$2.$u.routeIntercept === "function") {
      const isNext = await new Promise((resolve2, reject) => {
        index$2.$u.routeIntercept(mergeConfig2, resolve2);
      });
      isNext && this.openPage(mergeConfig2);
    } else {
      this.openPage(mergeConfig2);
    }
  }
  // 
  openPage(config2) {
    const {
      url: url2,
      type,
      delta,
      animationType,
      animationDuration
    } = config2;
    if (config2.type == "navigateTo" || config2.type == "to") {
      index$2.navigateTo({
        url: url2,
        animationType,
        animationDuration
      });
    }
    if (config2.type == "redirectTo" || config2.type == "redirect") {
      index$2.redirectTo({
        url: url2
      });
    }
    if (config2.type == "switchTab" || config2.type == "tab") {
      index$2.switchTab({
        url: url2
      });
    }
    if (config2.type == "reLaunch" || config2.type == "launch") {
      index$2.reLaunch({
        url: url2
      });
    }
    if (config2.type == "navigateBack" || config2.type == "back") {
      index$2.navigateBack({
        delta
      });
    }
  }
}
const route = new Router().route;
function colorGradient(startColor = "rgb(0, 0, 0)", endColor = "rgb(255, 255, 255)", step = 10) {
  const startRGB = hexToRgb(startColor, false);
  const startR = startRGB[0];
  const startG = startRGB[1];
  const startB = startRGB[2];
  const endRGB = hexToRgb(endColor, false);
  const endR = endRGB[0];
  const endG = endRGB[1];
  const endB = endRGB[2];
  const sR = (endR - startR) / step;
  const sG = (endG - startG) / step;
  const sB = (endB - startB) / step;
  const colorArr = [];
  for (let i = 0; i < step; i++) {
    let hex = rgbToHex(`rgb(${Math.round(sR * i + startR)},${Math.round(sG * i + startG)},${Math.round(sB * i + startB)})`);
    if (i === 0)
      hex = rgbToHex(startColor);
    if (i === step - 1)
      hex = rgbToHex(endColor);
    colorArr.push(hex);
  }
  return colorArr;
}
function hexToRgb(sColor, str = true) {
  const reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  sColor = String(sColor).toLowerCase();
  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      let sColorNew = "#";
      for (let i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }
      sColor = sColorNew;
    }
    const sColorChange = [];
    for (let i = 1; i < 7; i += 2) {
      sColorChange.push(parseInt(`0x${sColor.slice(i, i + 2)}`));
    }
    if (!str) {
      return sColorChange;
    }
    return `rgb(${sColorChange[0]},${sColorChange[1]},${sColorChange[2]})`;
  }
  if (/^(rgb|RGB)/.test(sColor)) {
    const arr = sColor.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
    return arr.map((val) => Number(val));
  }
  return sColor;
}
function rgbToHex(rgb2) {
  const _this = rgb2;
  const reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  if (/^(rgb|RGB)/.test(_this)) {
    const aColor = _this.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
    let strHex = "#";
    for (let i = 0; i < aColor.length; i++) {
      let hex = Number(aColor[i]).toString(16);
      hex = String(hex).length == 1 ? `${0}${hex}` : hex;
      if (hex === "0") {
        hex += hex;
      }
      strHex += hex;
    }
    if (strHex.length !== 7) {
      strHex = _this;
    }
    return strHex;
  }
  if (reg.test(_this)) {
    const aNum = _this.replace(/#/, "").split("");
    if (aNum.length === 6) {
      return _this;
    }
    if (aNum.length === 3) {
      let numHex = "#";
      for (let i = 0; i < aNum.length; i += 1) {
        numHex += aNum[i] + aNum[i];
      }
      return numHex;
    }
  } else {
    return _this;
  }
}
function colorToRgba(color2, alpha) {
  color2 = rgbToHex(color2);
  const reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  let sColor = String(color2).toLowerCase();
  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      let sColorNew = "#";
      for (let i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }
      sColor = sColorNew;
    }
    const sColorChange = [];
    for (let i = 1; i < 7; i += 2) {
      sColorChange.push(parseInt(`0x${sColor.slice(i, i + 2)}`));
    }
    return `rgba(${sColorChange.join(",")},${alpha})`;
  }
  return sColor;
}
const colorGradient$1 = {
  colorGradient,
  hexToRgb,
  rgbToHex,
  colorToRgba
};
function email(value) {
  return /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/.test(value);
}
function mobile(value) {
  return /^1([3589]\d|4[5-9]|6[1-2,4-7]|7[0-8])\d{8}$/.test(value);
}
function url(value) {
  return /^((https|http|ftp|rtsp|mms):\/\/)(([0-9a-zA-Z_!~*'().&=+$%-]+: )?[0-9a-zA-Z_!~*'().&=+$%-]+@)?(([0-9]{1,3}.){3}[0-9]{1,3}|([0-9a-zA-Z_!~*'()-]+.)*([0-9a-zA-Z][0-9a-zA-Z-]{0,61})?[0-9a-zA-Z].[a-zA-Z]{2,6})(:[0-9]{1,4})?((\/?)|(\/[0-9a-zA-Z_!~*'().;?:@&=+$,%#-]+)+\/?)$/.test(value);
}
function date(value) {
  if (!value)
    return false;
  if (number(value))
    value = +value;
  return !/Invalid|NaN/.test(new Date(value).toString());
}
function dateISO(value) {
  return /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
}
function number(value) {
  return /^[\+-]?(\d+\.?\d*|\.\d+|\d\.\d+e\+\d+)$/.test(value);
}
function string(value) {
  return typeof value === "string";
}
function digits(value) {
  return /^\d+$/.test(value);
}
function idCard(value) {
  return /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$/.test(
    value
  );
}
function carNo(value) {
  const xreg = /^[A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/;
  const creg = /^[A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9]{1}$/;
  if (value.length === 7) {
    return creg.test(value);
  }
  if (value.length === 8) {
    return xreg.test(value);
  }
  return false;
}
function amount(value) {
  return /^[1-9]\d*(,\d{3})*(\.\d{1,2})?$|^0\.\d{1,2}$/.test(value);
}
function chinese(value) {
  const reg = /^[\u4e00-\u9fa5]+$/gi;
  return reg.test(value);
}
function letter(value) {
  return /^[a-zA-Z]*$/.test(value);
}
function enOrNum(value) {
  const reg = /^[0-9a-zA-Z]*$/g;
  return reg.test(value);
}
function contains(value, param) {
  return value.indexOf(param) >= 0;
}
function range$1(value, param) {
  return value >= param[0] && value <= param[1];
}
function rangeLength(value, param) {
  return value.length >= param[0] && value.length <= param[1];
}
function landline(value) {
  const reg = /^\d{3,4}-\d{7,8}(-\d{3,4})?$/;
  return reg.test(value);
}
function empty$1(value) {
  switch (typeof value) {
    case "undefined":
      return true;
    case "string":
      if (value.replace(/(^[ \t\n\r]*)|([ \t\n\r]*$)/g, "").length == 0)
        return true;
      break;
    case "boolean":
      if (!value)
        return true;
      break;
    case "number":
      if (value === 0 || isNaN(value))
        return true;
      break;
    case "object":
      if (value === null || value.length === 0)
        return true;
      for (const i in value) {
        return false;
      }
      return true;
  }
  return false;
}
function jsonString(value) {
  if (typeof value === "string") {
    try {
      const obj = JSON.parse(value);
      if (typeof obj === "object" && obj) {
        return true;
      }
      return false;
    } catch (e2) {
      return false;
    }
  }
  return false;
}
function array(value) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(value);
  }
  return Object.prototype.toString.call(value) === "[object Array]";
}
function object(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
function code$1(value, len = 6) {
  return new RegExp(`^\\d{${len}}$`).test(value);
}
function func(value) {
  return typeof value === "function";
}
function promise(value) {
  return object(value) && func(value.then) && func(value.catch);
}
function image$1(value) {
  const newValue = value.split("?")[0];
  const IMAGE_REGEXP = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg)/i;
  return IMAGE_REGEXP.test(newValue);
}
function video(value) {
  const VIDEO_REGEXP = /\.(mp4|mpg|mpeg|dat|asf|avi|rm|rmvb|mov|wmv|flv|mkv|m3u8)/i;
  return VIDEO_REGEXP.test(value);
}
function regExp(o2) {
  return o2 && Object.prototype.toString.call(o2) === "[object RegExp]";
}
const test = {
  email,
  mobile,
  url,
  date,
  dateISO,
  number,
  digits,
  idCard,
  carNo,
  amount,
  chinese,
  letter,
  enOrNum,
  contains,
  range: range$1,
  rangeLength,
  empty: empty$1,
  isEmpty: empty$1,
  jsonString,
  landline,
  object,
  array,
  code: code$1,
  func,
  promise,
  video,
  image: image$1,
  regExp,
  string
};
let timeout = null;
function debounce(func2, wait = 500, immediate = false) {
  if (timeout !== null)
    clearTimeout(timeout);
  if (immediate) {
    const callNow = !timeout;
    timeout = setTimeout(() => {
      timeout = null;
    }, wait);
    if (callNow)
      typeof func2 === "function" && func2();
  } else {
    timeout = setTimeout(() => {
      typeof func2 === "function" && func2();
    }, wait);
  }
}
let flag;
function throttle(func2, wait = 500, immediate = true) {
  if (immediate) {
    if (!flag) {
      flag = true;
      typeof func2 === "function" && func2();
      setTimeout(() => {
        flag = false;
      }, wait);
    }
  } else if (!flag) {
    flag = true;
    setTimeout(() => {
      flag = false;
      typeof func2 === "function" && func2();
    }, wait);
  }
}
function strip(num, precision = 15) {
  return +parseFloat(Number(num).toPrecision(precision));
}
function digitLength(num) {
  const eSplit = num.toString().split(/[eE]/);
  const len = (eSplit[0].split(".")[1] || "").length - +(eSplit[1] || 0);
  return len > 0 ? len : 0;
}
function float2Fixed(num) {
  if (num.toString().indexOf("e") === -1) {
    return Number(num.toString().replace(".", ""));
  }
  const dLen = digitLength(num);
  return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
}
function checkBoundary(num) {
  {
    if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
      index$2.__f__("warn", "at node_modules/uview-ui/libs/function/digit.js:45", `${num} `);
    }
  }
}
function iteratorOperation(arr, operation) {
  const [num1, num2, ...others] = arr;
  let res = operation(num1, num2);
  others.forEach((num) => {
    res = operation(res, num);
  });
  return res;
}
function times(...nums) {
  if (nums.length > 2) {
    return iteratorOperation(nums, times);
  }
  const [num1, num2] = nums;
  const num1Changed = float2Fixed(num1);
  const num2Changed = float2Fixed(num2);
  const baseNum = digitLength(num1) + digitLength(num2);
  const leftValue = num1Changed * num2Changed;
  checkBoundary(leftValue);
  return leftValue / Math.pow(10, baseNum);
}
function divide(...nums) {
  if (nums.length > 2) {
    return iteratorOperation(nums, divide);
  }
  const [num1, num2] = nums;
  const num1Changed = float2Fixed(num1);
  const num2Changed = float2Fixed(num2);
  checkBoundary(num1Changed);
  checkBoundary(num2Changed);
  return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
}
function round(num, ratio) {
  const base = Math.pow(10, ratio);
  let result = divide(Math.round(Math.abs(times(num, base))), base);
  if (num < 0 && result !== 0) {
    result = times(result, -1);
  }
  return result;
}
function range(min = 0, max = 0, value = 0) {
  return Math.max(min, Math.min(max, Number(value)));
}
function getPx(value, unit = false) {
  if (test.number(value)) {
    return unit ? `${value}px` : Number(value);
  }
  if (/(rpx|upx)$/.test(value)) {
    return unit ? `${index$2.upx2px(parseInt(value))}px` : Number(index$2.upx2px(parseInt(value)));
  }
  return unit ? `${parseInt(value)}px` : parseInt(value);
}
function sleep(value = 30) {
  return new Promise((resolve2) => {
    setTimeout(() => {
      resolve2();
    }, value);
  });
}
function os() {
  return index$2.getSystemInfoSync().platform.toLowerCase();
}
function sys() {
  return index$2.getSystemInfoSync();
}
function random(min, max) {
  if (min >= 0 && max > 0 && max >= min) {
    const gab = max - min + 1;
    return Math.floor(Math.random() * gab + min);
  }
  return 0;
}
function guid(len = 32, firstU = true, radix = null) {
  const chars2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
  const uuid = [];
  radix = radix || chars2.length;
  if (len) {
    for (let i = 0; i < len; i++)
      uuid[i] = chars2[0 | Math.random() * radix];
  } else {
    let r;
    uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-";
    uuid[14] = "4";
    for (let i = 0; i < 36; i++) {
      if (!uuid[i]) {
        r = 0 | Math.random() * 16;
        uuid[i] = chars2[i == 19 ? r & 3 | 8 : r];
      }
    }
  }
  if (firstU) {
    uuid.shift();
    return `u${uuid.join("")}`;
  }
  return uuid.join("");
}
function $parent(name = void 0) {
  let parent = this.$parent;
  while (parent) {
    if (parent.$options && parent.$options.name !== name) {
      parent = parent.$parent;
    } else {
      return parent;
    }
  }
  return false;
}
function addStyle(customStyle, target = "object") {
  if (test.empty(customStyle) || typeof customStyle === "object" && target === "object" || target === "string" && typeof customStyle === "string") {
    return customStyle;
  }
  if (target === "object") {
    customStyle = trim(customStyle);
    const styleArray = customStyle.split(";");
    const style = {};
    for (let i = 0; i < styleArray.length; i++) {
      if (styleArray[i]) {
        const item = styleArray[i].split(":");
        style[trim(item[0])] = trim(item[1]);
      }
    }
    return style;
  }
  let string2 = "";
  for (const i in customStyle) {
    const key = i.replace(/([A-Z])/g, "-$1").toLowerCase();
    string2 += `${key}:${customStyle[i]};`;
  }
  return trim(string2);
}
function addUnit(value = "auto", unit = ((_b) => (_b = ((_a) => (_a = index$2 == null ? void 0 : index$2.$u) == null ? void 0 : _a.config)()) == null ? void 0 : _b.unit)() ?? "px") {
  value = String(value);
  return test.number(value) ? `${value}${unit}` : value;
}
function deepClone(obj, cache = /* @__PURE__ */ new WeakMap()) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (cache.has(obj))
    return cache.get(obj);
  let clone2;
  if (obj instanceof Date) {
    clone2 = new Date(obj.getTime());
  } else if (obj instanceof RegExp) {
    clone2 = new RegExp(obj);
  } else if (obj instanceof Map) {
    clone2 = new Map(Array.from(obj, ([key, value]) => [key, deepClone(value, cache)]));
  } else if (obj instanceof Set) {
    clone2 = new Set(Array.from(obj, (value) => deepClone(value, cache)));
  } else if (Array.isArray(obj)) {
    clone2 = obj.map((value) => deepClone(value, cache));
  } else if (Object.prototype.toString.call(obj) === "[object Object]") {
    clone2 = Object.create(Object.getPrototypeOf(obj));
    cache.set(obj, clone2);
    for (const [key, value] of Object.entries(obj)) {
      clone2[key] = deepClone(value, cache);
    }
  } else {
    clone2 = Object.assign({}, obj);
  }
  cache.set(obj, clone2);
  return clone2;
}
function deepMerge(target = {}, source = {}) {
  target = deepClone(target);
  if (typeof target !== "object" || target === null || typeof source !== "object" || source === null)
    return target;
  const merged = Array.isArray(target) ? target.slice() : Object.assign({}, target);
  for (const prop in source) {
    if (!source.hasOwnProperty(prop))
      continue;
    const sourceValue = source[prop];
    const targetValue = merged[prop];
    if (sourceValue instanceof Date) {
      merged[prop] = new Date(sourceValue);
    } else if (sourceValue instanceof RegExp) {
      merged[prop] = new RegExp(sourceValue);
    } else if (sourceValue instanceof Map) {
      merged[prop] = new Map(sourceValue);
    } else if (sourceValue instanceof Set) {
      merged[prop] = new Set(sourceValue);
    } else if (typeof sourceValue === "object" && sourceValue !== null) {
      merged[prop] = deepMerge(targetValue, sourceValue);
    } else {
      merged[prop] = sourceValue;
    }
  }
  return merged;
}
function error(err) {
  {
    index$2.__f__("error", "at node_modules/uview-ui/libs/function/index.js:250", `uView${err}`);
  }
}
function randomArray(array2 = []) {
  return array2.sort(() => Math.random() - 0.5);
}
if (!String.prototype.padStart) {
  String.prototype.padStart = function(maxLength, fillString = " ") {
    if (Object.prototype.toString.call(fillString) !== "[object String]") {
      throw new TypeError(
        "fillString must be String"
      );
    }
    const str = this;
    if (str.length >= maxLength)
      return String(str);
    const fillLength = maxLength - str.length;
    let times2 = Math.ceil(fillLength / fillString.length);
    while (times2 >>= 1) {
      fillString += fillString;
      if (times2 === 1) {
        fillString += fillString;
      }
    }
    return fillString.slice(0, fillLength) + str;
  };
}
function timeFormat(dateTime = null, formatStr = "yyyy-mm-dd") {
  let date2;
  if (!dateTime) {
    date2 = /* @__PURE__ */ new Date();
  } else if (/^\d{10}$/.test(dateTime == null ? void 0 : dateTime.toString().trim())) {
    date2 = new Date(dateTime * 1e3);
  } else if (typeof dateTime === "string" && /^\d+$/.test(dateTime.trim())) {
    date2 = new Date(Number(dateTime));
  } else if (typeof dateTime === "string" && dateTime.includes("-") && !dateTime.includes("T")) {
    date2 = new Date(dateTime.replace(/-/g, "/"));
  } else {
    date2 = new Date(dateTime);
  }
  const timeSource = {
    "y": date2.getFullYear().toString(),
    // 
    "m": (date2.getMonth() + 1).toString().padStart(2, "0"),
    // 
    "d": date2.getDate().toString().padStart(2, "0"),
    // 
    "h": date2.getHours().toString().padStart(2, "0"),
    // 
    "M": date2.getMinutes().toString().padStart(2, "0"),
    // 
    "s": date2.getSeconds().toString().padStart(2, "0")
    // 
    // 
  };
  for (const key in timeSource) {
    const [ret] = new RegExp(`${key}+`).exec(formatStr) || [];
    if (ret) {
      const beginIndex = key === "y" && ret.length === 2 ? 2 : 0;
      formatStr = formatStr.replace(ret, timeSource[key].slice(beginIndex));
    }
  }
  return formatStr;
}
function timeFrom(timestamp = null, format = "yyyy-mm-dd") {
  if (timestamp == null)
    timestamp = Number(/* @__PURE__ */ new Date());
  timestamp = parseInt(timestamp);
  if (timestamp.toString().length == 10)
    timestamp *= 1e3;
  let timer = (/* @__PURE__ */ new Date()).getTime() - timestamp;
  timer = parseInt(timer / 1e3);
  let tips = "";
  switch (true) {
    case timer < 300:
      tips = "";
      break;
    case (timer >= 300 && timer < 3600):
      tips = `${parseInt(timer / 60)}`;
      break;
    case (timer >= 3600 && timer < 86400):
      tips = `${parseInt(timer / 3600)}`;
      break;
    case (timer >= 86400 && timer < 2592e3):
      tips = `${parseInt(timer / 86400)}`;
      break;
    default:
      if (format === false) {
        if (timer >= 2592e3 && timer < 365 * 86400) {
          tips = `${parseInt(timer / (86400 * 30))}`;
        } else {
          tips = `${parseInt(timer / (86400 * 365))}`;
        }
      } else {
        tips = timeFormat(timestamp, format);
      }
  }
  return tips;
}
function trim(str, pos = "both") {
  str = String(str);
  if (pos == "both") {
    return str.replace(/^\s+|\s+$/g, "");
  }
  if (pos == "left") {
    return str.replace(/^\s*/, "");
  }
  if (pos == "right") {
    return str.replace(/(\s*$)/g, "");
  }
  if (pos == "all") {
    return str.replace(/\s+/g, "");
  }
  return str;
}
function queryParams(data = {}, isPrefix = true, arrayFormat = "brackets") {
  const prefix = isPrefix ? "?" : "";
  const _result = [];
  if (["indices", "brackets", "repeat", "comma"].indexOf(arrayFormat) == -1)
    arrayFormat = "brackets";
  for (const key in data) {
    const value = data[key];
    if (["", void 0, null].indexOf(value) >= 0) {
      continue;
    }
    if (value.constructor === Array) {
      switch (arrayFormat) {
        case "indices":
          for (let i = 0; i < value.length; i++) {
            _result.push(`${key}[${i}]=${value[i]}`);
          }
          break;
        case "brackets":
          value.forEach((_value) => {
            _result.push(`${key}[]=${_value}`);
          });
          break;
        case "repeat":
          value.forEach((_value) => {
            _result.push(`${key}=${_value}`);
          });
          break;
        case "comma":
          let commaStr = "";
          value.forEach((_value) => {
            commaStr += (commaStr ? "," : "") + _value;
          });
          _result.push(`${key}=${commaStr}`);
          break;
        default:
          value.forEach((_value) => {
            _result.push(`${key}[]=${_value}`);
          });
      }
    } else {
      _result.push(`${key}=${value}`);
    }
  }
  return _result.length ? prefix + _result.join("&") : "";
}
function toast$1(title, duration2 = 2e3) {
  index$2.showToast({
    title: String(title),
    icon: "none",
    duration: duration2
  });
}
function type2icon(type = "success", fill = false) {
  if (["primary", "info", "error", "warning", "success"].indexOf(type) == -1)
    type = "success";
  let iconName = "";
  switch (type) {
    case "primary":
      iconName = "info-circle";
      break;
    case "info":
      iconName = "info-circle";
      break;
    case "error":
      iconName = "close-circle";
      break;
    case "warning":
      iconName = "error-circle";
      break;
    case "success":
      iconName = "checkmark-circle";
      break;
    default:
      iconName = "checkmark-circle";
  }
  if (fill)
    iconName += "-fill";
  return iconName;
}
function priceFormat(number2, decimals = 0, decimalPoint = ".", thousandsSeparator = ",") {
  number2 = `${number2}`.replace(/[^0-9+-Ee.]/g, "");
  const n2 = !isFinite(+number2) ? 0 : +number2;
  const prec = !isFinite(+decimals) ? 0 : Math.abs(decimals);
  const sep = typeof thousandsSeparator === "undefined" ? "," : thousandsSeparator;
  const dec = typeof decimalPoint === "undefined" ? "." : decimalPoint;
  let s2 = "";
  s2 = (prec ? round(n2, prec) + "" : `${Math.round(n2)}`).split(".");
  const re = /(-?\d+)(\d{3})/;
  while (re.test(s2[0])) {
    s2[0] = s2[0].replace(re, `$1${sep}$2`);
  }
  if ((s2[1] || "").length < prec) {
    s2[1] = s2[1] || "";
    s2[1] += new Array(prec - s2[1].length + 1).join("0");
  }
  return s2.join(dec);
}
function getDuration(value, unit = true) {
  const valueNum = parseInt(value);
  if (unit) {
    if (/s$/.test(value))
      return value;
    return value > 30 ? `${value}ms` : `${value}s`;
  }
  if (/ms$/.test(value))
    return valueNum;
  if (/s$/.test(value))
    return valueNum > 30 ? valueNum : valueNum * 1e3;
  return valueNum;
}
function padZero(value) {
  return `00${value}`.slice(-2);
}
function formValidate(instance, event) {
  const formItem2 = index$2.$u.$parent.call(instance, "u-form-item");
  const form2 = index$2.$u.$parent.call(instance, "u-form");
  if (formItem2 && form2) {
    form2.validateField(formItem2.prop, () => {
    }, event);
  }
}
function getProperty(obj, key) {
  if (!obj) {
    return;
  }
  if (typeof key !== "string" || key === "") {
    return "";
  }
  if (key.indexOf(".") !== -1) {
    const keys = key.split(".");
    let firstObj = obj[keys[0]] || {};
    for (let i = 1; i < keys.length; i++) {
      if (firstObj) {
        firstObj = firstObj[keys[i]];
      }
    }
    return firstObj;
  }
  return obj[key];
}
function setProperty(obj, key, value) {
  if (!obj) {
    return;
  }
  const inFn = function(_obj, keys, v) {
    if (keys.length === 1) {
      _obj[keys[0]] = v;
      return;
    }
    while (keys.length > 1) {
      const k = keys[0];
      if (!_obj[k] || typeof _obj[k] !== "object") {
        _obj[k] = {};
      }
      keys.shift();
      inFn(_obj[k], keys, v);
    }
  };
  if (typeof key !== "string" || key === "")
    ;
  else if (key.indexOf(".") !== -1) {
    const keys = key.split(".");
    inFn(obj, keys, value);
  } else {
    obj[key] = value;
  }
}
function page() {
  var _a;
  const pages2 = getCurrentPages();
  return `/${((_a = pages2[pages2.length - 1]) == null ? void 0 : _a.route) ?? ""}`;
}
function pages() {
  const pages2 = getCurrentPages();
  return pages2;
}
function getHistoryPage(back = 0) {
  const pages2 = getCurrentPages();
  const len = pages2.length;
  return pages2[len - 1 + back];
}
function setConfig({
  props: props2 = {},
  config: config2 = {},
  color: color2 = {},
  zIndex: zIndex2 = {}
}) {
  const {
    deepMerge: deepMerge2
  } = index$2.$u;
  index$2.$u.config = deepMerge2(index$2.$u.config, config2);
  index$2.$u.props = deepMerge2(index$2.$u.props, props2);
  index$2.$u.color = deepMerge2(index$2.$u.color, color2);
  index$2.$u.zIndex = deepMerge2(index$2.$u.zIndex, zIndex2);
}
const index = {
  range,
  getPx,
  sleep,
  os,
  sys,
  random,
  guid,
  $parent,
  addStyle,
  addUnit,
  deepClone,
  deepMerge,
  error,
  randomArray,
  timeFormat,
  timeFrom,
  trim,
  queryParams,
  toast: toast$1,
  type2icon,
  priceFormat,
  getDuration,
  padZero,
  formValidate,
  getProperty,
  setProperty,
  page,
  pages,
  getHistoryPage,
  setConfig
};
const version$1 = "2.0.38";
{
  index$2.__f__("log", "at node_modules/uview-ui/libs/config/config.js:6", `
 %c uView V${version$1} %c https://uviewui.com/ 

`, "color: #ffffff; background: #3c9cff; padding:5px 0; border-radius: 5px;");
}
const config = {
  v: version$1,
  version: version$1,
  // 
  type: [
    "primary",
    "success",
    "info",
    "error",
    "warning"
  ],
  // scss:exportjsnvue
  color: {
    "u-primary": "#2979ff",
    "u-warning": "#ff9900",
    "u-success": "#19be6b",
    "u-error": "#fa3534",
    "u-info": "#909399",
    "u-main-color": "#303133",
    "u-content-color": "#606266",
    "u-tips-color": "#909399",
    "u-light-color": "#c0c4cc"
  },
  // rpxrpx
  unit: "px"
};
const actionSheet = {
  // action-sheet
  actionSheet: {
    show: false,
    title: "",
    description: "",
    actions: () => [],
    index: "",
    cancelText: "",
    closeOnClickAction: true,
    safeAreaInsetBottom: true,
    openType: "",
    closeOnClickOverlay: true,
    round: 0
  }
};
const album = {
  // album 
  album: {
    urls: () => [],
    keyName: "",
    singleSize: 180,
    multipleSize: 70,
    space: 6,
    singleMode: "scaleToFill",
    multipleMode: "aspectFill",
    maxCount: 9,
    previewFullImage: true,
    rowCount: 3,
    showMore: true
  }
};
const alert = {
  // alert
  alert: {
    title: "",
    type: "warning",
    description: "",
    closable: false,
    showIcon: false,
    effect: "light",
    center: false,
    fontSize: 14
  }
};
const avatar = {
  // avatar 
  avatar: {
    src: "",
    shape: "circle",
    size: 40,
    mode: "scaleToFill",
    text: "",
    bgColor: "#c0c4cc",
    color: "#ffffff",
    fontSize: 18,
    icon: "",
    mpAvatar: false,
    randomBgColor: false,
    defaultUrl: "",
    colorIndex: "",
    name: ""
  }
};
const avatarGroup = {
  // avatarGroup 
  avatarGroup: {
    urls: () => [],
    maxCount: 5,
    shape: "circle",
    mode: "scaleToFill",
    showMore: true,
    size: 40,
    keyName: "",
    gap: 0.5,
    extraValue: 0
  }
};
const backtop = {
  // backtop
  backtop: {
    mode: "circle",
    icon: "arrow-upward",
    text: "",
    duration: 100,
    scrollTop: 0,
    top: 400,
    bottom: 100,
    right: 20,
    zIndex: 9,
    iconStyle: () => ({
      color: "#909399",
      fontSize: "19px"
    })
  }
};
const badge = {
  // 
  badge: {
    isDot: false,
    value: "",
    show: true,
    max: 999,
    type: "error",
    showZero: false,
    bgColor: null,
    color: null,
    shape: "circle",
    numberType: "overflow",
    offset: () => [],
    inverted: false,
    absolute: false
  }
};
const button = {
  // button
  button: {
    hairline: false,
    type: "info",
    size: "normal",
    shape: "square",
    plain: false,
    disabled: false,
    loading: false,
    loadingText: "",
    loadingMode: "spinner",
    loadingSize: 15,
    openType: "",
    formType: "",
    appParameter: "",
    hoverStopPropagation: true,
    lang: "en",
    sessionFrom: "",
    sendMessageTitle: "",
    sendMessagePath: "",
    sendMessageImg: "",
    showMessageCard: false,
    dataName: "",
    throttleTime: 0,
    hoverStartTime: 0,
    hoverStayTime: 200,
    text: "",
    icon: "",
    iconColor: "",
    color: ""
  }
};
const calendar = {
  // calendar 
  calendar: {
    title: "",
    showTitle: true,
    showSubtitle: true,
    mode: "single",
    startText: "",
    endText: "",
    customList: () => [],
    color: "#3c9cff",
    minDate: 0,
    maxDate: 0,
    defaultDate: null,
    maxCount: Number.MAX_SAFE_INTEGER,
    // Infinity
    rowHeight: 56,
    formatter: null,
    showLunar: false,
    showMark: true,
    confirmText: "",
    confirmDisabledText: "",
    show: false,
    closeOnClickOverlay: false,
    readonly: false,
    showConfirm: true,
    maxRange: Number.MAX_SAFE_INTEGER,
    // Infinity
    rangePrompt: "",
    showRangePrompt: true,
    allowSameDay: false,
    round: 0,
    monthNum: 3
  }
};
const carKeyboard = {
  // 
  carKeyboard: {
    random: false
  }
};
const cell = {
  // cellprops
  cell: {
    customClass: "",
    title: "",
    label: "",
    value: "",
    icon: "",
    disabled: false,
    border: true,
    center: false,
    url: "",
    linkType: "navigateTo",
    clickable: false,
    isLink: false,
    required: false,
    arrowDirection: "",
    iconStyle: {},
    rightIconStyle: {},
    rightIcon: "arrow-right",
    titleStyle: {},
    size: "",
    stop: true,
    name: ""
  }
};
const cellGroup = {
  // cell-groupprops
  cellGroup: {
    title: "",
    border: true,
    customStyle: {}
  }
};
const checkbox = {
  // checkbox
  checkbox: {
    name: "",
    shape: "",
    size: "",
    checkbox: false,
    disabled: "",
    activeColor: "",
    inactiveColor: "",
    iconSize: "",
    iconColor: "",
    label: "",
    labelSize: "",
    labelColor: "",
    labelDisabled: ""
  }
};
const checkboxGroup = {
  // checkbox-group
  checkboxGroup: {
    name: "",
    value: () => [],
    shape: "square",
    disabled: false,
    activeColor: "#2979ff",
    inactiveColor: "#c8c9cc",
    size: 18,
    placement: "row",
    labelSize: 14,
    labelColor: "#303133",
    labelDisabled: false,
    iconColor: "#ffffff",
    iconSize: 12,
    iconPlacement: "left",
    borderBottom: false
  }
};
const circleProgress = {
  // circleProgress 
  circleProgress: {
    percentage: 30
  }
};
const code = {
  // code 
  code: {
    seconds: 60,
    startText: "",
    changeText: "X",
    endText: "",
    keepRunning: false,
    uniqueKey: ""
  }
};
const codeInput = {
  // codeInput 
  codeInput: {
    adjustPosition: true,
    maxlength: 6,
    dot: false,
    mode: "box",
    hairline: false,
    space: 10,
    value: "",
    focus: false,
    bold: false,
    color: "#606266",
    fontSize: 18,
    size: 35,
    disabledKeyboard: false,
    borderColor: "#c9cacc",
    disabledDot: true
  }
};
const col = {
  // col 
  col: {
    span: 12,
    offset: 0,
    justify: "start",
    align: "stretch",
    textAlign: "left"
  }
};
const collapse = {
  // collapse 
  collapse: {
    value: null,
    accordion: false,
    border: true
  }
};
const collapseItem = {
  // collapseItem 
  collapseItem: {
    title: "",
    value: "",
    label: "",
    disabled: false,
    isLink: true,
    clickable: true,
    border: true,
    align: "left",
    name: "",
    icon: "",
    duration: 300
  }
};
const columnNotice = {
  // columnNotice 
  columnNotice: {
    text: "",
    icon: "volume",
    mode: "",
    color: "#f9ae3d",
    bgColor: "#fdf6ec",
    fontSize: 14,
    speed: 80,
    step: false,
    duration: 1500,
    disableTouch: true
  }
};
const countDown = {
  // u-count-down 
  countDown: {
    time: 0,
    format: "HH:mm:ss",
    autoStart: true,
    millisecond: false
  }
};
const countTo = {
  // countTo 
  countTo: {
    startVal: 0,
    endVal: 0,
    duration: 2e3,
    autoplay: true,
    decimals: 0,
    useEasing: true,
    decimal: ".",
    color: "#606266",
    fontSize: 22,
    bold: false,
    separator: ""
  }
};
const datetimePicker = {
  // datetimePicker 
  datetimePicker: {
    show: false,
    showToolbar: true,
    value: "",
    title: "",
    mode: "datetime",
    maxDate: new Date((/* @__PURE__ */ new Date()).getFullYear() + 10, 0, 1).getTime(),
    minDate: new Date((/* @__PURE__ */ new Date()).getFullYear() - 10, 0, 1).getTime(),
    minHour: 0,
    maxHour: 23,
    minMinute: 0,
    maxMinute: 59,
    filter: null,
    formatter: null,
    loading: false,
    itemHeight: 44,
    cancelText: "",
    confirmText: "",
    cancelColor: "#909193",
    confirmColor: "#3c9cff",
    visibleItemCount: 5,
    closeOnClickOverlay: false,
    immediateChange: false,
    defaultIndex: () => []
  }
};
const divider = {
  // divider
  divider: {
    dashed: false,
    hairline: true,
    dot: false,
    textPosition: "center",
    text: "",
    textSize: 14,
    textColor: "#909399",
    lineColor: "#dcdfe6"
  }
};
const empty = {
  // empty
  empty: {
    icon: "",
    text: "",
    textColor: "#c0c4cc",
    textSize: 14,
    iconColor: "#c0c4cc",
    iconSize: 90,
    mode: "data",
    width: 160,
    height: 160,
    show: true,
    marginTop: 0
  }
};
const form = {
  // form 
  form: {
    model: () => ({}),
    rules: () => ({}),
    errorType: "message",
    borderBottom: true,
    labelPosition: "left",
    labelWidth: 45,
    labelAlign: "left",
    labelStyle: () => ({})
  }
};
const formItem = {
  // formItem 
  formItem: {
    label: "",
    prop: "",
    borderBottom: "",
    labelPosition: "",
    labelWidth: "",
    rightIcon: "",
    leftIcon: "",
    required: false,
    leftIconStyle: ""
  }
};
const gap = {
  // gap
  gap: {
    bgColor: "transparent",
    height: 20,
    marginTop: 0,
    marginBottom: 0,
    customStyle: {}
  }
};
const grid = {
  // grid
  grid: {
    col: 3,
    border: false,
    align: "left"
  }
};
const gridItem = {
  // grid-item
  gridItem: {
    name: null,
    bgColor: "transparent"
  }
};
const {
  color: color$3
} = config;
const icon = {
  // icon
  icon: {
    name: "",
    color: color$3["u-content-color"],
    size: "16px",
    bold: false,
    index: "",
    hoverClass: "",
    customPrefix: "uicon",
    label: "",
    labelPos: "right",
    labelSize: "15px",
    labelColor: color$3["u-content-color"],
    space: "3px",
    imgMode: "",
    width: "",
    height: "",
    top: 0,
    stop: false
  }
};
const image = {
  // image
  image: {
    src: "",
    mode: "aspectFill",
    width: "300",
    height: "225",
    shape: "square",
    radius: 0,
    lazyLoad: true,
    showMenuByLongpress: true,
    loadingIcon: "photo",
    errorIcon: "error-circle",
    showLoading: true,
    showError: true,
    fade: true,
    webp: false,
    duration: 500,
    bgColor: "#f3f4f6"
  }
};
const indexAnchor = {
  // indexAnchor 
  indexAnchor: {
    text: "",
    color: "#606266",
    size: 14,
    bgColor: "#dedede",
    height: 32
  }
};
const indexList = {
  // indexList 
  indexList: {
    inactiveColor: "#606266",
    activeColor: "#5677fc",
    indexList: () => [],
    sticky: true,
    customNavHeight: 0
  }
};
const input = {
  // index 
  input: {
    value: "",
    type: "text",
    fixed: false,
    disabled: false,
    disabledColor: "#f5f7fa",
    clearable: false,
    password: false,
    maxlength: -1,
    placeholder: null,
    placeholderClass: "input-placeholder",
    placeholderStyle: "color: #c0c4cc",
    showWordLimit: false,
    confirmType: "done",
    confirmHold: false,
    holdKeyboard: false,
    focus: false,
    autoBlur: false,
    disableDefaultPadding: false,
    cursor: -1,
    cursorSpacing: 30,
    selectionStart: -1,
    selectionEnd: -1,
    adjustPosition: true,
    inputAlign: "left",
    fontSize: "15px",
    color: "#303133",
    prefixIcon: "",
    prefixIconStyle: "",
    suffixIcon: "",
    suffixIconStyle: "",
    border: "surround",
    readonly: false,
    shape: "square",
    formatter: null
  }
};
const keyboard = {
  // 
  keyboard: {
    mode: "number",
    dotDisabled: false,
    tooltip: true,
    showTips: true,
    tips: "",
    showCancel: true,
    showConfirm: true,
    random: false,
    safeAreaInsetBottom: true,
    closeOnClickOverlay: true,
    show: false,
    overlay: true,
    zIndex: 10075,
    cancelText: "",
    confirmText: "",
    autoChange: false
  }
};
const line = {
  // line
  line: {
    color: "#d6d7d9",
    length: "100%",
    direction: "row",
    hairline: true,
    margin: 0,
    dashed: false
  }
};
const lineProgress = {
  // lineProgress 
  lineProgress: {
    activeColor: "#19be6b",
    inactiveColor: "#ececec",
    percentage: 0,
    showText: true,
    height: 12
  }
};
const {
  color: color$2
} = config;
const link = {
  // linkprops
  link: {
    color: color$2["u-primary"],
    fontSize: 15,
    underLine: false,
    href: "",
    mpTips: "",
    lineColor: "",
    text: ""
  }
};
const list = {
  // list 
  list: {
    showScrollbar: false,
    lowerThreshold: 50,
    upperThreshold: 0,
    scrollTop: 0,
    offsetAccuracy: 10,
    enableFlex: false,
    pagingEnabled: false,
    scrollable: true,
    scrollIntoView: "",
    scrollWithAnimation: false,
    enableBackToTop: false,
    height: 0,
    width: 0,
    preLoadScreen: 1
  }
};
const listItem = {
  // listItem 
  listItem: {
    anchor: ""
  }
};
const {
  color: color$1
} = config;
const loadingIcon = {
  // loading-icon
  loadingIcon: {
    show: true,
    color: color$1["u-tips-color"],
    textColor: color$1["u-tips-color"],
    vertical: false,
    mode: "spinner",
    size: 24,
    textSize: 15,
    text: "",
    timingFunction: "ease-in-out",
    duration: 1200,
    inactiveColor: ""
  }
};
const loadingPage = {
  // loading-page
  loadingPage: {
    loadingText: "",
    image: "",
    loadingMode: "circle",
    loading: false,
    bgColor: "#ffffff",
    color: "#C8C8C8",
    fontSize: 19,
    iconSize: 28,
    loadingColor: "#C8C8C8"
  }
};
const loadmore = {
  // loadmore 
  loadmore: {
    status: "loadmore",
    bgColor: "transparent",
    icon: true,
    fontSize: 14,
    iconSize: 17,
    color: "#606266",
    loadingIcon: "spinner",
    loadmoreText: "",
    loadingText: "...",
    nomoreText: "",
    isDot: false,
    iconColor: "#b7b7b7",
    marginTop: 10,
    marginBottom: 10,
    height: "auto",
    line: false,
    lineColor: "#E6E8EB",
    dashed: false
  }
};
const modal = {
  // modal 
  modal: {
    show: false,
    title: "",
    content: "",
    confirmText: "",
    cancelText: "",
    showConfirmButton: true,
    showCancelButton: false,
    confirmColor: "#2979ff",
    cancelColor: "#606266",
    buttonReverse: false,
    zoom: true,
    asyncClose: false,
    closeOnClickOverlay: false,
    negativeTop: 0,
    width: "650rpx",
    confirmButtonShape: "",
    duration: 400
  }
};
const color = {
  primary: "#3c9cff",
  info: "#909399",
  default: "#909399",
  warning: "#f9ae3d",
  error: "#f56c6c",
  success: "#5ac725",
  mainColor: "#303133",
  contentColor: "#606266",
  tipsColor: "#909399",
  lightColor: "#c0c4cc",
  borderColor: "#e4e7ed"
};
const navbar = {
  // navbar 
  navbar: {
    safeAreaInsetTop: true,
    placeholder: false,
    fixed: true,
    border: false,
    leftIcon: "arrow-left",
    leftText: "",
    rightText: "",
    rightIcon: "",
    title: "",
    bgColor: "#ffffff",
    titleWidth: "400rpx",
    height: "44px",
    leftIconSize: 20,
    leftIconColor: color.mainColor,
    autoBack: false,
    titleStyle: ""
  }
};
const noNetwork = {
  // noNetwork
  noNetwork: {
    tips: "",
    zIndex: "",
    image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAYAAAB5fY51AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAABLKADAAQAAAABAAABLAAAAADYYILnAABAAElEQVR4Ae29CZhkV3kefNeq6m2W7tn3nl0aCbHIAgmQPGB+sLCNzSID9g9PYrAf57d/+4+DiW0cy8QBJ06c2In/PLFDHJ78+MGCGNsYgyxwIwktwEijAc1ohtmnZ+2Z7p5eq6vu9r/vuXWrq25VdVV1V3dXVX9Hmj73nv285963vvOd75yraeIEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQaD8E9PbrkvRopSMwMBBYRs+5O/yJS68cPnzYXel4tFP/jXbqjPRFEAiCQNe6Bw/6gdFn9Oy9Q90LLG2DgBBW2wyldIQIPPPCte2a5q3jtR+4ff/4wuBuXotrDwSEsNpjHKUXQODppy+udYJMEUEZgbd94DvnNwlA7YGAEFZ7jOOK78Xp06eTTkq7sxwQhmXuf/754VXl4iSstRAQwmqt8ZLWlkHg0UcD49qYfUjXfLtMtOZ7npExJu4iqZWLl7DWQUAIq3XGSlpaAYHD77q8xwuCOSUoXw8Sl0eMux977DGzQjES3AIICGG1wCBJEysj8PXnz230XXdr5RQFMYbRvWnv6w8UhMhliyGwYghr4Pjg3oEXL34ey9zyC9tiD2ml5h47dr1LN7S6CMjz/A3PvHh1Z6UyJby5EVgRhKUe7Kz/JU0LfvrJo5f+Y3MPibSuFgQGBgasYSd9l6GDsup0WS/T/9RTp9fXmU2SNwECdQ92E7S57iaMeJnPQLK6ixkDLfjlb7546RfrLkQyNBcC3dsP6oHWMd9G+V3JgwPHh7rnm1/yLQ8CbU9Y33zp0j+nZFUMb/DHmB7+SHGY3LUKAk8cObtD00xlHDrfNge+Z2ozU3c9dvx4Yr5lSL6lR6CtCWvg6OAPw9z538ZhhZRl6XrwhW8du1KX/iNejtwvPQIDR8+vSRqJ/obU7GupjdNdh2gW0ZDypJBFR6BtB2rg2OVtuub9JcmpHIpBoK1xfffLzx4f7C0XL2HNiYDp6bs9z23Ypn1fC1Y/9PCFDc3ZW2lVHIG2JKzTp4Ok7nv/G6Q054MIvda+bNb74pEgKGtwGAdL7pcfAa8vOKEZ2kyjWuLr7uDh+/qvN6o8KWdxEWhLwroyeek/g4zuqwU6kNrhyZcu/UktaSXN8iNwuL9/RuvVXtJ9PbPQ1vhmcP6t9+47u9ByJP/SIdB2hDVw9MJHQFYfrQdCph84evFX68kjaZcPAZJWwjMXRFpJ2zr91tfuvrh8vZCa54NA2xGWrunvmg8QWCJ/N4ir7fCYDxatkOeBB7an501agXbygVdvv9IK/ZQ2FiPQdi9osGbH+zRNf7y4m9Xu9Me7N9nv0HXdr5ZS4psHgXpJC9P/wDRTx0Vn1TxjWG9LGrbaUm/Fi5meSvcrkxf/Cg/ow9XqAUk91v3qHT97r6471dJKfHMi8Oyzgx1Z03t1YAQVT2MwgsC3u+yXHzi0faQ5eyGtqgWBtpOw2Ol9+/TM+sTOn8L08MtzgQCy+tOHXr3jA0JWc6HU/HF5Scssr4jXcYqfP6V/T8iq+ceyWgvbUsKKOn38eJAYyl56TAuCEr2WYei//9Crd/5GlFb81kdASVopSFrerKRlaoZj9HR+700H10+0fg+lB21NWBxe2lhNHsUpDZr27mi4dV379R9+za4/iO7Fbx8ECknLCPTsTDJ17O33bJpqnx6u7J60PWFxeAcCbMV56dJfQKf1bkMLfuGh1+76zMoe9vbuPUnLsb2DtmOe5HSxvXsrvWtLBEhaTx29+Ma27Jx0ShAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQaEsEVoQdVluO3BJ06ptHL34b1XRjp4Ch6Rq24+kmjG4Nwwg+9uA9u/73EjRBqhAEihAoe3xwUQq5WTYEzp0b3ZnV/Ncf6O/9AvY9wlh/6dy3X7ncN512Zw9BVLXjuAP4np44vnQtkZoEgVkEhLBmsWiKqwsXpjbPBOn3gRfenwnc+7GBe+zsjclvonFDS9nA9Iy/u3x9+vAP3735VPk4CRUEFhcBIazFxbfm0k9fHD7k+v4nQFaPQIrx8Gmyx/GJ0J/t7ez7mw0b9MmaC2pQQgh0/ZSm4g5TwueWWtqLt0HuVy4CQljLPPYnB0depTn+b3t+8B4t0AdBUv93h2H9xc6da0aXs2m+r1WQsLRnl7NdUvfKRkAIa5nG//r1oGtsZvjTgev/kqYHF/TA+AXoqv4npJemOEiQU1Eo2l+G0movBK1UBBPU7s9E1+ILAkuNgKwSLjXiqO/khVtvARH8dxDBRkMzPrF/V+9/BlG5y9CUqlXinHv9mRPXtvuus88L9H3JPv2zD2yXExCqAicJBIFWRwAvv3Xqwq0/Pnn+lv/K+ZvfPH3p9p5W75O0fxaBp793ce3AwIDMWmYhafiVgNtwSMsXeHp4eNXJC8Nf0PAdRCiuf/XgrnWUqsqotcvnl9DmRkCdweX4b9N7+m/ih+mbMraLM14yJVwcXItKpT1VRve+ArC3Qqn+3gM7132jKEGZm6tXg86J7OhDfuA/iHwPUpfUZSfu2L59tXxEoQxeyxkEgjKeOnLxHb4RqC+NY5H3+2953d4XlrNN7Vq3ENYij+yZwbG9jpt9GkBPQ5H9zgP9607OVeWp87cOQtn9zwJf+xDMNFfj+jryPqXpxj8c2Nn7P+SXey70lidu4IXzb0DNB4tr9751+HV7zxSHyd1CERDCWiiCc+QPjUCnsaqmZ62O5IN7N/VUNP48ee7mAZDTf4Tt049iUG4Guv4ZfNLos9UIbo7qJWoJEHjy+bP7fNsoOcnW0A0/aacef8PdG28sQTNWTBVCWIs01OfPj66BpfqTmq732UnjgT1bei+Vq4pTv7HM8Ceg2/o1qLQug7T+FaaM3IqTLZdewpoHgYEjV9fphvOj+OShWa5V+CxvZtpzv/LwG/aNl4uXsPoRwI+4uEYjAJ2GmdG8L0FK2mYa+tsrkdXZy+P7x2ZuHdW14P+BLdank9q6Qwd3rf+ckFWjR6Tx5Q2cP58K9Jm3VCIr1ogt48lO237r3//96YofeG18y9q7RFklXITxPXV+5DchKb3ZDMy37Nu5tuxG4R9cHH6b42QfAzlds+3EPXu2rfrBIjRFilwkBIIR7SHoJDurFU89ZOd680Gke6JaWomvjoBIWNUxqivFD87fej0e0n8Fwvr0/t1rnyqX+QfnRz7g+8FX8Rv8vL3auF/IqhxKzR2WCPxXqKeq3krDTdj2ierpJEUtCIgOqxaUakwzNBR0D09yiqePHOjveyOkpxLr9VMXb73V97S/h3nDXx7Y2fdPkAYbncW1IgIDxy5vM7LZt/hgrnLtxyaBrJNxv/72N+6tuNhSLp+EVUZACKsyNnXHvHL+1qcgNf2KbSXu2bt9dcmS9qlzo/fARgcmCtpzB3b1/Vg5QiuslLowENyDWDn8cSjl98PgdBviu03N+rl9/WufLEwr18uDwLdevLTF1YK3xnVZ2HI1bUxrT7z5zTuXdRP78qCyeLUKYTUI25OXbm4JPO00TBj+6I7+db8ZL3ZwMOiYdG4dA1lN9HWte2iuI2NAVPapC8O/CGPR34Ip/AZIbIMo7yX8G9QMbcS09P+2b1vf5XgdrXaPfiYns9oeLLEd8D1/B7Dp0E1jGP042pXQj7RKf546cmGzp+tv1TRf6YQD35/QO3seP3xow5IfC9QqmM23naJ0ny9ysXwgq98BWc0kVhv/Nhalbqe8kd/Fr8MOSEr3zEVWrwyO3I29hl+E9LUHGf+nAXI6sGPdd8uV2YphIKnE5IyL6bLxk7cn3bdkHHefrpvJAExMZ1uBZmqeNzXtfzUzk/m/ens7LjV7Px+8d9e1579/44l0duZtge+Np5zEEw8c2pBu9na3YvtEwmrAqNE8IZvNHsep5//yjl3r/0O8yFOXbv0QCO05gP0JGIL+fjw+uj91YeRh/Dp/PtCDM7Zpfmjvjt6Xo7hW9ycmJjaYduf7Hdf/8HTGfa3rG9rYxLSWnsloPg7fijZV8oFM2Ja2a9t6EJd7bCztvHP7us4rrdD/r3/7ct9I99jEI4cOiQ3dIg2YEFYDgOUJDFj1e8TqX7cT4kImXuQr5279A4DeBEX8ayvprU4N3rovcALot/TH13T0fXDTJn0qXk4r3k9OTm4y7a6PzjjORzOOvn1kbEqbnEprPhRzwAKzwFLHk05hv6Yd6N+o3R6beG50aPSdr3qV6IJKkVp5ITIlXOCYn4Yexr0w/DO6YXymHFlR0e5r7tsM3fxgJbI6fW1ivTeT+SsYmr54cFff+5Cu5X+hb94Merp6/J/PusGvTE6724eGJ7RpSFOkKPCUZvBPBccoHBet3Rwe13rX9tw/PjXzZ5hKvr8SfhWKkeA2REAIa4GD6p0feRdWBnvxjv2PckVhVfBf4A29uG/X2i+Ui2eYn8n8NryuDr3jPfWSFV5k44UT137eshIP2K7/64cObbheqZ6lCp+Ydt8TBO7vTM5od1+/NR4SFVhoLpKKt410lnE8LTMzo3V2dLznxLkhYgQ9obiVjEDln7mVjEodfYcpw+MAsftg/7qSDbAnb97sCSb0Yei2fqOcbovVqKNnNO8HmAE9Cv3Wp+uoWjt27HpXNqH9WTKR+kBHKqEFbvo5y3N/avfu4g23R45f3WGa1k9ZicTd0zPTf/f6O7f8dT311Jp2fHzmgJlI/N70jPPe4bEZ6Kg4qw0lqlrLiNKBiLWerpTW25PUbkPXZViW62ecHz+4d8PXojTirzwEyhq8rTwYFtRjvpX/rlwJ+iSXugPbMuyKBOHo3geRJtuT7PujcmVUCuPJlhnL/9NUqvMD2eyM5sxMaIlE4n7XML907tyNjcxHQjty4sZv66Z1xEok/xNW5n4uZSf+8sT5m++vVO58wkEu5sR09pd9w/rWyET2vReujiqygrSopn/zKZN5qMeirotKeTyolm7p/+X06Wvr51ue5Gt9BISwFjiGsLl6N6SrvylXDNTK70D4mX071pwtF88w6Jd/DG/1E1u26NOV0pQL71y3/8PJVOcHMzPTWkcCH2YGOaTTaS2RTN6f1fQvvvDK1bdnbO2JZCr1SeRfn05Pa1PTU0gXJBKW+ecnzlxvCGndhFQ1NRP8bcY1/vjS9bF1V26MwHwsVKiXa3etYVw1TNhYJ3TDjQCO42jJVMcez7J+t9YyJF37ISCEtahjGjxkGDr2DJZ31D8h5vUQJL5RPkXlUMM07u3qSGidICvkzzuSlmlZb0olrK9hD9v9JCrPC196JoPMAolFg6CV+PPj54YeyWecx8Vk2v1Q0rSfhFT18LnBmzBRyNalp5qrSuq7kiAsh4SFa7oZ9M0wzI+cPHOjZPo9V1kS1z4ICGEt4lhiCvZrSa2jol7qzPXJPk6nIGbVbWfUvcr7hO9MP97ZVXpggOu6ajplYStj7l1XvbRMXbPAbp6HzSSBlkraNknrvfVCcPt2sHYi7f3pTDb47KUbYxuvKqkKpYBXKBnV869c3WgbDEixAck0FGFFfEzJzbIsO9C1TyrcymWWsLZGIHoW2rqTzdo5dXyykz0NC8l779i5vu4zwM+eHVntGP5jqVTq/6AkVc5NZ3wNH2lVxNWZNIukMSjiNd9z0+CHp5DXAdX4SAg203w8GB5IATtODHzdK8C15kEjhXvNS9rWA11dnfcMDY9prscss48RySakrOLWqODCoIKAgkuVgsS0urtD60haeV1YYVbbtjUn6/74HXvW/11huFy3PwKzT1r797Upe3jq4sib9u9Y+wxe+vh7W1N7jx49v6ZzbffnQD4/Cj1Pfjx54XiBls6GVuTUc9mQsOIO9mPQFdkIRlz4fy5JLm2ZMOqTcJaXIqpcqnixVe+rdbZ3dbc2OT0D0wZIibHSksmklslknvx+//q3PiKnXcTQae/b+LPQ3r1t0969cOL6G7o6E09qgZegdMJBpVQ1DbKCpyUt6oPKz/4NEJalCAuZFIuEVBJd+jgLh4rvAiFqUVGkhJZMWFp3Z0obGSu/d5gSnWmavuO6h+/cvYHSobgVgoAYjrb4QPMUiGtj1/79jBMkLBwiTlMASlYzTkhWCJyTrGAyMOFkst/BoYMmuIIyGJYcMXMMdNwHPhYN1qWS1t6ZLGaKZL8yzFXTr15BooLLMugHMBRNKgW+It8y9TEcJGt4rvcRFCCEVQbFdg0Swmrxkb0+cf2XOzq73kgdFieEXF2jdEUJKQH6SVWQrNjtZDKlpTPp38U58iUbthk/Ph7sN6zg/xudSGvD4xkq6otcnnjyF0XRRTflkyC0IIJE1JG0QbqGNpMNp5xFhRTcZDNoj66988SFm5vv3LX+WkGUXLYxAuXnCW3c4XbqGs9hwjv+a9lsuN+ahOJSCoLjNDAFvVUll0p1aNPp6adTweSflEszPO48oFn+4yOTmR+6enOshKyYhzWpf/jDuuf6x2aV/qNRaPG/1d0gUXWCA0uu7GhMmkqmerEc8KOVU0lMuyFQ+Ylut562YX9Sncmf7Ojo3BDZWbGLtMkiUVXSWTFNuMqWuYG530f7+/tnGFboxsfdd9mm8XdDo9O7rg6NFq0CFqZr5DWlK9qV0fZqGvZchSuPlevB2VmG/hOV4yWm3RAQwmrhEcW64qu4ykfJho52Vp3J8quBYQooqWDKADftBd6HD+5efyoKj/zR8ew/hWXY56/cnFh7a3RCTTGjuMX0SVB9qzu1qfQM+jO3dBW1g6uVSHv/qVNX10Vh4rc3AkJYLTy+WA/8ou9kJjo7bOh+DLVFZ64TEbCyBktxI5PJZj56R//Gx+NdH5vM4vuI+p8NXh9LjU1iw3EZhXc8TyPuuV9wDaaCfBjTM06N0hVWQmHBDzvSDZ5tvqYR7ZAymh8BIazmH6OKLbzv0KZvJEz3ZzEFnEolaEtV2XEaCLKadrIz//TQnk1/EU85NuH8th8Yf4j9gMZUOrNkZEVZCnsbtTU9KW18GqcKFyjh420sd2+j33pg3F8uTsLaDwEhrBYf04O7N/2t7/o/C2FoGnsIy/YGlvAwSfCvZzLOe+8oR1ZT3u/5uvHJC9dGtJlMrfqjslXVHwjpat2aLi2rjFFLjUSrFUjlO0juddXSSXx7ICCE1QbjiHO0/hofbPgwpnDTOR2V6hWNQqGUx34890noet5yaO+Gko3Y45PO7/uB/lvnrwxrWdha1absbgxo1FWtwplXqYSJY5Nn5lU3bLHQmGA/yko0plVSSjMjIITVzKNTR9sO7dv8RSeb/T9BWmMkKv4D+YzBXuljV7yxd+zfte6VeHGKrHTz4+cv38JWmyUmKzSGG5z7VndoE7kz3uPtq+Welvhwm39weVjOyaoFsBZPI4TV4gNY2Pw79mz8KyebeRIH+VEZTaX0sf27+v794TKmCxNTzr/2NOPj5wZBVjjdYSklq6jN69dyKuhqmWztivYob+RTSkPbe/xMdlMUJn77IiCE1W5jq+s4dYEO6mzsYAmvi/+CrH7LDYxPcBq4HGTFVcG1ULLT5orS1ULIkoSFI2cMHKG8obiXcteOCAhhtdmo6gaOh4EWWlkyYU9gvHswXfgV19d/7+LVkSWfBrItJJhObL/p7elQR8fUZnEV70XxPc01sM+xrzhU7toRgZIHuh07uZL6xA3LBaYB+Ar8rBsfz34YX1j+D5eu317QNGy2xPquSE4mDuXb2IujY2AgytNE67RiKFshzuwCR5s9ZSMlsK0QEMJqq+GkBKOF5yFzRoidK5BoFCeMjM/8mG+a//Xy0Li55KYLBRiTrGjwOQ1br4VMBQuKVJeQKVPxMLlvPwSEsNpsTEECmBLSgbHUpwD1YGwse59l2p+9fmuig4fiNZIowrqq/6Xeqm9Vh9JbjcOKvqFtACX7gV8kTVZvkaRoRQSEsFpx1OZoM2iKxxuHLtDcsZlgLzYZfv7m7XSv+r7fIm234XSP/8o5ktWqzqSyZr89PoXPYDTYkZvziw0NLluKayoEyq4iNVULpTF1IaDjHHZmoAW4aep9geN8fiLt998cGYdtVp7K6iqzXGJFUCAi7jdkuapsBJKcPBwgyP8YRyV7B04Q3dDbpY3jg6gupoMNla5U41BbUN9n0sr1ScKaHwEhrOYfo7paCAW0WiWknihhW/0Tabf/6tDtxpIVSIhGnz1dSXUkDL8fSHKi4/lWPId9Kp3Vxqegp8J/m9f14D6DQ/nmb281FwgkZ1Dj7bnSSFx7ICCE1R7jmO8FJJr8jCvjeNrIxFjDJBpKVaSlXhwDw384MyucBoLAGEfHI5ptO6n1YAq4FjorH9IWjUOnFlF3pj62aui3whbI33ZGQAir/UY3XCVEvzgdw/8NcSyGUhSlpVWQrFg2p39xp0JYLyIohaXxdZ2FGofG6yi85/QS32F0Asu8URgu1+2JgCjd22xcsVElPC85169Gaa1YTkRWJKpSqooBiQQzONvq9sRULKKxtzzAEJw1api2EFZjoW3K0oSwmnJY5tcoSD09HanEDztubnfO/IopyUWC6sUmZUpW5aSqkgwgK04DxxaZrFivacCaIdAuH9zaM1rSDgloOwSEsNpoSMenvU93dXb+EE5taFivKElRqd67qrNmsqIF+yjMF/i56MV2JqadYKxXMDXM6+4Wu04pf/kQEMJaPuwbWvPticwj4Il/NnTrdl7JrqaDC5wTUle1GmdWWVCw1+JotjA6PgnThsIdQrXknF8arkJi/+R355dbcrUaArU9ha3WqxXW3tHR9C5dN//T9eEJ3aGdUwP7T0V7F86Mr0VW4mF6o2NTS/ilaB2HDmb8wA2+08AuS1FNjIAQVhMPTi1NgwRkGKbxRxMz3uaJSRzVUkumOtLwo6Zc7aOkVdEhynN9NQ1cyuNqeEqD67mX9TXGyxXbJhFthYAQVosP58S0909czfqJqzdGODVqaG/IUbCWr2p0yukfp4FUtDfeir1yl8IPUGjPHFy/fqJyKolpJwSEsFp4NEfT6Z3YBvOp8MvMc0hAi9hHNQ1cBrJil5TUZxhfXsTuSdFNhoAQVpMNSD3NMTzzU1PZYAM/ProYkg3UV5rHT8lXmA7SwnwEq4FLLVkRI04HM+n0LdvzvlEPZpK2tREQwmrR8ZucCd7hePr7rw2N5PfxLUZXON1zHKz4kb0KnIttP6Njk8tyaimbwXPrsW/yq3v3bhoqaJZctjkCQlgtOMCYCnU4GedTI+NpQ32XbxH7QOmKG5nzdIWZJz8HNkKygqI9TmSL2JSiovGVn0A39c8WBcpN2yMghNWCQ4zPc0HRbr6GEs6chJFnmfl3knZO4/hmII1B6fiFG9br0s6qAeXPp2WUrhzHeXH/jr6n5pNf8rQuAkJYLTZ2kK7Wul7w6zeGx9DyUsZovOodOizosTg1TM9k1Wogpa7lIisOF+w48E/7E5B1Y/cgtdizsBKbK6c1tNioT6X9n3MDcyePOo7OoJqrC6S0+ZIYV+GSOHxvc18PJCxXG4ed13I727axqTp9yk9rX1jutkj9S4+ASFhLj/m8axwdDdbgELxfGsLpoZyqVXPVU1QugVJUV0dC27p+FaaBWWxknq6ceAljTNMiAf/BoUMbJpewWqmqSRAQCatJBqKWZpgJ731Zx9pJM4aK0hXe5vlKVFEbKFlxs3PvqpSSqpbzKztRm+gnEkktnU6/2GFMfa4wXK5XDgJCWC0y1iAR6/Z49iOjY7C5qkG6mk+3SFQGlEP8FFdnygrNFqBsn1OxP5+K5pGHbcBhqhT8fqu/v39mHkVIljZAQAirRQYx7Wj3Zj3tddQjVVJ4l50CMjHe8mqOTJCCvmoTyIrENXx7Uinbm4Gs2PZUqkObnp76i0N7N36tWl8kvn0RaGnCGhgILKPn3B3+xKVXDh8+nPseX3sOlpt13+P4uonv71WeDqLr1ampFB8S1JrulNaHc9rTMxltcpofOeWns0rTLkeIZUHRnpm5YibMf7kc9UudzYNAyyrd8ZLpWvfgQT8w+oyevXeo++bBtaEtQd9s1/ffRsV3I6eDJCp+nourgH04UZQnhIYfWm1o8xdUGCU8/E/bil89sH3dlQUVJplbHoGWJaxnXri2HTvd1nEEcCBS3z++MLi75UejQgcmJjL92ax/gNJPo6QekhVXAbdvXI3D+XQ1Bcxiu02zTAEjKFIdHTQS/S8Hd2/4YhQm/spFoCUJ6+mnL651gkwRQRmBt33gO+c3teNQYin/oG6aKX5rcKEukqqoWN+Ij5vy81v8UATDG0WGC21jlJ96K6wKPpWd8H8jChN/ZSPQcoR1+vTppJPS7iw3bIZl7n/++eFV5eJaOczX9Z2YvM1LPxWpocBHKv8qHHdMqSphGUqqahaThfj40ITBcbLnsDj6oXvu2bS4n96JVy73TYtASxHWo48GxrUx+5Cu+XY5RH3PMzLGxF0ktXLxrRoGNVPPfNtOolIrgElLGYH2wbZqcipdIFVFlDbfGhqfj9bskCaHHS/7gTt3r73Y+BqkxFZFoKUI6/C7Lu/Bl1jmlKB8PUhcHjHufuyxx/g5lbZw+BL7bX4EoiZqyS0T0uM0j1+82QSl+ua+bhxj7GjD2LicwWkLzaarigbKsmDJ7gcTmezMBw/t3ixntUfAiK8QaBmzhq8/f26j77pbaxo3w+jetPf1B5D2RE3pmzyR4/nH+Mti4Wx1dUrCHO0lSVGqskFUnakkpn6mhu086jgYHkWTW3Wbo4Tli6L5gqYHE47vfeDufVv+YflaIjU3KwItIWEdO3a9Szc0ElDNDqcLbHjmxas7a87QxAnX9ljfxcr+Mzs29ykpi1O8iJjoR/cm5o7dnUl89LRLW93dyWmVIip+Kp7pmlWqIvQ8Mga9Gslm3Efu3LX+K008HNK0ZUSgplnGMrZPGxgYsIKeXa/TA61jPu0w0+7xBx/cd3M+eZspD0wbDgWm+RXP13cODY/jWGKuGAb48jG+agNpilbqlKZoWDqDY2AyjtNUlupzYZlKpXgaxIVMNv0zd+/d+uxcaSVuZSPQ/IT13TN34QRvZW81n6HSDdMLUqmjh9tgd//Fi8OHEl3JL3Z2dh3MzGA7XU664llVWRz/QhLjNYmsmaWp/DjCjqIDdlaZTOZZ1/A+fGj7hjP5OLkQBMog0NSE9cSRszuswNhdpt31BRnazM3U9IuPHDrUuG+419eChqU+cvzqjp7u5P9KJpMPpqc51Zv9QntLkFQBEqZluVCw/7nhaP9i376+8YIouRQEyiLQtIQ1cPT8GjOw7vE8tyFtxBrb2MBXdh579FF99g0vC0nzB548ebNHT2l/aFmJj1BPBYyav9EFLaQ+jdPAVNL8/pZ13a8qiJLLOhAAjvrTRy/d0enbF+69d0tzHFhWR/vnk7Rple6mp+9uFFkRGF8LVj/08IUN8wGp2fIcPLh+4sCu9R+F3ucj0MLf4vaVVnChqYWmdaQS2jpY2vd0djh86Vqh7c3Yxm8dudTPxaW0lrn7yJEjZW0Tm7HdC2lT0xKW1xecgHE3FDWNcb7uDh6+r/96Y0prjlIO7ur7TOD5b3ayzt9ylY0Gl83qKFXZsCXrXdOlrV3djf2LBr556JOshLDmMWhPPXV6vav5O5jVxYLUhNl3iIbV8yiqpbI0bQcP85C2Xu0l3dczC0XUN4Pzb71339mFltOM+Q/0rzu5f2fvu1zH+QDOt3uZ0pbVRMRFouJK5qqeTkhVqyBdtdUmhGV5JI4cudrpd5kHiyp3tTU/8s6r+4rC2vCmaQmLWJO0Ep65INJK2tbpt75298U2HLuiLh3oX/95L+0/kHUyvwTieiUJHVEimVzy1UKeWMqv2pCoKEVFRNXT1aHawnBx80eAZj7TwcxdAc5Gi5fiaNnNT37nCk4xaV/X1IRF2B94YHt63qQVaCcfePX2K+07fMU9U7qtHev+xE/7r3cc70O+6w1gxuV0dHZiusgvJS/O7IskRXLs6KCxqj+B26t9a3uUREWi4plbQlTFYzXvu+7tB3EIUGel/L6e3TNw5NS8zYAqldss4YvzBC9C7559drAja3qvDoyg6pwCP+KBZaVOPPjazS1vMLpQKE9fuPnawDB+EqehPwzWuAuSl8LPg90WVxhJJPWQCUmPBAWTBEz1TFUGpqO3wYYvIPgr2az35a2b1/50V6f1e1NTlVcvEzB0xRekj67usu5FmS2/crvQcaol/zeeObfTSOj91dIq28PxiaOHDx9quy8LtQxhcZBqIS0Dhkl2l/3yA4e2j1Qb2JUUD1Iyz1waOQib0vsxKXsAFvH3wMB0JySwtZC+DBPTN5BOCEnhrI1BuKe9l6tIzsVCiD6E0DOabrwI2elZ09aP7N3aNxjheXvK+a1OENa0EFYEyYL9rz072Ju03ZpNQKj7Xd899cKhNrA9LASvZTY/s9GcHoK0XsrakLS8UklLxyl+/rj+/Qfu2367sJNyTS7SuZfneO7ffweBGScu3NwAqWgrTvTc5jjBZmw87tMCfRXYKQWOgula4OiBOQUZ7DZuhrAGdQXxV0zPuCaGnkv3VPGHOpPw7+QPR62OM5HhdNddGOeX2kmCbSnC4mDlSStVTFr4eLljdHV+702vWz9R66Cu5HS5h5hmHvz3QiOxwJTRo2BGgY06dm7OVhewYGAY6s75oD+ZDs4JPY9JyqSCQ7ABqftd5VFM3/j2Ja4mtsWpJQSq6ZXu5UZTKeJnsHpohiYPRqBn04nkS2+CQWW59BK2dAjwS0Y4IHDz2ERWG8Gnwm7iK9W3sFmbvrqGPzw6gW8eTmvTM07XmTPX28KYd7EQ3rjnvv1QFHbPt3zT9DcMPHd+13zzN1s+/hC2rKOo7NjeQdsxT5LEWrYjbdLw05eHtwWe9jl0542u62HZHZIVpalY/yIlP5X3MHYddLLZfy4fmYiBhNuB509vw+rG3tKY+kOwGHLi7W/cS91jS7v4s9TSnZHGLx8CICH9lXNDX+zpWfXuycnaBV2e3e567nAm4973qv0bzy1fD5qr5oEB7KXt0u7B3Loh7yhWVfypbOalh9+wr6U3mbfklLC5Hi1pDRE4ef7Wj+EEiZ+amqpvJT2bzWjJRLIPR3n9riA5i4DZg720DSIrlsrvHXSZ9p7ZGlrzSgirNcetqVp9/vz5FJTqj6JRejTdq6eBMzNpHP9s//QrF4bvrydfO6f1JrCX1mvcXlo98Kembjotr3wXwmrnp36J+pYNeh5JdqRem83O77gxkpxtW3bgOZ/g1HKJmt3U1Rw+3D+zrc89aunagnWzpq6PdxujLz388L4F78tdbtCEsJZ7BFq8/sHBoMPX/I9hyrGgnuDUUZzrnnz7yQu3HlxQQW2Ued++fZmJ1e5LoPB5k5ZpWCPXz+08du+99zrtAI0QVjuM4jL2YcIZeh+2+9wF49MFtYJSlgmHE0g/JlLWLJQPg7RmhtyXsJ18eja0tivsXhj6xy9ve/mRR5TRcG2ZmjyViN9NPkDN3Dz1FW5z9XM4i+s1ME1YcFNpUIrVLHzJzHnwjl0bn1twgW1UwPHjxxPXpztejR0HFTc+F3YXRwxdfdM9W08D0zrs4wtLaM5rkbCac1xaolWOvurhZIPIih0OdVm2haNTfqUlAFjCRnJP4HBn+iUqz6tVa2nGpTe/etsP2o2s2G8hrGqjL/FlEQC5GHghfplSUSMdvwaEA/9+4vjpa3c2stx2KIsfUek2dr+EuXNF2xEjSJx98w/tbFt7NiGsdniSl6EPp84O3W/Z1oPzXRms1GRKWdCJdeCIlJ+vlGYlh997r+70+EPH8NHJEtLCauCph+7bmj81ox1xEsJqx1Fdij4Zxi9AT2KSYBrtslgxhOD2gWOyz7AstFzx6zFHj1mGobYUYAgC9cHge3ddK5uhjQKFsNpoMJeqK6+8cm0X6noXiWUxHA8WxAdWNyQM45HFKL8dyiRpueM7jllmMGpnjO+1w9fNaxmXxiogaqlR0jQdAkeOBPjczrnOiQ6jw88ESSOA6KT7iQzOHEvavu1pZsLQg4QPP/DdZG9Xx/vWrOr+mfR03SvtNffdxleAQIgvTzjBT0w409Mpu2faufZy+vDhw5WPMa25dEnYqggIYbXqyNXY7i/jCyvdfmaVb5hdVsLp9LJGp43j1/1A7/RdvdMwPRzEboRnLVHe9vEvL3eXBOB4ZMta22H+TiqV2LJQ26u5u6Bju44Z3J7O/Lvp6cwPmBanOwQ4uNHRTWMK21bSvh1Mm642nTWCtKkH07rnTE72aOO0XZq7bIltVQSEsFp15HLthg5J/+aJE12m3tVjOPYq1/dW4cTjHnwMYhXOce8xDd3y/PJW6OpMdsTRVy4iK/rKMR/jwvz825VIHFzT3fkx13UW/dnhRy3GJyeeHEs7n1XNibUPFvY6vtGDw5vV9w0Vofn81qGhZfDhi3HX8SfQ/3HPMse9CWcCX0gel2OIFJIt+2fRH7qWRaYJG85NxldGzV4tGayFSLQ24+q9ULyu9gJfMU5ELTn6wUISTl03NHz1KzyiJLqmX657OLLdSJgoXTO7cBxyN172blier4YCvBsFdSNXV2dC35tKJrbzfPfFdjwvC/qs9MSMxxNRsSqmT6LhUDQHE+jUBE7UnATXTuLsrRn01K2l/x6+qItiR3TNG8V59KNB0DGSfNXGUXwJY2Gm+osNhpSvEBDCasIHgVLTt75/aQ0MnXpBNb2QgNYEntfr4wu/nBYpKQLtxtdwAh0SBX3VDe7nM/Ha5vf1Fb/CURS2bCTAWWuxR229qRsbQQQbUed61LfW14JVKKsTJ5sk8WUcHbtlNANyTOhgcmAGKH7p3m1FWpqtuZCu+LByVdKHVMjpKEQrBwIW9tnpXOIH+QTDSH/D9f0bmCLewDn1I4HmwtAypPDZ/oe9oXKf/aMPsWxSs/RR13FHrURiZE1gDR86tKHEdCDMKX+XCwEhrOVCvqBeHNaW6ui11/mWDtLQ1kEiWodXE4rwYgepAPssTPCMOjIdAk94TZ8pMZjch8HjDorGFUTUAwlkh64be0A9/ZCatiDZWtOyE7ClQmIdJICJFYhA+TRV4Fo5/QIHiUvrTEbkVRCxiJfsSBbfYk87OTExXxdazY5yUgiRKfpHQ1YSkONmAZY+gV4NIeVFfCXoLNA5h/Plb5LzWAyzF+IVXdNnvO/6GcsyhjC1vmWZ7s2pO3fdOqzriy9asnJxZREoerDLppDAhiIAEtCfO3F5rW0a6z1PX4/nf53nG5RqqrpieSnULEVh8cx4E7ugH78H8tG9eP/24oVezY+pkpA8b/abhPF8le75BqdsXUtaFeaTlTI2IByEoU1l8oq1mkokcZHElIRoWmpejMMCMyCvQXyy7JjjuUcgOl4tLCzCMpTHgFpcgkViX/dH/ax2Szf8m2Yqc/MN+1r7BM/C/rfCtRDWEozSkbMjq7NTY5t13dqE6dhG3wsSqlp+C9DDi0ifLrqmT1f6BgUaPjiHN0lJAGAfvpWcI4XjiHIMF6ocO/EjmMa9HeelQ1LT1PRpoce/sJwOTCQtc+kfGQp6Uxl+9JWtmL+jNEaJ0gKBgbsygR58B4sHfwV5aliVWg3vCHv6ymHcdG868IzrVsK6pnd71+/dsmXxbD3m3/W2ybn0T1/bQFe5I8euX+9ybuqbXMPbDA7ZCKV4uMOecyz+9OfmWvj9x9zEw6JW+JuOX298WhE6qtwLEV3TL1tb/AWj7sqwfqaro/sdmcyM+vBp2XzzDEzaBiQsNH+e+eeTjQ+ohwqnG0BYhfVzNYKrkOmpyauYYH8KvD8G6RPBszrC6Jq+ystl0ghzXEZjR5+O4+iZwTh+eG7Yqa5rq/3hGzzTSkXKn4YgIITVABjBP+ZzP7i8ydasrZCetuCHvIvFRs92SEdlpnCYE2LOQi12OA7RNf1yjrphHIyE9yOXPnfNMDg70DpdTf8DWDKs5rRvMVwChAWrUgh21HzllD0NrigqlxKVC7bKQuOOWeGiuI7OTkhb6T8C/Xw3xkel9cXxj6eIxiY3Hhx3X9dHsWJwDaa3l1+zd9Mt/F4tUk/ijWnP+/DBb8++LWqvnh0c7NDGta0pO7kl6zpb8AJzEUr91kYEFdeBRCt69Nm4+AsSl6jwjVGckY6VwPwUpLhLURx9xliWvxFHi/w+zB0SWCnLsVpxnoXesSI2ngp4zmRJXPgf/0IleGH51R6uwjeX5MR76qtITh7+8N9Cp4GF7Sm8Zl1s35pVXVomm/5c1vG+Wm284njHJeJq44/FjixUAld8w7uijW6+xo3MhW2S6+oIVHumqpewglJ87+LFtcFUcqur+1vxwPcZJqYPMOyhXw6GKI4+4/GwQpjCBhe+6XDIpFb06PM+np5hhS5eXzw9bLJ2pBLGv4Fe36BU4kA6IQGw8MUY6MJywVeqDs54Z69zrWdY7jI3G1ZtUiSV6zzDI3IqLLew/wu9jspl+yywrA1pEed5QceXPT3jBb/DLrA5ua5UHZ/4eMTbFx+fwvE3DJO8fANrjlctL7giJhRx9MrfR89R+VgJ1Y6currONuwd0FNsxwtV02mPlWGLy1TxlPHf6Hh8PH9xesvw9yRM+5PIRT2ZIgVKKZxWUY/PT8aTFPji0i3m4Ed1hDWV/7uY9bNGtiGqAyorJRWSqCgdkrQiR5KddrwPlsq8xfhG6efvx8dvtiQczDdmmPaldDBxSVYeZ3GJXxUMWzxq5d4fPz7Ym7X1HTAL2A7NqtJHEQ3qtCPjw3LoxB/v+OMZ5VVzR5aHWRuErYA+y4uu6fM+Xl9J/lh7bFvbY+vmv0bWos9tsXAWSLIiaSnyApHxJz6SbFSFuXTw8i86r5vVRW1m+6IHmUREAuI0lcREP5q2ztWPrO9/YK54xsXHI56+cePvj3qBfimZNS+J5FWMcrjptThsRd4dPX9+DcwEd5iQphwozfkCwJKaLv9ewHYKeicfSudwShcnJDBBOD3MTwGRO0cqLIj73jQTaejDBYaPHTBgJ/i5+HyYijd95sFhRzkzB7yL2IrCtGwezj9nOQVTUlfPwiicifnu5J0qHHd8mXHIG6ZD7JQqIk9kJK6QwAokMWRUhMaSeJ0vcfaiXNhs7PyuwpYV51Vh+EM/Pu2M9GckpyiOuZm2Wvtom+Y4me8xPbvIIujzPu6Wbvyt1ejL3U7Sv/v754ZHsORwaX3KGdwiJhO5pzY+Mivk/urVq52jTnIXlEc78LKu8qAMx/G8kHhyOicosz0ovM3IrIDKb15HSvDoOoqv+hMLYCOWI8ash0vmufryZVcqLz4u8fym3ov1xT/EVp4UDUTn4/iS0xW+sZTMojASmLqGp64iH4FRXJQ2TKj+lv7JVRTVxwQkm9APyaboGnGMzSVR6VR87ipsVT645ovOzi5tamb6zzB1/nqzjz+s9YetwLioZW5C8jq08K9+1IxS8yQsfF6ap1WL2BK8VOaJc6NbPcPrx7wJ++hmHQUPvOaQgMJ3ETtVlERDP0wVsQ19uPgcLQyt/Dc+p4jlL6k/1xa2qVyh5ApEzEoErm/DsPOTXV3de6anq36roFyRdYWVbVSshHJEMt98saIXfIu9koplYZL6m/hUz7kS/Jt0/PE8+Jj6X/Y6k+fv2tA1BKIvB/OC8WnGAmp5dpqx3XW36fjgYK/upXbhFd+BrRlqn16MfkrspkoC4hnirYjbUVWzs4rHx8uL3cerjwt0TA4RcBcsuX8Rn97q54okVsCKJJ9YkSvy1gJR4aOtnAr6OJP+L13d+BKBKMEzHhAfgDh6yzD+vqHjTDDvYpAxLqwEfVdbE9bpIEi6V27tdLP+LnzPrWS/XrRTnz5d4e79+LNY7r4kP+Z7Jv7z1LyPL0B4Tb+ci9cXLy+eJ54e8Rw//rqqcUR+HOrgYVprJbBl5E2w63oI64J7k8mUDZLGhmAXs19ucVkxP8gKQu4ptCxbMy2TW3KAGI4u1P207ztH3CDx/7bL+Cdse8h1Zy5ev7Dp8uHD7blJuy0J69TV8XW6l92Dl3cbLG6g98idbhDgdANcY1ZY9o2N4mpNr96GRf1Da3Wui0RW69F1bWslvp81LD2xDTOGu9DhQzBc7AcYfYlkAqo6A6ozqHNBYJTESGitTGShsp0qQSxT4AcoPJQw0LBlEPhBFakHDjoLvY+XgVIyg7WK77tG8n9pvpHXBbXL+OMBd7FN6KLu+uf27esbX9RHdIkLbxvCGhgYsDb3v2a7obt7YHakpKmYiqgE2ioqJbzIOszXcSov/DAzRRNehyJKvPx4+igv/ZLKEaCkoZxUFMYXE1I8f7Xyq/UHp9CkAlfbCF3NdlhS7IQguA0N2wiJYy1ktC5IISb1Okr5jSYruy2SGlYkIkKLSC3yy/WrUWGzSnjaTUX/QEhYQuNewLCdwBFKRkpOuAfr4sBnwwfDg6B0MHagORhBHNqHw5WxTwYav6lAt/42MBLfrYZXHO9w3Ftr/B0Hp0pY+tkD29ddAz5ln8NGjddSlNPyhHV8aKjbzAS7Dd3egRcvgRHJWyrHASw9Pyp+vlSxEluH0jWAGQF9VVZMpxHVRZ/xSKQU4PR5Xy0+/sLQZCFS9DN/XKtSeh5WrL2x+sMyZv+W67+vwz5eC7oDx12rm9pakNg639B68XL3Qh+2Bm94DySxHhg0daBHSQhiCbyyyMS9SDi8RhEHyYP1qD9qak0S4VGn5VYrSTRKEkKHWYYiHuQmCYb/YKYLqS+3H5LYckxJmz6qhSYJ5yNgzgtuclESpncBfN8Fj3lgJdCSGpHcGECoxrouMoHjzO+4evLLMB1VKxJV8Wyj8Q80Ix043jnTu32hlTdkh08Yn7UWcnio9Qs3pzZm0lN7LCOxIdIZxbuQ1+lAVFFxJB7aMeUIiPkiPRPjo2v6dPF4FVjHnxi/oQK0Az/bymf5uI7ayGLj6eM63nrbF5VNXzV7nv3HViQL3JAEaSV1z0iBNJIgJBCYkSKJYbdjEiSHw7a0BI5s6QBBbINUswMUsQ6E11UojZGccA9dcZDBdQY+TgyFTgkiEKYyIBvstAQzIRk8cBJ+A2j4gZFDFWAqjAp3V5IhQYYwwUJ57ByS0QINzMYK8FyrRxt3KNbXb2qG/UVNT5wDyCt6/A0boGbdqzPA4tD21SPquWihPy1FWHjQzYs3xnZkM95ePIZd8RccBx1xez/UPowp46I4+uVcLD9/8Plq0Gfy6Jp+uez5uqPyY+UtNN5DuVQc06drpv4bIDXsjtsMpdkOSC79QK4Xog3PzwF4IBNCBiIhpBSpoE8jioqWaM2KCRuOqwLXgIQItKIe0lCYD/lZjoqgGIo0+J++SsmMKA8eqQ21qHuUh2PfzQHN6vgG6vVK8GfmQhcbr3Yff+AEi3rtdCtNF8u/eIWD2ATXx4Mg0XH1Vr/hm7sDQw8PvyvTrriKWocEE0C6oM/kJRJHrAykgj6WGlq+JUifu6YfS6pu4/UVa6AgQcXKi78ApekhcWFBwMstEkTX9MvVHw+Lt2ex+4+Pg62CxgsHEwZbAdgWIJfA+ICkfDRYtyAwWWB7Ay8F8VT/KB0bOJ4Gx/CQfUKSwZGrJJs8iZHYgB0zMB+zk8hopQ8hEcEog2ERASIBAOL5fIrVIKLxXKtzKPZLgZUckvGf+/nH5HsK0+Uz3316zeAjj3D23Lwu90w0ZwNpiZ72UnvwfO/AXIFnXfLBxLOsHn6yiLqmr3oQ04LHX9hq6TFHI6txrlYWkHj98UT1lh8vryR/rIKq6aO204drdP8hRWF3itmLUw42QnW1CSTSA2IAIXkWOBYKLWw8wjVqNkEaFqjFwLQNJhWI4ZiFoiq6QX0SbsEo6HMoWVFCYprwjw6FP65BXCSoXJwiOwpnFK9A6yiWkQhRDwA9XAfpwLS/AqnqSKP7jwapquiznXFXMn6x8Yg/X/HySvLHKqiaPlZfvf0H6BloAM/v3tpzHkJwUx59Uxb4GE5Lfnt2ZGS16SX3+F5mq4llfegtwnaSR6J5EC8hPUV6IDaS6aDnoZ5DpYe6AtdgOr4pyhXLNPH0KKCo/DDP7N+S+mI6qHzbQr7AbdgW+iylWn0l5cf6E29ftfSN6L9lGl04x30tOtMHklmLhxpClW9BL4S1T+i2uNPRp+0FflD0AN9A9LHnmHGBBfJCE3QL9ALiguoJqiu+64gDzWGIIAlhzhaSDsMV/yjJi3BxyY9khP9BXBSzEMY/AFORGMmM1yyKZfmm+ZKuJf4uMHV1THEj+o+S864E7zYd/8Dliqp2MamvPbt9uw4dY/M4DnXTuMuXx/scK9iHLcbryzfKwvOJBSGNPl10Tb8WV0xYyMFymDdXXv46Kq+ueChJQI4WlSUqf8StOf5CNdXqr9afxe8/Gm6AoLAqGKyCGLSG350ACFzKM2FvaeOseEhFOsjItdQ2S6wYYmkOdl2+CfLBvmpIV55vYY2Qn6uAxAWC40zbhxSmWArcQj0TSIiSU37mx0kgVesgLereOSz8E5EWJa6Qzyh1hZEcO7xY4Ct9WLfNvwa+5xA2h6uGP6vMPxMsZ8WNf0Gf+cOCw9usq51a5+kNG9Sn1IjJsjoO0LI7EpVra/vxhPdFs7JyjYriohlbTAKGxO1C6oJEljseOLqmTxfPX66OucJK66OUNzuDjK7p05UIbGwX25I/vrj4BYrnD0uZ/Rtvfzz9fPsPIkgkbL0DZNMFRVEHFEY2ZCBTcwMLdfCsCCVN4SwpE9YG+ARNgD24IDHYSYB1yNCYDkLRFoC8oOUG40AKQx5IYyAmlQ6SF7dDoSof0hbJiApzqLs43aPc5UG+AvVQ/4T7nGQFQiJ5kdbAkmgH2Sz0FaWB4gLrad22v4nmuvPt/yzCc1+V4t0e4z93r8PYwDCvNANxLSthkai0jmCf5+jq6y6Y4SkjTfoKprgWufj9Dg3AozBmiK7pl3H8WDH3u0YfLY6u6c/HVS2vSvsxoygyTF2q/qNenEyjJ5NJPYGPRidME1M1/JYqwyoNq32Ihu4J0z5M+WA2DoqwEI9wfmEaEhQJzPNsKNOh0jJwrfRVJqbnNOrC6IGwQFzgHiKrpCuq2kE+FizrMXWE7IWCEKemg7hSiimOQchNIC3EchqpHlBO95TshQThkwF5TL9k+Mm/MZLGzVo3AlQdLzagDle1vCYd/wU9/5Z5ZcyZPnNow/J8ZHZZCGtsbKw3rdn7nIzTx42o0WfP1cPKuYJ6XPFs5q7p8zmKx5v8cdcxDeMPOR1fj+gh4X10TV/dukiC+nJPeLy8eH1hrtm/UVvpKxcrP2oL/dlcs1eQ9PCeo73wGcp+R2Xyvlp74vH19B9EkoA2CYKUlcQqJCQj6vkoyBjh/IurcJiy4Zxy2FMptRBO7sK3kClR0UYUZAX+wMqfC1ICiYHMYBsKSQsSFKaAUEqZLoiK00ASFsgpN0UEUWE6yOkiiArE6NmUb91OWwAAEuNJREFUszCNxA0c/uBoF04W86YOarWQAYjGmHBBEIkUiXEqib025hNmInWknv6zKo77Sh3/RvcfSx5Xl4O4yr5Y7NxiuEEQFT4uvs8yrF5VvosX28LLS185vsiRHkc9YPiJtrCbJIzHyx3gJdfpl80flZWPR6qIxJghus7xjSqj4E9UNn2VvN76Csqq6XIR+48OYEeGlcAaXhLfQwxNQcgQEI9IErOOxBUuCuDLz9Arm5iyOTaYy7Jty8hAb2VCm43ZmwnwQTbgFpAWyA4SGEKhaMdgYNpngKAcpeMCAfFjYGE4yAqco3RZ0LorUqOkxVkf6AgzvFBPFbISSsOUD+WRrWijpcwbmI4Gomj4yxAIv4bPVU+q9sfxk/EP36UlfP49N3vNWr/m9CZdX/zzjDDofAoW3XHVr9NPHdB8p2+uORl/mjFLUktMbBTtkSJbpLCRxYyD5OpJps/4+DJuvq5IIgoLqfi3pLzcRuloM7QSzKImsBSWG80LVKkxkSvOkFHaCjL5QvrPN9rwvaSVtEg2ICmQCNRQkGjwnlOpNktMxdds+GxcRFrIyCmhTQMEUJjl4qwtzPbAOVC8o0DUZroGiMmBpEUfRBZ4DvRUJC4/1GOpij1ML9XU0PJdFxIZGsOpJkkOQ0YdFh5CPodKl0WfRqQkVUhTIEf1iN4GkdJU4Rx/xsJfHkpfMv4cd+IAUJb1+YdkfSU7NXp6+/bti7qquKiEdfVq0Gl2TO2DonYzAcUTCv0slCB8FuGia/q8j7iAPl30aNIPHVKq55w+00MvjFLo05WmV8H5P9XLzydVF/H0xbGl9UGfjm226B98po2u6fO+0f3H9M7SbT1h+FoS00ybSmm+5/RZHxzbwWvVHtSvNuLRR4BKl0vPtHRhWh1SESUsNBkH0qjvNiAx4MA1JDBc4yBmTPmwJArJCFM+dA1SE5XsmFIqRTzKUrZYkMio78IUkauFoW6Mcbin1GWrOR8nqOEUEUQFmuK3ZdEw6NFg92s9j3XLp0CIsAuS8VdPkcKhCZ9/KAc81x/c3NdzFjy6KHZc0YPNh7VhDg9jYnh4co9n2dvx1nLalys7Rimx2xLGigfEJBQ0Xr149FkBVb04BQiTlPAFbTiDxRGKM1pJf5AgarPKG0sQu413N07hkCANO5m0fSebtCwziW5DqMISHTRMJCDF23inYbmsauNCHq+Vn1ta5dErzKN8psP/RiIXVpAegKJQ30Y06AQSEXdAIpdL0wbTNsLpoSIeCwRJHZYBpTusIFAIlPC0iqL5AxoCcmLPQkkLdITRCc0dSFqQD1A51g4pLOXmhZCwDMO2BpH9q6ZtDoU4oKQIy5yEynFnv+mzw+0+/q3Sf5yT4aYs89zq1alLIK7wYeQANcCpgW5AOaqIARzxcudrXrMTz+cuFAxBI1Rw06eLKz3xsnDikt+Mmr9mWBlXrbySeJAlTt8MXJImXHRNv0zx2GpWZ3r0KKqzXHlRHH26+fQf+mkbg56ADjppUuihMJl7BEhGtmnj+4Phj1lEUAzjaQcgJkzcqPPmlI/yjdJV8Trf/+hbeYyP0uMS0zSVF8SEaSELxkhR6a7IC1IVHkNMBWEkCljxYQ7YXgWKrDCHw2ohJDDKSkr5Tst3TANBp7DdgkTFKSOpxYMtV2i3hXQoJjwbBo3L4oibAajdXmSbCl01PEvi6x3PetMvwfi3cv+xHpPRk8GZvo6Oq5y5FvZlvtfqQZ5v5igfH7iRdHqrn/H24McyEb6ejCUxkCwqEATi8JDNKtWRIxI6wrLj+aOyQgIqLT/KTZ+OLYnCFGHE60PdSgzIgVmcfrbt5evjYkB97VeNyv8plx/UYoChElhYgB7KtD3PAUWRpejIVNzNAjNzyDuYRqnrMF5dIx4CkTrlAJQRps2FhZIX5lqYwfFLOygTBeSmkUhDEgNvIC7MR5ML6JhozoCpn+858G1utbH4j7BRT0Z9VlZzbTyOKJCKeCjkqYbkFBJh+DXCPVcKuXKIFURlm8WBoZSFOBCYmk6i33ioT+Kw1CegEMspcFfe+M8+rRySNum/YUwm9I7TPT04NWOBDg/nwtz16xMbEp3mPswIOuI6G7wBSlynz1pQWZEIP0smIcEEWN3QsfJDn+nj9FFSPh73wilgdE2f+eOumo4pPqWI2kI/LKu4RVXLq7H/kJopRUFhnkj4joNT9KC/BlZgAIVD1I+cwASVUBgCIsF1KEQxJLpGPKHGP5LYrAs5ikREnmJ61KF4K5cG1+REVS6HC1JauGroYYcOrLWUEp6MSF0UpoZgK5hV2dgEzeNLYbMBnRQZEUPnOwGMT6GOp57Kg/0WTCMYjnsQHpDmlJFTR5IcNt/alvV1PdF5NsKcLSpGG03L6QcjnWDpeIXqgFYb//A9wGi1+fMPDeqY7nae6uvT530KKp+JebkhHJyX6Fqz33X83tCgRr1d6gXBH+XnFtEwDmEVMBfAtbK7UvHxVTb1gGLQokbFVBZMDtUJHmT+dsPxmqSRU2nkrxkWxhfbOfEVwLov4sIaonSRr1qZy6vy8xliPbn+qPjYHxSm6mJwdB357DfaVtJ/BMLeW0/ayVQSR6TA5AB7h8kwmFeRrFBUSFYkJk7GsM+F5SuiCQmFBEriCskHYcxfEM9ozBjBS/yaKD//rBzndjD3BHswAcmqwFdhOWGugCw5owwpEt9sxMlVGWQEK4GlcAOi1XAcL6eLICfdcMFmNDnH7xdO/YTCHTkxM2B6EiSPbuXmHrZO5eJy4Iu6lfo2Gu8orFfA+PM9UMjnHpBIx9v+/Q9Wm8nMfcMTE1d7u7vP4Ec6fzy1wqOGP3xI63JHjgT2/rsy/boTbMP0pe78dVUWS5wjK0VUjIqNN3kA62ZYeIcfxofXDFNFUZBTT4W6m71mWBlXrb4yWSoEYWh0jVIUdJEmzA6o18mRDN7dCplCEkK8IiP4WRAU9OO8j5wimZB3SAhKYlJEphLkJCaSEP7PEdxsfVG5UWFxP6qPPngTlvBED6IWLN8dTPmg8ocFPPRXWBdlFWqqCEmLlhAgLRtKdLaAkpQNfRUM6DUQGOUiTimNEaT7FvRVw/F6K91XG4/mHf9KPaovvJ36jzfSS1mpc6mUdhnvhZL4a0GjZsKBKK+n0+kt0AHvztCAsIzjeeAeUKVPF1l101cBWCICxcGmcPalUeHRnyguIsJYej79fFnpKxdjrKhu+spVK69Ke+OW6SXlh7Xk/8b7D5umJKY6nUiQAEmp5ZKoD5Ay8kTFzcAsJIrL+ZREYCWAaU4ubXRNP8wfpuSuGubHMwCJhSuGPCiYJIMw5GV6xkfY0Wd+WoPiBAlEhvnzNluw3SKZYTkQHIQ5J1RQDg7Lw/QQGUIdFp4wcC9KgQ/7KkxjucEHROVmc3ZaCFfEjMxUvlPvBZ0WhT1Q1zG06hQKyGPA9qEh4bPRJuO/0p//WvoPyXpa77BPr9L1mn64QiJRT0vlP3jg1oyn0/th1dnN6VOkQyh8wVRuPpLUH9GHi+sckD4vLaj43NSHLwfv8cKjbGxdgc97JUpFpIRbpovKYHTUltkpHYkyEqNYf1gWfZU+Vn+JiMZERS4qKyTAMv1hmwoItLT/aL6OL9cn8A4mknhDkR5CUuh43ExhAXjnIQVxRQ9UwnU1JM73meHISINzlY/1Ir3jwNQBtui5IpU3K2mFZbEUEhgJiHlZhkqI8rws7hPFxBHlZ5romu1CGRSv2HyQEQiLPkwefJcSk2o0mU+F8Z46KswbKd8qvRUWiq7BsuoYlF/q+Jd839p4/KNnFHhw+Fbc819r/y3dHO7qsk9D2lLPBvEq59SLXC6CYSCq1OTk5F48g+FxLyQSvvyzhFK8taaYL1ACiYdkkSOg/HVO4irmAySLlR8+yHy5wnaWysTF7YmnRxdyecMXFDcxx3KjNCUEGUtb2r4Iixwh5qebxEG58v2Hkh0ERqlLp5kClNLkngLSyF8XExrZi089SYbFm9DRg1FCbEKyoxQE8sqFkTOgTwrDVIPCP/k8qpRcGrxMEXmxnpwjUeXbhjpgA2bBNsp0HPQWOiwNOnddw5YcNIdSFyzTlUKehEbrLDxDNn7osjCXPw5FO22qgPfKHn/pf8XxxxetvSvYlX8BxBVKCdGDmPPDhz0W+Oijjxof//jHt+Hh2oko/qKqFx4l0BJQmQIwS3RNn/fxZXqGFbq4nQzimI9tKFs+S1S1KJ9XoQkEfUQwtKg98fSzefMMwmx5F28/IqK2RLjM2b54/gX0H0v6+IiDZSVgHJogfYWNzDMUpCtsUkKg4pKIUJAsnNTlkjNWzfBCPMOhi8JAiCSqPBmyMFVQ1OdctQwLywNZ5cPCpDl80D6IhjzBASQF0sUeREpSJCyE4ceSpJXbEO2612AHepaTSRn/YrtEAD3n8xV/ntv4+S96nyGRO9gccQZmEPiBK3bRi5kPHcG+v2T32n2+53bxNY8oQyWIB0SR9OmqxMeTh5lm/8azx8srEbCQNSqTpUTX+eagwCiPqiWeQAXO/olHV2tPaYUFjWCxsQJjt7MV564K6iOB2Xj1adNGa3PqDMFl4XwSSnAQCUIibqFPlwtTwbiOkoSR+JvLx3KYv9BXaSrlLyifSegQBNMFTAWhiIeFArRZnoX+8Y2EzKhbnuNlYO9wFpZXkwoH5Kmj/6qOFTz+0n8+Y4Y/2pVIcJqY35+YJ6wjEN33ZzL9kPY3hWjx6Sv+RcByLIQAZZYQJSn2C944FRF/QkvjQ31XZDcV04GVPOGl+WdJEhVGbaNPV3d7Va7ZP83U/1ACgzTjkg4gjUFvHhGWkrPAPnnBLNeFSEKKfAbzOu9yBAUdVj6cZURpZuU3XOUILioD93x2IEnxxFGc9c6M+M93cHSNZVzHquBQDeMn4x898wQ2us7pgGvAbyU8/z5e5EupVEqtJirCgp4KHxVI7sbrQIYKHyKF3+yvIvEEX8FsQNk9qXwgBpgQwNo7p9OKrukzfdzF08+WTmYrV35YF+tU8bEpYImInGtLVH+8PkzZ8iQcVpjrawXCLOHH5uo/9JmWjbXHJMQcNhVW8bOklbsumnJw7Q+cgtVK2mJxAUNNKKncp54KHuzAwnjCE01B1UIHA1A80ik/IkdIfTj6mE8MXh2sSKZhdHUd+IcDykwFLj4eMv7Fv+il75c8/xEmeHaojD+jZ4LgbsPVVvO5iutg4oSAFCCiAqVp/jrUKRU8mzVexsube05ff3tiD0Q1wkP/ojrYgeiaftiheHsjLKL4GrudTxYvb0H9h94bpzeAwCD4cAqJf5SmlBjFH5D8ChVC1Q8KyIkrjtgbE64y4lqtINJHel5Hq4q4ZdsYzsWBWaU+rkFWtFzQbiNNnWciNbT/qD4+Hitq/FdE/3mWzmvQU+W4hZZPenQuRHRNfylcvfVjpUqz0Tj6dNE1/fm4euufTx1z5am3/hr6z6lj9A9ElneKwPJ3IYEVEpqKys0YFeUhoDBP4TV/+bjVIkfqKuu8/ixC/+tqR73111V4DYnrrb+G8a+h1tkk9dY/m7MxV7XUzwdP3ApBgCYG6Co+L6/+kcB4X0g0ERFFzwXjojBc5q8ZhqOKtWEoROmLEwSWBIHowVySyqSS5kIABEYhisRFEov8SgRWGD6K9OMgq8IwBIkTBBYXASGsxcW3pUoHgfF5iIiLPv9x+03kuLxMqaqsUj1KJL4gsFgICGEtFrJtUG6OwDhtJHHhqLOl+dBAG0AnXRAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBIGVhMD/D0fV/fpMMM+gAAAAAElFTkSuQmCC"
  }
};
const noticeBar = {
  // noticeBar
  noticeBar: {
    text: () => [],
    direction: "row",
    step: false,
    icon: "volume",
    mode: "",
    color: "#f9ae3d",
    bgColor: "#fdf6ec",
    speed: 80,
    fontSize: 14,
    duration: 2e3,
    disableTouch: true,
    url: "",
    linkType: "navigateTo"
  }
};
const notify = {
  // notify
  notify: {
    top: 0,
    type: "primary",
    color: "#ffffff",
    bgColor: "",
    message: "",
    duration: 3e3,
    fontSize: 15,
    safeAreaInsetTop: false
  }
};
const numberBox = {
  // 
  numberBox: {
    name: "",
    value: 0,
    min: 1,
    max: Number.MAX_SAFE_INTEGER,
    step: 1,
    integer: false,
    disabled: false,
    disabledInput: false,
    asyncChange: false,
    inputWidth: 35,
    showMinus: true,
    showPlus: true,
    decimalLength: null,
    longPress: true,
    color: "#323233",
    buttonSize: 30,
    bgColor: "#EBECEE",
    cursorSpacing: 100,
    disableMinus: false,
    disablePlus: false,
    iconStyle: ""
  }
};
const numberKeyboard = {
  // 
  numberKeyboard: {
    mode: "number",
    dotDisabled: false,
    random: false
  }
};
const overlay = {
  // overlay
  overlay: {
    show: false,
    zIndex: 10070,
    duration: 300,
    opacity: 0.5
  }
};
const parse = {
  // parse
  parse: {
    copyLink: true,
    errorImg: "",
    lazyLoad: false,
    loadingImg: "",
    pauseVideo: true,
    previewImg: true,
    setTitle: true,
    showImgMenu: true
  }
};
const picker = {
  // picker
  picker: {
    show: false,
    showToolbar: true,
    title: "",
    columns: () => [],
    loading: false,
    itemHeight: 44,
    cancelText: "",
    confirmText: "",
    cancelColor: "#909193",
    confirmColor: "#3c9cff",
    visibleItemCount: 5,
    keyName: "text",
    closeOnClickOverlay: false,
    defaultIndex: () => [],
    immediateChange: false
  }
};
const popup = {
  // popup
  popup: {
    show: false,
    overlay: true,
    mode: "bottom",
    duration: 300,
    closeable: false,
    overlayStyle: () => {
    },
    closeOnClickOverlay: true,
    zIndex: 10075,
    safeAreaInsetBottom: true,
    safeAreaInsetTop: false,
    closeIconPos: "top-right",
    round: 0,
    zoom: true,
    bgColor: "",
    overlayOpacity: 0.5
  }
};
const radio = {
  // radio
  radio: {
    name: "",
    shape: "",
    disabled: "",
    labelDisabled: "",
    activeColor: "",
    inactiveColor: "",
    iconSize: "",
    labelSize: "",
    label: "",
    labelColor: "",
    size: "",
    iconColor: "",
    placement: ""
  }
};
const radioGroup = {
  // radio-group
  radioGroup: {
    value: "",
    disabled: false,
    shape: "circle",
    activeColor: "#2979ff",
    inactiveColor: "#c8c9cc",
    name: "",
    size: 18,
    placement: "row",
    label: "",
    labelColor: "#303133",
    labelSize: 14,
    labelDisabled: false,
    iconColor: "#ffffff",
    iconSize: 12,
    borderBottom: false,
    iconPlacement: "left"
  }
};
const rate = {
  // rate
  rate: {
    value: 1,
    count: 5,
    disabled: false,
    size: 18,
    inactiveColor: "#b2b2b2",
    activeColor: "#FA3534",
    gutter: 4,
    minCount: 1,
    allowHalf: false,
    activeIcon: "star-fill",
    inactiveIcon: "star",
    touchable: true
  }
};
const readMore = {
  // readMore
  readMore: {
    showHeight: 400,
    toggle: false,
    closeText: "",
    openText: "",
    color: "#2979ff",
    fontSize: 14,
    textIndent: "2em",
    name: ""
  }
};
const row = {
  // row
  row: {
    gutter: 0,
    justify: "start",
    align: "center"
  }
};
const rowNotice = {
  // rowNotice
  rowNotice: {
    text: "",
    icon: "volume",
    mode: "",
    color: "#f9ae3d",
    bgColor: "#fdf6ec",
    fontSize: 14,
    speed: 80
  }
};
const scrollList = {
  // scrollList
  scrollList: {
    indicatorWidth: 50,
    indicatorBarWidth: 20,
    indicator: true,
    indicatorColor: "#f2f2f2",
    indicatorActiveColor: "#3c9cff",
    indicatorStyle: ""
  }
};
const search = {
  // search
  search: {
    shape: "round",
    bgColor: "#f2f2f2",
    placeholder: "",
    clearabled: true,
    focus: false,
    showAction: true,
    actionStyle: () => ({}),
    actionText: "",
    inputAlign: "left",
    inputStyle: () => ({}),
    disabled: false,
    borderColor: "transparent",
    searchIconColor: "#909399",
    searchIconSize: 22,
    color: "#606266",
    placeholderColor: "#909399",
    searchIcon: "search",
    margin: "0",
    animation: false,
    value: "",
    maxlength: "-1",
    height: 32,
    label: null
  }
};
const section = {
  // u-section
  section: {
    title: "",
    subTitle: "",
    right: true,
    fontSize: 15,
    bold: true,
    color: "#303133",
    subColor: "#909399",
    showLine: true,
    lineColor: "",
    arrow: true
  }
};
const skeleton = {
  // skeleton
  skeleton: {
    loading: true,
    animate: true,
    rows: 0,
    rowsWidth: "100%",
    rowsHeight: 18,
    title: true,
    titleWidth: "50%",
    titleHeight: 18,
    avatar: false,
    avatarSize: 32,
    avatarShape: "circle"
  }
};
const slider = {
  // slider
  slider: {
    value: 0,
    blockSize: 18,
    min: 0,
    max: 100,
    step: 1,
    activeColor: "#2979ff",
    inactiveColor: "#c0c4cc",
    blockColor: "#ffffff",
    showValue: false,
    disabled: false,
    blockStyle: () => {
    }
  }
};
const statusBar = {
  // statusBar
  statusBar: {
    bgColor: "transparent"
  }
};
const steps = {
  // steps
  steps: {
    direction: "row",
    current: 0,
    activeColor: "#3c9cff",
    inactiveColor: "#969799",
    activeIcon: "",
    inactiveIcon: "",
    dot: false
  }
};
const stepsItem = {
  // steps-item
  stepsItem: {
    title: "",
    desc: "",
    iconSize: 17,
    error: false
  }
};
const sticky = {
  // sticky
  sticky: {
    offsetTop: 0,
    customNavHeight: 0,
    disabled: false,
    bgColor: "transparent",
    zIndex: "",
    index: ""
  }
};
const subsection = {
  // subsection
  subsection: {
    list: [],
    current: 0,
    activeColor: "#3c9cff",
    inactiveColor: "#303133",
    mode: "button",
    fontSize: 12,
    bold: true,
    bgColor: "#eeeeef",
    keyName: "name"
  }
};
const swipeAction = {
  // swipe-action
  swipeAction: {
    autoClose: true
  }
};
const swipeActionItem = {
  // swipeActionItem 
  swipeActionItem: {
    show: false,
    name: "",
    disabled: false,
    threshold: 20,
    autoClose: true,
    options: [],
    duration: 300
  }
};
const swiper = {
  // swiper 
  swiper: {
    list: () => [],
    indicator: false,
    indicatorActiveColor: "#FFFFFF",
    indicatorInactiveColor: "rgba(255, 255, 255, 0.35)",
    indicatorStyle: "",
    indicatorMode: "line",
    autoplay: true,
    current: 0,
    currentItemId: "",
    interval: 3e3,
    duration: 300,
    circular: false,
    previousMargin: 0,
    nextMargin: 0,
    acceleration: false,
    displayMultipleItems: 1,
    easingFunction: "default",
    keyName: "url",
    imgMode: "aspectFill",
    height: 130,
    bgColor: "#f3f4f6",
    radius: 4,
    loading: false,
    showTitle: false
  }
};
const swipterIndicator = {
  // swiperIndicator 
  swiperIndicator: {
    length: 0,
    current: 0,
    indicatorActiveColor: "",
    indicatorInactiveColor: "",
    indicatorMode: "line"
  }
};
const _switch = {
  // switch
  switch: {
    loading: false,
    disabled: false,
    size: 25,
    activeColor: "#2979ff",
    inactiveColor: "#ffffff",
    value: false,
    activeValue: true,
    inactiveValue: false,
    asyncChange: false,
    space: 0
  }
};
const tabbar = {
  // tabbar
  tabbar: {
    value: null,
    safeAreaInsetBottom: true,
    border: true,
    zIndex: 1,
    activeColor: "#1989fa",
    inactiveColor: "#7d7e80",
    fixed: true,
    placeholder: true
  }
};
const tabbarItem = {
  //
  tabbarItem: {
    name: null,
    icon: "",
    badge: null,
    dot: false,
    text: "",
    badgeStyle: "top: 6px;right:2px;"
  }
};
const tabs = {
  //
  tabs: {
    duration: 300,
    list: () => [],
    lineColor: "#3c9cff",
    activeStyle: () => ({
      color: "#303133"
    }),
    inactiveStyle: () => ({
      color: "#606266"
    }),
    lineWidth: 20,
    lineHeight: 3,
    lineBgSize: "cover",
    itemStyle: () => ({
      height: "44px"
    }),
    scrollable: true,
    current: 0,
    keyName: "name"
  }
};
const tag = {
  // tag 
  tag: {
    type: "primary",
    disabled: false,
    size: "medium",
    shape: "square",
    text: "",
    bgColor: "",
    color: "",
    borderColor: "",
    closeColor: "#C6C7CB",
    name: "",
    plainFill: false,
    plain: false,
    closable: false,
    show: true,
    icon: ""
  }
};
const text = {
  // text 
  text: {
    type: "",
    show: true,
    text: "",
    prefixIcon: "",
    suffixIcon: "",
    mode: "",
    href: "",
    format: "",
    call: false,
    openType: "",
    bold: false,
    block: false,
    lines: "",
    color: "#303133",
    size: 15,
    iconStyle: () => ({
      fontSize: "15px"
    }),
    decoration: "none",
    margin: 0,
    lineHeight: "",
    align: "left",
    wordWrap: "normal"
  }
};
const textarea = {
  // textarea 
  textarea: {
    value: "",
    placeholder: "",
    placeholderClass: "textarea-placeholder",
    placeholderStyle: "color: #c0c4cc",
    height: 70,
    confirmType: "done",
    disabled: false,
    count: false,
    focus: false,
    autoHeight: false,
    fixed: false,
    cursorSpacing: 0,
    cursor: "",
    showConfirmBar: true,
    selectionStart: -1,
    selectionEnd: -1,
    adjustPosition: true,
    disableDefaultPadding: false,
    holdKeyboard: false,
    maxlength: 140,
    border: "surround",
    formatter: null
  }
};
const toast = {
  // toast
  toast: {
    zIndex: 10090,
    loading: false,
    text: "",
    icon: "",
    type: "",
    loadingMode: "",
    show: "",
    overlay: false,
    position: "center",
    params: () => {
    },
    duration: 2e3,
    isTab: false,
    url: "",
    callback: null,
    back: false
  }
};
const toolbar = {
  // toolbar 
  toolbar: {
    show: true,
    cancelText: "",
    confirmText: "",
    cancelColor: "#909193",
    confirmColor: "#3c9cff",
    title: ""
  }
};
const tooltip = {
  // tooltip 
  tooltip: {
    text: "",
    copyText: "",
    size: 14,
    color: "#606266",
    bgColor: "transparent",
    direction: "top",
    zIndex: 10071,
    showCopy: true,
    buttons: () => [],
    overlay: true,
    showToast: true
  }
};
const transition = {
  // transitionprops
  transition: {
    show: false,
    mode: "fade",
    duration: "300",
    timingFunction: "ease-out"
  }
};
const upload = {
  // upload
  upload: {
    accept: "image",
    capture: () => ["album", "camera"],
    compressed: true,
    camera: "back",
    maxDuration: 60,
    uploadIcon: "camera-fill",
    uploadIconColor: "#D3D4D6",
    useBeforeRead: false,
    previewFullImage: true,
    maxCount: 52,
    disabled: false,
    imageMode: "aspectFill",
    name: "",
    sizeType: () => ["original", "compressed"],
    multiple: false,
    deletable: true,
    maxSize: Number.MAX_VALUE,
    fileList: () => [],
    uploadText: "",
    width: 80,
    height: 80,
    previewImage: true
  }
};
const props = {
  ...actionSheet,
  ...album,
  ...alert,
  ...avatar,
  ...avatarGroup,
  ...backtop,
  ...badge,
  ...button,
  ...calendar,
  ...carKeyboard,
  ...cell,
  ...cellGroup,
  ...checkbox,
  ...checkboxGroup,
  ...circleProgress,
  ...code,
  ...codeInput,
  ...col,
  ...collapse,
  ...collapseItem,
  ...columnNotice,
  ...countDown,
  ...countTo,
  ...datetimePicker,
  ...divider,
  ...empty,
  ...form,
  ...formItem,
  ...gap,
  ...grid,
  ...gridItem,
  ...icon,
  ...image,
  ...indexAnchor,
  ...indexList,
  ...input,
  ...keyboard,
  ...line,
  ...lineProgress,
  ...link,
  ...list,
  ...listItem,
  ...loadingIcon,
  ...loadingPage,
  ...loadmore,
  ...modal,
  ...navbar,
  ...noNetwork,
  ...noticeBar,
  ...notify,
  ...numberBox,
  ...numberKeyboard,
  ...overlay,
  ...parse,
  ...picker,
  ...popup,
  ...radio,
  ...radioGroup,
  ...rate,
  ...readMore,
  ...row,
  ...rowNotice,
  ...scrollList,
  ...search,
  ...section,
  ...skeleton,
  ...slider,
  ...statusBar,
  ...steps,
  ...stepsItem,
  ...sticky,
  ...subsection,
  ...swipeAction,
  ...swipeActionItem,
  ...swiper,
  ...swipterIndicator,
  ..._switch,
  ...tabbar,
  ...tabbarItem,
  ...tabs,
  ...tag,
  ...text,
  ...textarea,
  ...toast,
  ...toolbar,
  ...tooltip,
  ...transition,
  ...upload
};
const zIndex = {
  toast: 10090,
  noNetwork: 10080,
  // popuppopupactionsheetkeyboardpicker
  popup: 10075,
  mask: 10070,
  navbar: 980,
  topTips: 975,
  sticky: 970,
  indexListSticky: 965
};
let platform = "none";
platform = "vue3";
platform = "weixin";
platform = "mp";
const platform$1 = platform;
const $u = {
  route,
  date: index.timeFormat,
  // date
  colorGradient: colorGradient$1.colorGradient,
  hexToRgb: colorGradient$1.hexToRgb,
  rgbToHex: colorGradient$1.rgbToHex,
  colorToRgba: colorGradient$1.colorToRgba,
  test,
  type: ["primary", "success", "error", "warning", "info"],
  http: new Request(),
  config,
  // uView
  zIndex,
  debounce,
  throttle,
  mixin: mixin$1,
  mpMixin,
  props,
  ...index,
  color,
  platform: platform$1
};
index$2.$u = $u;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var aliyunOssSdk$1 = { exports: {} };
(function(module2, exports2) {
  (function(global2) {
    (function(f2) {
      {
        module2.exports = f2();
      }
    })(function() {
      return (/* @__PURE__ */ function() {
        function r(e2, n2, t2) {
          function o2(i2, f2) {
            if (!n2[i2]) {
              if (!e2[i2]) {
                var c = "function" == typeof commonjsRequire && commonjsRequire;
                if (!f2 && c)
                  return c(i2, true);
                if (u2)
                  return u2(i2, true);
                var a2 = new Error("Cannot find module '" + i2 + "'");
                throw a2.code = "MODULE_NOT_FOUND", a2;
              }
              var p2 = n2[i2] = { exports: {} };
              e2[i2][0].call(p2.exports, function(r2) {
                var n3 = e2[i2][1][r2];
                return o2(n3 || r2);
              }, p2, p2.exports, r, e2, n2, t2);
            }
            return n2[i2].exports;
          }
          for (var u2 = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t2.length; i++)
            o2(t2[i]);
          return o2;
        }
        return r;
      }())({ 1: [function(require2, module3, exports3) {
        var OSS2 = require2("./browser/client");
        OSS2.Buffer = require2("buffer").Buffer;
        OSS2.urllib = require2("../shims/xhr");
        OSS2.version = require2("./browser/version").version;
        module3.exports = OSS2;
      }, { "../shims/xhr": 546, "./browser/client": 3, "./browser/version": 6, "buffer": 103 }], 2: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.slice.js");
        var assert2 = require2("assert");
        var _require = require2("../common/utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports3;
        function isArray2(arr) {
          if (Array.isArray)
            return Array.isArray(arr);
          return Object.prototype.toString.call(arr) === "[object Array]";
        }
        function toArray(obj) {
          if (!obj)
            return [];
          if (isArray2(obj))
            return obj;
          return [obj];
        }
        proto.useBucket = function useBucket(name) {
          _checkBucketName(name);
          this.options.bucket = name;
          return this;
        };
        proto.setBucket = function useBucket(name) {
          _checkBucketName(name);
          this.options.bucket = name;
          return this;
        };
        proto.getBucket = function getBucket() {
          return this.options.bucket;
        };
        proto.deleteBucket = /* @__PURE__ */ function() {
          var _deleteBucket = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    params = this._bucketRequestParams("DELETE", name, "", options);
                    _context.next = 3;
                    return this.request(params);
                  case 3:
                    result = _context.sent;
                    if (!(result.status === 200 || result.status === 204)) {
                      _context.next = 6;
                      break;
                    }
                    return _context.abrupt("return", {
                      res: result.res
                    });
                  case 6:
                    _context.next = 8;
                    return this.requestError(result);
                  case 8:
                    throw _context.sent;
                  case 9:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function deleteBucket(_x, _x2) {
            return _deleteBucket.apply(this, arguments);
          }
          return deleteBucket;
        }();
        proto.putBucketACL = /* @__PURE__ */ function() {
          var _putBucketACL = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(name, acl, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee2$(_context2) {
              while (1)
                switch (_context2.prev = _context2.next) {
                  case 0:
                    params = this._bucketRequestParams("PUT", name, "acl", options);
                    params.headers = {
                      "x-oss-acl": acl
                    };
                    params.successStatuses = [200];
                    _context2.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context2.sent;
                    return _context2.abrupt("return", {
                      bucket: result.headers.location && result.headers.location.substring(1) || null,
                      res: result.res
                    });
                  case 7:
                  case "end":
                    return _context2.stop();
                }
            }, _callee2, this);
          }));
          function putBucketACL(_x3, _x4, _x5) {
            return _putBucketACL.apply(this, arguments);
          }
          return putBucketACL;
        }();
        proto.getBucketACL = /* @__PURE__ */ function() {
          var _getBucketACL = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee3$(_context3) {
              while (1)
                switch (_context3.prev = _context3.next) {
                  case 0:
                    params = this._bucketRequestParams("GET", name, "acl", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context3.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context3.sent;
                    return _context3.abrupt("return", {
                      acl: result.data.AccessControlList.Grant,
                      owner: {
                        id: result.data.Owner.ID,
                        displayName: result.data.Owner.DisplayName
                      },
                      res: result.res
                    });
                  case 7:
                  case "end":
                    return _context3.stop();
                }
            }, _callee3, this);
          }));
          function getBucketACL(_x6, _x7) {
            return _getBucketACL.apply(this, arguments);
          }
          return getBucketACL;
        }();
        proto.putBucketLogging = /* @__PURE__ */ function() {
          var _putBucketLogging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(name, prefix, options) {
            var params, xml, result;
            return _regenerator.default.wrap(function _callee4$(_context4) {
              while (1)
                switch (_context4.prev = _context4.next) {
                  case 0:
                    params = this._bucketRequestParams("PUT", name, "logging", options);
                    xml = '<?xml version="1.0" encoding="UTF-8"?>\n<BucketLoggingStatus>\n<LoggingEnabled>\n<TargetBucket>'.concat(name, "</TargetBucket>\n");
                    if (prefix) {
                      xml += "<TargetPrefix>".concat(prefix, "</TargetPrefix>\n");
                    }
                    xml += "</LoggingEnabled>\n</BucketLoggingStatus>";
                    params.content = xml;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context4.next = 9;
                    return this.request(params);
                  case 9:
                    result = _context4.sent;
                    return _context4.abrupt("return", {
                      res: result.res
                    });
                  case 11:
                  case "end":
                    return _context4.stop();
                }
            }, _callee4, this);
          }));
          function putBucketLogging(_x8, _x9, _x10) {
            return _putBucketLogging.apply(this, arguments);
          }
          return putBucketLogging;
        }();
        proto.getBucketLogging = /* @__PURE__ */ function() {
          var _getBucketLogging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(name, options) {
            var params, result, enable;
            return _regenerator.default.wrap(function _callee5$(_context5) {
              while (1)
                switch (_context5.prev = _context5.next) {
                  case 0:
                    params = this._bucketRequestParams("GET", name, "logging", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context5.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context5.sent;
                    enable = result.data.LoggingEnabled;
                    return _context5.abrupt("return", {
                      enable: !!enable,
                      prefix: enable && enable.TargetPrefix || null,
                      res: result.res
                    });
                  case 8:
                  case "end":
                    return _context5.stop();
                }
            }, _callee5, this);
          }));
          function getBucketLogging(_x11, _x12) {
            return _getBucketLogging.apply(this, arguments);
          }
          return getBucketLogging;
        }();
        proto.deleteBucketLogging = /* @__PURE__ */ function() {
          var _deleteBucketLogging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee6$(_context6) {
              while (1)
                switch (_context6.prev = _context6.next) {
                  case 0:
                    params = this._bucketRequestParams("DELETE", name, "logging", options);
                    params.successStatuses = [204, 200];
                    _context6.next = 4;
                    return this.request(params);
                  case 4:
                    result = _context6.sent;
                    return _context6.abrupt("return", {
                      res: result.res
                    });
                  case 6:
                  case "end":
                    return _context6.stop();
                }
            }, _callee6, this);
          }));
          function deleteBucketLogging(_x13, _x14) {
            return _deleteBucketLogging.apply(this, arguments);
          }
          return deleteBucketLogging;
        }();
        proto.putBucketCORS = /* @__PURE__ */ function() {
          var _putBucketCORS = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7(name, rules, options) {
            var params, xml, parseOrigin, parseMethod, parseHeader, parseExposeHeader, i, l, rule, result;
            return _regenerator.default.wrap(function _callee7$(_context7) {
              while (1)
                switch (_context7.prev = _context7.next) {
                  case 0:
                    rules = rules || [];
                    assert2(rules.length, "rules is required");
                    rules.forEach(function(rule2) {
                      assert2(rule2.allowedOrigin, "allowedOrigin is required");
                      assert2(rule2.allowedMethod, "allowedMethod is required");
                    });
                    params = this._bucketRequestParams("PUT", name, "cors", options);
                    xml = '<?xml version="1.0" encoding="UTF-8"?>\n<CORSConfiguration>';
                    parseOrigin = function parseOrigin2(val) {
                      xml += "<AllowedOrigin>".concat(val, "</AllowedOrigin>");
                    };
                    parseMethod = function parseMethod2(val) {
                      xml += "<AllowedMethod>".concat(val, "</AllowedMethod>");
                    };
                    parseHeader = function parseHeader2(val) {
                      xml += "<AllowedHeader>".concat(val, "</AllowedHeader>");
                    };
                    parseExposeHeader = function parseExposeHeader2(val) {
                      xml += "<ExposeHeader>".concat(val, "</ExposeHeader>");
                    };
                    for (i = 0, l = rules.length; i < l; i++) {
                      rule = rules[i];
                      xml += "<CORSRule>";
                      toArray(rule.allowedOrigin).forEach(parseOrigin);
                      toArray(rule.allowedMethod).forEach(parseMethod);
                      toArray(rule.allowedHeader).forEach(parseHeader);
                      toArray(rule.exposeHeader).forEach(parseExposeHeader);
                      if (rule.maxAgeSeconds) {
                        xml += "<MaxAgeSeconds>".concat(rule.maxAgeSeconds, "</MaxAgeSeconds>");
                      }
                      xml += "</CORSRule>";
                    }
                    xml += "</CORSConfiguration>";
                    params.content = xml;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context7.next = 16;
                    return this.request(params);
                  case 16:
                    result = _context7.sent;
                    return _context7.abrupt("return", {
                      res: result.res
                    });
                  case 18:
                  case "end":
                    return _context7.stop();
                }
            }, _callee7, this);
          }));
          function putBucketCORS(_x15, _x16, _x17) {
            return _putBucketCORS.apply(this, arguments);
          }
          return putBucketCORS;
        }();
        proto.getBucketCORS = /* @__PURE__ */ function() {
          var _getBucketCORS = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee8(name, options) {
            var params, result, rules, CORSRule;
            return _regenerator.default.wrap(function _callee8$(_context8) {
              while (1)
                switch (_context8.prev = _context8.next) {
                  case 0:
                    params = this._bucketRequestParams("GET", name, "cors", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context8.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context8.sent;
                    rules = [];
                    if (result.data && result.data.CORSRule) {
                      CORSRule = result.data.CORSRule;
                      if (!isArray2(CORSRule))
                        CORSRule = [CORSRule];
                      CORSRule.forEach(function(rule) {
                        var r = {};
                        Object.keys(rule).forEach(function(key) {
                          r[key.slice(0, 1).toLowerCase() + key.slice(1, key.length)] = rule[key];
                        });
                        rules.push(r);
                      });
                    }
                    return _context8.abrupt("return", {
                      rules,
                      res: result.res
                    });
                  case 9:
                  case "end":
                    return _context8.stop();
                }
            }, _callee8, this);
          }));
          function getBucketCORS(_x18, _x19) {
            return _getBucketCORS.apply(this, arguments);
          }
          return getBucketCORS;
        }();
        proto.deleteBucketCORS = /* @__PURE__ */ function() {
          var _deleteBucketCORS = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee9(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee9$(_context9) {
              while (1)
                switch (_context9.prev = _context9.next) {
                  case 0:
                    params = this._bucketRequestParams("DELETE", name, "cors", options);
                    params.successStatuses = [204];
                    _context9.next = 4;
                    return this.request(params);
                  case 4:
                    result = _context9.sent;
                    return _context9.abrupt("return", {
                      res: result.res
                    });
                  case 6:
                  case "end":
                    return _context9.stop();
                }
            }, _callee9, this);
          }));
          function deleteBucketCORS(_x20, _x21) {
            return _deleteBucketCORS.apply(this, arguments);
          }
          return deleteBucketCORS;
        }();
        proto.putBucketReferer = /* @__PURE__ */ function() {
          var _putBucketReferer = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee10(name, allowEmpty, referers, options) {
            var params, xml, i, result;
            return _regenerator.default.wrap(function _callee10$(_context10) {
              while (1)
                switch (_context10.prev = _context10.next) {
                  case 0:
                    params = this._bucketRequestParams("PUT", name, "referer", options);
                    xml = '<?xml version="1.0" encoding="UTF-8"?>\n<RefererConfiguration>\n';
                    xml += "  <AllowEmptyReferer>".concat(allowEmpty ? "true" : "false", "</AllowEmptyReferer>\n");
                    if (referers && referers.length > 0) {
                      xml += "  <RefererList>\n";
                      for (i = 0; i < referers.length; i++) {
                        xml += "    <Referer>".concat(referers[i], "</Referer>\n");
                      }
                      xml += "  </RefererList>\n";
                    } else {
                      xml += "  <RefererList />\n";
                    }
                    xml += "</RefererConfiguration>";
                    params.content = xml;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context10.next = 10;
                    return this.request(params);
                  case 10:
                    result = _context10.sent;
                    return _context10.abrupt("return", {
                      res: result.res
                    });
                  case 12:
                  case "end":
                    return _context10.stop();
                }
            }, _callee10, this);
          }));
          function putBucketReferer(_x22, _x23, _x24, _x25) {
            return _putBucketReferer.apply(this, arguments);
          }
          return putBucketReferer;
        }();
        proto.getBucketReferer = /* @__PURE__ */ function() {
          var _getBucketReferer = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee11(name, options) {
            var params, result, referers;
            return _regenerator.default.wrap(function _callee11$(_context11) {
              while (1)
                switch (_context11.prev = _context11.next) {
                  case 0:
                    params = this._bucketRequestParams("GET", name, "referer", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context11.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context11.sent;
                    referers = result.data.RefererList.Referer || null;
                    if (referers) {
                      if (!isArray2(referers)) {
                        referers = [referers];
                      }
                    }
                    return _context11.abrupt("return", {
                      allowEmpty: result.data.AllowEmptyReferer === "true",
                      referers,
                      res: result.res
                    });
                  case 9:
                  case "end":
                    return _context11.stop();
                }
            }, _callee11, this);
          }));
          function getBucketReferer(_x26, _x27) {
            return _getBucketReferer.apply(this, arguments);
          }
          return getBucketReferer;
        }();
        proto.deleteBucketReferer = /* @__PURE__ */ function() {
          var _deleteBucketReferer = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee12(name, options) {
            return _regenerator.default.wrap(function _callee12$(_context12) {
              while (1)
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return this.putBucketReferer(name, true, null, options);
                  case 2:
                    return _context12.abrupt("return", _context12.sent);
                  case 3:
                  case "end":
                    return _context12.stop();
                }
            }, _callee12, this);
          }));
          function deleteBucketReferer(_x28, _x29) {
            return _deleteBucketReferer.apply(this, arguments);
          }
          return deleteBucketReferer;
        }();
        proto._bucketRequestParams = function _bucketRequestParams(method, bucket, subres, options) {
          return {
            method,
            bucket,
            subres,
            additionalHeaders: options && options.additionalHeaders,
            timeout: options && options.timeout,
            ctx: options && options.ctx
          };
        };
      }, { "../common/utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "assert": 95, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/web.dom-collections.for-each.js": 380 }], 3: [function(require2, module3, exports3) {
        (function(Buffer2, process) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
            require2("core-js/modules/es.function.name.js");
            require2("core-js/modules/es.object.assign.js");
            require2("core-js/modules/es.array.includes.js");
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.replace.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.symbol.js");
            require2("core-js/modules/es.symbol.description.js");
            require2("core-js/modules/es.array.slice.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.regexp.to-string.js");
            var debug = require2("debug")("ali-oss");
            var xml = require2("xml2js");
            var AgentKeepalive = require2("agentkeepalive");
            var merge = require2("merge-descriptors");
            var platform2 = require2("platform");
            var utility = require2("utility");
            var urllib = require2("urllib");
            var pkg = require2("./version");
            var bowser = require2("bowser");
            var signUtils = require2("../common/signUtils");
            var _initOptions = require2("../common/client/initOptions");
            var _require = require2("../common/utils/createRequest"), createRequest = _require.createRequest;
            var _require2 = require2("../common/utils/encoder"), encoder = _require2.encoder;
            var _require3 = require2("../common/client/getReqUrl"), getReqUrl = _require3.getReqUrl;
            var _require4 = require2("../common/utils/setSTSToken"), setSTSToken = _require4.setSTSToken;
            var _require5 = require2("../common/utils/retry"), retry = _require5.retry;
            var _require6 = require2("../common/utils/isFunction"), isFunction2 = _require6.isFunction;
            var _require7 = require2("../common/utils/getStandardRegion"), getStandardRegion = _require7.getStandardRegion;
            var globalHttpAgent = new AgentKeepalive();
            function _unSupportBrowserTip() {
              var name = platform2.name, version2 = platform2.version;
              if (name && name.toLowerCase && name.toLowerCase() === "ie" && version2.split(".")[0] < 10) {
                index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:577", "ali-oss does not support the current browser");
              }
            }
            function isHttpsWebProtocol() {
              return location && location.protocol === "https:";
            }
            function Client(options, ctx) {
              _unSupportBrowserTip();
              if (!(this instanceof Client)) {
                return new Client(options, ctx);
              }
              if (options && options.inited) {
                this.options = options;
              } else {
                this.options = Client.initOptions(options);
              }
              this.options.cancelFlag = false;
              if (this.options.urllib) {
                this.urllib = this.options.urllib;
              } else {
                this.urllib = urllib;
                this.agent = this.options.agent || globalHttpAgent;
              }
              this.ctx = ctx;
              this.userAgent = this._getUserAgent();
              this.stsTokenFreshTime = /* @__PURE__ */ new Date();
              this.options.amendTimeSkewed = 0;
            }
            module3.exports = Client;
            Client.initOptions = function initOptions(options) {
              if (!options.stsToken) {
                index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:620", "Please use STS Token for safety, see more details at https://help.aliyun.com/document_detail/32077.html");
              }
              var opts = Object.assign({
                secure: isHttpsWebProtocol(),
                // for browser compatibility disable fetch.
                useFetch: false
              }, options);
              return _initOptions(opts);
            };
            var proto = Client.prototype;
            proto.debug = debug;
            merge(proto, require2("./object"));
            merge(proto, require2("./bucket"));
            merge(proto, require2("../common/bucket/getBucketWebsite"));
            merge(proto, require2("../common/bucket/putBucketWebsite"));
            merge(proto, require2("../common/bucket/deleteBucketWebsite"));
            merge(proto, require2("../common/bucket/getBucketLifecycle"));
            merge(proto, require2("../common/bucket/putBucketLifecycle"));
            merge(proto, require2("../common/bucket/deleteBucketLifecycle"));
            merge(proto, require2("../common/bucket/putBucketVersioning"));
            merge(proto, require2("../common/bucket/getBucketVersioning"));
            merge(proto, require2("../common/bucket/getBucketInventory"));
            merge(proto, require2("../common/bucket/deleteBucketInventory"));
            merge(proto, require2("../common/bucket/listBucketInventory"));
            merge(proto, require2("../common/bucket/putBucketInventory"));
            merge(proto, require2("../common/bucket/abortBucketWorm"));
            merge(proto, require2("../common/bucket/completeBucketWorm"));
            merge(proto, require2("../common/bucket/extendBucketWorm"));
            merge(proto, require2("../common/bucket/getBucketWorm"));
            merge(proto, require2("../common/bucket/initiateBucketWorm"));
            merge(proto, require2("./managed-upload"));
            merge(proto, require2("../common/multipart-copy"));
            merge(proto, require2("../common/multipart"));
            merge(proto, require2("../common/parallel"));
            proto.signature = function signature(stringToSign) {
              this.debug("authorization stringToSign: %s", stringToSign, "info");
              return signUtils.computeSignature(this.options.accessKeySecret, stringToSign, this.options.headerEncoding);
            };
            proto._getReqUrl = getReqUrl;
            proto.authorization = function authorization(method, resource, subres, headers) {
              var stringToSign = signUtils.buildCanonicalString(method.toUpperCase(), resource, {
                headers,
                parameters: subres
              });
              return signUtils.authorization(this.options.accessKeyId, this.options.accessKeySecret, stringToSign, this.options.headerEncoding);
            };
            proto.authorizationV4 = function authorizationV4(method, requestParams, bucketName, objectName, additionalHeaders) {
              return signUtils.authorizationV4(this.options.accessKeyId, this.options.accessKeySecret, getStandardRegion(this.options.region), method, requestParams, bucketName, objectName, additionalHeaders, this.options.headerEncoding);
            };
            proto.request = /* @__PURE__ */ function() {
              var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(params) {
                var _this = this;
                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1)
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!this.options.retryMax) {
                          _context.next = 6;
                          break;
                        }
                        _context.next = 3;
                        return retry(request.bind(this), this.options.retryMax, {
                          errorHandler: function errorHandler(err) {
                            var _errHandle = function _errHandle2(_err) {
                              if (params.stream)
                                return false;
                              var statusErr = [-1, -2].includes(_err.status);
                              var requestErrorRetryHandle = _this.options.requestErrorRetryHandle || function() {
                                return true;
                              };
                              return statusErr && requestErrorRetryHandle(_err);
                            };
                            if (_errHandle(err))
                              return true;
                            return false;
                          }
                        })(params);
                      case 3:
                        return _context.abrupt("return", _context.sent);
                      case 6:
                        return _context.abrupt("return", request.call(this, params));
                      case 7:
                      case "end":
                        return _context.stop();
                    }
                }, _callee, this);
              }));
              return function(_x) {
                return _ref.apply(this, arguments);
              };
            }();
            function request(_x2) {
              return _request.apply(this, arguments);
            }
            function _request() {
              _request = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(params) {
                var reqParams, result, reqErr, useStream, err, parseData;
                return _regenerator.default.wrap(function _callee4$(_context4) {
                  while (1)
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        if (!(this.options.stsToken && isFunction2(this.options.refreshSTSToken))) {
                          _context4.next = 3;
                          break;
                        }
                        _context4.next = 3;
                        return setSTSToken.call(this);
                      case 3:
                        reqParams = createRequest.call(this, params);
                        if (!this.options.useFetch) {
                          reqParams.params.mode = "disable-fetch";
                        }
                        useStream = !!params.stream;
                        _context4.prev = 6;
                        _context4.next = 9;
                        return this.urllib.request(reqParams.url, reqParams.params);
                      case 9:
                        result = _context4.sent;
                        this.debug("response %s %s, got %s, headers: %j", params.method, reqParams.url, result.status, result.headers, "info");
                        _context4.next = 16;
                        break;
                      case 13:
                        _context4.prev = 13;
                        _context4.t0 = _context4["catch"](6);
                        reqErr = _context4.t0;
                      case 16:
                        if (!(result && params.successStatuses && params.successStatuses.indexOf(result.status) === -1)) {
                          _context4.next = 28;
                          break;
                        }
                        _context4.next = 19;
                        return this.requestError(result);
                      case 19:
                        err = _context4.sent;
                        if (!(err.code === "RequestTimeTooSkewed" && !useStream)) {
                          _context4.next = 25;
                          break;
                        }
                        this.options.amendTimeSkewed = +new Date(err.serverTime) - /* @__PURE__ */ new Date();
                        _context4.next = 24;
                        return this.request(params);
                      case 24:
                        return _context4.abrupt("return", _context4.sent);
                      case 25:
                        err.params = params;
                        _context4.next = 32;
                        break;
                      case 28:
                        if (!reqErr) {
                          _context4.next = 32;
                          break;
                        }
                        _context4.next = 31;
                        return this.requestError(reqErr);
                      case 31:
                        err = _context4.sent;
                      case 32:
                        if (!err) {
                          _context4.next = 34;
                          break;
                        }
                        throw err;
                      case 34:
                        if (!params.xmlResponse) {
                          _context4.next = 39;
                          break;
                        }
                        _context4.next = 37;
                        return this.parseXML(result.data);
                      case 37:
                        parseData = _context4.sent;
                        result.data = parseData;
                      case 39:
                        return _context4.abrupt("return", result);
                      case 40:
                      case "end":
                        return _context4.stop();
                    }
                }, _callee4, this, [[6, 13]]);
              }));
              return _request.apply(this, arguments);
            }
            proto._getResource = function _getResource(params) {
              var resource = "/";
              if (params.bucket)
                resource += "".concat(params.bucket, "/");
              if (params.object)
                resource += encoder(params.object, this.options.headerEncoding);
              return resource;
            };
            proto._escape = function _escape(name) {
              return utility.encodeURIComponent(name).replace(/%2F/g, "/");
            };
            proto._getUserAgent = function _getUserAgent() {
              var agent = process && process.browser ? "js" : "nodejs";
              var sdk = "aliyun-sdk-".concat(agent, "/").concat(pkg.version);
              var plat = platform2.description;
              if (!plat && process) {
                plat = "Node.js ".concat(process.version.slice(1), " on ").concat(process.platform, " ").concat(process.arch);
              }
              return this._checkUserAgent("".concat(sdk, " ").concat(plat));
            };
            proto._checkUserAgent = function _checkUserAgent(ua) {
              var userAgent = ua.replace(/\u03b1/, "alpha").replace(/\u03b2/, "beta");
              return userAgent;
            };
            proto.checkBrowserAndVersion = function checkBrowserAndVersion(name, version2) {
              return bowser.name === name && bowser.version.split(".")[0] === version2;
            };
            proto.parseXML = function parseXMLThunk(str) {
              return new Promise(function(resolve2, reject) {
                if (Buffer2.isBuffer(str)) {
                  str = str.toString();
                }
                xml.parseString(str, {
                  explicitRoot: false,
                  explicitArray: false
                }, function(err, result) {
                  if (err) {
                    reject(err);
                  } else {
                    resolve2(result);
                  }
                });
              });
            };
            proto.requestError = /* @__PURE__ */ function() {
              var _requestError = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(result) {
                var _this2 = this;
                var err, setError, ossErr, message, _message;
                return _regenerator.default.wrap(function _callee3$(_context3) {
                  while (1)
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        err = null;
                        setError = /* @__PURE__ */ function() {
                          var _ref2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(message2) {
                            var info, msg;
                            return _regenerator.default.wrap(function _callee2$(_context2) {
                              while (1)
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    _context2.prev = 0;
                                    _context2.next = 3;
                                    return _this2.parseXML(message2);
                                  case 3:
                                    _context2.t0 = _context2.sent;
                                    if (_context2.t0) {
                                      _context2.next = 6;
                                      break;
                                    }
                                    _context2.t0 = {};
                                  case 6:
                                    info = _context2.t0;
                                    _context2.next = 16;
                                    break;
                                  case 9:
                                    _context2.prev = 9;
                                    _context2.t1 = _context2["catch"](0);
                                    _this2.debug(message2, "error");
                                    _context2.t1.message += "\nraw xml: ".concat(message2);
                                    _context2.t1.status = result.status;
                                    _context2.t1.requestId = result.headers && result.headers["x-oss-request-id"];
                                    return _context2.abrupt("return", _context2.t1);
                                  case 16:
                                    msg = info.Message || "unknow request error, status: ".concat(result.status);
                                    if (info.Condition) {
                                      msg += " (condition: ".concat(info.Condition, ")");
                                    }
                                    err = new Error(msg);
                                    err.name = info.Code ? "".concat(info.Code, "Error") : "UnknownError";
                                    err.status = result.status;
                                    err.code = info.Code;
                                    err.ecCode = info.EC;
                                    err.requestId = info.RequestId;
                                    err.hostId = info.HostId;
                                    err.serverTime = info.ServerTime;
                                    return _context2.abrupt("return", err);
                                  case 27:
                                  case "end":
                                    return _context2.stop();
                                }
                            }, _callee2, null, [[0, 9]]);
                          }));
                          return function setError2(_x4) {
                            return _ref2.apply(this, arguments);
                          };
                        }();
                        if (!(!result.data || !result.data.length)) {
                          _context3.next = 38;
                          break;
                        }
                        if (!(result.status === -1 || result.status === -2)) {
                          _context3.next = 10;
                          break;
                        }
                        err = new Error(result.message);
                        err.name = result.name;
                        err.status = result.status;
                        err.code = result.name;
                        _context3.next = 36;
                        break;
                      case 10:
                        if (!(result.status === 404)) {
                          _context3.next = 17;
                          break;
                        }
                        err = new Error("Object not exists");
                        err.name = "NoSuchKeyError";
                        err.status = 404;
                        err.code = "NoSuchKey";
                        _context3.next = 34;
                        break;
                      case 17:
                        if (!(result.status === 412)) {
                          _context3.next = 24;
                          break;
                        }
                        err = new Error("Pre condition failed");
                        err.name = "PreconditionFailedError";
                        err.status = 412;
                        err.code = "PreconditionFailed";
                        _context3.next = 34;
                        break;
                      case 24:
                        err = new Error("Unknow error, status: ".concat(result.status));
                        err.name = "UnknownError";
                        err.status = result.status;
                        err.res = result;
                        ossErr = result.headers && result.headers["x-oss-err"];
                        if (!ossErr) {
                          _context3.next = 34;
                          break;
                        }
                        message = atob(ossErr);
                        _context3.next = 33;
                        return setError(message);
                      case 33:
                        err = _context3.sent;
                      case 34:
                        err.requestId = result.headers && result.headers["x-oss-request-id"];
                        err.host = "";
                      case 36:
                        _context3.next = 43;
                        break;
                      case 38:
                        _message = String(result.data);
                        this.debug("request response error data: %s", _message, "error");
                        _context3.next = 42;
                        return setError(_message);
                      case 42:
                        err = _context3.sent;
                      case 43:
                        this.debug("generate error %j", err, "error");
                        return _context3.abrupt("return", err);
                      case 45:
                      case "end":
                        return _context3.stop();
                    }
                }, _callee3, this);
              }));
              function requestError(_x3) {
                return _requestError.apply(this, arguments);
              }
              return requestError;
            }();
          }).call(this);
        }).call(this, { "isBuffer": require2("../../node_modules/is-buffer/index.js") }, require2("_process"));
      }, { "../../node_modules/is-buffer/index.js": 409, "../common/bucket/abortBucketWorm": 7, "../common/bucket/completeBucketWorm": 8, "../common/bucket/deleteBucketInventory": 9, "../common/bucket/deleteBucketLifecycle": 10, "../common/bucket/deleteBucketWebsite": 11, "../common/bucket/extendBucketWorm": 12, "../common/bucket/getBucketInventory": 13, "../common/bucket/getBucketLifecycle": 14, "../common/bucket/getBucketVersioning": 15, "../common/bucket/getBucketWebsite": 16, "../common/bucket/getBucketWorm": 17, "../common/bucket/initiateBucketWorm": 18, "../common/bucket/listBucketInventory": 19, "../common/bucket/putBucketInventory": 20, "../common/bucket/putBucketLifecycle": 21, "../common/bucket/putBucketVersioning": 22, "../common/bucket/putBucketWebsite": 23, "../common/client/getReqUrl": 25, "../common/client/initOptions": 26, "../common/multipart": 30, "../common/multipart-copy": 29, "../common/parallel": 51, "../common/signUtils": 52, "../common/utils/createRequest": 58, "../common/utils/encoder": 62, "../common/utils/getStandardRegion": 65, "../common/utils/isFunction": 72, "../common/utils/retry": 80, "../common/utils/setSTSToken": 82, "./bucket": 2, "./managed-upload": 4, "./object": 5, "./version": 6, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "_process": 538, "agentkeepalive": 94, "bowser": 101, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.includes.js": 315, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.function.name.js": 322, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.string.replace.js": 345, "core-js/modules/es.symbol.description.js": 351, "core-js/modules/es.symbol.js": 354, "debug": 536, "merge-descriptors": 428, "platform": 440, "urllib": 546, "utility": 545, "xml2js": 496 }], 4: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
            require2("core-js/modules/es.function.name.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.array.from.js");
            require2("core-js/modules/es.string.iterator.js");
            require2("core-js/modules/es.array.map.js");
            require2("core-js/modules/es.array.filter.js");
            require2("core-js/modules/es.array.find.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.regexp.to-string.js");
            require2("core-js/modules/es.array.slice.js");
            require2("core-js/modules/es.array.iterator.js");
            require2("core-js/modules/es.array-buffer.slice.js");
            require2("core-js/modules/es.typed-array.uint8-array.js");
            require2("core-js/modules/es.typed-array.copy-within.js");
            require2("core-js/modules/es.typed-array.every.js");
            require2("core-js/modules/es.typed-array.fill.js");
            require2("core-js/modules/es.typed-array.filter.js");
            require2("core-js/modules/es.typed-array.find.js");
            require2("core-js/modules/es.typed-array.find-index.js");
            require2("core-js/modules/es.typed-array.for-each.js");
            require2("core-js/modules/es.typed-array.includes.js");
            require2("core-js/modules/es.typed-array.index-of.js");
            require2("core-js/modules/es.typed-array.iterator.js");
            require2("core-js/modules/es.typed-array.join.js");
            require2("core-js/modules/es.typed-array.last-index-of.js");
            require2("core-js/modules/es.typed-array.map.js");
            require2("core-js/modules/es.typed-array.reduce.js");
            require2("core-js/modules/es.typed-array.reduce-right.js");
            require2("core-js/modules/es.typed-array.reverse.js");
            require2("core-js/modules/es.typed-array.set.js");
            require2("core-js/modules/es.typed-array.slice.js");
            require2("core-js/modules/es.typed-array.some.js");
            require2("core-js/modules/es.typed-array.sort.js");
            require2("core-js/modules/es.typed-array.subarray.js");
            require2("core-js/modules/es.typed-array.to-locale-string.js");
            require2("core-js/modules/es.typed-array.to-string.js");
            var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
            var util = require2("util");
            var path = require2("path");
            var mime = require2("mime");
            var copy = require2("copy-to");
            var _require = require2("../common/utils/isBlob"), isBlob = _require.isBlob;
            var _require2 = require2("../common/utils/isFile"), isFile = _require2.isFile;
            var _require3 = require2("../common/utils/isBuffer"), isBuffer = _require3.isBuffer;
            var proto = exports3;
            proto.multipartUpload = /* @__PURE__ */ function() {
              var _multipartUpload = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, file) {
                var options, minPartSize, fileSize, result, ret, initResult, uploadId, partSize, checkpoint, _args = arguments;
                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1)
                    switch (_context.prev = _context.next) {
                      case 0:
                        options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                        this.resetCancelFlag();
                        options.disabledMD5 = options.disabledMD5 === void 0 ? true : !!options.disabledMD5;
                        if (!(options.checkpoint && options.checkpoint.uploadId)) {
                          _context.next = 8;
                          break;
                        }
                        if (file && isFile(file))
                          options.checkpoint.file = file;
                        _context.next = 7;
                        return this._resumeMultipart(options.checkpoint, options);
                      case 7:
                        return _context.abrupt("return", _context.sent);
                      case 8:
                        minPartSize = 100 * 1024;
                        if (!options.mime) {
                          if (isFile(file)) {
                            options.mime = mime.getType(path.extname(file.name));
                          } else if (isBlob(file)) {
                            options.mime = file.type;
                          } else if (isBuffer(file)) {
                            options.mime = "";
                          } else {
                            options.mime = mime.getType(path.extname(file));
                          }
                        }
                        options.headers = options.headers || {};
                        this._convertMetaToHeaders(options.meta, options.headers);
                        _context.next = 14;
                        return this._getFileSize(file);
                      case 14:
                        fileSize = _context.sent;
                        if (!(fileSize < minPartSize)) {
                          _context.next = 26;
                          break;
                        }
                        options.contentLength = fileSize;
                        _context.next = 19;
                        return this.put(name, file, options);
                      case 19:
                        result = _context.sent;
                        if (!(options && options.progress)) {
                          _context.next = 23;
                          break;
                        }
                        _context.next = 23;
                        return options.progress(1);
                      case 23:
                        ret = {
                          res: result.res,
                          bucket: this.options.bucket,
                          name,
                          etag: result.res.headers.etag
                        };
                        if (options.headers && options.headers["x-oss-callback"] || options.callback) {
                          ret.data = result.data;
                        }
                        return _context.abrupt("return", ret);
                      case 26:
                        if (!(options.partSize && !(parseInt(options.partSize, 10) === options.partSize))) {
                          _context.next = 28;
                          break;
                        }
                        throw new Error("partSize must be int number");
                      case 28:
                        if (!(options.partSize && options.partSize < minPartSize)) {
                          _context.next = 30;
                          break;
                        }
                        throw new Error("partSize must not be smaller than ".concat(minPartSize));
                      case 30:
                        _context.next = 32;
                        return this.initMultipartUpload(name, options);
                      case 32:
                        initResult = _context.sent;
                        uploadId = initResult.uploadId;
                        partSize = this._getPartSize(fileSize, options.partSize);
                        checkpoint = {
                          file,
                          name,
                          fileSize,
                          partSize,
                          uploadId,
                          doneParts: []
                        };
                        if (!(options && options.progress)) {
                          _context.next = 39;
                          break;
                        }
                        _context.next = 39;
                        return options.progress(0, checkpoint, initResult.res);
                      case 39:
                        _context.next = 41;
                        return this._resumeMultipart(checkpoint, options);
                      case 41:
                        return _context.abrupt("return", _context.sent);
                      case 42:
                      case "end":
                        return _context.stop();
                    }
                }, _callee, this);
              }));
              function multipartUpload(_x, _x2) {
                return _multipartUpload.apply(this, arguments);
              }
              return multipartUpload;
            }();
            proto._resumeMultipart = /* @__PURE__ */ function() {
              var _resumeMultipart2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(checkpoint, options) {
                var that, file, fileSize, partSize, uploadId, doneParts, name, internalDoneParts, partOffs, numParts, multipartFinish, uploadPartJob, all, done, todo, defaultParallel, parallel, jobErr, abortEvent;
                return _regenerator.default.wrap(function _callee3$(_context3) {
                  while (1)
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        that = this;
                        if (!this.isCancel()) {
                          _context3.next = 3;
                          break;
                        }
                        throw this._makeCancelEvent();
                      case 3:
                        file = checkpoint.file, fileSize = checkpoint.fileSize, partSize = checkpoint.partSize, uploadId = checkpoint.uploadId, doneParts = checkpoint.doneParts, name = checkpoint.name;
                        internalDoneParts = [];
                        if (doneParts.length > 0) {
                          copy(doneParts).to(internalDoneParts);
                        }
                        partOffs = this._divideParts(fileSize, partSize);
                        numParts = partOffs.length;
                        multipartFinish = false;
                        uploadPartJob = function uploadPartJob2(self2, partNo) {
                          return new Promise(/* @__PURE__ */ function() {
                            var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(resolve2, reject) {
                              var pi, content2, data, result, tempErr;
                              return _regenerator.default.wrap(function _callee2$(_context2) {
                                while (1)
                                  switch (_context2.prev = _context2.next) {
                                    case 0:
                                      _context2.prev = 0;
                                      if (self2.isCancel()) {
                                        _context2.next = 29;
                                        break;
                                      }
                                      pi = partOffs[partNo - 1];
                                      _context2.next = 5;
                                      return self2._createBuffer(file, pi.start, pi.end);
                                    case 5:
                                      content2 = _context2.sent;
                                      data = {
                                        content: content2,
                                        size: pi.end - pi.start
                                      };
                                      _context2.prev = 7;
                                      _context2.next = 10;
                                      return self2._uploadPart(name, uploadId, partNo, data, options);
                                    case 10:
                                      result = _context2.sent;
                                      _context2.next = 18;
                                      break;
                                    case 13:
                                      _context2.prev = 13;
                                      _context2.t0 = _context2["catch"](7);
                                      if (!(_context2.t0.status === 404)) {
                                        _context2.next = 17;
                                        break;
                                      }
                                      throw self2._makeAbortEvent();
                                    case 17:
                                      throw _context2.t0;
                                    case 18:
                                      if (!(!self2.isCancel() && !multipartFinish)) {
                                        _context2.next = 26;
                                        break;
                                      }
                                      checkpoint.doneParts.push({
                                        number: partNo,
                                        etag: result.res.headers.etag
                                      });
                                      if (!options.progress) {
                                        _context2.next = 23;
                                        break;
                                      }
                                      _context2.next = 23;
                                      return options.progress(doneParts.length / (numParts + 1), checkpoint, result.res);
                                    case 23:
                                      resolve2({
                                        number: partNo,
                                        etag: result.res.headers.etag
                                      });
                                      _context2.next = 27;
                                      break;
                                    case 26:
                                      resolve2();
                                    case 27:
                                      _context2.next = 30;
                                      break;
                                    case 29:
                                      resolve2();
                                    case 30:
                                      _context2.next = 41;
                                      break;
                                    case 32:
                                      _context2.prev = 32;
                                      _context2.t1 = _context2["catch"](0);
                                      tempErr = new Error();
                                      tempErr.name = _context2.t1.name;
                                      tempErr.message = _context2.t1.message;
                                      tempErr.stack = _context2.t1.stack;
                                      tempErr.partNum = partNo;
                                      copy(_context2.t1).to(tempErr);
                                      reject(tempErr);
                                    case 41:
                                    case "end":
                                      return _context2.stop();
                                  }
                              }, _callee2, null, [[0, 32], [7, 13]]);
                            }));
                            return function(_x5, _x6) {
                              return _ref.apply(this, arguments);
                            };
                          }());
                        };
                        all = Array.from(new Array(numParts), function(x, i) {
                          return i + 1;
                        });
                        done = internalDoneParts.map(function(p2) {
                          return p2.number;
                        });
                        todo = all.filter(function(p2) {
                          return done.indexOf(p2) < 0;
                        });
                        defaultParallel = 5;
                        parallel = options.parallel || defaultParallel;
                        _context3.next = 17;
                        return this._parallel(todo, parallel, function(value) {
                          return new Promise(function(resolve2, reject) {
                            uploadPartJob(that, value).then(function(result) {
                              if (result) {
                                internalDoneParts.push(result);
                              }
                              resolve2();
                            }).catch(function(err) {
                              reject(err);
                            });
                          });
                        });
                      case 17:
                        jobErr = _context3.sent;
                        multipartFinish = true;
                        abortEvent = jobErr.find(function(err) {
                          return err.name === "abort";
                        });
                        if (!abortEvent) {
                          _context3.next = 22;
                          break;
                        }
                        throw abortEvent;
                      case 22:
                        if (!this.isCancel()) {
                          _context3.next = 25;
                          break;
                        }
                        uploadPartJob = null;
                        throw this._makeCancelEvent();
                      case 25:
                        if (!(jobErr && jobErr.length > 0)) {
                          _context3.next = 28;
                          break;
                        }
                        jobErr[0].message = "Failed to upload some parts with error: ".concat(jobErr[0].toString(), " part_num: ").concat(jobErr[0].partNum);
                        throw jobErr[0];
                      case 28:
                        _context3.next = 30;
                        return this.completeMultipartUpload(name, uploadId, internalDoneParts, options);
                      case 30:
                        return _context3.abrupt("return", _context3.sent);
                      case 31:
                      case "end":
                        return _context3.stop();
                    }
                }, _callee3, this);
              }));
              function _resumeMultipart(_x3, _x4) {
                return _resumeMultipart2.apply(this, arguments);
              }
              return _resumeMultipart;
            }();
            proto._getFileSize = /* @__PURE__ */ function() {
              var _getFileSize2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(file) {
                return _regenerator.default.wrap(function _callee4$(_context4) {
                  while (1)
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        if (!isBuffer(file)) {
                          _context4.next = 4;
                          break;
                        }
                        return _context4.abrupt("return", file.length);
                      case 4:
                        if (!(isBlob(file) || isFile(file))) {
                          _context4.next = 6;
                          break;
                        }
                        return _context4.abrupt("return", file.size);
                      case 6:
                        throw new Error("_getFileSize requires Buffer/File/Blob.");
                      case 7:
                      case "end":
                        return _context4.stop();
                    }
                }, _callee4);
              }));
              function _getFileSize(_x7) {
                return _getFileSize2.apply(this, arguments);
              }
              return _getFileSize;
            }();
            var _require4 = require2("stream"), Readable = _require4.Readable;
            function WebFileReadStream(file, options) {
              if (!(this instanceof WebFileReadStream)) {
                return new WebFileReadStream(file, options);
              }
              Readable.call(this, options);
              this.file = file;
              this.reader = new FileReader();
              this.start = 0;
              this.finish = false;
              this.fileBuffer = null;
            }
            util.inherits(WebFileReadStream, Readable);
            WebFileReadStream.prototype.readFileAndPush = function readFileAndPush(size2) {
              if (this.fileBuffer) {
                var pushRet = true;
                while (pushRet && this.fileBuffer && this.start < this.fileBuffer.length) {
                  var start = this.start;
                  var end = start + size2;
                  end = end > this.fileBuffer.length ? this.fileBuffer.length : end;
                  this.start = end;
                  pushRet = this.push(this.fileBuffer.slice(start, end));
                }
              }
            };
            WebFileReadStream.prototype._read = function _read(size2) {
              if (this.file && this.start >= this.file.size || this.fileBuffer && this.start >= this.fileBuffer.length || this.finish || this.start === 0 && !this.file) {
                if (!this.finish) {
                  this.fileBuffer = null;
                  this.finish = true;
                }
                this.push(null);
                return;
              }
              var defaultReadSize = 16 * 1024;
              size2 = size2 || defaultReadSize;
              var that = this;
              this.reader.onload = function onload(e2) {
                that.fileBuffer = Buffer2.from(new Uint8Array(e2.target.result));
                that.file = null;
                that.readFileAndPush(size2);
              };
              if (this.start === 0) {
                this.reader.readAsArrayBuffer(this.file);
              } else {
                this.readFileAndPush(size2);
              }
            };
            function getBuffer(file) {
              if (file.arrayBuffer)
                return file.arrayBuffer();
              return new Promise(function(resolve2, reject) {
                var reader = new FileReader();
                reader.onload = function(e2) {
                  resolve2(e2.target.result);
                };
                reader.onerror = function(e2) {
                  reject(e2);
                };
                reader.readAsArrayBuffer(file);
              });
            }
            proto._createBuffer = /* @__PURE__ */ function() {
              var _createBuffer2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(file, start, end) {
                var _file, fileContent;
                return _regenerator.default.wrap(function _callee5$(_context5) {
                  while (1)
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        if (!(isBlob(file) || isFile(file))) {
                          _context5.next = 8;
                          break;
                        }
                        _file = file.slice(start, end);
                        _context5.next = 4;
                        return getBuffer(_file);
                      case 4:
                        fileContent = _context5.sent;
                        return _context5.abrupt("return", Buffer2.from(fileContent));
                      case 8:
                        if (!isBuffer(file)) {
                          _context5.next = 12;
                          break;
                        }
                        return _context5.abrupt("return", file.subarray(start, end));
                      case 12:
                        throw new Error("_createBuffer requires File/Blob/Buffer.");
                      case 13:
                      case "end":
                        return _context5.stop();
                    }
                }, _callee5);
              }));
              function _createBuffer(_x8, _x9, _x10) {
                return _createBuffer2.apply(this, arguments);
              }
              return _createBuffer;
            }();
            proto._getPartSize = function _getPartSize(fileSize, partSize) {
              var maxNumParts = 10 * 1e3;
              var defaultPartSize = 1 * 1024 * 1024;
              if (!partSize)
                partSize = defaultPartSize;
              var safeSize = Math.ceil(fileSize / maxNumParts);
              if (partSize < safeSize) {
                partSize = safeSize;
                index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:1638", "partSize has been set to ".concat(partSize, ", because the partSize you provided causes partNumber to be greater than 10,000"));
              }
              return partSize;
            };
            proto._divideParts = function _divideParts(fileSize, partSize) {
              var numParts = Math.ceil(fileSize / partSize);
              var partOffs = [];
              for (var i = 0; i < numParts; i++) {
                var start = partSize * i;
                var end = Math.min(start + partSize, fileSize);
                partOffs.push({
                  start,
                  end
                });
              }
              return partOffs;
            };
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "../common/utils/isBlob": 68, "../common/utils/isBuffer": 69, "../common/utils/isFile": 71, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "buffer": 103, "copy-to": 107, "core-js/modules/es.array-buffer.slice.js": 309, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.filter.js": 312, "core-js/modules/es.array.find.js": 313, "core-js/modules/es.array.from.js": 314, "core-js/modules/es.array.iterator.js": 316, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.function.name.js": 322, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.string.iterator.js": 343, "core-js/modules/es.typed-array.copy-within.js": 356, "core-js/modules/es.typed-array.every.js": 357, "core-js/modules/es.typed-array.fill.js": 358, "core-js/modules/es.typed-array.filter.js": 359, "core-js/modules/es.typed-array.find-index.js": 360, "core-js/modules/es.typed-array.find.js": 361, "core-js/modules/es.typed-array.for-each.js": 362, "core-js/modules/es.typed-array.includes.js": 363, "core-js/modules/es.typed-array.index-of.js": 364, "core-js/modules/es.typed-array.iterator.js": 365, "core-js/modules/es.typed-array.join.js": 366, "core-js/modules/es.typed-array.last-index-of.js": 367, "core-js/modules/es.typed-array.map.js": 368, "core-js/modules/es.typed-array.reduce-right.js": 369, "core-js/modules/es.typed-array.reduce.js": 370, "core-js/modules/es.typed-array.reverse.js": 371, "core-js/modules/es.typed-array.set.js": 372, "core-js/modules/es.typed-array.slice.js": 373, "core-js/modules/es.typed-array.some.js": 374, "core-js/modules/es.typed-array.sort.js": 375, "core-js/modules/es.typed-array.subarray.js": 376, "core-js/modules/es.typed-array.to-locale-string.js": 377, "core-js/modules/es.typed-array.to-string.js": 378, "core-js/modules/es.typed-array.uint8-array.js": 379, "mime": 430, "path": 439, "stream": 468, "util": 489 }], 5: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        require2("core-js/modules/es.function.name.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.number.constructor.js");
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.promise.js");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var fs = require2("fs");
        var copy = require2("copy-to");
        var path = require2("path");
        var mime = require2("mime");
        var callback = require2("../common/callback");
        var merge = require2("merge-descriptors");
        var _require = require2("../common/utils/isBlob"), isBlob = _require.isBlob;
        var _require2 = require2("../common/utils/isFile"), isFile = _require2.isFile;
        var _require3 = require2("../common/utils/isBuffer"), isBuffer = _require3.isBuffer;
        var _require4 = require2("../common/utils/obj2xml"), obj2xml = _require4.obj2xml;
        var _require5 = require2("../common/utils/parseRestoreInfo"), parseRestoreInfo = _require5.parseRestoreInfo;
        var proto = exports3;
        proto.append = /* @__PURE__ */ function() {
          var _append = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, file, options) {
            var result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    if (options.position === void 0)
                      options.position = "0";
                    options.subres = {
                      append: "",
                      position: options.position
                    };
                    options.method = "POST";
                    _context.next = 6;
                    return this.put(name, file, options);
                  case 6:
                    result = _context.sent;
                    result.nextAppendPosition = result.res.headers["x-oss-next-append-position"];
                    return _context.abrupt("return", result);
                  case 9:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function append(_x, _x2, _x3) {
            return _append.apply(this, arguments);
          }
          return append;
        }();
        proto.put = /* @__PURE__ */ function() {
          var _put = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(name, file, options) {
            var content2, method, params, result, ret;
            return _regenerator.default.wrap(function _callee2$(_context2) {
              while (1)
                switch (_context2.prev = _context2.next) {
                  case 0:
                    options = options || {};
                    options.disabledMD5 = options.disabledMD5 === void 0 ? true : !!options.disabledMD5;
                    options.headers = options.headers || {};
                    name = this._objectName(name);
                    if (!isBuffer(file)) {
                      _context2.next = 8;
                      break;
                    }
                    content2 = file;
                    _context2.next = 19;
                    break;
                  case 8:
                    if (!(isBlob(file) || isFile(file))) {
                      _context2.next = 18;
                      break;
                    }
                    if (!options.mime) {
                      if (isFile(file)) {
                        options.mime = mime.getType(path.extname(file.name));
                      } else {
                        options.mime = file.type;
                      }
                    }
                    _context2.next = 12;
                    return this._createBuffer(file, 0, file.size);
                  case 12:
                    content2 = _context2.sent;
                    _context2.next = 15;
                    return this._getFileSize(file);
                  case 15:
                    options.contentLength = _context2.sent;
                    _context2.next = 19;
                    break;
                  case 18:
                    throw new TypeError("Must provide Buffer/Blob/File for put.");
                  case 19:
                    this._convertMetaToHeaders(options.meta, options.headers);
                    method = options.method || "PUT";
                    params = this._objectRequestParams(method, name, options);
                    callback.encodeCallback(params, options);
                    params.mime = options.mime;
                    params.disabledMD5 = options.disabledMD5;
                    params.content = content2;
                    params.successStatuses = [200];
                    _context2.next = 29;
                    return this.request(params);
                  case 29:
                    result = _context2.sent;
                    ret = {
                      name,
                      url: this._objectUrl(name),
                      res: result.res
                    };
                    if (params.headers && params.headers["x-oss-callback"]) {
                      ret.data = JSON.parse(result.data.toString());
                    }
                    return _context2.abrupt("return", ret);
                  case 33:
                  case "end":
                    return _context2.stop();
                }
            }, _callee2, this);
          }));
          function put(_x4, _x5, _x6) {
            return _put.apply(this, arguments);
          }
          return put;
        }();
        proto.putStream = /* @__PURE__ */ function() {
          var _putStream = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(name, stream, options) {
            var method, params, result, ret;
            return _regenerator.default.wrap(function _callee3$(_context3) {
              while (1)
                switch (_context3.prev = _context3.next) {
                  case 0:
                    options = options || {};
                    options.headers = options.headers || {};
                    name = this._objectName(name);
                    if (options.contentLength) {
                      options.headers["Content-Length"] = options.contentLength;
                    } else {
                      options.headers["Transfer-Encoding"] = "chunked";
                    }
                    this._convertMetaToHeaders(options.meta, options.headers);
                    method = options.method || "PUT";
                    params = this._objectRequestParams(method, name, options);
                    callback.encodeCallback(params, options);
                    params.mime = options.mime;
                    params.stream = stream;
                    params.successStatuses = [200];
                    _context3.next = 13;
                    return this.request(params);
                  case 13:
                    result = _context3.sent;
                    ret = {
                      name,
                      url: this._objectUrl(name),
                      res: result.res
                    };
                    if (params.headers && params.headers["x-oss-callback"]) {
                      ret.data = JSON.parse(result.data.toString());
                    }
                    return _context3.abrupt("return", ret);
                  case 17:
                  case "end":
                    return _context3.stop();
                }
            }, _callee3, this);
          }));
          function putStream(_x7, _x8, _x9) {
            return _putStream.apply(this, arguments);
          }
          return putStream;
        }();
        merge(proto, require2("../common/object/copyObject"));
        merge(proto, require2("../common/object/getObjectTagging"));
        merge(proto, require2("../common/object/putObjectTagging"));
        merge(proto, require2("../common/object/deleteObjectTagging"));
        merge(proto, require2("../common/image"));
        merge(proto, require2("../common/object/getBucketVersions"));
        merge(proto, require2("../common/object/getACL"));
        merge(proto, require2("../common/object/putACL"));
        merge(proto, require2("../common/object/head"));
        merge(proto, require2("../common/object/delete"));
        merge(proto, require2("../common/object/get"));
        merge(proto, require2("../common/object/putSymlink"));
        merge(proto, require2("../common/object/getSymlink"));
        merge(proto, require2("../common/object/deleteMulti"));
        merge(proto, require2("../common/object/getObjectMeta"));
        merge(proto, require2("../common/object/getObjectUrl"));
        merge(proto, require2("../common/object/generateObjectUrl"));
        merge(proto, require2("../common/object/signatureUrl"));
        merge(proto, require2("../common/object/asyncSignatureUrl"));
        merge(proto, require2("../common/object/signatureUrlV4"));
        merge(proto, require2("../common/object/signPostObjectPolicyV4"));
        proto.putMeta = /* @__PURE__ */ function() {
          var _putMeta = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(name, meta, options) {
            var copyResult;
            return _regenerator.default.wrap(function _callee4$(_context4) {
              while (1)
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this.copy(name, name, {
                      meta: meta || {},
                      timeout: options && options.timeout,
                      ctx: options && options.ctx
                    });
                  case 2:
                    copyResult = _context4.sent;
                    return _context4.abrupt("return", copyResult);
                  case 4:
                  case "end":
                    return _context4.stop();
                }
            }, _callee4, this);
          }));
          function putMeta(_x10, _x11, _x12) {
            return _putMeta.apply(this, arguments);
          }
          return putMeta;
        }();
        proto.list = /* @__PURE__ */ function() {
          var _list = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(query, options) {
            var params, result, objects, that, prefixes;
            return _regenerator.default.wrap(function _callee5$(_context5) {
              while (1)
                switch (_context5.prev = _context5.next) {
                  case 0:
                    params = this._objectRequestParams("GET", "", options);
                    params.query = query;
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    _context5.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context5.sent;
                    objects = result.data.Contents || [];
                    that = this;
                    if (objects) {
                      if (!Array.isArray(objects)) {
                        objects = [objects];
                      }
                      objects = objects.map(function(obj) {
                        return {
                          name: obj.Key,
                          url: that._objectUrl(obj.Key),
                          lastModified: obj.LastModified,
                          etag: obj.ETag,
                          type: obj.Type,
                          size: Number(obj.Size),
                          storageClass: obj.StorageClass,
                          owner: {
                            id: obj.Owner.ID,
                            displayName: obj.Owner.DisplayName
                          },
                          restoreInfo: parseRestoreInfo(obj.RestoreInfo)
                        };
                      });
                    }
                    prefixes = result.data.CommonPrefixes || null;
                    if (prefixes) {
                      if (!Array.isArray(prefixes)) {
                        prefixes = [prefixes];
                      }
                      prefixes = prefixes.map(function(item) {
                        return item.Prefix;
                      });
                    }
                    return _context5.abrupt("return", {
                      res: result.res,
                      objects,
                      prefixes,
                      nextMarker: result.data.NextMarker || null,
                      isTruncated: result.data.IsTruncated === "true"
                    });
                  case 13:
                  case "end":
                    return _context5.stop();
                }
            }, _callee5, this);
          }));
          function list2(_x13, _x14) {
            return _list.apply(this, arguments);
          }
          return list2;
        }();
        proto.listV2 = /* @__PURE__ */ function() {
          var _listV = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6(query) {
            var options, continuation_token, params, result, objects, that, prefixes, _args6 = arguments;
            return _regenerator.default.wrap(function _callee6$(_context6) {
              while (1)
                switch (_context6.prev = _context6.next) {
                  case 0:
                    options = _args6.length > 1 && _args6[1] !== void 0 ? _args6[1] : {};
                    continuation_token = query["continuation-token"] || query.continuationToken;
                    if (continuation_token) {
                      options.subres = Object.assign({
                        "continuation-token": continuation_token
                      }, options.subres);
                    }
                    params = this._objectRequestParams("GET", "", options);
                    params.query = Object.assign({
                      "list-type": 2
                    }, query);
                    delete params.query["continuation-token"];
                    delete params.query.continuationToken;
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    _context6.next = 11;
                    return this.request(params);
                  case 11:
                    result = _context6.sent;
                    objects = result.data.Contents || [];
                    that = this;
                    if (objects) {
                      if (!Array.isArray(objects)) {
                        objects = [objects];
                      }
                      objects = objects.map(function(obj) {
                        var owner = null;
                        if (obj.Owner) {
                          owner = {
                            id: obj.Owner.ID,
                            displayName: obj.Owner.DisplayName
                          };
                        }
                        return {
                          name: obj.Key,
                          url: that._objectUrl(obj.Key),
                          lastModified: obj.LastModified,
                          etag: obj.ETag,
                          type: obj.Type,
                          size: Number(obj.Size),
                          storageClass: obj.StorageClass,
                          owner,
                          restoreInfo: parseRestoreInfo(obj.RestoreInfo)
                        };
                      });
                    }
                    prefixes = result.data.CommonPrefixes || null;
                    if (prefixes) {
                      if (!Array.isArray(prefixes)) {
                        prefixes = [prefixes];
                      }
                      prefixes = prefixes.map(function(item) {
                        return item.Prefix;
                      });
                    }
                    return _context6.abrupt("return", {
                      res: result.res,
                      objects,
                      prefixes,
                      isTruncated: result.data.IsTruncated === "true",
                      keyCount: +result.data.KeyCount,
                      continuationToken: result.data.ContinuationToken || null,
                      nextContinuationToken: result.data.NextContinuationToken || null
                    });
                  case 18:
                  case "end":
                    return _context6.stop();
                }
            }, _callee6, this);
          }));
          function listV2(_x15) {
            return _listV.apply(this, arguments);
          }
          return listV2;
        }();
        proto.restore = /* @__PURE__ */ function() {
          var _restore = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7(name) {
            var options, params, paramsXMLObj, result, _args7 = arguments;
            return _regenerator.default.wrap(function _callee7$(_context7) {
              while (1)
                switch (_context7.prev = _context7.next) {
                  case 0:
                    options = _args7.length > 1 && _args7[1] !== void 0 ? _args7[1] : {
                      type: "Archive"
                    };
                    options = options || {};
                    options.subres = Object.assign({
                      restore: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("POST", name, options);
                    paramsXMLObj = {
                      RestoreRequest: {
                        Days: options.Days ? options.Days : 2
                      }
                    };
                    if (options.type === "ColdArchive" || options.type === "DeepColdArchive") {
                      paramsXMLObj.RestoreRequest.JobParameters = {
                        Tier: options.JobParameters ? options.JobParameters : "Standard"
                      };
                    }
                    params.content = obj2xml(paramsXMLObj, {
                      headers: true
                    });
                    params.mime = "xml";
                    params.successStatuses = [202];
                    _context7.next = 12;
                    return this.request(params);
                  case 12:
                    result = _context7.sent;
                    return _context7.abrupt("return", {
                      res: result.res
                    });
                  case 14:
                  case "end":
                    return _context7.stop();
                }
            }, _callee7, this);
          }));
          function restore(_x16) {
            return _restore.apply(this, arguments);
          }
          return restore;
        }();
        proto._objectUrl = function _objectUrl(name) {
          return this._getReqUrl({
            bucket: this.options.bucket,
            object: name
          });
        };
        proto._objectRequestParams = function _objectRequestParams(method, name, options) {
          if (!this.options.bucket && !this.options.cname) {
            throw new Error("Please create a bucket first");
          }
          options = options || {};
          name = this._objectName(name);
          var params = {
            object: name,
            bucket: this.options.bucket,
            method,
            subres: options && options.subres,
            additionalHeaders: options && options.additionalHeaders,
            timeout: options && options.timeout,
            ctx: options && options.ctx
          };
          if (options.headers) {
            params.headers = {};
            copy(options.headers).to(params.headers);
          }
          return params;
        };
        proto._objectName = function _objectName(name) {
          return name.replace(/^\/+/, "");
        };
        proto._convertMetaToHeaders = function _convertMetaToHeaders(meta, headers) {
          if (!meta) {
            return;
          }
          Object.keys(meta).forEach(function(k) {
            headers["x-oss-meta-".concat(k)] = meta[k];
          });
        };
        proto._deleteFileSafe = function _deleteFileSafe(filepath) {
          var _this = this;
          return new Promise(function(resolve2) {
            fs.exists(filepath, function(exists) {
              if (!exists) {
                resolve2();
              } else {
                fs.unlink(filepath, function(err) {
                  if (err) {
                    _this.debug("unlink %j error: %s", filepath, err, "error");
                  }
                  resolve2();
                });
              }
            });
          });
        };
      }, { "../common/callback": 24, "../common/image": 27, "../common/object/asyncSignatureUrl": 31, "../common/object/copyObject": 32, "../common/object/delete": 33, "../common/object/deleteMulti": 34, "../common/object/deleteObjectTagging": 35, "../common/object/generateObjectUrl": 36, "../common/object/get": 37, "../common/object/getACL": 38, "../common/object/getBucketVersions": 39, "../common/object/getObjectMeta": 40, "../common/object/getObjectTagging": 41, "../common/object/getObjectUrl": 42, "../common/object/getSymlink": 43, "../common/object/head": 44, "../common/object/putACL": 45, "../common/object/putObjectTagging": 46, "../common/object/putSymlink": 47, "../common/object/signPostObjectPolicyV4": 48, "../common/object/signatureUrl": 49, "../common/object/signatureUrlV4": 50, "../common/utils/isBlob": 68, "../common/utils/isBuffer": 69, "../common/utils/isFile": 71, "../common/utils/obj2xml": 76, "../common/utils/parseRestoreInfo": 78, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "copy-to": 107, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.function.name.js": 322, "core-js/modules/es.number.constructor.js": 324, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.string.replace.js": 345, "core-js/modules/web.dom-collections.for-each.js": 380, "fs": 102, "merge-descriptors": 428, "mime": 430, "path": 439 }], 6: [function(require2, module3, exports3) {
        exports3.version = "6.23.0";
      }, {}], 7: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.abortBucketWorm = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        function abortBucketWorm(_x, _x2) {
          return _abortBucketWorm.apply(this, arguments);
        }
        function _abortBucketWorm() {
          _abortBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name);
                    params = this._bucketRequestParams("DELETE", name, "worm", options);
                    _context.next = 4;
                    return this.request(params);
                  case 4:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res,
                      status: result.status
                    });
                  case 6:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _abortBucketWorm.apply(this, arguments);
        }
        exports3.abortBucketWorm = abortBucketWorm;
      }, { "../utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 8: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.completeBucketWorm = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        function completeBucketWorm(_x, _x2, _x3) {
          return _completeBucketWorm.apply(this, arguments);
        }
        function _completeBucketWorm() {
          _completeBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, wormId, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name);
                    params = this._bucketRequestParams("POST", name, {
                      wormId
                    }, options);
                    _context.next = 4;
                    return this.request(params);
                  case 4:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res,
                      status: result.status
                    });
                  case 6:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _completeBucketWorm.apply(this, arguments);
        }
        exports3.completeBucketWorm = completeBucketWorm;
      }, { "../utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 9: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.deleteBucketInventory = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        function deleteBucketInventory(_x, _x2) {
          return _deleteBucketInventory.apply(this, arguments);
        }
        function _deleteBucketInventory() {
          _deleteBucketInventory = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName, inventoryId) {
            var options, subres, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    subres = Object.assign({
                      inventory: "",
                      inventoryId
                    }, options.subres);
                    checkBucketName_1.checkBucketName(bucketName);
                    params = this._bucketRequestParams("DELETE", bucketName, subres, options);
                    params.successStatuses = [204];
                    _context.next = 7;
                    return this.request(params);
                  case 7:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      status: result.status,
                      res: result.res
                    });
                  case 9:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _deleteBucketInventory.apply(this, arguments);
        }
        exports3.deleteBucketInventory = deleteBucketInventory;
      }, { "../utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 10: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports3;
        proto.deleteBucketLifecycle = /* @__PURE__ */ function() {
          var _deleteBucketLifecycle = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name);
                    params = this._bucketRequestParams("DELETE", name, "lifecycle", options);
                    params.successStatuses = [204];
                    _context.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res
                    });
                  case 7:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function deleteBucketLifecycle(_x, _x2) {
            return _deleteBucketLifecycle.apply(this, arguments);
          }
          return deleteBucketLifecycle;
        }();
      }, { "../utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 11: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports3;
        proto.deleteBucketWebsite = /* @__PURE__ */ function() {
          var _deleteBucketWebsite = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name);
                    params = this._bucketRequestParams("DELETE", name, "website", options);
                    params.successStatuses = [204];
                    _context.next = 5;
                    return this.request(params);
                  case 5:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res
                    });
                  case 7:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function deleteBucketWebsite(_x, _x2) {
            return _deleteBucketWebsite.apply(this, arguments);
          }
          return deleteBucketWebsite;
        }();
      }, { "../utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 12: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.extendBucketWorm = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var obj2xml_1 = require2("../utils/obj2xml");
        function extendBucketWorm(_x, _x2, _x3, _x4) {
          return _extendBucketWorm.apply(this, arguments);
        }
        function _extendBucketWorm() {
          _extendBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, wormId, days, options) {
            var params, paramlXMLObJ, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name);
                    params = this._bucketRequestParams("POST", name, {
                      wormExtend: "",
                      wormId
                    }, options);
                    paramlXMLObJ = {
                      ExtendWormConfiguration: {
                        RetentionPeriodInDays: days
                      }
                    };
                    params.mime = "xml";
                    params.content = obj2xml_1.obj2xml(paramlXMLObJ, {
                      headers: true
                    });
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res,
                      status: result.status
                    });
                  case 10:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _extendBucketWorm.apply(this, arguments);
        }
        exports3.extendBucketWorm = extendBucketWorm;
      }, { "../utils/checkBucketName": 53, "../utils/obj2xml": 76, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 13: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.getBucketInventory = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var formatInventoryConfig_1 = require2("../utils/formatInventoryConfig");
        function getBucketInventory(_x, _x2) {
          return _getBucketInventory.apply(this, arguments);
        }
        function _getBucketInventory() {
          _getBucketInventory = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName, inventoryId) {
            var options, subres, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    subres = Object.assign({
                      inventory: "",
                      inventoryId
                    }, options.subres);
                    checkBucketName_1.checkBucketName(bucketName);
                    params = this._bucketRequestParams("GET", bucketName, subres, options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      status: result.status,
                      res: result.res,
                      inventory: formatInventoryConfig_1.formatInventoryConfig(result.data)
                    });
                  case 10:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _getBucketInventory.apply(this, arguments);
        }
        exports3.getBucketInventory = getBucketInventory;
      }, { "../utils/checkBucketName": 53, "../utils/formatInventoryConfig": 63, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 14: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.map.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/isArray"), isArray2 = _require2.isArray;
        var _require3 = require2("../utils/formatObjKey"), formatObjKey = _require3.formatObjKey;
        var proto = exports3;
        proto.getBucketLifecycle = /* @__PURE__ */ function() {
          var _getBucketLifecycle = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var params, result, rules;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name);
                    params = this._bucketRequestParams("GET", name, "lifecycle", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context.sent;
                    rules = result.data.Rule || null;
                    if (rules) {
                      if (!isArray2(rules)) {
                        rules = [rules];
                      }
                      rules = rules.map(function(_) {
                        if (_.ID) {
                          _.id = _.ID;
                          delete _.ID;
                        }
                        if (_.Tag && !isArray2(_.Tag)) {
                          _.Tag = [_.Tag];
                        }
                        return formatObjKey(_, "firstLowerCase");
                      });
                    }
                    return _context.abrupt("return", {
                      rules,
                      res: result.res
                    });
                  case 10:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function getBucketLifecycle(_x, _x2) {
            return _getBucketLifecycle.apply(this, arguments);
          }
          return getBucketLifecycle;
        }();
      }, { "../utils/checkBucketName": 53, "../utils/formatObjKey": 64, "../utils/isArray": 67, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.map.js": 318 }], 15: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports3;
        proto.getBucketVersioning = /* @__PURE__ */ function() {
          var _getBucketVersioning = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName, options) {
            var params, result, versionStatus;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(bucketName);
                    params = this._bucketRequestParams("GET", bucketName, "versioning", options);
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    _context.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context.sent;
                    versionStatus = result.data.Status;
                    return _context.abrupt("return", {
                      status: result.status,
                      versionStatus,
                      res: result.res
                    });
                  case 9:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function getBucketVersioning(_x, _x2) {
            return _getBucketVersioning.apply(this, arguments);
          }
          return getBucketVersioning;
        }();
      }, { "../utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 16: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/isObject"), isObject2 = _require2.isObject;
        var proto = exports3;
        proto.getBucketWebsite = /* @__PURE__ */ function() {
          var _getBucketWebsite = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var params, result, routingRules;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name);
                    params = this._bucketRequestParams("GET", name, "website", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context.sent;
                    routingRules = [];
                    if (result.data.RoutingRules && result.data.RoutingRules.RoutingRule) {
                      if (isObject2(result.data.RoutingRules.RoutingRule)) {
                        routingRules = [result.data.RoutingRules.RoutingRule];
                      } else {
                        routingRules = result.data.RoutingRules.RoutingRule;
                      }
                    }
                    return _context.abrupt("return", {
                      index: result.data.IndexDocument && result.data.IndexDocument.Suffix || "",
                      supportSubDir: result.data.IndexDocument && result.data.IndexDocument.SupportSubDir || "false",
                      type: result.data.IndexDocument && result.data.IndexDocument.Type,
                      routingRules,
                      error: result.data.ErrorDocument && result.data.ErrorDocument.Key || null,
                      res: result.res
                    });
                  case 10:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function getBucketWebsite(_x, _x2) {
            return _getBucketWebsite.apply(this, arguments);
          }
          return getBucketWebsite;
        }();
      }, { "../utils/checkBucketName": 53, "../utils/isObject": 74, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 17: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.getBucketWorm = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var dataFix_1 = require2("../utils/dataFix");
        function getBucketWorm(_x, _x2) {
          return _getBucketWorm.apply(this, arguments);
        }
        function _getBucketWorm() {
          _getBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name);
                    params = this._bucketRequestParams("GET", name, "worm", options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 6;
                    return this.request(params);
                  case 6:
                    result = _context.sent;
                    dataFix_1.dataFix(result.data, {
                      lowerFirst: true,
                      rename: {
                        RetentionPeriodInDays: "days"
                      }
                    });
                    return _context.abrupt("return", Object.assign(Object.assign({}, result.data), {
                      res: result.res,
                      status: result.status
                    }));
                  case 9:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _getBucketWorm.apply(this, arguments);
        }
        exports3.getBucketWorm = getBucketWorm;
      }, { "../utils/checkBucketName": 53, "../utils/dataFix": 59, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 18: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.initiateBucketWorm = void 0;
        var obj2xml_1 = require2("../utils/obj2xml");
        var checkBucketName_1 = require2("../utils/checkBucketName");
        function initiateBucketWorm(_x, _x2, _x3) {
          return _initiateBucketWorm.apply(this, arguments);
        }
        function _initiateBucketWorm() {
          _initiateBucketWorm = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, days, options) {
            var params, paramlXMLObJ, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    checkBucketName_1.checkBucketName(name);
                    params = this._bucketRequestParams("POST", name, "worm", options);
                    paramlXMLObJ = {
                      InitiateWormConfiguration: {
                        RetentionPeriodInDays: days
                      }
                    };
                    params.mime = "xml";
                    params.content = obj2xml_1.obj2xml(paramlXMLObJ, {
                      headers: true
                    });
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res,
                      wormId: result.res.headers["x-oss-worm-id"],
                      status: result.status
                    });
                  case 10:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _initiateBucketWorm.apply(this, arguments);
        }
        exports3.initiateBucketWorm = initiateBucketWorm;
      }, { "../utils/checkBucketName": 53, "../utils/obj2xml": 76, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 19: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.listBucketInventory = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var formatInventoryConfig_1 = require2("../utils/formatInventoryConfig");
        function listBucketInventory(_x) {
          return _listBucketInventory.apply(this, arguments);
        }
        function _listBucketInventory() {
          _listBucketInventory = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName) {
            var options, continuationToken, subres, params, result, data, res, status, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    continuationToken = options.continuationToken;
                    subres = Object.assign({
                      inventory: ""
                    }, continuationToken && {
                      "continuation-token": continuationToken
                    }, options.subres);
                    checkBucketName_1.checkBucketName(bucketName);
                    params = this._bucketRequestParams("GET", bucketName, subres, options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 9;
                    return this.request(params);
                  case 9:
                    result = _context.sent;
                    data = result.data, res = result.res, status = result.status;
                    return _context.abrupt("return", {
                      isTruncated: data.IsTruncated === "true",
                      nextContinuationToken: data.NextContinuationToken,
                      inventoryList: formatInventoryConfig_1.formatInventoryConfig(data.InventoryConfiguration, true),
                      status,
                      res
                    });
                  case 12:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _listBucketInventory.apply(this, arguments);
        }
        exports3.listBucketInventory = listBucketInventory;
      }, { "../utils/checkBucketName": 53, "../utils/formatInventoryConfig": 63, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 20: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.array.concat.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.putBucketInventory = void 0;
        var checkBucketName_1 = require2("../utils/checkBucketName");
        var obj2xml_1 = require2("../utils/obj2xml");
        function putBucketInventory(_x, _x2) {
          return _putBucketInventory.apply(this, arguments);
        }
        function _putBucketInventory() {
          _putBucketInventory = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(bucketName, inventory) {
            var options, subres, OSSBucketDestination, optionalFields, includedObjectVersions, destinationBucketPrefix, rolePrefix, paramXMLObj, paramXML, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    subres = Object.assign({
                      inventory: "",
                      inventoryId: inventory.id
                    }, options.subres);
                    checkBucketName_1.checkBucketName(bucketName);
                    OSSBucketDestination = inventory.OSSBucketDestination, optionalFields = inventory.optionalFields, includedObjectVersions = inventory.includedObjectVersions;
                    destinationBucketPrefix = "acs:oss:::";
                    rolePrefix = "acs:ram::".concat(OSSBucketDestination.accountId, ":role/");
                    paramXMLObj = {
                      InventoryConfiguration: {
                        Id: inventory.id,
                        IsEnabled: inventory.isEnabled,
                        Filter: {
                          Prefix: inventory.prefix || ""
                        },
                        Destination: {
                          OSSBucketDestination: {
                            Format: OSSBucketDestination.format,
                            AccountId: OSSBucketDestination.accountId,
                            RoleArn: "".concat(rolePrefix).concat(OSSBucketDestination.rolename),
                            Bucket: "".concat(destinationBucketPrefix).concat(OSSBucketDestination.bucket),
                            Prefix: OSSBucketDestination.prefix || "",
                            Encryption: OSSBucketDestination.encryption || ""
                          }
                        },
                        Schedule: {
                          Frequency: inventory.frequency
                        },
                        IncludedObjectVersions: includedObjectVersions,
                        OptionalFields: {
                          Field: (optionalFields === null || optionalFields === void 0 ? void 0 : optionalFields.field) || []
                        }
                      }
                    };
                    paramXML = obj2xml_1.obj2xml(paramXMLObj, {
                      headers: true,
                      firstUpperCase: true
                    });
                    params = this._bucketRequestParams("PUT", bucketName, subres, options);
                    params.successStatuses = [200];
                    params.mime = "xml";
                    params.content = paramXML;
                    _context.next = 14;
                    return this.request(params);
                  case 14:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      status: result.status,
                      res: result.res
                    });
                  case 16:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _putBucketInventory.apply(this, arguments);
        }
        exports3.putBucketInventory = putBucketInventory;
      }, { "../utils/checkBucketName": 53, "../utils/obj2xml": 76, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.object.assign.js": 325 }], 21: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.array.includes.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/isArray"), isArray2 = _require2.isArray;
        var _require3 = require2("../utils/deepCopy"), deepCopy2 = _require3.deepCopy;
        var _require4 = require2("../utils/isObject"), isObject2 = _require4.isObject;
        var _require5 = require2("../utils/obj2xml"), obj2xml = _require5.obj2xml;
        var _require6 = require2("../utils/checkObjectTag"), checkObjectTag = _require6.checkObjectTag;
        var _require7 = require2("../utils/getStrBytesCount"), getStrBytesCount = _require7.getStrBytesCount;
        var proto = exports3;
        proto.putBucketLifecycle = /* @__PURE__ */ function() {
          var _putBucketLifecycle = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, rules, options) {
            var params, Rule, paramXMLObj, paramXML, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    _checkBucketName(name);
                    if (isArray2(rules)) {
                      _context.next = 3;
                      break;
                    }
                    throw new Error("rules must be Array");
                  case 3:
                    params = this._bucketRequestParams("PUT", name, "lifecycle", options);
                    Rule = [];
                    paramXMLObj = {
                      LifecycleConfiguration: {
                        Rule
                      }
                    };
                    rules.forEach(function(_) {
                      defaultDaysAndDate2Expiration(_);
                      checkRule(_);
                      if (_.id) {
                        _.ID = _.id;
                        delete _.id;
                      }
                      Rule.push(_);
                    });
                    paramXML = obj2xml(paramXMLObj, {
                      headers: true,
                      firstUpperCase: true
                    });
                    params.content = paramXML;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context.next = 13;
                    return this.request(params);
                  case 13:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res
                    });
                  case 15:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function putBucketLifecycle(_x, _x2, _x3) {
            return _putBucketLifecycle.apply(this, arguments);
          }
          return putBucketLifecycle;
        }();
        function defaultDaysAndDate2Expiration(obj) {
          if (obj.days) {
            obj.expiration = {
              days: obj.days
            };
          }
          if (obj.date) {
            obj.expiration = {
              createdBeforeDate: obj.date
            };
          }
        }
        function checkDaysAndDate(obj, key) {
          var days = obj.days, createdBeforeDate = obj.createdBeforeDate;
          if (!days && !createdBeforeDate) {
            throw new Error("".concat(key, " must includes days or createdBeforeDate"));
          } else if (days && (isArray2(days) || !/^[1-9][0-9]*$/.test(days))) {
            throw new Error("days must be a positive integer");
          } else if (createdBeforeDate && !/\d{4}-\d{2}-\d{2}T00:00:00.000Z/.test(createdBeforeDate)) {
            throw new Error("createdBeforeDate must be date and conform to iso8601 format");
          }
        }
        function checkNoncurrentDays(obj, key) {
          var noncurrentDays = obj.noncurrentDays;
          if (!noncurrentDays) {
            throw new Error("".concat(key, " must includes noncurrentDays"));
          } else if (noncurrentDays && (isArray2(noncurrentDays) || !/^[1-9][0-9]*$/.test(noncurrentDays))) {
            throw new Error("noncurrentDays must be a positive integer");
          }
        }
        function handleCheckTag(tag2) {
          if (!isArray2(tag2) && !isObject2(tag2)) {
            throw new Error("tag must be Object or Array");
          }
          tag2 = isObject2(tag2) ? [tag2] : tag2;
          var tagObj = {};
          var tagClone = deepCopy2(tag2);
          tagClone.forEach(function(v) {
            tagObj[v.key] = v.value;
          });
          checkObjectTag(tagObj);
        }
        function checkStorageClass(storageClass) {
          if (!["IA", "Archive", "ColdArchive", "DeepColdArchive"].includes(storageClass))
            throw new Error("StorageClass must be IA or Archive or ColdArchive or DeepColdArchive");
        }
        function checkRule(rule) {
          if (rule.id && getStrBytesCount(rule.id) > 255)
            throw new Error("ID is composed of 255 bytes at most");
          if (rule.prefix === void 0)
            throw new Error("Rule must includes prefix");
          if (!["Enabled", "Disabled"].includes(rule.status))
            throw new Error("Status must be Enabled or Disabled");
          if (!rule.expiration && !rule.noncurrentVersionExpiration && !rule.abortMultipartUpload && !rule.transition && !rule.noncurrentVersionTransition) {
            throw new Error("Rule must includes expiration or noncurrentVersionExpiration or abortMultipartUpload or transition or noncurrentVersionTransition");
          }
          if (rule.transition) {
            checkStorageClass(rule.transition.storageClass);
            checkDaysAndDate(rule.transition, "Transition");
          }
          if (rule.expiration) {
            if (!rule.expiration.expiredObjectDeleteMarker) {
              checkDaysAndDate(rule.expiration, "Expiration");
            } else if (rule.expiration.days || rule.expiration.createdBeforeDate) {
              throw new Error("expiredObjectDeleteMarker cannot be used with days or createdBeforeDate");
            }
          }
          if (rule.abortMultipartUpload) {
            checkDaysAndDate(rule.abortMultipartUpload, "AbortMultipartUpload");
          }
          if (rule.noncurrentVersionTransition) {
            checkStorageClass(rule.noncurrentVersionTransition.storageClass);
            checkNoncurrentDays(rule.noncurrentVersionTransition, "NoncurrentVersionTransition");
          }
          if (rule.noncurrentVersionExpiration) {
            checkNoncurrentDays(rule.noncurrentVersionExpiration, "NoncurrentVersionExpiration");
          }
          if (rule.tag) {
            if (rule.abortMultipartUpload) {
              throw new Error("Tag cannot be used with abortMultipartUpload");
            }
            handleCheckTag(rule.tag);
          }
        }
      }, { "../utils/checkBucketName": 53, "../utils/checkObjectTag": 56, "../utils/deepCopy": 60, "../utils/getStrBytesCount": 66, "../utils/isArray": 67, "../utils/isObject": 74, "../utils/obj2xml": 76, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.includes.js": 315, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/web.dom-collections.for-each.js": 380 }], 22: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.includes.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/obj2xml"), obj2xml = _require2.obj2xml;
        var proto = exports3;
        proto.putBucketVersioning = /* @__PURE__ */ function() {
          var _putBucketVersioning = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, status) {
            var options, params, paramXMLObj, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    _checkBucketName(name);
                    if (["Enabled", "Suspended"].includes(status)) {
                      _context.next = 4;
                      break;
                    }
                    throw new Error("status must be Enabled or Suspended");
                  case 4:
                    params = this._bucketRequestParams("PUT", name, "versioning", options);
                    paramXMLObj = {
                      VersioningConfiguration: {
                        Status: status
                      }
                    };
                    params.mime = "xml";
                    params.content = obj2xml(paramXMLObj, {
                      headers: true
                    });
                    _context.next = 10;
                    return this.request(params);
                  case 10:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res,
                      status: result.status
                    });
                  case 12:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function putBucketVersioning(_x, _x2) {
            return _putBucketVersioning.apply(this, arguments);
          }
          return putBucketVersioning;
        }();
      }, { "../utils/checkBucketName": 53, "../utils/obj2xml": 76, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.includes.js": 315 }], 23: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/obj2xml"), obj2xml = _require2.obj2xml;
        var _require3 = require2("../utils/isArray"), isArray2 = _require3.isArray;
        var proto = exports3;
        proto.putBucketWebsite = /* @__PURE__ */ function() {
          var _putBucketWebsite = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name) {
            var config2, options, params, IndexDocument, WebsiteConfiguration, website, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    config2 = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options = _args.length > 2 ? _args[2] : void 0;
                    _checkBucketName(name);
                    params = this._bucketRequestParams("PUT", name, "website", options);
                    IndexDocument = {
                      Suffix: config2.index || "index.html"
                    };
                    WebsiteConfiguration = {
                      IndexDocument
                    };
                    website = {
                      WebsiteConfiguration
                    };
                    if (config2.supportSubDir) {
                      IndexDocument.SupportSubDir = config2.supportSubDir;
                    }
                    if (config2.type) {
                      IndexDocument.Type = config2.type;
                    }
                    if (config2.error) {
                      WebsiteConfiguration.ErrorDocument = {
                        Key: config2.error
                      };
                    }
                    if (!(config2.routingRules !== void 0)) {
                      _context.next = 14;
                      break;
                    }
                    if (isArray2(config2.routingRules)) {
                      _context.next = 13;
                      break;
                    }
                    throw new Error("RoutingRules must be Array");
                  case 13:
                    WebsiteConfiguration.RoutingRules = {
                      RoutingRule: config2.routingRules
                    };
                  case 14:
                    website = obj2xml(website);
                    params.content = website;
                    params.mime = "xml";
                    params.successStatuses = [200];
                    _context.next = 20;
                    return this.request(params);
                  case 20:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res
                    });
                  case 22:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function putBucketWebsite(_x) {
            return _putBucketWebsite.apply(this, arguments);
          }
          return putBucketWebsite;
        }();
      }, { "../utils/checkBucketName": 53, "../utils/isArray": 67, "../utils/obj2xml": 76, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93 }], 24: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.regexp.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.object.keys.js");
            exports3.encodeCallback = function encodeCallback(reqParams, options) {
              reqParams.headers = reqParams.headers || {};
              if (!Object.prototype.hasOwnProperty.call(reqParams.headers, "x-oss-callback")) {
                if (options.callback) {
                  var json = {
                    callbackUrl: encodeURI(options.callback.url),
                    callbackBody: options.callback.body
                  };
                  if (options.callback.host) {
                    json.callbackHost = options.callback.host;
                  }
                  if (options.callback.contentType) {
                    json.callbackBodyType = options.callback.contentType;
                  }
                  if (options.callback.callbackSNI) {
                    json.callbackSNI = options.callback.callbackSNI;
                  }
                  var callback = Buffer2.from(JSON.stringify(json)).toString("base64");
                  reqParams.headers["x-oss-callback"] = callback;
                  if (options.callback.customValue) {
                    var callbackVar = {};
                    Object.keys(options.callback.customValue).forEach(function(key) {
                      callbackVar["x:".concat(key)] = options.callback.customValue[key].toString();
                    });
                    reqParams.headers["x-oss-callback-var"] = Buffer2.from(JSON.stringify(callbackVar)).toString("base64");
                  }
                }
              }
            };
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 103, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/web.dom-collections.for-each.js": 380 }], 25: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        var __importDefault = function(mod) {
          return mod && mod.__esModule ? mod : {
            "default": mod
          };
        };
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.getReqUrl = void 0;
        var copy_to_1 = __importDefault(require2("copy-to"));
        var url_1 = __importDefault(require2("url"));
        var merge_descriptors_1 = __importDefault(require2("merge-descriptors"));
        var is_type_of_1 = __importDefault(require2("is-type-of"));
        var isIP_1 = require2("../utils/isIP");
        var checkConfigValid_1 = require2("../utils/checkConfigValid");
        function getReqUrl(params) {
          var ep = {};
          var isCname = this.options.cname;
          checkConfigValid_1.checkConfigValid(this.options.endpoint, "endpoint");
          copy_to_1.default(this.options.endpoint, false).to(ep);
          if (params.bucket && !isCname && !isIP_1.isIP(ep.hostname) && !this.options.sldEnable) {
            ep.host = "".concat(params.bucket, ".").concat(ep.host);
          }
          var resourcePath = "/";
          if (params.bucket && this.options.sldEnable) {
            resourcePath += "".concat(params.bucket, "/");
          }
          if (params.object) {
            resourcePath += this._escape(params.object).replace(/\+/g, "%2B");
          }
          ep.pathname = resourcePath;
          var query = {};
          if (params.query) {
            merge_descriptors_1.default(query, params.query);
          }
          if (params.subres) {
            var subresAsQuery = {};
            if (is_type_of_1.default.string(params.subres)) {
              subresAsQuery[params.subres] = "";
            } else if (is_type_of_1.default.array(params.subres)) {
              params.subres.forEach(function(k) {
                subresAsQuery[k] = "";
              });
            } else {
              subresAsQuery = params.subres;
            }
            merge_descriptors_1.default(query, subresAsQuery);
          }
          ep.query = query;
          return url_1.default.format(ep);
        }
        exports3.getReqUrl = getReqUrl;
      }, { "../utils/checkConfigValid": 54, "../utils/isIP": 73, "copy-to": 107, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.replace.js": 345, "core-js/modules/web.dom-collections.for-each.js": 380, "is-type-of": 537, "merge-descriptors": 428, "url": 543 }], 26: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.string.trim.js");
        var ms = require2("humanize-ms");
        var urlutil = require2("url");
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var _require2 = require2("../utils/setRegion"), setRegion = _require2.setRegion;
        var _require3 = require2("../utils/checkConfigValid"), checkConfigValid = _require3.checkConfigValid;
        function setEndpoint(endpoint, secure) {
          checkConfigValid(endpoint, "endpoint");
          var url2 = urlutil.parse(endpoint);
          if (!url2.protocol) {
            url2 = urlutil.parse("http".concat(secure ? "s" : "", "://").concat(endpoint));
          }
          if (url2.protocol !== "http:" && url2.protocol !== "https:") {
            throw new Error("Endpoint protocol must be http or https.");
          }
          return url2;
        }
        module3.exports = function(options) {
          if (!options || !options.accessKeyId || !options.accessKeySecret) {
            throw new Error("require accessKeyId, accessKeySecret");
          }
          if (options.stsToken && !options.refreshSTSToken && !options.refreshSTSTokenInterval) {
            index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:3421", "It's recommended to set 'refreshSTSToken' and 'refreshSTSTokenInterval' to refresh stsTokenaccessKeyIdaccessKeySecret automatically when sts token has expired");
          }
          if (options.bucket) {
            _checkBucketName(options.bucket);
          }
          var opts = Object.assign({
            region: "oss-cn-hangzhou",
            internal: false,
            secure: false,
            timeout: 6e4,
            bucket: null,
            endpoint: null,
            cname: false,
            isRequestPay: false,
            sldEnable: false,
            headerEncoding: "utf-8",
            refreshSTSToken: null,
            refreshSTSTokenInterval: 6e4 * 5,
            retryMax: 0,
            authorizationV4: false
            // v4
          }, options);
          opts.accessKeyId = opts.accessKeyId.trim();
          opts.accessKeySecret = opts.accessKeySecret.trim();
          if (opts.timeout) {
            opts.timeout = ms(opts.timeout);
          }
          if (opts.endpoint) {
            opts.endpoint = setEndpoint(opts.endpoint, opts.secure);
          } else if (opts.region) {
            opts.endpoint = setRegion(opts.region, opts.internal, opts.secure);
          } else {
            throw new Error("require options.endpoint or options.region");
          }
          opts.inited = true;
          return opts;
        };
      }, { "../utils/checkBucketName": 53, "../utils/checkConfigValid": 54, "../utils/setRegion": 81, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.string.trim.js": 349, "humanize-ms": 399, "url": 543 }], 27: [function(require2, module3, exports3) {
        var merge = require2("merge-descriptors");
        var proto = exports3;
        merge(proto, require2("./processObjectSave"));
      }, { "./processObjectSave": 28, "merge-descriptors": 428 }], 28: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.concat.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var querystring2 = require2("querystring");
        var _require2 = require2("js-base64"), str2Base64 = _require2.Base64.encode;
        var proto = exports3;
        proto.processObjectSave = /* @__PURE__ */ function() {
          var _processObjectSave = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(sourceObject, targetObject, process, targetBucket) {
            var params, bucketParam, content2, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    checkArgs(sourceObject, "sourceObject");
                    checkArgs(targetObject, "targetObject");
                    checkArgs(process, "process");
                    targetObject = this._objectName(targetObject);
                    if (targetBucket) {
                      _checkBucketName(targetBucket);
                    }
                    params = this._objectRequestParams("POST", sourceObject, {
                      subres: "x-oss-process"
                    });
                    bucketParam = targetBucket ? ",b_".concat(str2Base64(targetBucket)) : "";
                    targetObject = str2Base64(targetObject);
                    content2 = {
                      "x-oss-process": "".concat(process, "|sys/saveas,o_").concat(targetObject).concat(bucketParam)
                    };
                    params.content = querystring2.stringify(content2);
                    _context.next = 12;
                    return this.request(params);
                  case 12:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res,
                      status: result.res.status
                    });
                  case 14:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function processObjectSave(_x, _x2, _x3, _x4) {
            return _processObjectSave.apply(this, arguments);
          }
          return processObjectSave;
        }();
        function checkArgs(name, key) {
          if (!name) {
            throw new Error("".concat(key, " is required"));
          }
          if (typeof name !== "string") {
            throw new Error("".concat(key, " must be String"));
          }
        }
      }, { "../utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.concat.js": 310, "js-base64": 413, "querystring": 451 }], 29: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.function.name.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.promise.js");
        require2("core-js/modules/es.array.from.js");
        require2("core-js/modules/es.string.iterator.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.array.filter.js");
        require2("core-js/modules/es.array.find.js");
        require2("core-js/modules/es.regexp.to-string.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var debug = require2("debug")("ali-oss:multipart-copy");
        var copy = require2("copy-to");
        var proto = exports3;
        proto.uploadPartCopy = /* @__PURE__ */ function() {
          var _uploadPartCopy = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, uploadId, partNo, range2, sourceData) {
            var options, versionId, copySource, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 5 && _args[5] !== void 0 ? _args[5] : {};
                    options.headers = options.headers || {};
                    versionId = options.versionId || options.subres && options.subres.versionId || null;
                    if (versionId) {
                      copySource = "/".concat(sourceData.sourceBucketName, "/").concat(encodeURIComponent(sourceData.sourceKey), "?versionId=").concat(versionId);
                    } else {
                      copySource = "/".concat(sourceData.sourceBucketName, "/").concat(encodeURIComponent(sourceData.sourceKey));
                    }
                    options.headers["x-oss-copy-source"] = copySource;
                    if (range2) {
                      options.headers["x-oss-copy-source-range"] = "bytes=".concat(range2);
                    }
                    options.subres = {
                      partNumber: partNo,
                      uploadId
                    };
                    params = this._objectRequestParams("PUT", name, options);
                    params.mime = options.mime;
                    params.successStatuses = [200];
                    _context.next = 12;
                    return this.request(params);
                  case 12:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      name,
                      etag: result.res.headers.etag,
                      res: result.res
                    });
                  case 14:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function uploadPartCopy(_x, _x2, _x3, _x4, _x5) {
            return _uploadPartCopy.apply(this, arguments);
          }
          return uploadPartCopy;
        }();
        proto.multipartUploadCopy = /* @__PURE__ */ function() {
          var _multipartUploadCopy = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(name, sourceData) {
            var options, _options$versionId, versionId, metaOpt, objectMeta, fileSize, minPartSize, copySize, init, uploadId, partSize, checkpoint, _args2 = arguments;
            return _regenerator.default.wrap(function _callee2$(_context2) {
              while (1)
                switch (_context2.prev = _context2.next) {
                  case 0:
                    options = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : {};
                    this.resetCancelFlag();
                    _options$versionId = options.versionId, versionId = _options$versionId === void 0 ? null : _options$versionId;
                    metaOpt = {
                      versionId
                    };
                    _context2.next = 6;
                    return this._getObjectMeta(sourceData.sourceBucketName, sourceData.sourceKey, metaOpt);
                  case 6:
                    objectMeta = _context2.sent;
                    fileSize = objectMeta.res.headers["content-length"];
                    sourceData.startOffset = sourceData.startOffset || 0;
                    sourceData.endOffset = sourceData.endOffset || fileSize;
                    if (!(options.checkpoint && options.checkpoint.uploadId)) {
                      _context2.next = 14;
                      break;
                    }
                    _context2.next = 13;
                    return this._resumeMultipartCopy(options.checkpoint, sourceData, options);
                  case 13:
                    return _context2.abrupt("return", _context2.sent);
                  case 14:
                    minPartSize = 100 * 1024;
                    copySize = sourceData.endOffset - sourceData.startOffset;
                    if (!(copySize < minPartSize)) {
                      _context2.next = 18;
                      break;
                    }
                    throw new Error("copySize must not be smaller than ".concat(minPartSize));
                  case 18:
                    if (!(options.partSize && options.partSize < minPartSize)) {
                      _context2.next = 20;
                      break;
                    }
                    throw new Error("partSize must not be smaller than ".concat(minPartSize));
                  case 20:
                    _context2.next = 22;
                    return this.initMultipartUpload(name, options);
                  case 22:
                    init = _context2.sent;
                    uploadId = init.uploadId;
                    partSize = this._getPartSize(copySize, options.partSize);
                    checkpoint = {
                      name,
                      copySize,
                      partSize,
                      uploadId,
                      doneParts: []
                    };
                    if (!(options && options.progress)) {
                      _context2.next = 29;
                      break;
                    }
                    _context2.next = 29;
                    return options.progress(0, checkpoint, init.res);
                  case 29:
                    _context2.next = 31;
                    return this._resumeMultipartCopy(checkpoint, sourceData, options);
                  case 31:
                    return _context2.abrupt("return", _context2.sent);
                  case 32:
                  case "end":
                    return _context2.stop();
                }
            }, _callee2, this);
          }));
          function multipartUploadCopy(_x6, _x7) {
            return _multipartUploadCopy.apply(this, arguments);
          }
          return multipartUploadCopy;
        }();
        proto._resumeMultipartCopy = /* @__PURE__ */ function() {
          var _resumeMultipartCopy2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(checkpoint, sourceData, options) {
            var _options$versionId2, versionId, metaOpt, copySize, partSize, uploadId, doneParts, name, partOffs, numParts, uploadPartCopyOptions, uploadPartJob, all, done, todo, defaultParallel, parallel, i, errors, abortEvent, err;
            return _regenerator.default.wrap(function _callee4$(_context4) {
              while (1)
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!this.isCancel()) {
                      _context4.next = 2;
                      break;
                    }
                    throw this._makeCancelEvent();
                  case 2:
                    _options$versionId2 = options.versionId, versionId = _options$versionId2 === void 0 ? null : _options$versionId2;
                    metaOpt = {
                      versionId
                    };
                    copySize = checkpoint.copySize, partSize = checkpoint.partSize, uploadId = checkpoint.uploadId, doneParts = checkpoint.doneParts, name = checkpoint.name;
                    partOffs = this._divideMultipartCopyParts(copySize, partSize, sourceData.startOffset);
                    numParts = partOffs.length;
                    uploadPartCopyOptions = {
                      headers: {}
                    };
                    if (options.copyheaders) {
                      copy(options.copyheaders).to(uploadPartCopyOptions.headers);
                    }
                    if (versionId) {
                      copy(metaOpt).to(uploadPartCopyOptions);
                    }
                    uploadPartJob = function uploadPartJob2(self2, partNo, source) {
                      return new Promise(/* @__PURE__ */ function() {
                        var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(resolve2, reject) {
                          var pi, range2, result;
                          return _regenerator.default.wrap(function _callee3$(_context3) {
                            while (1)
                              switch (_context3.prev = _context3.next) {
                                case 0:
                                  _context3.prev = 0;
                                  if (self2.isCancel()) {
                                    _context3.next = 22;
                                    break;
                                  }
                                  pi = partOffs[partNo - 1];
                                  range2 = "".concat(pi.start, "-").concat(pi.end - 1);
                                  _context3.prev = 4;
                                  _context3.next = 7;
                                  return self2.uploadPartCopy(name, uploadId, partNo, range2, source, uploadPartCopyOptions);
                                case 7:
                                  result = _context3.sent;
                                  _context3.next = 15;
                                  break;
                                case 10:
                                  _context3.prev = 10;
                                  _context3.t0 = _context3["catch"](4);
                                  if (!(_context3.t0.status === 404)) {
                                    _context3.next = 14;
                                    break;
                                  }
                                  throw self2._makeAbortEvent();
                                case 14:
                                  throw _context3.t0;
                                case 15:
                                  if (self2.isCancel()) {
                                    _context3.next = 22;
                                    break;
                                  }
                                  debug("content-range ".concat(result.res.headers["content-range"]));
                                  doneParts.push({
                                    number: partNo,
                                    etag: result.res.headers.etag
                                  });
                                  checkpoint.doneParts = doneParts;
                                  if (!(options && options.progress)) {
                                    _context3.next = 22;
                                    break;
                                  }
                                  _context3.next = 22;
                                  return options.progress(doneParts.length / numParts, checkpoint, result.res);
                                case 22:
                                  resolve2();
                                  _context3.next = 29;
                                  break;
                                case 25:
                                  _context3.prev = 25;
                                  _context3.t1 = _context3["catch"](0);
                                  _context3.t1.partNum = partNo;
                                  reject(_context3.t1);
                                case 29:
                                case "end":
                                  return _context3.stop();
                              }
                          }, _callee3, null, [[0, 25], [4, 10]]);
                        }));
                        return function(_x11, _x12) {
                          return _ref.apply(this, arguments);
                        };
                      }());
                    };
                    all = Array.from(new Array(numParts), function(x, i2) {
                      return i2 + 1;
                    });
                    done = doneParts.map(function(p2) {
                      return p2.number;
                    });
                    todo = all.filter(function(p2) {
                      return done.indexOf(p2) < 0;
                    });
                    defaultParallel = 5;
                    parallel = options.parallel || defaultParallel;
                    if (!(this.checkBrowserAndVersion("Internet Explorer", "10") || parallel === 1)) {
                      _context4.next = 28;
                      break;
                    }
                    i = 0;
                  case 18:
                    if (!(i < todo.length)) {
                      _context4.next = 26;
                      break;
                    }
                    if (!this.isCancel()) {
                      _context4.next = 21;
                      break;
                    }
                    throw this._makeCancelEvent();
                  case 21:
                    _context4.next = 23;
                    return uploadPartJob(this, todo[i], sourceData);
                  case 23:
                    i++;
                    _context4.next = 18;
                    break;
                  case 26:
                    _context4.next = 40;
                    break;
                  case 28:
                    _context4.next = 30;
                    return this._parallelNode(todo, parallel, uploadPartJob, sourceData);
                  case 30:
                    errors = _context4.sent;
                    abortEvent = errors.find(function(err2) {
                      return err2.name === "abort";
                    });
                    if (!abortEvent) {
                      _context4.next = 34;
                      break;
                    }
                    throw abortEvent;
                  case 34:
                    if (!this.isCancel()) {
                      _context4.next = 36;
                      break;
                    }
                    throw this._makeCancelEvent();
                  case 36:
                    if (!(errors && errors.length > 0)) {
                      _context4.next = 40;
                      break;
                    }
                    err = errors[0];
                    err.message = "Failed to copy some parts with error: ".concat(err.toString(), " part_num: ").concat(err.partNum);
                    throw err;
                  case 40:
                    _context4.next = 42;
                    return this.completeMultipartUpload(name, uploadId, doneParts, options);
                  case 42:
                    return _context4.abrupt("return", _context4.sent);
                  case 43:
                  case "end":
                    return _context4.stop();
                }
            }, _callee4, this);
          }));
          function _resumeMultipartCopy(_x8, _x9, _x10) {
            return _resumeMultipartCopy2.apply(this, arguments);
          }
          return _resumeMultipartCopy;
        }();
        proto._divideMultipartCopyParts = function _divideMultipartCopyParts(fileSize, partSize, startOffset) {
          var numParts = Math.ceil(fileSize / partSize);
          var partOffs = [];
          for (var i = 0; i < numParts; i++) {
            var start = partSize * i + startOffset;
            var end = Math.min(start + partSize, fileSize + startOffset);
            partOffs.push({
              start,
              end
            });
          }
          return partOffs;
        };
        proto._getObjectMeta = /* @__PURE__ */ function() {
          var _getObjectMeta2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(bucket, name, options) {
            var currentBucket, data;
            return _regenerator.default.wrap(function _callee5$(_context5) {
              while (1)
                switch (_context5.prev = _context5.next) {
                  case 0:
                    currentBucket = this.getBucket();
                    this.setBucket(bucket);
                    _context5.next = 4;
                    return this.head(name, options);
                  case 4:
                    data = _context5.sent;
                    this.setBucket(currentBucket);
                    return _context5.abrupt("return", data);
                  case 7:
                  case "end":
                    return _context5.stop();
                }
            }, _callee5, this);
          }));
          function _getObjectMeta(_x13, _x14, _x15) {
            return _getObjectMeta2.apply(this, arguments);
          }
          return _getObjectMeta;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "copy-to": 107, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.filter.js": 312, "core-js/modules/es.array.find.js": 313, "core-js/modules/es.array.from.js": 314, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.function.name.js": 322, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.string.iterator.js": 343, "debug": 536 }], 30: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
            require2("core-js/modules/es.array.map.js");
            require2("core-js/modules/es.array.filter.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.array.sort.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.object.keys.js");
            require2("core-js/modules/es.regexp.to-string.js");
            var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
            var copy = require2("copy-to");
            var callback = require2("./callback");
            var _require = require2("./utils/deepCopy"), deepCopyWith = _require.deepCopyWith;
            var _require2 = require2("./utils/isBuffer"), isBuffer = _require2.isBuffer;
            var _require3 = require2("./utils/omit"), omit = _require3.omit;
            var proto = exports3;
            proto.listUploads = /* @__PURE__ */ function() {
              var _listUploads = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(query, options) {
                var opt, params, result, uploads;
                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1)
                    switch (_context.prev = _context.next) {
                      case 0:
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.subres = "uploads";
                        params = this._objectRequestParams("GET", "", opt);
                        params.query = query;
                        params.xmlResponse = true;
                        params.successStatuses = [200];
                        _context.next = 10;
                        return this.request(params);
                      case 10:
                        result = _context.sent;
                        uploads = result.data.Upload || [];
                        if (!Array.isArray(uploads)) {
                          uploads = [uploads];
                        }
                        uploads = uploads.map(function(up) {
                          return {
                            name: up.Key,
                            uploadId: up.UploadId,
                            initiated: up.Initiated
                          };
                        });
                        return _context.abrupt("return", {
                          res: result.res,
                          uploads,
                          bucket: result.data.Bucket,
                          nextKeyMarker: result.data.NextKeyMarker,
                          nextUploadIdMarker: result.data.NextUploadIdMarker,
                          isTruncated: result.data.IsTruncated === "true"
                        });
                      case 15:
                      case "end":
                        return _context.stop();
                    }
                }, _callee, this);
              }));
              function listUploads(_x, _x2) {
                return _listUploads.apply(this, arguments);
              }
              return listUploads;
            }();
            proto.listParts = /* @__PURE__ */ function() {
              var _listParts = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(name, uploadId, query, options) {
                var opt, params, result;
                return _regenerator.default.wrap(function _callee2$(_context2) {
                  while (1)
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.subres = {
                          uploadId
                        };
                        params = this._objectRequestParams("GET", name, opt);
                        params.query = query;
                        params.xmlResponse = true;
                        params.successStatuses = [200];
                        _context2.next = 10;
                        return this.request(params);
                      case 10:
                        result = _context2.sent;
                        return _context2.abrupt("return", {
                          res: result.res,
                          uploadId: result.data.UploadId,
                          bucket: result.data.Bucket,
                          name: result.data.Key,
                          partNumberMarker: result.data.PartNumberMarker,
                          nextPartNumberMarker: result.data.NextPartNumberMarker,
                          maxParts: result.data.MaxParts,
                          isTruncated: result.data.IsTruncated,
                          parts: result.data.Part || []
                        });
                      case 12:
                      case "end":
                        return _context2.stop();
                    }
                }, _callee2, this);
              }));
              function listParts(_x3, _x4, _x5, _x6) {
                return _listParts.apply(this, arguments);
              }
              return listParts;
            }();
            proto.abortMultipartUpload = /* @__PURE__ */ function() {
              var _abortMultipartUpload = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(name, uploadId, options) {
                var opt, params, result;
                return _regenerator.default.wrap(function _callee3$(_context3) {
                  while (1)
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        this._stop();
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.subres = {
                          uploadId
                        };
                        params = this._objectRequestParams("DELETE", name, opt);
                        params.successStatuses = [204];
                        _context3.next = 9;
                        return this.request(params);
                      case 9:
                        result = _context3.sent;
                        return _context3.abrupt("return", {
                          res: result.res
                        });
                      case 11:
                      case "end":
                        return _context3.stop();
                    }
                }, _callee3, this);
              }));
              function abortMultipartUpload(_x7, _x8, _x9) {
                return _abortMultipartUpload.apply(this, arguments);
              }
              return abortMultipartUpload;
            }();
            proto.initMultipartUpload = /* @__PURE__ */ function() {
              var _initMultipartUpload = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(name, options) {
                var opt, params, result;
                return _regenerator.default.wrap(function _callee4$(_context4) {
                  while (1)
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.headers = opt.headers || {};
                        this._convertMetaToHeaders(options.meta, opt.headers);
                        opt.subres = "uploads";
                        params = this._objectRequestParams("POST", name, opt);
                        params.mime = options.mime;
                        params.xmlResponse = true;
                        params.successStatuses = [200];
                        _context4.next = 12;
                        return this.request(params);
                      case 12:
                        result = _context4.sent;
                        return _context4.abrupt("return", {
                          res: result.res,
                          bucket: result.data.Bucket,
                          name: result.data.Key,
                          uploadId: result.data.UploadId
                        });
                      case 14:
                      case "end":
                        return _context4.stop();
                    }
                }, _callee4, this);
              }));
              function initMultipartUpload(_x10, _x11) {
                return _initMultipartUpload.apply(this, arguments);
              }
              return initMultipartUpload;
            }();
            proto.uploadPart = /* @__PURE__ */ function() {
              var _uploadPart2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(name, uploadId, partNo, file, start, end, options) {
                var data, isBrowserEnv;
                return _regenerator.default.wrap(function _callee5$(_context5) {
                  while (1)
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        data = {
                          size: end - start
                        };
                        isBrowserEnv = process && process.browser;
                        if (!isBrowserEnv) {
                          _context5.next = 8;
                          break;
                        }
                        _context5.next = 5;
                        return this._createBuffer(file, start, end);
                      case 5:
                        data.content = _context5.sent;
                        _context5.next = 11;
                        break;
                      case 8:
                        _context5.next = 10;
                        return this._createStream(file, start, end);
                      case 10:
                        data.stream = _context5.sent;
                      case 11:
                        _context5.next = 13;
                        return this._uploadPart(name, uploadId, partNo, data, options);
                      case 13:
                        return _context5.abrupt("return", _context5.sent);
                      case 14:
                      case "end":
                        return _context5.stop();
                    }
                }, _callee5, this);
              }));
              function uploadPart(_x12, _x13, _x14, _x15, _x16, _x17, _x18) {
                return _uploadPart2.apply(this, arguments);
              }
              return uploadPart;
            }();
            proto.completeMultipartUpload = /* @__PURE__ */ function() {
              var _completeMultipartUpload = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6(name, uploadId, parts, options) {
                var completeParts, xml, i, p2, opt, params, result, ret;
                return _regenerator.default.wrap(function _callee6$(_context6) {
                  while (1)
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        completeParts = parts.concat().sort(function(a2, b) {
                          return a2.number - b.number;
                        }).filter(function(item, index2, arr) {
                          return !index2 || item.number !== arr[index2 - 1].number;
                        });
                        xml = '<?xml version="1.0" encoding="UTF-8"?>\n<CompleteMultipartUpload>\n';
                        for (i = 0; i < completeParts.length; i++) {
                          p2 = completeParts[i];
                          xml += "<Part>\n";
                          xml += "<PartNumber>".concat(p2.number, "</PartNumber>\n");
                          xml += "<ETag>".concat(p2.etag, "</ETag>\n");
                          xml += "</Part>\n";
                        }
                        xml += "</CompleteMultipartUpload>";
                        options = options || {};
                        opt = {};
                        opt = deepCopyWith(options, function(_) {
                          if (isBuffer(_))
                            return null;
                        });
                        opt.subres = {
                          uploadId
                        };
                        opt.headers = omit(opt.headers, ["x-oss-server-side-encryption", "x-oss-storage-class"]);
                        params = this._objectRequestParams("POST", name, opt);
                        callback.encodeCallback(params, opt);
                        params.mime = "xml";
                        params.content = xml;
                        if (!(params.headers && params.headers["x-oss-callback"])) {
                          params.xmlResponse = true;
                        }
                        params.successStatuses = [200];
                        _context6.next = 17;
                        return this.request(params);
                      case 17:
                        result = _context6.sent;
                        if (!options.progress) {
                          _context6.next = 21;
                          break;
                        }
                        _context6.next = 21;
                        return options.progress(1, null, result.res);
                      case 21:
                        ret = {
                          res: result.res,
                          bucket: params.bucket,
                          name,
                          etag: result.res.headers.etag
                        };
                        if (params.headers && params.headers["x-oss-callback"]) {
                          ret.data = JSON.parse(result.data.toString());
                        }
                        return _context6.abrupt("return", ret);
                      case 24:
                      case "end":
                        return _context6.stop();
                    }
                }, _callee6, this);
              }));
              function completeMultipartUpload(_x19, _x20, _x21, _x22) {
                return _completeMultipartUpload.apply(this, arguments);
              }
              return completeMultipartUpload;
            }();
            proto._uploadPart = /* @__PURE__ */ function() {
              var _uploadPart3 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7(name, uploadId, partNo, data, options) {
                var opt, params, isBrowserEnv, result;
                return _regenerator.default.wrap(function _callee7$(_context7) {
                  while (1)
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        options = options || {};
                        opt = {};
                        copy(options).to(opt);
                        opt.headers = opt.headers || {};
                        opt.headers["Content-Length"] = data.size;
                        opt.headers = omit(opt.headers, ["x-oss-server-side-encryption", "x-oss-storage-class"]);
                        opt.subres = {
                          partNumber: partNo,
                          uploadId
                        };
                        params = this._objectRequestParams("PUT", name, opt);
                        params.mime = opt.mime;
                        isBrowserEnv = process && process.browser;
                        isBrowserEnv ? params.content = data.content : params.stream = data.stream;
                        params.successStatuses = [200];
                        params.disabledMD5 = options.disabledMD5;
                        _context7.next = 15;
                        return this.request(params);
                      case 15:
                        result = _context7.sent;
                        if (result.res.headers.etag) {
                          _context7.next = 18;
                          break;
                        }
                        throw new Error("Please set the etag of expose-headers in OSS \n https://help.aliyun.com/document_detail/32069.html");
                      case 18:
                        if (data.stream) {
                          data.stream = null;
                          params.stream = null;
                        }
                        return _context7.abrupt("return", {
                          name,
                          etag: result.res.headers.etag,
                          res: result.res
                        });
                      case 20:
                      case "end":
                        return _context7.stop();
                    }
                }, _callee7, this);
              }));
              function _uploadPart(_x23, _x24, _x25, _x26, _x27) {
                return _uploadPart3.apply(this, arguments);
              }
              return _uploadPart;
            }();
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./callback": 24, "./utils/deepCopy": 60, "./utils/isBuffer": 69, "./utils/omit": 77, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "_process": 538, "copy-to": 107, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.filter.js": 312, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.array.sort.js": 320, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.to-string.js": 339 }], 31: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.regexp.exec.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var urlutil = require2("url");
        var utility = require2("utility");
        var copy = require2("copy-to");
        var signHelper = require2("../../common/signUtils");
        var _require = require2("../utils/isIP"), isIP = _require.isIP;
        var _require2 = require2("../utils/setSTSToken"), setSTSToken = _require2.setSTSToken;
        var _require3 = require2("../utils/isFunction"), isFunction2 = _require3.isFunction;
        var proto = exports3;
        proto.asyncSignatureUrl = /* @__PURE__ */ function() {
          var _asyncSignatureUrl = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var strictObjectNameValidation, expires, params, resource, signRes, url2, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    strictObjectNameValidation = _args.length > 2 && _args[2] !== void 0 ? _args[2] : true;
                    if (!isIP(this.options.endpoint.hostname)) {
                      _context.next = 3;
                      break;
                    }
                    throw new Error("can not get the object URL when endpoint is IP");
                  case 3:
                    if (!(strictObjectNameValidation && /^\?/.test(name))) {
                      _context.next = 5;
                      break;
                    }
                    throw new Error("Invalid object name ".concat(name));
                  case 5:
                    options = options || {};
                    name = this._objectName(name);
                    options.method = options.method || "GET";
                    expires = utility.timestamp() + (options.expires || 1800);
                    params = {
                      bucket: this.options.bucket,
                      object: name
                    };
                    resource = this._getResource(params);
                    if (!(this.options.stsToken && isFunction2(this.options.refreshSTSToken))) {
                      _context.next = 14;
                      break;
                    }
                    _context.next = 14;
                    return setSTSToken.call(this);
                  case 14:
                    if (this.options.stsToken) {
                      options["security-token"] = this.options.stsToken;
                    }
                    signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);
                    url2 = urlutil.parse(this._getReqUrl(params));
                    url2.query = {
                      OSSAccessKeyId: this.options.accessKeyId,
                      Expires: expires,
                      Signature: signRes.Signature
                    };
                    copy(signRes.subResource).to(url2.query);
                    return _context.abrupt("return", url2.format());
                  case 20:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function asyncSignatureUrl(_x, _x2) {
            return _asyncSignatureUrl.apply(this, arguments);
          }
          return asyncSignatureUrl;
        }();
      }, { "../../common/signUtils": 52, "../utils/isFunction": 72, "../utils/isIP": 73, "../utils/setSTSToken": 82, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "copy-to": 107, "core-js/modules/es.regexp.exec.js": 338, "url": 543, "utility": 545 }], 32: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.find.js");
        require2("core-js/modules/es.array.includes.js");
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkBucketName"), _checkBucketName = _require.checkBucketName;
        var proto = exports3;
        var REPLACE_HEDERS = ["content-type", "content-encoding", "content-language", "content-disposition", "cache-control", "expires"];
        proto.copy = /* @__PURE__ */ function() {
          var _copy = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, sourceName, bucketName, options) {
            var params, result, data;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    if ((0, _typeof2.default)(bucketName) === "object") {
                      options = bucketName;
                    }
                    options = options || {};
                    options.headers = options.headers || {};
                    Object.keys(options.headers).forEach(function(key) {
                      options.headers["x-oss-copy-source-".concat(key.toLowerCase())] = options.headers[key];
                    });
                    if (options.meta || Object.keys(options.headers).find(function(_) {
                      return REPLACE_HEDERS.includes(_.toLowerCase());
                    })) {
                      options.headers["x-oss-metadata-directive"] = "REPLACE";
                    }
                    this._convertMetaToHeaders(options.meta, options.headers);
                    sourceName = this._getSourceName(sourceName, bucketName);
                    if (options.versionId) {
                      sourceName = "".concat(sourceName, "?versionId=").concat(options.versionId);
                    }
                    options.headers["x-oss-copy-source"] = sourceName;
                    params = this._objectRequestParams("PUT", name, options);
                    params.xmlResponse = true;
                    params.successStatuses = [200, 304];
                    _context.next = 14;
                    return this.request(params);
                  case 14:
                    result = _context.sent;
                    data = result.data;
                    if (data) {
                      data = {
                        etag: data.ETag,
                        lastModified: data.LastModified
                      };
                    }
                    return _context.abrupt("return", {
                      data,
                      res: result.res
                    });
                  case 18:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function copy(_x, _x2, _x3, _x4) {
            return _copy.apply(this, arguments);
          }
          return copy;
        }();
        proto._getSourceName = function _getSourceName(sourceName, bucketName) {
          if (typeof bucketName === "string") {
            sourceName = this._objectName(sourceName);
          } else if (sourceName[0] !== "/") {
            bucketName = this.options.bucket;
          } else {
            bucketName = sourceName.replace(/\/(.+?)(\/.*)/, "$1");
            sourceName = sourceName.replace(/(\/.+?\/)(.*)/, "$2");
          }
          _checkBucketName(bucketName);
          sourceName = encodeURIComponent(sourceName);
          sourceName = "/".concat(bucketName, "/").concat(sourceName);
          return sourceName;
        };
      }, { "../utils/checkBucketName": 53, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/helpers/typeof": 91, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.find.js": 313, "core-js/modules/es.array.includes.js": 315, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.replace.js": 345, "core-js/modules/web.dom-collections.for-each.js": 380 }], 33: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        proto.delete = /* @__PURE__ */ function() {
          var _delete2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name) {
            var options, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({}, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("DELETE", name, options);
                    params.successStatuses = [204];
                    _context.next = 7;
                    return this.request(params);
                  case 7:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res
                    });
                  case 9:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function _delete(_x) {
            return _delete2.apply(this, arguments);
          }
          return _delete;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 34: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var utility = require2("utility");
        var _require = require2("../utils/obj2xml"), obj2xml = _require.obj2xml;
        var proto = exports3;
        proto.deleteMulti = /* @__PURE__ */ function() {
          var _deleteMulti = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(names) {
            var options, objects, i, object2, _names$i, key, versionId, paramXMLObj, paramXML, params, result, r, deleted, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    objects = [];
                    if (!(!names || !names.length)) {
                      _context.next = 4;
                      break;
                    }
                    throw new Error("names is required");
                  case 4:
                    for (i = 0; i < names.length; i++) {
                      object2 = {};
                      if (typeof names[i] === "string") {
                        object2.Key = utility.escape(this._objectName(names[i]));
                      } else {
                        _names$i = names[i], key = _names$i.key, versionId = _names$i.versionId;
                        object2.Key = utility.escape(this._objectName(key));
                        object2.VersionId = versionId;
                      }
                      objects.push(object2);
                    }
                    paramXMLObj = {
                      Delete: {
                        Quiet: !!options.quiet,
                        Object: objects
                      }
                    };
                    paramXML = obj2xml(paramXMLObj, {
                      headers: true
                    });
                    options.subres = Object.assign({
                      delete: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("POST", "", options);
                    params.mime = "xml";
                    params.content = paramXML;
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    _context.next = 16;
                    return this.request(params);
                  case 16:
                    result = _context.sent;
                    r = result.data;
                    deleted = r && r.Deleted || null;
                    if (deleted) {
                      if (!Array.isArray(deleted)) {
                        deleted = [deleted];
                      }
                    }
                    return _context.abrupt("return", {
                      res: result.res,
                      deleted: deleted || []
                    });
                  case 21:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function deleteMulti(_x) {
            return _deleteMulti.apply(this, arguments);
          }
          return deleteMulti;
        }();
      }, { "../utils/obj2xml": 76, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325, "utility": 545 }], 35: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        proto.deleteObjectTagging = /* @__PURE__ */ function() {
          var _deleteObjectTagging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name) {
            var options, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({
                      tagging: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name = this._objectName(name);
                    params = this._objectRequestParams("DELETE", name, options);
                    params.successStatuses = [204];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      status: result.status,
                      res: result.res
                    });
                  case 10:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function deleteObjectTagging(_x) {
            return _deleteObjectTagging.apply(this, arguments);
          }
          return deleteObjectTagging;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 36: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.concat.js");
        var urlutil = require2("url");
        var _require = require2("../utils/isIP"), isIP = _require.isIP;
        var proto = exports3;
        proto.generateObjectUrl = function generateObjectUrl(name, baseUrl) {
          if (isIP(this.options.endpoint.hostname)) {
            throw new Error("can not get the object URL when endpoint is IP");
          }
          if (!baseUrl) {
            baseUrl = this.options.endpoint.format();
            var copyUrl = urlutil.parse(baseUrl);
            var bucket = this.options.bucket;
            copyUrl.hostname = "".concat(bucket, ".").concat(copyUrl.hostname);
            copyUrl.host = "".concat(bucket, ".").concat(copyUrl.host);
            baseUrl = copyUrl.format();
          } else if (baseUrl[baseUrl.length - 1] !== "/") {
            baseUrl += "/";
          }
          return baseUrl + this._escape(this._objectName(name));
        };
      }, { "../utils/isIP": 73, "core-js/modules/es.array.concat.js": 310, "url": 543 }], 37: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
            require2("core-js/modules/es.object.assign.js");
            var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
            var fs = require2("fs");
            var is = require2("is-type-of");
            var _require = require2("../utils/isObject"), isObject2 = _require.isObject;
            var proto = exports3;
            proto.get = /* @__PURE__ */ function() {
              var _get = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, file) {
                var options, writeStream, needDestroy, isBrowserEnv, responseCacheControl, defaultSubresOptions, result, params, _args = arguments;
                return _regenerator.default.wrap(function _callee$(_context) {
                  while (1)
                    switch (_context.prev = _context.next) {
                      case 0:
                        options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                        writeStream = null;
                        needDestroy = false;
                        if (is.writableStream(file)) {
                          writeStream = file;
                        } else if (is.string(file)) {
                          writeStream = fs.createWriteStream(file);
                          needDestroy = true;
                        } else if (isObject2(file)) {
                          options = file;
                        }
                        options = options || {};
                        isBrowserEnv = process && process.browser;
                        responseCacheControl = options.responseCacheControl === null ? "" : "no-cache";
                        defaultSubresOptions = isBrowserEnv && responseCacheControl ? {
                          "response-cache-control": responseCacheControl
                        } : {};
                        options.subres = Object.assign(defaultSubresOptions, options.subres);
                        if (options.versionId) {
                          options.subres.versionId = options.versionId;
                        }
                        if (options.process) {
                          options.subres["x-oss-process"] = options.process;
                        }
                        _context.prev = 11;
                        params = this._objectRequestParams("GET", name, options);
                        params.writeStream = writeStream;
                        params.successStatuses = [200, 206, 304];
                        _context.next = 17;
                        return this.request(params);
                      case 17:
                        result = _context.sent;
                        if (needDestroy) {
                          writeStream.destroy();
                        }
                        _context.next = 28;
                        break;
                      case 21:
                        _context.prev = 21;
                        _context.t0 = _context["catch"](11);
                        if (!needDestroy) {
                          _context.next = 27;
                          break;
                        }
                        writeStream.destroy();
                        _context.next = 27;
                        return this._deleteFileSafe(file);
                      case 27:
                        throw _context.t0;
                      case 28:
                        return _context.abrupt("return", {
                          res: result.res,
                          content: result.data
                        });
                      case 29:
                      case "end":
                        return _context.stop();
                    }
                }, _callee, this, [[11, 21]]);
              }));
              function get3(_x, _x2) {
                return _get.apply(this, arguments);
              }
              return get3;
            }();
          }).call(this);
        }).call(this, require2("_process"));
      }, { "../utils/isObject": 74, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "_process": 538, "core-js/modules/es.object.assign.js": 325, "fs": 102, "is-type-of": 537 }], 38: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        proto.getACL = /* @__PURE__ */ function() {
          var _getACL = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name) {
            var options, params, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({
                      acl: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name = this._objectName(name);
                    params = this._objectRequestParams("GET", name, options);
                    params.successStatuses = [200];
                    params.xmlResponse = true;
                    _context.next = 9;
                    return this.request(params);
                  case 9:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      acl: result.data.AccessControlList.Grant,
                      owner: {
                        id: result.data.Owner.ID,
                        displayName: result.data.Owner.DisplayName
                      },
                      res: result.res
                    });
                  case 11:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function getACL(_x) {
            return _getACL.apply(this, arguments);
          }
          return getACL;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 39: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.number.constructor.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        var _require = require2("../utils/isObject"), isObject2 = _require.isObject;
        var _require2 = require2("../utils/isArray"), isArray2 = _require2.isArray;
        var _require3 = require2("../utils/parseRestoreInfo"), parseRestoreInfo = _require3.parseRestoreInfo;
        proto.getBucketVersions = getBucketVersions;
        proto.listObjectVersions = getBucketVersions;
        function getBucketVersions() {
          return _getBucketVersions.apply(this, arguments);
        }
        function _getBucketVersions() {
          _getBucketVersions = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee() {
            var query, options, params, result, objects, deleteMarker, that, prefixes, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    query = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    if (!(query.versionIdMarker && query.keyMarker === void 0)) {
                      _context.next = 4;
                      break;
                    }
                    throw new Error("A version-id marker cannot be specified without a key marker");
                  case 4:
                    options.subres = Object.assign({
                      versions: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("GET", "", options);
                    params.xmlResponse = true;
                    params.successStatuses = [200];
                    params.query = formatQuery(query);
                    _context.next = 12;
                    return this.request(params);
                  case 12:
                    result = _context.sent;
                    objects = result.data.Version || [];
                    deleteMarker = result.data.DeleteMarker || [];
                    that = this;
                    if (objects) {
                      if (!Array.isArray(objects)) {
                        objects = [objects];
                      }
                      objects = objects.map(function(obj) {
                        return {
                          name: obj.Key,
                          url: that._objectUrl(obj.Key),
                          lastModified: obj.LastModified,
                          isLatest: obj.IsLatest === "true",
                          versionId: obj.VersionId,
                          etag: obj.ETag,
                          type: obj.Type,
                          size: Number(obj.Size),
                          storageClass: obj.StorageClass,
                          owner: {
                            id: obj.Owner.ID,
                            displayName: obj.Owner.DisplayName
                          },
                          restoreInfo: parseRestoreInfo(obj.RestoreInfo)
                        };
                      });
                    }
                    if (deleteMarker) {
                      if (!isArray2(deleteMarker)) {
                        deleteMarker = [deleteMarker];
                      }
                      deleteMarker = deleteMarker.map(function(obj) {
                        return {
                          name: obj.Key,
                          lastModified: obj.LastModified,
                          versionId: obj.VersionId,
                          owner: {
                            id: obj.Owner.ID,
                            displayName: obj.Owner.DisplayName
                          }
                        };
                      });
                    }
                    prefixes = result.data.CommonPrefixes || null;
                    if (prefixes) {
                      if (!isArray2(prefixes)) {
                        prefixes = [prefixes];
                      }
                      prefixes = prefixes.map(function(item) {
                        return item.Prefix;
                      });
                    }
                    return _context.abrupt("return", {
                      res: result.res,
                      objects,
                      deleteMarker,
                      prefixes,
                      // attirbute of legacy error
                      nextMarker: result.data.NextKeyMarker || null,
                      // attirbute of legacy error
                      NextVersionIdMarker: result.data.NextVersionIdMarker || null,
                      nextKeyMarker: result.data.NextKeyMarker || null,
                      nextVersionIdMarker: result.data.NextVersionIdMarker || null,
                      isTruncated: result.data.IsTruncated === "true"
                    });
                  case 21:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _getBucketVersions.apply(this, arguments);
        }
        function camel2Line(name) {
          return name.replace(/([A-Z])/g, "-$1").toLowerCase();
        }
        function formatQuery() {
          var query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var obj = {};
          if (isObject2(query)) {
            Object.keys(query).forEach(function(key) {
              obj[camel2Line(key)] = query[key];
            });
          }
          return obj;
        }
      }, { "../utils/isArray": 67, "../utils/isObject": 74, "../utils/parseRestoreInfo": 78, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.number.constructor.js": 324, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.replace.js": 345, "core-js/modules/web.dom-collections.for-each.js": 380 }], 40: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        proto.getObjectMeta = /* @__PURE__ */ function() {
          var _getObjectMeta = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    name = this._objectName(name);
                    options.subres = Object.assign({
                      objectMeta: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("HEAD", name, options);
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      status: result.status,
                      res: result.res
                    });
                  case 10:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function getObjectMeta(_x, _x2) {
            return _getObjectMeta.apply(this, arguments);
          }
          return getObjectMeta;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 41: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        var _require = require2("../utils/isObject"), isObject2 = _require.isObject;
        proto.getObjectTagging = /* @__PURE__ */ function() {
          var _getObjectTagging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name) {
            var options, params, result, Tagging, Tag, tag2, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({
                      tagging: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name = this._objectName(name);
                    params = this._objectRequestParams("GET", name, options);
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    _context.next = 11;
                    return this.parseXML(result.data);
                  case 11:
                    Tagging = _context.sent;
                    Tag = Tagging.TagSet.Tag;
                    Tag = Tag && isObject2(Tag) ? [Tag] : Tag || [];
                    tag2 = {};
                    Tag.forEach(function(item) {
                      tag2[item.Key] = item.Value;
                    });
                    return _context.abrupt("return", {
                      status: result.status,
                      res: result.res,
                      tag: tag2
                    });
                  case 17:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function getObjectTagging(_x) {
            return _getObjectTagging.apply(this, arguments);
          }
          return getObjectTagging;
        }();
      }, { "../utils/isObject": 74, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/web.dom-collections.for-each.js": 380 }], 42: [function(require2, module3, exports3) {
        var _require = require2("../utils/isIP"), isIP = _require.isIP;
        var proto = exports3;
        proto.getObjectUrl = function getObjectUrl(name, baseUrl) {
          if (isIP(this.options.endpoint.hostname)) {
            throw new Error("can not get the object URL when endpoint is IP");
          }
          if (!baseUrl) {
            baseUrl = this.options.endpoint.format();
          } else if (baseUrl[baseUrl.length - 1] !== "/") {
            baseUrl += "/";
          }
          return baseUrl + this._escape(this._objectName(name));
        };
      }, { "../utils/isIP": 73 }], 43: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        proto.getSymlink = /* @__PURE__ */ function() {
          var _getSymlink = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name) {
            var options, params, result, target, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    options.subres = Object.assign({
                      symlink: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name = this._objectName(name);
                    params = this._objectRequestParams("GET", name, options);
                    params.successStatuses = [200];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    target = result.res.headers["x-oss-symlink-target"];
                    return _context.abrupt("return", {
                      targetName: decodeURIComponent(target),
                      res: result.res
                    });
                  case 11:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function getSymlink(_x) {
            return _getSymlink.apply(this, arguments);
          }
          return getSymlink;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 44: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/checkEnv"), checkEnv = _require.checkEnv;
        var proto = exports3;
        proto.head = /* @__PURE__ */ function() {
          var _head = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name) {
            var options, params, result, data, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    checkEnv("Because HeadObject has gzip enabled, head cannot get the file size correctly. If you need to get the file size, please use getObjectMeta");
                    options.subres = Object.assign({}, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    params = this._objectRequestParams("HEAD", name, options);
                    params.successStatuses = [200, 304];
                    _context.next = 8;
                    return this.request(params);
                  case 8:
                    result = _context.sent;
                    data = {
                      meta: null,
                      res: result.res,
                      status: result.status
                    };
                    if (result.status === 200) {
                      Object.keys(result.headers).forEach(function(k) {
                        if (k.indexOf("x-oss-meta-") === 0) {
                          if (!data.meta) {
                            data.meta = {};
                          }
                          data.meta[k.substring(11)] = result.headers[k];
                        }
                      });
                    }
                    return _context.abrupt("return", data);
                  case 12:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function head(_x) {
            return _head.apply(this, arguments);
          }
          return head;
        }();
      }, { "../utils/checkEnv": 55, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/web.dom-collections.for-each.js": 380 }], 45: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        proto.putACL = /* @__PURE__ */ function() {
          var _putACL = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, acl, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    options.subres = Object.assign({
                      acl: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    options.headers = options.headers || {};
                    options.headers["x-oss-object-acl"] = acl;
                    name = this._objectName(name);
                    params = this._objectRequestParams("PUT", name, options);
                    params.successStatuses = [200];
                    _context.next = 10;
                    return this.request(params);
                  case 10:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res
                    });
                  case 12:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function putACL(_x, _x2, _x3) {
            return _putACL.apply(this, arguments);
          }
          return putACL;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 46: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.object.keys.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("../utils/obj2xml"), obj2xml = _require.obj2xml;
        var _require2 = require2("../utils/checkObjectTag"), checkObjectTag = _require2.checkObjectTag;
        var proto = exports3;
        proto.putObjectTagging = /* @__PURE__ */ function() {
          var _putObjectTagging = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, tag2) {
            var options, params, paramXMLObj, result, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    checkObjectTag(tag2);
                    options.subres = Object.assign({
                      tagging: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    name = this._objectName(name);
                    params = this._objectRequestParams("PUT", name, options);
                    params.successStatuses = [200];
                    tag2 = Object.keys(tag2).map(function(key) {
                      return {
                        Key: key,
                        Value: tag2[key]
                      };
                    });
                    paramXMLObj = {
                      Tagging: {
                        TagSet: {
                          Tag: tag2
                        }
                      }
                    };
                    params.mime = "xml";
                    params.content = obj2xml(paramXMLObj);
                    _context.next = 13;
                    return this.request(params);
                  case 13:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res,
                      status: result.status
                    });
                  case 15:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function putObjectTagging(_x, _x2) {
            return _putObjectTagging.apply(this, arguments);
          }
          return putObjectTagging;
        }();
      }, { "../utils/checkObjectTag": 56, "../utils/obj2xml": 76, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.keys.js": 328 }], 47: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var proto = exports3;
        proto.putSymlink = /* @__PURE__ */ function() {
          var _putSymlink = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(name, targetName, options) {
            var params, result;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    options.headers = options.headers || {};
                    targetName = this._escape(this._objectName(targetName));
                    this._convertMetaToHeaders(options.meta, options.headers);
                    options.headers["x-oss-symlink-target"] = targetName;
                    options.subres = Object.assign({
                      symlink: ""
                    }, options.subres);
                    if (options.versionId) {
                      options.subres.versionId = options.versionId;
                    }
                    if (options.storageClass) {
                      options.headers["x-oss-storage-class"] = options.storageClass;
                    }
                    name = this._objectName(name);
                    params = this._objectRequestParams("PUT", name, options);
                    params.successStatuses = [200];
                    _context.next = 13;
                    return this.request(params);
                  case 13:
                    result = _context.sent;
                    return _context.abrupt("return", {
                      res: result.res
                    });
                  case 15:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function putSymlink(_x, _x2, _x3) {
            return _putSymlink.apply(this, arguments);
          }
          return putSymlink;
        }();
      }, { "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.object.assign.js": 325 }], 48: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.regexp.to-string.js");
            var __importDefault = function(mod) {
              return mod && mod.__esModule ? mod : {
                "default": mod
              };
            };
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.signPostObjectPolicyV4 = void 0;
            var dateformat_1 = __importDefault(require2("dateformat"));
            var getStandardRegion_1 = require2("../utils/getStandardRegion");
            var policy2Str_1 = require2("../utils/policy2Str");
            var signUtils_1 = require2("../signUtils");
            function signPostObjectPolicyV4(policy, date2) {
              var policyStr = Buffer2.from(policy2Str_1.policy2Str(policy), "utf8").toString("base64");
              var formattedDate = dateformat_1.default(date2, "UTC:yyyymmdd'T'HHMMss'Z'");
              var onlyDate = formattedDate.split("T")[0];
              var signature = signUtils_1.getSignatureV4(this.options.accessKeySecret, onlyDate, getStandardRegion_1.getStandardRegion(this.options.region), policyStr);
              return signature;
            }
            exports3.signPostObjectPolicyV4 = signPostObjectPolicyV4;
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "../signUtils": 52, "../utils/getStandardRegion": 65, "../utils/policy2Str": 79, "buffer": 103, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.to-string.js": 339, "dateformat": 383 }], 49: [function(require2, module3, exports3) {
        require2("core-js/modules/es.regexp.exec.js");
        var urlutil = require2("url");
        var utility = require2("utility");
        var copy = require2("copy-to");
        var signHelper = require2("../../common/signUtils");
        var _require = require2("../utils/isIP"), isIP = _require.isIP;
        var proto = exports3;
        proto.signatureUrl = function signatureUrl(name, options) {
          var strictObjectNameValidation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
          if (isIP(this.options.endpoint.hostname)) {
            throw new Error("can not get the object URL when endpoint is IP");
          }
          if (strictObjectNameValidation && /^\?/.test(name)) {
            throw new Error("Invalid object name ".concat(name));
          }
          options = options || {};
          name = this._objectName(name);
          options.method = options.method || "GET";
          var expires = utility.timestamp() + (options.expires || 1800);
          var params = {
            bucket: this.options.bucket,
            object: name
          };
          var resource = this._getResource(params);
          if (this.options.stsToken) {
            options["security-token"] = this.options.stsToken;
          }
          var signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);
          var url2 = urlutil.parse(this._getReqUrl(params));
          url2.query = {
            OSSAccessKeyId: this.options.accessKeyId,
            Expires: expires,
            Signature: signRes.Signature
          };
          copy(signRes.subResource).to(url2.query);
          return url2.format();
        };
      }, { "../../common/signUtils": 52, "../utils/isIP": 73, "copy-to": 107, "core-js/modules/es.regexp.exec.js": 338, "url": 543, "utility": 545 }], 50: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.assign.js");
        require2("core-js/modules/es.array.join.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var dateFormat = require2("dateformat");
        var urlUtil = require2("url");
        var signHelper = require2("../../common/signUtils");
        var _require = require2("../utils/setSTSToken"), setSTSToken = _require.setSTSToken;
        var _require2 = require2("../utils/isFunction"), isFunction2 = _require2.isFunction;
        var _require3 = require2("../utils/getStandardRegion"), getStandardRegion = _require3.getStandardRegion;
        var proto = exports3;
        proto.signatureUrlV4 = /* @__PURE__ */ function() {
          var _signatureUrlV = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(method, expires, request, objectName, additionalHeaders) {
            var cloudBoxId, product, signRegion, headers, queries, date2, formattedDate, onlyDate, fixedAdditionalHeaders, canonicalRequest, stringToSign, signedUrl;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    cloudBoxId = this.options.cloudBoxId;
                    product = signHelper.getProduct(cloudBoxId);
                    signRegion = signHelper.getSignRegion(getStandardRegion(this.options.region), cloudBoxId);
                    headers = request && request.headers || {};
                    queries = Object.assign({}, request && request.queries || {});
                    date2 = /* @__PURE__ */ new Date();
                    formattedDate = dateFormat(date2, "UTC:yyyymmdd'T'HHMMss'Z'");
                    onlyDate = formattedDate.split("T")[0];
                    fixedAdditionalHeaders = signHelper.fixAdditionalHeaders(additionalHeaders);
                    if (fixedAdditionalHeaders.length > 0) {
                      queries["x-oss-additional-headers"] = fixedAdditionalHeaders.join(";");
                    }
                    queries["x-oss-credential"] = signHelper.getCredential(onlyDate, signRegion, this.options.accessKeyId, product);
                    queries["x-oss-date"] = formattedDate;
                    queries["x-oss-expires"] = expires;
                    queries["x-oss-signature-version"] = "OSS4-HMAC-SHA256";
                    if (!(this.options.stsToken && isFunction2(this.options.refreshSTSToken))) {
                      _context.next = 17;
                      break;
                    }
                    _context.next = 17;
                    return setSTSToken.call(this);
                  case 17:
                    if (this.options.stsToken) {
                      queries["x-oss-security-token"] = this.options.stsToken;
                    }
                    canonicalRequest = signHelper.getCanonicalRequest(method, {
                      headers,
                      queries
                    }, this.options.bucket, objectName, fixedAdditionalHeaders);
                    stringToSign = signHelper.getStringToSign(signRegion, formattedDate, canonicalRequest, product);
                    queries["x-oss-signature"] = signHelper.getSignatureV4(this.options.accessKeySecret, onlyDate, signRegion, stringToSign, product);
                    signedUrl = urlUtil.parse(this._getReqUrl({
                      bucket: this.options.bucket,
                      object: objectName
                    }));
                    signedUrl.query = Object.assign({}, queries);
                    return _context.abrupt("return", signedUrl.format());
                  case 24:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function signatureUrlV4(_x, _x2, _x3, _x4, _x5) {
            return _signatureUrlV.apply(this, arguments);
          }
          return signatureUrlV4;
        }();
      }, { "../../common/signUtils": 52, "../utils/getStandardRegion": 65, "../utils/isFunction": 72, "../utils/setSTSToken": 82, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.join.js": 317, "core-js/modules/es.object.assign.js": 325, "dateformat": 383, "url": 543 }], 51: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.array.iterator.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.promise.js");
        require2("core-js/modules/es.string.iterator.js");
        require2("core-js/modules/web.dom-collections.iterator.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.function.name.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        var _require = require2("./utils/isArray"), isArray2 = _require.isArray;
        var proto = exports3;
        proto._parallelNode = /* @__PURE__ */ function() {
          var _parallelNode2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(todo, parallel, fn, sourceData) {
            var that, jobErr, jobs, tempBatch, remainder, batch, taskIndex, i;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    that = this;
                    jobErr = [];
                    jobs = [];
                    tempBatch = todo.length / parallel;
                    remainder = todo.length % parallel;
                    batch = remainder === 0 ? tempBatch : (todo.length - remainder) / parallel + 1;
                    taskIndex = 1;
                    i = 0;
                  case 8:
                    if (!(i < todo.length)) {
                      _context.next = 26;
                      break;
                    }
                    if (!that.isCancel()) {
                      _context.next = 11;
                      break;
                    }
                    return _context.abrupt("break", 26);
                  case 11:
                    if (sourceData) {
                      jobs.push(fn(that, todo[i], sourceData));
                    } else {
                      jobs.push(fn(that, todo[i]));
                    }
                    if (!(jobs.length === parallel || taskIndex === batch && i === todo.length - 1)) {
                      _context.next = 23;
                      break;
                    }
                    _context.prev = 13;
                    taskIndex += 1;
                    _context.next = 17;
                    return Promise.all(jobs);
                  case 17:
                    _context.next = 22;
                    break;
                  case 19:
                    _context.prev = 19;
                    _context.t0 = _context["catch"](13);
                    jobErr.push(_context.t0);
                  case 22:
                    jobs = [];
                  case 23:
                    i++;
                    _context.next = 8;
                    break;
                  case 26:
                    return _context.abrupt("return", jobErr);
                  case 27:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this, [[13, 19]]);
          }));
          function _parallelNode(_x, _x2, _x3, _x4) {
            return _parallelNode2.apply(this, arguments);
          }
          return _parallelNode;
        }();
        proto._parallel = function _parallel(todo, parallel, jobPromise) {
          var that = this;
          return new Promise(function(resolve2) {
            var _jobErr = [];
            if (parallel <= 0 || !todo) {
              resolve2(_jobErr);
              return;
            }
            function onlyOnce(fn) {
              return function() {
                if (fn === null)
                  throw new Error("Callback was already called.");
                var callFn = fn;
                fn = null;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                callFn.apply(this, args);
              };
            }
            function createArrayIterator(coll) {
              var i = -1;
              var len = coll.length;
              return function next() {
                return ++i < len && !that.isCancel() ? {
                  value: coll[i],
                  key: i
                } : null;
              };
            }
            var nextElem = createArrayIterator(todo);
            var done = false;
            var running = 0;
            var looping = false;
            function iterateeCallback(err) {
              running -= 1;
              if (err) {
                done = true;
                _jobErr.push(err);
                resolve2(_jobErr);
              } else if (done && running <= 0) {
                done = true;
                resolve2(_jobErr);
              } else if (!looping) {
                if (that.isCancel()) {
                  resolve2(_jobErr);
                } else {
                  replenish();
                }
              }
            }
            function iteratee(value, callback) {
              jobPromise(value).then(function(result) {
                callback(null, result);
              }).catch(function(err) {
                callback(err);
              });
            }
            function replenish() {
              looping = true;
              while (running < parallel && !done && !that.isCancel()) {
                var elem = nextElem();
                if (elem === null || _jobErr.length > 0) {
                  done = true;
                  if (running <= 0) {
                    resolve2(_jobErr);
                  }
                  return;
                }
                running += 1;
                iteratee(elem.value, onlyOnce(iterateeCallback));
              }
              looping = false;
            }
            replenish();
          });
        };
        proto.cancel = function cancel(abort) {
          this.options.cancelFlag = true;
          if (isArray2(this.multipartUploadStreams)) {
            this.multipartUploadStreams.forEach(function(_) {
              if (_.destroyed === false) {
                var err = {
                  name: "cancel",
                  message: "cancel"
                };
                _.destroy(err);
              }
            });
          }
          this.multipartUploadStreams = [];
          if (abort) {
            this.abortMultipartUpload(abort.name, abort.uploadId, abort.options);
          }
        };
        proto.isCancel = function isCancel() {
          return this.options.cancelFlag;
        };
        proto.resetCancelFlag = function resetCancelFlag() {
          this.options.cancelFlag = false;
        };
        proto._stop = function _stop() {
          this.options.cancelFlag = true;
        };
        proto._makeCancelEvent = function _makeCancelEvent() {
          var cancelEvent = {
            status: 0,
            name: "cancel"
          };
          return cancelEvent;
        };
        proto._makeAbortEvent = function _makeAbortEvent() {
          var abortEvent = {
            status: 0,
            name: "abort",
            message: "upload task has been abort"
          };
          return abortEvent;
        };
      }, { "./utils/isArray": 67, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.iterator.js": 316, "core-js/modules/es.function.name.js": 322, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333, "core-js/modules/es.string.iterator.js": 343, "core-js/modules/web.dom-collections.for-each.js": 380, "core-js/modules/web.dom-collections.iterator.js": 381 }], 52: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _toConsumableArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/toConsumableArray"));
            require2("core-js/modules/es.string.trim.js");
            require2("core-js/modules/es.array.sort.js");
            require2("core-js/modules/es.array.join.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.object.keys.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.array.filter.js");
            require2("core-js/modules/es.array.iterator.js");
            require2("core-js/modules/es.set.js");
            require2("core-js/modules/es.string.iterator.js");
            require2("core-js/modules/web.dom-collections.iterator.js");
            require2("core-js/modules/es.array.map.js");
            require2("core-js/modules/es.string.starts-with.js");
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.replace.js");
            require2("core-js/modules/es.object.entries.js");
            require2("core-js/modules/es.regexp.to-string.js");
            var crypto2 = require2("./../../shims/crypto/crypto.js");
            var is = require2("is-type-of");
            var qs2 = require2("qs");
            var _require = require2("./utils/lowercaseKeyHeader"), lowercaseKeyHeader = _require.lowercaseKeyHeader;
            var _require2 = require2("./utils/encodeString"), encodeString = _require2.encodeString;
            exports3.getProduct = function getProduct(cloudBoxId) {
              if (cloudBoxId === void 0)
                return "oss";
              return "oss-cloudbox";
            };
            exports3.getSignRegion = function getSignRegion(region, cloudBoxId) {
              if (cloudBoxId === void 0)
                return region;
              return cloudBoxId;
            };
            exports3.buildCanonicalizedResource = function buildCanonicalizedResource(resourcePath, parameters) {
              var canonicalizedResource = "".concat(resourcePath);
              var separatorString = "?";
              if (is.string(parameters) && parameters.trim() !== "") {
                canonicalizedResource += separatorString + parameters;
              } else if (is.array(parameters)) {
                parameters.sort();
                canonicalizedResource += separatorString + parameters.join("&");
              } else if (parameters) {
                var processFunc = function processFunc2(key) {
                  canonicalizedResource += separatorString + key;
                  if (parameters[key] || parameters[key] === 0) {
                    canonicalizedResource += "=".concat(parameters[key]);
                  }
                  separatorString = "&";
                };
                Object.keys(parameters).sort().forEach(processFunc);
              }
              return canonicalizedResource;
            };
            exports3.buildCanonicalString = function canonicalString(method, resourcePath, request, expires) {
              request = request || {};
              var headers = lowercaseKeyHeader(request.headers);
              var OSS_PREFIX = "x-oss-";
              var ossHeaders = [];
              var headersToSign = {};
              var signContent = [method.toUpperCase(), headers["content-md5"] || "", headers["content-type"], expires || headers["x-oss-date"]];
              Object.keys(headers).forEach(function(key) {
                var lowerKey = key.toLowerCase();
                if (lowerKey.indexOf(OSS_PREFIX) === 0) {
                  headersToSign[lowerKey] = String(headers[key]).trim();
                }
              });
              Object.keys(headersToSign).sort().forEach(function(key) {
                ossHeaders.push("".concat(key, ":").concat(headersToSign[key]));
              });
              signContent = signContent.concat(ossHeaders);
              signContent.push(this.buildCanonicalizedResource(resourcePath, request.parameters));
              return signContent.join("\n");
            };
            exports3.computeSignature = function computeSignature(accessKeySecret, canonicalString) {
              var headerEncoding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "utf-8";
              var signature = crypto2.createHmac("sha1", accessKeySecret);
              return signature.update(Buffer2.from(canonicalString, headerEncoding)).digest("base64");
            };
            exports3.authorization = function authorization(accessKeyId, accessKeySecret, canonicalString, headerEncoding) {
              return "OSS ".concat(accessKeyId, ":").concat(this.computeSignature(accessKeySecret, canonicalString, headerEncoding));
            };
            exports3.fixAdditionalHeaders = function(additionalHeaders) {
              if (!additionalHeaders) {
                return [];
              }
              var OSS_PREFIX = "x-oss-";
              return (0, _toConsumableArray2.default)(new Set(additionalHeaders.map(function(v) {
                return v.toLowerCase();
              }))).filter(function(v) {
                return v !== "content-type" && v !== "content-md5" && !v.startsWith(OSS_PREFIX);
              }).sort();
            };
            exports3.getCanonicalRequest = function getCanonicalRequest(method, request, bucketName, objectName, additionalHeaders) {
              var headers = lowercaseKeyHeader(request.headers);
              var queries = request.queries || {};
              var OSS_PREFIX = "x-oss-";
              if (objectName && !bucketName) {
                throw Error("Please ensure that bucketName is passed into getCanonicalRequest.");
              }
              var signContent = [
                method.toUpperCase(),
                // HTTP Verb
                encodeString("/".concat(bucketName ? "".concat(bucketName, "/") : "").concat(objectName || "")).replace(/%2F/g, "/")
                // Canonical URI
              ];
              signContent.push(qs2.stringify(queries, {
                encoder: encodeString,
                sort: function sort(a2, b) {
                  return a2.localeCompare(b);
                },
                strictNullHandling: true
              }));
              if (additionalHeaders) {
                additionalHeaders.forEach(function(v) {
                  if (!Object.prototype.hasOwnProperty.call(headers, v)) {
                    throw Error("Can't find additional header ".concat(v, " in request headers."));
                  }
                });
              }
              var tempHeaders = new Set(additionalHeaders);
              Object.keys(headers).forEach(function(v) {
                if (v === "content-type" || v === "content-md5" || v.startsWith(OSS_PREFIX)) {
                  tempHeaders.add(v);
                }
              });
              var canonicalHeaders = "".concat((0, _toConsumableArray2.default)(tempHeaders).sort().map(function(v) {
                return "".concat(v, ":").concat(is.string(headers[v]) ? headers[v].trim() : headers[v], "\n");
              }).join(""));
              signContent.push(canonicalHeaders);
              if (additionalHeaders && additionalHeaders.length > 0) {
                signContent.push(additionalHeaders.join(";"));
              } else {
                signContent.push("");
              }
              signContent.push(headers["x-oss-content-sha256"] || "UNSIGNED-PAYLOAD");
              return signContent.join("\n");
            };
            exports3.getCredential = function getCredential(date2, region, accessKeyId) {
              var product = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "oss";
              var tempCredential = "".concat(date2, "/").concat(region, "/").concat(product, "/aliyun_v4_request");
              if (accessKeyId) {
                return "".concat(accessKeyId, "/").concat(tempCredential);
              }
              return tempCredential;
            };
            exports3.getStringToSign = function getStringToSign(region, date2, canonicalRequest) {
              var product = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "oss";
              var stringToSign = [
                "OSS4-HMAC-SHA256",
                date2,
                // TimeStamp
                this.getCredential(date2.split("T")[0], region, void 0, product),
                // Scope
                crypto2.createHash("sha256").update(canonicalRequest).digest("hex")
                // Hashed Canonical Request
              ];
              return stringToSign.join("\n");
            };
            exports3.getSignatureV4 = function getSignatureV4(accessKeySecret, date2, region, stringToSign) {
              var product = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "oss";
              var signingDate = crypto2.createHmac("sha256", "aliyun_v4".concat(accessKeySecret)).update(date2).digest();
              var signingRegion = crypto2.createHmac("sha256", signingDate).update(region).digest();
              var signingOss = crypto2.createHmac("sha256", signingRegion).update(product).digest();
              var signingKey = crypto2.createHmac("sha256", signingOss).update("aliyun_v4_request").digest();
              var signatureValue = crypto2.createHmac("sha256", signingKey).update(stringToSign).digest("hex");
              return signatureValue;
            };
            exports3.authorizationV4 = function authorizationV4(accessKeyId, accessKeySecret, region, method, request, bucketName, objectName, additionalHeaders) {
              var headerEncoding = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : "utf-8";
              var cloudBoxId = arguments.length > 9 ? arguments[9] : void 0;
              var product = this.getProduct(cloudBoxId);
              var fixedAdditionalHeaders = this.fixAdditionalHeaders(additionalHeaders);
              var fixedHeaders = {};
              Object.entries(request.headers).forEach(function(v) {
                fixedHeaders[v[0]] = is.string(v[1]) ? Buffer2.from(v[1], headerEncoding).toString() : v[1];
              });
              var date2 = fixedHeaders["x-oss-date"] || request.queries && request.queries["x-oss-date"];
              var canonicalRequest = this.getCanonicalRequest(method, {
                headers: fixedHeaders,
                queries: request.queries
              }, bucketName, objectName, fixedAdditionalHeaders);
              var stringToSign = this.getStringToSign(region, date2, canonicalRequest, product);
              var onlyDate = date2.split("T")[0];
              var signatureValue = this.getSignatureV4(accessKeySecret, onlyDate, region, stringToSign, product);
              var additionalHeadersValue = fixedAdditionalHeaders.length > 0 ? "AdditionalHeaders=".concat(fixedAdditionalHeaders.join(";"), ",") : "";
              return "OSS4-HMAC-SHA256 Credential=".concat(this.getCredential(onlyDate, region, accessKeyId, product), ",").concat(additionalHeadersValue, "Signature=").concat(signatureValue);
            };
            exports3._signatureForURL = function _signatureForURL(accessKeySecret) {
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var resource = arguments.length > 2 ? arguments[2] : void 0;
              var expires = arguments.length > 3 ? arguments[3] : void 0;
              var headerEncoding = arguments.length > 4 ? arguments[4] : void 0;
              var headers = {};
              var _options$subResource = options.subResource, subResource = _options$subResource === void 0 ? {} : _options$subResource;
              if (options.process) {
                var processKeyword = "x-oss-process";
                subResource[processKeyword] = options.process;
              }
              if (options.trafficLimit) {
                var trafficLimitKey = "x-oss-traffic-limit";
                subResource[trafficLimitKey] = options.trafficLimit;
              }
              if (options.response) {
                Object.keys(options.response).forEach(function(k) {
                  var key = "response-".concat(k.toLowerCase());
                  subResource[key] = options.response[k];
                });
              }
              Object.keys(options).forEach(function(key) {
                var lowerKey = key.toLowerCase();
                var value = options[key];
                if (lowerKey.indexOf("x-oss-") === 0) {
                  headers[lowerKey] = value;
                } else if (lowerKey.indexOf("content-md5") === 0) {
                  headers[key] = value;
                } else if (lowerKey.indexOf("content-type") === 0) {
                  headers[key] = value;
                }
              });
              if (Object.prototype.hasOwnProperty.call(options, "security-token")) {
                subResource["security-token"] = options["security-token"];
              }
              if (Object.prototype.hasOwnProperty.call(options, "callback")) {
                var json = {
                  callbackUrl: encodeURI(options.callback.url),
                  callbackBody: options.callback.body
                };
                if (options.callback.host) {
                  json.callbackHost = options.callback.host;
                }
                if (options.callback.contentType) {
                  json.callbackBodyType = options.callback.contentType;
                }
                if (options.callback.callbackSNI) {
                  json.callbackSNI = options.callback.callbackSNI;
                }
                subResource.callback = Buffer2.from(JSON.stringify(json)).toString("base64");
                if (options.callback.customValue) {
                  var callbackVar = {};
                  Object.keys(options.callback.customValue).forEach(function(key) {
                    callbackVar["x:".concat(key)] = options.callback.customValue[key];
                  });
                  subResource["callback-var"] = Buffer2.from(JSON.stringify(callbackVar)).toString("base64");
                }
              }
              var canonicalString = this.buildCanonicalString(options.method, resource, {
                headers,
                parameters: subResource
              }, expires.toString());
              return {
                Signature: this.computeSignature(accessKeySecret, canonicalString, headerEncoding),
                subResource
              };
            };
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "./../../shims/crypto/crypto.js": 531, "./utils/encodeString": 61, "./utils/lowercaseKeyHeader": 75, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/helpers/toConsumableArray": 90, "buffer": 103, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.filter.js": 312, "core-js/modules/es.array.iterator.js": 316, "core-js/modules/es.array.join.js": 317, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.array.sort.js": 320, "core-js/modules/es.object.entries.js": 326, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.set.js": 341, "core-js/modules/es.string.iterator.js": 343, "core-js/modules/es.string.replace.js": 345, "core-js/modules/es.string.starts-with.js": 348, "core-js/modules/es.string.trim.js": 349, "core-js/modules/web.dom-collections.for-each.js": 380, "core-js/modules/web.dom-collections.iterator.js": 381, "is-type-of": 537, "qs": 445 }], 53: [function(require2, module3, exports3) {
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.checkBucketName = void 0;
        exports3.checkBucketName = function(name) {
          var createBucket = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var bucketRegex = createBucket ? /^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$/ : /^[a-z0-9_][a-z0-9-_]{1,61}[a-z0-9_]$/;
          if (!bucketRegex.test(name)) {
            throw new Error("The bucket must be conform to the specifications");
          }
        };
      }, { "core-js/modules/es.regexp.exec.js": 338 }], 54: [function(require2, module3, exports3) {
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.checkConfigValid = void 0;
        var checkConfigMap = {
          endpoint: checkEndpoint,
          region: /^[a-zA-Z0-9\-_]+$/
        };
        function checkEndpoint(endpoint) {
          if (typeof endpoint === "string") {
            return /^[a-zA-Z0-9._:/-]+$/.test(endpoint);
          } else if (endpoint.host) {
            return /^[a-zA-Z0-9._:/-]+$/.test(endpoint.host);
          }
          return false;
        }
        exports3.checkConfigValid = function(conf, key) {
          if (checkConfigMap[key]) {
            var isConfigValid = true;
            if (checkConfigMap[key] instanceof Function) {
              isConfigValid = checkConfigMap[key](conf);
            } else {
              isConfigValid = checkConfigMap[key].test(conf);
            }
            if (!isConfigValid) {
              throw new Error("The ".concat(key, " must be conform to the specifications"));
            }
          }
        };
      }, { "core-js/modules/es.regexp.exec.js": 338 }], 55: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.checkEnv = void 0;
            function checkEnv(msg) {
              if (process.browser) {
                index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:6356", msg);
              }
            }
            exports3.checkEnv = checkEnv;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 538 }], 56: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.object.entries.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.checkObjectTag = void 0;
        var _require = require2("./checkValid"), checkValid = _require.checkValid;
        var _require2 = require2("./isObject"), isObject2 = _require2.isObject;
        var commonRules = [{
          validator: function validator(value) {
            if (typeof value !== "string") {
              throw new Error("the key and value of the tag must be String");
            }
          }
        }, {
          pattern: /^[a-zA-Z0-9 +-=._:/]+$/,
          msg: "tag can contain letters, numbers, spaces, and the following symbols: plus sign (+), hyphen (-), equal sign (=), period (.), underscore (_), colon (:), and forward slash (/)"
        }];
        var rules = {
          key: [].concat(commonRules, [{
            pattern: /^.{1,128}$/,
            msg: "tag key can be a maximum of 128 bytes in length"
          }]),
          value: [].concat(commonRules, [{
            pattern: /^.{0,256}$/,
            msg: "tag value can be a maximum of 256 bytes in length"
          }])
        };
        function checkObjectTag(tag2) {
          if (!isObject2(tag2)) {
            throw new Error("tag must be Object");
          }
          var entries = Object.entries(tag2);
          if (entries.length > 10) {
            throw new Error("maximum of 10 tags for a object");
          }
          var rulesIndexKey = ["key", "value"];
          entries.forEach(function(keyValue) {
            keyValue.forEach(function(item, index2) {
              checkValid(item, rules[rulesIndexKey[index2]]);
            });
          });
        }
        exports3.checkObjectTag = checkObjectTag;
      }, { "./checkValid": 57, "./isObject": 74, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.object.entries.js": 326, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/web.dom-collections.for-each.js": 380 }], 57: [function(require2, module3, exports3) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.checkValid = void 0;
        function checkValid(_value, _rules) {
          _rules.forEach(function(rule) {
            if (rule.validator) {
              rule.validator(_value);
            } else if (rule.pattern && !rule.pattern.test(_value)) {
              throw new Error(rule.msg);
            }
          });
        }
        exports3.checkValid = checkValid;
      }, { "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/web.dom-collections.for-each.js": 380 }], 58: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            require2("core-js/modules/es.array.includes.js");
            require2("core-js/modules/es.string.includes.js");
            require2("core-js/modules/es.object.assign.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.object.entries.js");
            require2("core-js/modules/es.array.concat.js");
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.createRequest = void 0;
            var crypto2 = require2("./../../../shims/crypto/crypto.js");
            var debug = require2("debug")("ali-oss");
            var _isString = require2("lodash/isString");
            var _isArray = require2("lodash/isArray");
            var _isObject = require2("lodash/isObject");
            var mime = require2("mime");
            var dateFormat = require2("dateformat");
            var copy = require2("copy-to");
            var path = require2("path");
            var _require = require2("./encoder"), encoder = _require.encoder;
            var _require2 = require2("./isIP"), isIP = _require2.isIP;
            var _require3 = require2("./setRegion"), setRegion = _require3.setRegion;
            var _require4 = require2("../client/getReqUrl"), getReqUrl = _require4.getReqUrl;
            var _require5 = require2("./isDingTalk"), isDingTalk = _require5.isDingTalk;
            function getHeader(headers, name) {
              return headers[name] || headers[name.toLowerCase()];
            }
            function delHeader(headers, name) {
              delete headers[name];
              delete headers[name.toLowerCase()];
            }
            function createRequest(params) {
              var date2 = /* @__PURE__ */ new Date();
              if (this.options.amendTimeSkewed) {
                date2 = +/* @__PURE__ */ new Date() + this.options.amendTimeSkewed;
              }
              var headers = {
                "x-oss-date": dateFormat(date2, this.options.authorizationV4 ? "UTC:yyyymmdd'T'HHMMss'Z'" : "UTC:ddd, dd mmm yyyy HH:MM:ss 'GMT'")
              };
              if (this.options.authorizationV4) {
                headers["x-oss-content-sha256"] = "UNSIGNED-PAYLOAD";
              }
              if (typeof window !== "undefined") {
                headers["x-oss-user-agent"] = this.userAgent;
              }
              if (this.userAgent.includes("nodejs")) {
                headers["User-Agent"] = this.userAgent;
              }
              if (this.options.isRequestPay) {
                Object.assign(headers, {
                  "x-oss-request-payer": "requester"
                });
              }
              if (this.options.stsToken) {
                headers["x-oss-security-token"] = this.options.stsToken;
              }
              copy(params.headers).to(headers);
              if (!getHeader(headers, "Content-Type")) {
                if (params.mime && params.mime.indexOf("/") > 0) {
                  headers["Content-Type"] = params.mime;
                } else if (isDingTalk()) {
                  headers["Content-Type"] = "application/octet-stream";
                } else {
                  headers["Content-Type"] = mime.getType(params.mime || path.extname(params.object || ""));
                }
              }
              if (!getHeader(headers, "Content-Type")) {
                delHeader(headers, "Content-Type");
              }
              if (params.content) {
                if (!params.disabledMD5) {
                  if (!params.headers || !params.headers["Content-MD5"]) {
                    headers["Content-MD5"] = crypto2.createHash("md5").update(Buffer2.from(params.content, "utf8")).digest("base64");
                  } else {
                    headers["Content-MD5"] = params.headers["Content-MD5"];
                  }
                }
                if (!headers["Content-Length"]) {
                  headers["Content-Length"] = params.content.length;
                }
              }
              var hasOwnProperty2 = Object.prototype.hasOwnProperty;
              for (var k in headers) {
                if (headers[k] && hasOwnProperty2.call(headers, k)) {
                  headers[k] = encoder(String(headers[k]), this.options.headerEncoding);
                }
              }
              var queries = {};
              if (_isString(params.subres)) {
                queries[params.subres] = null;
              } else if (_isArray(params.subres)) {
                params.subres.forEach(function(v) {
                  queries[v] = null;
                });
              } else if (_isObject(params.subres)) {
                Object.entries(params.subres).forEach(function(v) {
                  queries[v[0]] = v[1] === "" ? null : v[1];
                });
              }
              if (_isObject(params.query)) {
                Object.entries(params.query).forEach(function(v) {
                  queries[v[0]] = v[1];
                });
              }
              headers.authorization = this.options.authorizationV4 ? this.authorizationV4(params.method, {
                headers,
                queries
              }, params.bucket, params.object, params.additionalHeaders) : this.authorization(params.method, this._getResource(params), params.subres, headers, this.options.headerEncoding);
              if (isIP(this.options.endpoint.hostname)) {
                var _this$options = this.options, region = _this$options.region, internal = _this$options.internal, secure = _this$options.secure;
                var hostInfo = setRegion(region, internal, secure);
                headers.host = "".concat(params.bucket, ".").concat(hostInfo.host);
              }
              var url2 = getReqUrl.bind(this)(params);
              debug("request %s %s, with headers %j, !!stream: %s", params.method, url2, headers, !!params.stream);
              var timeout2 = params.timeout || this.options.timeout;
              var reqParams = {
                method: params.method,
                content: params.content,
                stream: params.stream,
                headers,
                timeout: timeout2,
                writeStream: params.writeStream,
                customResponse: params.customResponse,
                ctx: params.ctx || this.ctx
              };
              if (this.agent) {
                reqParams.agent = this.agent;
              }
              if (this.httpsAgent) {
                reqParams.httpsAgent = this.httpsAgent;
              }
              reqParams.enableProxy = !!this.options.enableProxy;
              reqParams.proxy = this.options.proxy ? this.options.proxy : null;
              return {
                url: url2,
                params: reqParams
              };
            }
            exports3.createRequest = createRequest;
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "../client/getReqUrl": 25, "./../../../shims/crypto/crypto.js": 531, "./encoder": 62, "./isDingTalk": 70, "./isIP": 73, "./setRegion": 81, "buffer": 103, "copy-to": 107, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.includes.js": 315, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.entries.js": 326, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.string.includes.js": 342, "core-js/modules/web.dom-collections.for-each.js": 380, "dateformat": 383, "debug": 536, "lodash/isArray": 422, "lodash/isObject": 423, "lodash/isString": 425, "mime": 430, "path": 439 }], 59: [function(require2, module3, exports3) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.entries.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.array.includes.js");
        require2("core-js/modules/es.object.keys.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.dataFix = void 0;
        var isObject_1 = require2("./isObject");
        var TRUE = ["true", "TRUE", "1", 1];
        var FALSE = ["false", "FALSE", "0", 0];
        function dataFix(o2, conf, finalKill) {
          if (!isObject_1.isObject(o2))
            return;
          var _conf$remove = conf.remove, remove2 = _conf$remove === void 0 ? [] : _conf$remove, _conf$rename = conf.rename, rename = _conf$rename === void 0 ? {} : _conf$rename, _conf$camel = conf.camel, camel = _conf$camel === void 0 ? [] : _conf$camel, _conf$bool = conf.bool, bool = _conf$bool === void 0 ? [] : _conf$bool, _conf$lowerFirst = conf.lowerFirst, lowerFirst = _conf$lowerFirst === void 0 ? false : _conf$lowerFirst;
          remove2.forEach(function(v) {
            return delete o2[v];
          });
          Object.entries(rename).forEach(function(v) {
            if (!o2[v[0]])
              return;
            if (o2[v[1]])
              return;
            o2[v[1]] = o2[v[0]];
            delete o2[v[0]];
          });
          camel.forEach(function(v) {
            if (!o2[v])
              return;
            var afterKey = v.replace(/^(.)/, function($0) {
              return $0.toLowerCase();
            }).replace(/-(\w)/g, function(_, $1) {
              return $1.toUpperCase();
            });
            if (o2[afterKey])
              return;
            o2[afterKey] = o2[v];
          });
          bool.forEach(function(v) {
            o2[v] = fixBool(o2[v]);
          });
          if (typeof finalKill === "function") {
            finalKill(o2);
          }
          fixLowerFirst(o2, lowerFirst);
          return dataFix;
        }
        exports3.dataFix = dataFix;
        function fixBool(value) {
          if (!value)
            return false;
          if (TRUE.includes(value))
            return true;
          return FALSE.includes(value) ? false : value;
        }
        function fixLowerFirst(o2, lowerFirst) {
          if (lowerFirst) {
            Object.keys(o2).forEach(function(key) {
              var lowerK = key.replace(/^\w/, function(match) {
                return match.toLowerCase();
              });
              if (typeof o2[lowerK] === "undefined") {
                o2[lowerK] = o2[key];
                delete o2[key];
              }
            });
          }
        }
      }, { "./isObject": 74, "core-js/modules/es.array.includes.js": 315, "core-js/modules/es.object.entries.js": 326, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.replace.js": 345, "core-js/modules/web.dom-collections.for-each.js": 380 }], 60: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        require2("core-js/modules/es.array.slice.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.deepCopyWith = exports3.deepCopy = void 0;
        var isBuffer_1 = require2("./isBuffer");
        exports3.deepCopy = function(obj) {
          if (obj === null || (0, _typeof2.default)(obj) !== "object") {
            return obj;
          }
          if (isBuffer_1.isBuffer(obj)) {
            return obj.slice();
          }
          var copy = Array.isArray(obj) ? [] : {};
          Object.keys(obj).forEach(function(key) {
            copy[key] = exports3.deepCopy(obj[key]);
          });
          return copy;
        };
        exports3.deepCopyWith = function(obj, customizer) {
          function deepCopyWithHelper(value, innerKey, innerObject) {
            var result = customizer(value, innerKey, innerObject);
            if (result !== void 0)
              return result;
            if (value === null || (0, _typeof2.default)(value) !== "object") {
              return value;
            }
            if (isBuffer_1.isBuffer(value)) {
              return value.slice();
            }
            var copy = Array.isArray(value) ? [] : {};
            Object.keys(value).forEach(function(k) {
              copy[k] = deepCopyWithHelper(value[k], k, value);
            });
            return copy;
          }
          if (customizer) {
            return deepCopyWithHelper(obj, "", null);
          } else {
            return exports3.deepCopy(obj);
          }
        };
      }, { "./isBuffer": 69, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/helpers/typeof": 91, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/web.dom-collections.for-each.js": 380 }], 61: [function(require2, module3, exports3) {
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        var __importDefault = function(mod) {
          return mod && mod.__esModule ? mod : {
            "default": mod
          };
        };
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.encodeString = void 0;
        var toString_1 = __importDefault(require2("lodash/toString"));
        function encodeString(str) {
          var tempStr = toString_1.default(str);
          return encodeURIComponent(tempStr).replace(/[!'()*]/g, function(c) {
            return "%".concat(c.charCodeAt(0).toString(16).toUpperCase());
          });
        }
        exports3.encodeString = encodeString;
      }, { "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.string.replace.js": 345, "lodash/toString": 427 }], 62: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.regexp.to-string.js");
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.encoder = void 0;
            function encoder(str) {
              var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf-8";
              if (encoding === "utf-8")
                return str;
              return Buffer2.from(str).toString("latin1");
            }
            exports3.encoder = encoder;
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 103, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.to-string.js": 339 }], 63: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.formatInventoryConfig = void 0;
        var dataFix_1 = require2("../utils/dataFix");
        var isObject_1 = require2("../utils/isObject");
        var isArray_1 = require2("../utils/isArray");
        var formatObjKey_1 = require2("../utils/formatObjKey");
        function formatInventoryConfig(inventoryConfig) {
          var toArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (toArray && isObject_1.isObject(inventoryConfig))
            inventoryConfig = [inventoryConfig];
          if (isArray_1.isArray(inventoryConfig)) {
            inventoryConfig = inventoryConfig.map(formatFn);
          } else {
            inventoryConfig = formatFn(inventoryConfig);
          }
          return inventoryConfig;
        }
        exports3.formatInventoryConfig = formatInventoryConfig;
        function formatFn(_) {
          dataFix_1.dataFix(_, {
            bool: ["IsEnabled"]
          }, function(conf) {
            var _a, _b;
            conf.prefix = conf.Filter.Prefix;
            delete conf.Filter;
            conf.OSSBucketDestination = conf.Destination.OSSBucketDestination;
            conf.OSSBucketDestination.rolename = conf.OSSBucketDestination.RoleArn.replace(/.*\//, "");
            delete conf.OSSBucketDestination.RoleArn;
            conf.OSSBucketDestination.bucket = conf.OSSBucketDestination.Bucket.replace(/.*:::/, "");
            delete conf.OSSBucketDestination.Bucket;
            delete conf.Destination;
            conf.frequency = conf.Schedule.Frequency;
            delete conf.Schedule.Frequency;
            if (((_a = conf === null || conf === void 0 ? void 0 : conf.OptionalFields) === null || _a === void 0 ? void 0 : _a.Field) && !isArray_1.isArray((_b = conf.OptionalFields) === null || _b === void 0 ? void 0 : _b.Field))
              conf.OptionalFields.Field = [conf.OptionalFields.Field];
          });
          _ = formatObjKey_1.formatObjKey(_, "firstLowerCase", {
            exclude: ["OSSBucketDestination", "SSE-OSS", "SSE-KMS"]
          });
          return _;
        }
      }, { "../utils/dataFix": 59, "../utils/formatObjKey": 64, "../utils/isArray": 67, "../utils/isObject": 74, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.replace.js": 345 }], 64: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.includes.js");
        require2("core-js/modules/es.string.includes.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.formatObjKey = void 0;
        function formatObjKey(obj, type, options) {
          if (obj === null || (0, _typeof2.default)(obj) !== "object") {
            return obj;
          }
          var o2;
          if (Array.isArray(obj)) {
            o2 = [];
            for (var i = 0; i < obj.length; i++) {
              o2.push(formatObjKey(obj[i], type, options));
            }
          } else {
            o2 = {};
            Object.keys(obj).forEach(function(key) {
              o2[handelFormat(key, type, options)] = formatObjKey(obj[key], type, options);
            });
          }
          return o2;
        }
        exports3.formatObjKey = formatObjKey;
        function handelFormat(key, type, options) {
          if (options && options.exclude && options.exclude.includes(key))
            return key;
          if (type === "firstUpperCase") {
            key = key.replace(/^./, function(_) {
              return _.toUpperCase();
            });
          } else if (type === "firstLowerCase") {
            key = key.replace(/^./, function(_) {
              return _.toLowerCase();
            });
          }
          return key;
        }
      }, { "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/helpers/typeof": 91, "core-js/modules/es.array.includes.js": 315, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.includes.js": 342, "core-js/modules/es.string.replace.js": 345, "core-js/modules/web.dom-collections.for-each.js": 380 }], 65: [function(require2, module3, exports3) {
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.getStandardRegion = void 0;
        function getStandardRegion(str) {
          return str.replace(/^oss-/g, "");
        }
        exports3.getStandardRegion = getStandardRegion;
      }, { "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.replace.js": 345 }], 66: [function(require2, module3, exports3) {
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.getStrBytesCount = void 0;
        function getStrBytesCount(str) {
          var bytesCount = 0;
          for (var i = 0; i < str.length; i++) {
            var c = str.charAt(i);
            if (/^[\u00-\uff]$/.test(c)) {
              bytesCount += 1;
            } else {
              bytesCount += 2;
            }
          }
          return bytesCount;
        }
        exports3.getStrBytesCount = getStrBytesCount;
      }, { "core-js/modules/es.regexp.exec.js": 338 }], 67: [function(require2, module3, exports3) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.isArray = void 0;
        exports3.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }, { "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.to-string.js": 339 }], 68: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.isBlob = void 0;
        function isBlob(blob) {
          return typeof Blob !== "undefined" && blob instanceof Blob;
        }
        exports3.isBlob = isBlob;
      }, {}], 69: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.isBuffer = void 0;
            function isBuffer(obj) {
              return Buffer2.isBuffer(obj);
            }
            exports3.isBuffer = isBuffer;
          }).call(this);
        }).call(this, { "isBuffer": require2("../../../node_modules/is-buffer/index.js") });
      }, { "../../../node_modules/is-buffer/index.js": 409 }], 70: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            require2("core-js/modules/es.array.includes.js");
            require2("core-js/modules/es.string.includes.js");
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            exports3.isDingTalk = void 0;
            function isDingTalk() {
              if (process.browser && window.navigator.userAgent.toLowerCase().includes("aliapp(dingtalk")) {
                return true;
              }
              return false;
            }
            exports3.isDingTalk = isDingTalk;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 538, "core-js/modules/es.array.includes.js": 315, "core-js/modules/es.string.includes.js": 342 }], 71: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.isFile = void 0;
        exports3.isFile = function(obj) {
          return typeof File !== "undefined" && obj instanceof File;
        };
      }, {}], 72: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.isFunction = void 0;
        exports3.isFunction = function(v) {
          return typeof v === "function";
        };
      }, {}], 73: [function(require2, module3, exports3) {
        require2("core-js/modules/es.regexp.exec.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.isIP = void 0;
        exports3.isIP = function(host2) {
          var ipv4Regex = /^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$/;
          var ipv6Regex = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
          return ipv4Regex.test(host2) || ipv6Regex.test(host2);
        };
      }, { "core-js/modules/es.regexp.exec.js": 338 }], 74: [function(require2, module3, exports3) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.isObject = void 0;
        exports3.isObject = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        };
      }, { "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.to-string.js": 339 }], 75: [function(require2, module3, exports3) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.lowercaseKeyHeader = void 0;
        var isObject_1 = require2("./isObject");
        function lowercaseKeyHeader(headers) {
          var lowercaseHeader = {};
          if (isObject_1.isObject(headers)) {
            Object.keys(headers).forEach(function(key) {
              lowercaseHeader[key.toLowerCase()] = headers[key];
            });
          }
          return lowercaseHeader;
        }
        exports3.lowercaseKeyHeader = lowercaseKeyHeader;
      }, { "./isObject": 74, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/web.dom-collections.for-each.js": 380 }], 76: [function(require2, module3, exports3) {
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        require2("core-js/modules/web.dom-collections.for-each.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.array.join.js");
        require2("core-js/modules/es.array.map.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.obj2xml = void 0;
        var formatObjKey_1 = require2("./formatObjKey");
        function type(params) {
          return Object.prototype.toString.call(params).replace(/(.*? |])/g, "").toLowerCase();
        }
        function obj2xml(obj, options) {
          var s2 = "";
          if (options && options.headers) {
            s2 = '<?xml version="1.0" encoding="UTF-8"?>\n';
          }
          if (options && options.firstUpperCase) {
            obj = formatObjKey_1.formatObjKey(obj, "firstUpperCase");
          }
          if (type(obj) === "object") {
            Object.keys(obj).forEach(function(key) {
              if (type(obj[key]) !== "undefined" && type(obj[key]) !== "null") {
                if (type(obj[key]) === "string" || type(obj[key]) === "number") {
                  s2 += "<".concat(key, ">").concat(obj[key], "</").concat(key, ">");
                } else if (type(obj[key]) === "object") {
                  s2 += "<".concat(key, ">").concat(obj2xml(obj[key]), "</").concat(key, ">");
                } else if (type(obj[key]) === "array") {
                  s2 += obj[key].map(function(keyChild) {
                    return "<".concat(key, ">").concat(obj2xml(keyChild), "</").concat(key, ">");
                  }).join("");
                } else {
                  s2 += "<".concat(key, ">").concat(obj[key].toString(), "</").concat(key, ">");
                }
              }
            });
          } else {
            s2 += obj.toString();
          }
          return s2;
        }
        exports3.obj2xml = obj2xml;
      }, { "./formatObjKey": 64, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.join.js": 317, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.string.replace.js": 345, "core-js/modules/web.dom-collections.for-each.js": 380 }], 77: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.slice.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        require2("core-js/modules/es.function.name.js");
        require2("core-js/modules/es.array.from.js");
        require2("core-js/modules/es.string.iterator.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.symbol.js");
        require2("core-js/modules/es.symbol.description.js");
        require2("core-js/modules/es.symbol.iterator.js");
        require2("core-js/modules/es.array.iterator.js");
        require2("core-js/modules/web.dom-collections.iterator.js");
        require2("core-js/modules/es.object.assign.js");
        function _createForOfIteratorHelper(o2, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
          if (!it) {
            if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
              if (it)
                o2 = it;
              var i = 0;
              var F2 = function F3() {
              };
              return { s: F2, n: function n2() {
                if (i >= o2.length)
                  return { done: true };
                return { done: false, value: o2[i++] };
              }, e: function e2(_e) {
                throw _e;
              }, f: F2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true, didErr = false, err;
          return { s: function s2() {
            it = it.call(o2);
          }, n: function n2() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          }, e: function e2(_e2) {
            didErr = true;
            err = _e2;
          }, f: function f2() {
            try {
              if (!normalCompletion && it.return != null)
                it.return();
            } finally {
              if (didErr)
                throw err;
            }
          } };
        }
        function _unsupportedIterableToArray(o2, minLen) {
          if (!o2)
            return;
          if (typeof o2 === "string")
            return _arrayLikeToArray(o2, minLen);
          var n2 = Object.prototype.toString.call(o2).slice(8, -1);
          if (n2 === "Object" && o2.constructor)
            n2 = o2.constructor.name;
          if (n2 === "Map" || n2 === "Set")
            return Array.from(o2);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return _arrayLikeToArray(o2, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.omit = void 0;
        function omit(originalObject, keysToOmit) {
          var cloneObject = Object.assign({}, originalObject);
          var _iterator = _createForOfIteratorHelper(keysToOmit), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var path = _step.value;
              delete cloneObject[path];
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return cloneObject;
        }
        exports3.omit = omit;
      }, { "core-js/modules/es.array.from.js": 314, "core-js/modules/es.array.iterator.js": 316, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.function.name.js": 322, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.string.iterator.js": 343, "core-js/modules/es.symbol.description.js": 351, "core-js/modules/es.symbol.iterator.js": 353, "core-js/modules/es.symbol.js": 354, "core-js/modules/web.dom-collections.iterator.js": 381 }], 78: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.includes.js");
        require2("core-js/modules/es.string.includes.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.match.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.parseRestoreInfo = void 0;
        exports3.parseRestoreInfo = function(originalRestoreInfo) {
          var tempRestoreInfo;
          if (originalRestoreInfo) {
            tempRestoreInfo = {
              ongoingRequest: originalRestoreInfo.includes("true")
            };
            if (!tempRestoreInfo.ongoingRequest) {
              var matchArray = originalRestoreInfo.match(/expiry-date="(.*)"/);
              if (matchArray && matchArray[1]) {
                tempRestoreInfo.expiryDate = new Date(matchArray[1]);
              }
            }
          }
          return tempRestoreInfo;
        };
      }, { "core-js/modules/es.array.includes.js": 315, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.includes.js": 342, "core-js/modules/es.string.match.js": 344 }], 79: [function(require2, module3, exports3) {
        require2("core-js/modules/es.object.keys.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.policy2Str = void 0;
        function policy2Str(policy) {
          var policyStr;
          if (policy) {
            if (typeof policy === "string") {
              try {
                policyStr = JSON.stringify(JSON.parse(policy));
              } catch (err) {
                throw new Error("Policy string is not a valid JSON: ".concat(err.message));
              }
            } else {
              policyStr = JSON.stringify(policy);
            }
          }
          return policyStr;
        }
        exports3.policy2Str = policy2Str;
      }, { "core-js/modules/es.object.keys.js": 328 }], 80: [function(require2, module3, exports3) {
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.promise.js");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.retry = void 0;
        function retry(func2, retryMax) {
          var config2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var retryNum = 0;
          var _config$retryDelay = config2.retryDelay, retryDelay = _config$retryDelay === void 0 ? 500 : _config$retryDelay, _config$errorHandler = config2.errorHandler, errorHandler = _config$errorHandler === void 0 ? function() {
            return true;
          } : _config$errorHandler;
          var funcR = function funcR2() {
            for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
              arg[_key] = arguments[_key];
            }
            return new Promise(function(resolve2, reject) {
              func2.apply(void 0, arg).then(function(result) {
                retryNum = 0;
                resolve2(result);
              }).catch(function(err) {
                if (retryNum < retryMax && errorHandler(err)) {
                  retryNum++;
                  setTimeout(function() {
                    resolve2(funcR2.apply(void 0, arg));
                  }, retryDelay);
                } else {
                  retryNum = 0;
                  reject(err);
                }
              });
            });
          };
          return funcR;
        }
        exports3.retry = retry;
      }, { "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333 }], 81: [function(require2, module3, exports3) {
        var __importDefault = function(mod) {
          return mod && mod.__esModule ? mod : {
            "default": mod
          };
        };
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.setRegion = void 0;
        var url_1 = __importDefault(require2("url"));
        var checkConfigValid_1 = require2("./checkConfigValid");
        function setRegion(region) {
          var internal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var secure = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          checkConfigValid_1.checkConfigValid(region, "region");
          var protocol = secure ? "https://" : "http://";
          var suffix = internal ? "-internal.aliyuncs.com" : ".aliyuncs.com";
          var prefix = "vpc100-oss-cn-";
          if (region.substr(0, prefix.length) === prefix) {
            suffix = ".aliyuncs.com";
          }
          return url_1.default.parse(protocol + region + suffix);
        }
        exports3.setRegion = setRegion;
      }, { "./checkConfigValid": 54, "url": 543 }], 82: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.array.find.js");
        require2("core-js/modules/es.object.assign.js");
        var _asyncToGenerator2 = _interopRequireDefault(require2("@babel/runtime/helpers/asyncToGenerator"));
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.checkCredentials = exports3.setSTSToken = void 0;
        var formatObjKey_1 = require2("./formatObjKey");
        function setSTSToken() {
          return _setSTSToken.apply(this, arguments);
        }
        function _setSTSToken() {
          _setSTSToken = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee() {
            var now, credentials;
            return _regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this.options)
                      this.options = {};
                    now = /* @__PURE__ */ new Date();
                    if (!this.stsTokenFreshTime) {
                      _context.next = 14;
                      break;
                    }
                    if (!(+now - this.stsTokenFreshTime >= this.options.refreshSTSTokenInterval)) {
                      _context.next = 12;
                      break;
                    }
                    this.stsTokenFreshTime = now;
                    _context.next = 7;
                    return this.options.refreshSTSToken();
                  case 7:
                    credentials = _context.sent;
                    credentials = formatObjKey_1.formatObjKey(credentials, "firstLowerCase");
                    if (credentials.securityToken) {
                      credentials.stsToken = credentials.securityToken;
                    }
                    checkCredentials(credentials);
                    Object.assign(this.options, credentials);
                  case 12:
                    _context.next = 15;
                    break;
                  case 14:
                    this.stsTokenFreshTime = now;
                  case 15:
                    return _context.abrupt("return", null);
                  case 16:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          return _setSTSToken.apply(this, arguments);
        }
        exports3.setSTSToken = setSTSToken;
        function checkCredentials(obj) {
          var stsTokenKey = ["accessKeySecret", "accessKeyId", "stsToken"];
          var objKeys = Object.keys(obj);
          stsTokenKey.forEach(function(_) {
            if (!objKeys.find(function(key) {
              return key === _;
            })) {
              throw Error("refreshSTSToken must return contains ".concat(_));
            }
          });
        }
        exports3.checkCredentials = checkCredentials;
      }, { "./formatObjKey": 64, "@babel/runtime/helpers/asyncToGenerator": 85, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/regenerator": 93, "core-js/modules/es.array.find.js": 313, "core-js/modules/es.object.assign.js": 325, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329 }], 83: [function(require2, module3, exports3) {
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        module3.exports = _arrayLikeToArray, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, {}], 84: [function(require2, module3, exports3) {
        var arrayLikeToArray = require2("./arrayLikeToArray.js");
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return arrayLikeToArray(arr);
        }
        module3.exports = _arrayWithoutHoles, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, { "./arrayLikeToArray.js": 83 }], 85: [function(require2, module3, exports3) {
        function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error2) {
            reject(error2);
            return;
          }
          if (info.done) {
            resolve2(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }
        function _asyncToGenerator(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve2, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        module3.exports = _asyncToGenerator, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, {}], 86: [function(require2, module3, exports3) {
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }
        module3.exports = _interopRequireDefault, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, {}], 87: [function(require2, module3, exports3) {
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        module3.exports = _iterableToArray, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, {}], 88: [function(require2, module3, exports3) {
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        module3.exports = _nonIterableSpread, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, {}], 89: [function(require2, module3, exports3) {
        var _typeof = require2("./typeof.js")["default"];
        function _regeneratorRuntime() {
          module3.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
            return e2;
          }, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
          var t2, e2 = {}, r = Object.prototype, n2 = r.hasOwnProperty, o2 = Object.defineProperty || function(t3, e3, r2) {
            t3[e3] = r2.value;
          }, i = "function" == typeof Symbol ? Symbol : {}, a2 = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u2 = i.toStringTag || "@@toStringTag";
          function define(t3, e3, r2) {
            return Object.defineProperty(t3, e3, {
              value: r2,
              enumerable: true,
              configurable: true,
              writable: true
            }), t3[e3];
          }
          try {
            define({}, "");
          } catch (t3) {
            define = function define2(t4, e3, r2) {
              return t4[e3] = r2;
            };
          }
          function wrap(t3, e3, r2, n3) {
            var i2 = e3 && e3.prototype instanceof Generator ? e3 : Generator, a3 = Object.create(i2.prototype), c2 = new Context2(n3 || []);
            return o2(a3, "_invoke", {
              value: makeInvokeMethod(t3, r2, c2)
            }), a3;
          }
          function tryCatch2(t3, e3, r2) {
            try {
              return {
                type: "normal",
                arg: t3.call(e3, r2)
              };
            } catch (t4) {
              return {
                type: "throw",
                arg: t4
              };
            }
          }
          e2.wrap = wrap;
          var h = "suspendedStart", l = "suspendedYield", f2 = "executing", s2 = "completed", y = {};
          function Generator() {
          }
          function GeneratorFunction() {
          }
          function GeneratorFunctionPrototype() {
          }
          var p2 = {};
          define(p2, a2, function() {
            return this;
          });
          var d = Object.getPrototypeOf, v = d && d(d(values([])));
          v && v !== r && n2.call(v, a2) && (p2 = v);
          var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
          function defineIteratorMethods(t3) {
            ["next", "throw", "return"].forEach(function(e3) {
              define(t3, e3, function(t4) {
                return this._invoke(e3, t4);
              });
            });
          }
          function AsyncIterator(t3, e3) {
            function invoke(r3, o3, i2, a3) {
              var c2 = tryCatch2(t3[r3], t3, o3);
              if ("throw" !== c2.type) {
                var u3 = c2.arg, h2 = u3.value;
                return h2 && "object" == _typeof(h2) && n2.call(h2, "__await") ? e3.resolve(h2.__await).then(function(t4) {
                  invoke("next", t4, i2, a3);
                }, function(t4) {
                  invoke("throw", t4, i2, a3);
                }) : e3.resolve(h2).then(function(t4) {
                  u3.value = t4, i2(u3);
                }, function(t4) {
                  return invoke("throw", t4, i2, a3);
                });
              }
              a3(c2.arg);
            }
            var r2;
            o2(this, "_invoke", {
              value: function value(t4, n3) {
                function callInvokeWithMethodAndArg() {
                  return new e3(function(e4, r3) {
                    invoke(t4, n3, e4, r3);
                  });
                }
                return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
              }
            });
          }
          function makeInvokeMethod(e3, r2, n3) {
            var o3 = h;
            return function(i2, a3) {
              if (o3 === f2)
                throw new Error("Generator is already running");
              if (o3 === s2) {
                if ("throw" === i2)
                  throw a3;
                return {
                  value: t2,
                  done: true
                };
              }
              for (n3.method = i2, n3.arg = a3; ; ) {
                var c2 = n3.delegate;
                if (c2) {
                  var u3 = maybeInvokeDelegate(c2, n3);
                  if (u3) {
                    if (u3 === y)
                      continue;
                    return u3;
                  }
                }
                if ("next" === n3.method)
                  n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === h)
                    throw o3 = s2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else
                  "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = f2;
                var p3 = tryCatch2(e3, r2, n3);
                if ("normal" === p3.type) {
                  if (o3 = n3.done ? s2 : l, p3.arg === y)
                    continue;
                  return {
                    value: p3.arg,
                    done: n3.done
                  };
                }
                "throw" === p3.type && (o3 = s2, n3.method = "throw", n3.arg = p3.arg);
              }
            };
          }
          function maybeInvokeDelegate(e3, r2) {
            var n3 = r2.method, o3 = e3.iterator[n3];
            if (o3 === t2)
              return r2.delegate = null, "throw" === n3 && e3.iterator["return"] && (r2.method = "return", r2.arg = t2, maybeInvokeDelegate(e3, r2), "throw" === r2.method) || "return" !== n3 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y;
            var i2 = tryCatch2(o3, e3.iterator, r2.arg);
            if ("throw" === i2.type)
              return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
            var a3 = i2.arg;
            return a3 ? a3.done ? (r2[e3.resultName] = a3.value, r2.next = e3.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t2), r2.delegate = null, y) : a3 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
          }
          function pushTryEntry(t3) {
            var e3 = {
              tryLoc: t3[0]
            };
            1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
          }
          function resetTryEntry(t3) {
            var e3 = t3.completion || {};
            e3.type = "normal", delete e3.arg, t3.completion = e3;
          }
          function Context2(t3) {
            this.tryEntries = [{
              tryLoc: "root"
            }], t3.forEach(pushTryEntry, this), this.reset(true);
          }
          function values(e3) {
            if (e3 || "" === e3) {
              var r2 = e3[a2];
              if (r2)
                return r2.call(e3);
              if ("function" == typeof e3.next)
                return e3;
              if (!isNaN(e3.length)) {
                var o3 = -1, i2 = function next() {
                  for (; ++o3 < e3.length; )
                    if (n2.call(e3, o3))
                      return next.value = e3[o3], next.done = false, next;
                  return next.value = t2, next.done = true, next;
                };
                return i2.next = i2;
              }
            }
            throw new TypeError(_typeof(e3) + " is not iterable");
          }
          return GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g, "constructor", {
            value: GeneratorFunctionPrototype,
            configurable: true
          }), o2(GeneratorFunctionPrototype, "constructor", {
            value: GeneratorFunction,
            configurable: true
          }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e2.isGeneratorFunction = function(t3) {
            var e3 = "function" == typeof t3 && t3.constructor;
            return !!e3 && (e3 === GeneratorFunction || "GeneratorFunction" === (e3.displayName || e3.name));
          }, e2.mark = function(t3) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define(t3, u2, "GeneratorFunction")), t3.prototype = Object.create(g), t3;
          }, e2.awrap = function(t3) {
            return {
              __await: t3
            };
          }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
            return this;
          }), e2.AsyncIterator = AsyncIterator, e2.async = function(t3, r2, n3, o3, i2) {
            void 0 === i2 && (i2 = Promise);
            var a3 = new AsyncIterator(wrap(t3, r2, n3, o3), i2);
            return e2.isGeneratorFunction(r2) ? a3 : a3.next().then(function(t4) {
              return t4.done ? t4.value : a3.next();
            });
          }, defineIteratorMethods(g), define(g, u2, "Generator"), define(g, a2, function() {
            return this;
          }), define(g, "toString", function() {
            return "[object Generator]";
          }), e2.keys = function(t3) {
            var e3 = Object(t3), r2 = [];
            for (var n3 in e3)
              r2.push(n3);
            return r2.reverse(), function next() {
              for (; r2.length; ) {
                var t4 = r2.pop();
                if (t4 in e3)
                  return next.value = t4, next.done = false, next;
              }
              return next.done = true, next;
            };
          }, e2.values = values, Context2.prototype = {
            constructor: Context2,
            reset: function reset(e3) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e3)
                for (var r2 in this)
                  "t" === r2.charAt(0) && n2.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t2);
            },
            stop: function stop() {
              this.done = true;
              var t3 = this.tryEntries[0].completion;
              if ("throw" === t3.type)
                throw t3.arg;
              return this.rval;
            },
            dispatchException: function dispatchException(e3) {
              if (this.done)
                throw e3;
              var r2 = this;
              function handle(n3, o4) {
                return a3.type = "throw", a3.arg = e3, r2.next = n3, o4 && (r2.method = "next", r2.arg = t2), !!o4;
              }
              for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
                var i2 = this.tryEntries[o3], a3 = i2.completion;
                if ("root" === i2.tryLoc)
                  return handle("end");
                if (i2.tryLoc <= this.prev) {
                  var c2 = n2.call(i2, "catchLoc"), u3 = n2.call(i2, "finallyLoc");
                  if (c2 && u3) {
                    if (this.prev < i2.catchLoc)
                      return handle(i2.catchLoc, true);
                    if (this.prev < i2.finallyLoc)
                      return handle(i2.finallyLoc);
                  } else if (c2) {
                    if (this.prev < i2.catchLoc)
                      return handle(i2.catchLoc, true);
                  } else {
                    if (!u3)
                      throw new Error("try statement without catch or finally");
                    if (this.prev < i2.finallyLoc)
                      return handle(i2.finallyLoc);
                  }
                }
              }
            },
            abrupt: function abrupt(t3, e3) {
              for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
                var o3 = this.tryEntries[r2];
                if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                  var i2 = o3;
                  break;
                }
              }
              i2 && ("break" === t3 || "continue" === t3) && i2.tryLoc <= e3 && e3 <= i2.finallyLoc && (i2 = null);
              var a3 = i2 ? i2.completion : {};
              return a3.type = t3, a3.arg = e3, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a3);
            },
            complete: function complete(t3, e3) {
              if ("throw" === t3.type)
                throw t3.arg;
              return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), y;
            },
            finish: function finish(t3) {
              for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
                var r2 = this.tryEntries[e3];
                if (r2.finallyLoc === t3)
                  return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
              }
            },
            "catch": function _catch(t3) {
              for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
                var r2 = this.tryEntries[e3];
                if (r2.tryLoc === t3) {
                  var n3 = r2.completion;
                  if ("throw" === n3.type) {
                    var o3 = n3.arg;
                    resetTryEntry(r2);
                  }
                  return o3;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function delegateYield(e3, r2, n3) {
              return this.delegate = {
                iterator: values(e3),
                resultName: r2,
                nextLoc: n3
              }, "next" === this.method && (this.arg = t2), y;
            }
          }, e2;
        }
        module3.exports = _regeneratorRuntime, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, { "./typeof.js": 91 }], 90: [function(require2, module3, exports3) {
        var arrayWithoutHoles = require2("./arrayWithoutHoles.js");
        var iterableToArray = require2("./iterableToArray.js");
        var unsupportedIterableToArray = require2("./unsupportedIterableToArray.js");
        var nonIterableSpread = require2("./nonIterableSpread.js");
        function _toConsumableArray(arr) {
          return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
        }
        module3.exports = _toConsumableArray, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, { "./arrayWithoutHoles.js": 84, "./iterableToArray.js": 87, "./nonIterableSpread.js": 88, "./unsupportedIterableToArray.js": 92 }], 91: [function(require2, module3, exports3) {
        function _typeof(o2) {
          "@babel/helpers - typeof";
          return module3.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, module3.exports.__esModule = true, module3.exports["default"] = module3.exports, _typeof(o2);
        }
        module3.exports = _typeof, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, {}], 92: [function(require2, module3, exports3) {
        var arrayLikeToArray = require2("./arrayLikeToArray.js");
        function _unsupportedIterableToArray(o2, minLen) {
          if (!o2)
            return;
          if (typeof o2 === "string")
            return arrayLikeToArray(o2, minLen);
          var n2 = Object.prototype.toString.call(o2).slice(8, -1);
          if (n2 === "Object" && o2.constructor)
            n2 = o2.constructor.name;
          if (n2 === "Map" || n2 === "Set")
            return Array.from(o2);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return arrayLikeToArray(o2, minLen);
        }
        module3.exports = _unsupportedIterableToArray, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
      }, { "./arrayLikeToArray.js": 83 }], 93: [function(require2, module3, exports3) {
        var runtime = require2("../helpers/regeneratorRuntime")();
        module3.exports = runtime;
        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          if (typeof globalThis === "object") {
            globalThis.regeneratorRuntime = runtime;
          } else {
            Function("r", "regeneratorRuntime = r")(runtime);
          }
        }
      }, { "../helpers/regeneratorRuntime": 89 }], 94: [function(require2, module3, exports3) {
        module3.exports = noop2;
        module3.exports.HttpsAgent = noop2;
        function noop2() {
        }
      }, {}], 95: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            var objectAssign = require2("object.assign/polyfill")();
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
             * @license  MIT
             */
            function compare(a2, b) {
              if (a2 === b) {
                return 0;
              }
              var x = a2.length;
              var y = b.length;
              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a2[i] !== b[i]) {
                  x = a2[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y) {
                return -1;
              }
              if (y < x) {
                return 1;
              }
              return 0;
            }
            function isBuffer(b) {
              if (global3.Buffer && typeof global3.Buffer.isBuffer === "function") {
                return global3.Buffer.isBuffer(b);
              }
              return !!(b != null && b._isBuffer);
            }
            var util = require2("util/");
            var hasOwn2 = Object.prototype.hasOwnProperty;
            var pSlice = Array.prototype.slice;
            var functionsHaveNames = function() {
              return (function foo() {
              }).name === "foo";
            }();
            function pToString(obj) {
              return Object.prototype.toString.call(obj);
            }
            function isView(arrbuf) {
              if (isBuffer(arrbuf)) {
                return false;
              }
              if (typeof global3.ArrayBuffer !== "function") {
                return false;
              }
              if (typeof ArrayBuffer.isView === "function") {
                return ArrayBuffer.isView(arrbuf);
              }
              if (!arrbuf) {
                return false;
              }
              if (arrbuf instanceof DataView) {
                return true;
              }
              if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                return true;
              }
              return false;
            }
            var assert2 = module3.exports = ok;
            var regex2 = /\s*function\s+([^\(\s]*)\s*/;
            function getName(func2) {
              if (!util.isFunction(func2)) {
                return;
              }
              if (functionsHaveNames) {
                return func2.name;
              }
              var str = func2.toString();
              var match = str.match(regex2);
              return match && match[1];
            }
            assert2.AssertionError = function AssertionError(options) {
              this.name = "AssertionError";
              this.actual = options.actual;
              this.expected = options.expected;
              this.operator = options.operator;
              if (options.message) {
                this.message = options.message;
                this.generatedMessage = false;
              } else {
                this.message = getMessage(this);
                this.generatedMessage = true;
              }
              var stackStartFunction = options.stackStartFunction || fail;
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, stackStartFunction);
              } else {
                var err = new Error();
                if (err.stack) {
                  var out = err.stack;
                  var fn_name = getName(stackStartFunction);
                  var idx = out.indexOf("\n" + fn_name);
                  if (idx >= 0) {
                    var next_line = out.indexOf("\n", idx + 1);
                    out = out.substring(next_line + 1);
                  }
                  this.stack = out;
                }
              }
            };
            util.inherits(assert2.AssertionError, Error);
            function truncate(s2, n2) {
              if (typeof s2 === "string") {
                return s2.length < n2 ? s2 : s2.slice(0, n2);
              } else {
                return s2;
              }
            }
            function inspect(something) {
              if (functionsHaveNames || !util.isFunction(something)) {
                return util.inspect(something);
              }
              var rawname = getName(something);
              var name = rawname ? ": " + rawname : "";
              return "[Function" + name + "]";
            }
            function getMessage(self2) {
              return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
            }
            function fail(actual, expected, message, operator, stackStartFunction) {
              throw new assert2.AssertionError({
                message,
                actual,
                expected,
                operator,
                stackStartFunction
              });
            }
            assert2.fail = fail;
            function ok(value, message) {
              if (!value)
                fail(value, true, message, "==", assert2.ok);
            }
            assert2.ok = ok;
            assert2.equal = function equal(actual, expected, message) {
              if (actual != expected)
                fail(actual, expected, message, "==", assert2.equal);
            };
            assert2.notEqual = function notEqual(actual, expected, message) {
              if (actual == expected) {
                fail(actual, expected, message, "!=", assert2.notEqual);
              }
            };
            assert2.deepEqual = function deepEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "deepEqual", assert2.deepEqual);
              }
            };
            assert2.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected, true)) {
                fail(actual, expected, message, "deepStrictEqual", assert2.deepStrictEqual);
              }
            };
            function _deepEqual(actual, expected, strict2, memos) {
              if (actual === expected) {
                return true;
              } else if (isBuffer(actual) && isBuffer(expected)) {
                return compare(actual, expected) === 0;
              } else if (util.isDate(actual) && util.isDate(expected)) {
                return actual.getTime() === expected.getTime();
              } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
              } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
                return strict2 ? actual === expected : actual == expected;
              } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
                return compare(
                  new Uint8Array(actual.buffer),
                  new Uint8Array(expected.buffer)
                ) === 0;
              } else if (isBuffer(actual) !== isBuffer(expected)) {
                return false;
              } else {
                memos = memos || { actual: [], expected: [] };
                var actualIndex = memos.actual.indexOf(actual);
                if (actualIndex !== -1) {
                  if (actualIndex === memos.expected.indexOf(expected)) {
                    return true;
                  }
                }
                memos.actual.push(actual);
                memos.expected.push(expected);
                return objEquiv(actual, expected, strict2, memos);
              }
            }
            function isArguments(object2) {
              return Object.prototype.toString.call(object2) == "[object Arguments]";
            }
            function objEquiv(a2, b, strict2, actualVisitedObjects) {
              if (a2 === null || a2 === void 0 || b === null || b === void 0)
                return false;
              if (util.isPrimitive(a2) || util.isPrimitive(b))
                return a2 === b;
              if (strict2 && Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b))
                return false;
              var aIsArgs = isArguments(a2);
              var bIsArgs = isArguments(b);
              if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
                return false;
              if (aIsArgs) {
                a2 = pSlice.call(a2);
                b = pSlice.call(b);
                return _deepEqual(a2, b, strict2);
              }
              var ka = objectKeys2(a2);
              var kb = objectKeys2(b);
              var key, i;
              if (ka.length !== kb.length)
                return false;
              ka.sort();
              kb.sort();
              for (i = ka.length - 1; i >= 0; i--) {
                if (ka[i] !== kb[i])
                  return false;
              }
              for (i = ka.length - 1; i >= 0; i--) {
                key = ka[i];
                if (!_deepEqual(a2[key], b[key], strict2, actualVisitedObjects))
                  return false;
              }
              return true;
            }
            assert2.notDeepEqual = function notDeepEqual(actual, expected, message) {
              if (_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, "notDeepEqual", assert2.notDeepEqual);
              }
            };
            assert2.notDeepStrictEqual = notDeepStrictEqual;
            function notDeepStrictEqual(actual, expected, message) {
              if (_deepEqual(actual, expected, true)) {
                fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
              }
            }
            assert2.strictEqual = function strictEqual(actual, expected, message) {
              if (actual !== expected) {
                fail(actual, expected, message, "===", assert2.strictEqual);
              }
            };
            assert2.notStrictEqual = function notStrictEqual(actual, expected, message) {
              if (actual === expected) {
                fail(actual, expected, message, "!==", assert2.notStrictEqual);
              }
            };
            function expectedException(actual, expected) {
              if (!actual || !expected) {
                return false;
              }
              if (Object.prototype.toString.call(expected) == "[object RegExp]") {
                return expected.test(actual);
              }
              try {
                if (actual instanceof expected) {
                  return true;
                }
              } catch (e2) {
              }
              if (Error.isPrototypeOf(expected)) {
                return false;
              }
              return expected.call({}, actual) === true;
            }
            function _tryBlock(block) {
              var error2;
              try {
                block();
              } catch (e2) {
                error2 = e2;
              }
              return error2;
            }
            function _throws(shouldThrow, block, expected, message) {
              var actual;
              if (typeof block !== "function") {
                throw new TypeError('"block" argument must be a function');
              }
              if (typeof expected === "string") {
                message = expected;
                expected = null;
              }
              actual = _tryBlock(block);
              message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
              if (shouldThrow && !actual) {
                fail(actual, expected, "Missing expected exception" + message);
              }
              var userProvidedMessage = typeof message === "string";
              var isUnwantedException = !shouldThrow && util.isError(actual);
              var isUnexpectedException = !shouldThrow && actual && !expected;
              if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
                fail(actual, expected, "Got unwanted exception" + message);
              }
              if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
                throw actual;
              }
            }
            assert2.throws = function(block, error2, message) {
              _throws(true, block, error2, message);
            };
            assert2.doesNotThrow = function(block, error2, message) {
              _throws(false, block, error2, message);
            };
            assert2.ifError = function(err) {
              if (err)
                throw err;
            };
            function strict(value, message) {
              if (!value)
                fail(value, true, message, "==", strict);
            }
            assert2.strict = objectAssign(strict, assert2, {
              equal: assert2.strictEqual,
              deepEqual: assert2.deepStrictEqual,
              notEqual: assert2.notStrictEqual,
              notDeepEqual: assert2.notDeepStrictEqual
            });
            assert2.strict.strict = assert2.strict;
            var objectKeys2 = Object.keys || function(obj) {
              var keys = [];
              for (var key in obj) {
                if (hasOwn2.call(obj, key))
                  keys.push(key);
              }
              return keys;
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "object.assign/polyfill": 438, "util/": 98 }], 96: [function(require2, module3, exports3) {
        if (typeof Object.create === "function") {
          module3.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };
        } else {
          module3.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      }, {}], 97: [function(require2, module3, exports3) {
        module3.exports = function isBuffer(arg) {
          return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
        };
      }, {}], 98: [function(require2, module3, exports3) {
        (function(process, global3) {
          (function() {
            var formatRegExp = /%[sdj%]/g;
            exports3.format = function(f2) {
              if (!isString2(f2)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(" ");
              }
              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f2).replace(formatRegExp, function(x2) {
                if (x2 === "%%")
                  return "%";
                if (i >= len)
                  return x2;
                switch (x2) {
                  case "%s":
                    return String(args[i++]);
                  case "%d":
                    return Number(args[i++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x2;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject2(x)) {
                  str += " " + x;
                } else {
                  str += " " + inspect(x);
                }
              }
              return str;
            };
            exports3.deprecate = function(fn, msg) {
              if (isUndefined2(global3.process)) {
                return function() {
                  return exports3.deprecate(fn, msg).apply(this, arguments);
                };
              }
              if (process.noDeprecation === true) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    index$2.__f__("error", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:8385", msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnviron;
            exports3.debuglog = function(set2) {
              if (isUndefined2(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || "";
              set2 = set2.toUpperCase();
              if (!debugs[set2]) {
                if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
                  var pid = process.pid;
                  debugs[set2] = function() {
                    var msg = exports3.format.apply(exports3, arguments);
                    index$2.__f__("error", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:8407", "%s %d: %s", set2, pid, msg);
                  };
                } else {
                  debugs[set2] = function() {
                  };
                }
              }
              return debugs[set2];
            };
            function inspect(obj, opts) {
              var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
              if (arguments.length >= 3)
                ctx.depth = arguments[2];
              if (arguments.length >= 4)
                ctx.colors = arguments[3];
              if (isBoolean2(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports3._extend(ctx, opts);
              }
              if (isUndefined2(ctx.showHidden))
                ctx.showHidden = false;
              if (isUndefined2(ctx.depth))
                ctx.depth = 2;
              if (isUndefined2(ctx.colors))
                ctx.colors = false;
              if (isUndefined2(ctx.customInspect))
                ctx.customInspect = true;
              if (ctx.colors)
                ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports3.inspect = inspect;
            inspect.colors = {
              "bold": [1, 22],
              "italic": [3, 23],
              "underline": [4, 24],
              "inverse": [7, 27],
              "white": [37, 39],
              "grey": [90, 39],
              "black": [30, 39],
              "blue": [34, 39],
              "cyan": [36, 39],
              "green": [32, 39],
              "magenta": [35, 39],
              "red": [31, 39],
              "yellow": [33, 39]
            };
            inspect.styles = {
              "special": "cyan",
              "number": "yellow",
              "boolean": "yellow",
              "undefined": "grey",
              "null": "bold",
              "string": "green",
              "date": "magenta",
              // "name": intentionally not styling
              "regexp": "red"
            };
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              if (style) {
                return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array2) {
              var hash = {};
              array2.forEach(function(val, idx) {
                hash[val] = true;
              });
              return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
              value.inspect !== exports3.inspect && // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString2(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction2(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate2(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = "", array2 = false, braces = ["{", "}"];
              if (isArray2(value)) {
                array2 = true;
                braces = ["[", "]"];
              }
              if (isFunction2(value)) {
                var n2 = value.name ? ": " + value.name : "";
                base = " [Function" + n2 + "]";
              }
              if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }
              if (isDate2(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = " " + formatError(value);
              }
              if (keys.length === 0 && (!array2 || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }
              ctx.seen.push(value);
              var output;
              if (array2) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2);
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined2(value))
                return ctx.stylize("undefined", "undefined");
              if (isString2(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber(value))
                return ctx.stylize("" + value, "number");
              if (isBoolean2(value))
                return ctx.stylize("" + value, "boolean");
              if (isNull(value))
                return ctx.stylize("null", "null");
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty2(value, String(i))) {
                  output.push(formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    String(i),
                    true
                  ));
                } else {
                  output.push("");
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    true
                  ));
                }
              });
              return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty2(visibleKeys, key)) {
                name = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array2) {
                      str = str.split("\n").map(function(line2) {
                        return "  " + line2;
                      }).join("\n").substr(2);
                    } else {
                      str = "\n" + str.split("\n").map(function(line2) {
                        return "   " + line2;
                      }).join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined2(name)) {
                if (array2 && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, "name");
                } else {
                  name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, "string");
                }
              }
              return name + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
              var length = output.reduce(function(prev, cur) {
                if (cur.indexOf("\n") >= 0)
                  ;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
              }
              return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            function isArray2(ar) {
              return Array.isArray(ar);
            }
            exports3.isArray = isArray2;
            function isBoolean2(arg) {
              return typeof arg === "boolean";
            }
            exports3.isBoolean = isBoolean2;
            function isNull(arg) {
              return arg === null;
            }
            exports3.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports3.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === "number";
            }
            exports3.isNumber = isNumber;
            function isString2(arg) {
              return typeof arg === "string";
            }
            exports3.isString = isString2;
            function isSymbol2(arg) {
              return typeof arg === "symbol";
            }
            exports3.isSymbol = isSymbol2;
            function isUndefined2(arg) {
              return arg === void 0;
            }
            exports3.isUndefined = isUndefined2;
            function isRegExp(re) {
              return isObject2(re) && objectToString2(re) === "[object RegExp]";
            }
            exports3.isRegExp = isRegExp;
            function isObject2(arg) {
              return typeof arg === "object" && arg !== null;
            }
            exports3.isObject = isObject2;
            function isDate2(d) {
              return isObject2(d) && objectToString2(d) === "[object Date]";
            }
            exports3.isDate = isDate2;
            function isError(e2) {
              return isObject2(e2) && (objectToString2(e2) === "[object Error]" || e2 instanceof Error);
            }
            exports3.isError = isError;
            function isFunction2(arg) {
              return typeof arg === "function";
            }
            exports3.isFunction = isFunction2;
            function isPrimitive(arg) {
              return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined";
            }
            exports3.isPrimitive = isPrimitive;
            exports3.isBuffer = require2("./support/isBuffer");
            function objectToString2(o2) {
              return Object.prototype.toString.call(o2);
            }
            function pad2(n2) {
              return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
            }
            var months = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ];
            function timestamp() {
              var d = /* @__PURE__ */ new Date();
              var time2 = [
                pad2(d.getHours()),
                pad2(d.getMinutes()),
                pad2(d.getSeconds())
              ].join(":");
              return [d.getDate(), months[d.getMonth()], time2].join(" ");
            }
            exports3.log = function() {
              index$2.__f__("log", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:8853", "%s - %s", timestamp(), exports3.format.apply(exports3, arguments));
            };
            exports3.inherits = require2("inherits");
            exports3._extend = function(origin, add2) {
              if (!add2 || !isObject2(add2))
                return origin;
              var keys = Object.keys(add2);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add2[keys[i]];
              }
              return origin;
            };
            function hasOwnProperty2(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./support/isBuffer": 97, "_process": 538, "inherits": 96 }], 99: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            var possibleNames = [
              "BigInt64Array",
              "BigUint64Array",
              "Float32Array",
              "Float64Array",
              "Int16Array",
              "Int32Array",
              "Int8Array",
              "Uint16Array",
              "Uint32Array",
              "Uint8Array",
              "Uint8ClampedArray"
            ];
            var g = typeof globalThis === "undefined" ? global3 : globalThis;
            module3.exports = function availableTypedArrays() {
              var out = [];
              for (var i = 0; i < possibleNames.length; i++) {
                if (typeof g[possibleNames[i]] === "function") {
                  out[out.length] = possibleNames[i];
                }
              }
              return out;
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 100: [function(require2, module3, exports3) {
        exports3.byteLength = byteLength;
        exports3.toByteArray = toByteArray;
        exports3.fromByteArray = fromByteArray;
        var lookup2 = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code2.length; i < len; ++i) {
          lookup2[i] = code2[i];
          revLookup[code2.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b642) {
          var len2 = b642.length;
          if (len2 % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          var validLen = b642.indexOf("=");
          if (validLen === -1)
            validLen = len2;
          var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
          return [validLen, placeHoldersLen];
        }
        function byteLength(b642) {
          var lens = getLens(b642);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b642, validLen, placeHoldersLen) {
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b642) {
          var tmp;
          var lens = getLens(b642);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b642, validLen, placeHoldersLen));
          var curByte = 0;
          var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i2;
          for (i2 = 0; i2 < len2; i2 += 4) {
            tmp = revLookup[b642.charCodeAt(i2)] << 18 | revLookup[b642.charCodeAt(i2 + 1)] << 12 | revLookup[b642.charCodeAt(i2 + 2)] << 6 | revLookup[b642.charCodeAt(i2 + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 2) {
            tmp = revLookup[b642.charCodeAt(i2)] << 2 | revLookup[b642.charCodeAt(i2 + 1)] >> 4;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 1) {
            tmp = revLookup[b642.charCodeAt(i2)] << 10 | revLookup[b642.charCodeAt(i2 + 1)] << 4 | revLookup[b642.charCodeAt(i2 + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i2 = start; i2 < end; i2 += 3) {
            tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len2 = uint8.length;
          var extraBytes = len2 % 3;
          var parts = [];
          var maxChunkLength = 16383;
          for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
            parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len2 - 1];
            parts.push(
              lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
            );
          } else if (extraBytes === 2) {
            tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
            parts.push(
              lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
            );
          }
          return parts.join("");
        }
      }, {}], 101: [function(require2, module3, exports3) {
        /*!
         * Bowser - a browser detector
         * https://github.com/ded/bowser
         * MIT License | (c) Dustin Diaz 2015
         */
        !function(root, name, definition) {
          if (typeof module3 != "undefined" && module3.exports)
            module3.exports = definition();
          else
            root[name] = definition();
        }(this, "bowser", function() {
          var t2 = true;
          function detect(ua) {
            function getFirstMatch(regex2) {
              var match = ua.match(regex2);
              return match && match.length > 1 && match[1] || "";
            }
            function getSecondMatch(regex2) {
              var match = ua.match(regex2);
              return match && match.length > 1 && match[2] || "";
            }
            var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(), likeAndroid = /like android/i.test(ua), android = !likeAndroid && /android/i.test(ua), nexusMobile = /nexus\s*[0-6]\s*/i.test(ua), nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua), chromeos = /CrOS/.test(ua), silk = /silk/i.test(ua), sailfish = /sailfish/i.test(ua), tizen = /tizen/i.test(ua), webos = /(web|hpw)(o|0)s/i.test(ua), windowsphone = /windows phone/i.test(ua), windows = !windowsphone && /windows/i.test(ua), mac = !iosdevice && !silk && /macintosh/i.test(ua), linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua), edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i), versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i), tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua), mobile2 = !tablet && /[^-]mobi/i.test(ua), xbox = /xbox/i.test(ua), result;
            if (/opera/i.test(ua)) {
              result = {
                name: "Opera",
                opera: t2,
                version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
              };
            } else if (/opr\/|opios/i.test(ua)) {
              result = {
                name: "Opera",
                opera: t2,
                version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
              };
            } else if (/SamsungBrowser/i.test(ua)) {
              result = {
                name: "Samsung Internet for Android",
                samsungBrowser: t2,
                version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
              };
            } else if (/Whale/i.test(ua)) {
              result = {
                name: "NAVER Whale browser",
                whale: t2,
                version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
              };
            } else if (/MZBrowser/i.test(ua)) {
              result = {
                name: "MZ Browser",
                mzbrowser: t2,
                version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
              };
            } else if (/coast/i.test(ua)) {
              result = {
                name: "Opera Coast",
                coast: t2,
                version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
              };
            } else if (/focus/i.test(ua)) {
              result = {
                name: "Focus",
                focus: t2,
                version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
              };
            } else if (/yabrowser/i.test(ua)) {
              result = {
                name: "Yandex Browser",
                yandexbrowser: t2,
                version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
              };
            } else if (/ucbrowser/i.test(ua)) {
              result = {
                name: "UC Browser",
                ucbrowser: t2,
                version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
              };
            } else if (/mxios/i.test(ua)) {
              result = {
                name: "Maxthon",
                maxthon: t2,
                version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
              };
            } else if (/epiphany/i.test(ua)) {
              result = {
                name: "Epiphany",
                epiphany: t2,
                version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
              };
            } else if (/puffin/i.test(ua)) {
              result = {
                name: "Puffin",
                puffin: t2,
                version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
              };
            } else if (/sleipnir/i.test(ua)) {
              result = {
                name: "Sleipnir",
                sleipnir: t2,
                version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
              };
            } else if (/k-meleon/i.test(ua)) {
              result = {
                name: "K-Meleon",
                kMeleon: t2,
                version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
              };
            } else if (windowsphone) {
              result = {
                name: "Windows Phone",
                osname: "Windows Phone",
                windowsphone: t2
              };
              if (edgeVersion) {
                result.msedge = t2;
                result.version = edgeVersion;
              } else {
                result.msie = t2;
                result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
              }
            } else if (/msie|trident/i.test(ua)) {
              result = {
                name: "Internet Explorer",
                msie: t2,
                version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
              };
            } else if (chromeos) {
              result = {
                name: "Chrome",
                osname: "Chrome OS",
                chromeos: t2,
                chromeBook: t2,
                chrome: t2,
                version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
              };
            } else if (/edg([ea]|ios)/i.test(ua)) {
              result = {
                name: "Microsoft Edge",
                msedge: t2,
                version: edgeVersion
              };
            } else if (/vivaldi/i.test(ua)) {
              result = {
                name: "Vivaldi",
                vivaldi: t2,
                version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
              };
            } else if (sailfish) {
              result = {
                name: "Sailfish",
                osname: "Sailfish OS",
                sailfish: t2,
                version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
              };
            } else if (/seamonkey\//i.test(ua)) {
              result = {
                name: "SeaMonkey",
                seamonkey: t2,
                version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
              };
            } else if (/firefox|iceweasel|fxios/i.test(ua)) {
              result = {
                name: "Firefox",
                firefox: t2,
                version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
              };
              if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
                result.firefoxos = t2;
                result.osname = "Firefox OS";
              }
            } else if (silk) {
              result = {
                name: "Amazon Silk",
                silk: t2,
                version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
              };
            } else if (/phantom/i.test(ua)) {
              result = {
                name: "PhantomJS",
                phantom: t2,
                version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
              };
            } else if (/slimerjs/i.test(ua)) {
              result = {
                name: "SlimerJS",
                slimer: t2,
                version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
              };
            } else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
              result = {
                name: "BlackBerry",
                osname: "BlackBerry OS",
                blackberry: t2,
                version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
              };
            } else if (webos) {
              result = {
                name: "WebOS",
                osname: "WebOS",
                webos: t2,
                version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
              };
              /touchpad\//i.test(ua) && (result.touchpad = t2);
            } else if (/bada/i.test(ua)) {
              result = {
                name: "Bada",
                osname: "Bada",
                bada: t2,
                version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
              };
            } else if (tizen) {
              result = {
                name: "Tizen",
                osname: "Tizen",
                tizen: t2,
                version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
              };
            } else if (/qupzilla/i.test(ua)) {
              result = {
                name: "QupZilla",
                qupzilla: t2,
                version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
              };
            } else if (/chromium/i.test(ua)) {
              result = {
                name: "Chromium",
                chromium: t2,
                version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
              };
            } else if (/chrome|crios|crmo/i.test(ua)) {
              result = {
                name: "Chrome",
                chrome: t2,
                version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
              };
            } else if (android) {
              result = {
                name: "Android",
                version: versionIdentifier
              };
            } else if (/safari|applewebkit/i.test(ua)) {
              result = {
                name: "Safari",
                safari: t2
              };
              if (versionIdentifier) {
                result.version = versionIdentifier;
              }
            } else if (iosdevice) {
              result = {
                name: iosdevice == "iphone" ? "iPhone" : iosdevice == "ipad" ? "iPad" : "iPod"
              };
              if (versionIdentifier) {
                result.version = versionIdentifier;
              }
            } else if (/googlebot/i.test(ua)) {
              result = {
                name: "Googlebot",
                googlebot: t2,
                version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
              };
            } else {
              result = {
                name: getFirstMatch(/^(.*)\/(.*) /),
                version: getSecondMatch(/^(.*)\/(.*) /)
              };
            }
            if (!result.msedge && /(apple)?webkit/i.test(ua)) {
              if (/(apple)?webkit\/537\.36/i.test(ua)) {
                result.name = result.name || "Blink";
                result.blink = t2;
              } else {
                result.name = result.name || "Webkit";
                result.webkit = t2;
              }
              if (!result.version && versionIdentifier) {
                result.version = versionIdentifier;
              }
            } else if (!result.opera && /gecko\//i.test(ua)) {
              result.name = result.name || "Gecko";
              result.gecko = t2;
              result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
            }
            if (!result.windowsphone && (android || result.silk)) {
              result.android = t2;
              result.osname = "Android";
            } else if (!result.windowsphone && iosdevice) {
              result[iosdevice] = t2;
              result.ios = t2;
              result.osname = "iOS";
            } else if (mac) {
              result.mac = t2;
              result.osname = "macOS";
            } else if (xbox) {
              result.xbox = t2;
              result.osname = "Xbox";
            } else if (windows) {
              result.windows = t2;
              result.osname = "Windows";
            } else if (linux) {
              result.linux = t2;
              result.osname = "Linux";
            }
            function getWindowsVersion(s2) {
              switch (s2) {
                case "NT":
                  return "NT";
                case "XP":
                  return "XP";
                case "NT 5.0":
                  return "2000";
                case "NT 5.1":
                  return "XP";
                case "NT 5.2":
                  return "2003";
                case "NT 6.0":
                  return "Vista";
                case "NT 6.1":
                  return "7";
                case "NT 6.2":
                  return "8";
                case "NT 6.3":
                  return "8.1";
                case "NT 10.0":
                  return "10";
                default:
                  return void 0;
              }
            }
            var osVersion = "";
            if (result.windows) {
              osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i));
            } else if (result.windowsphone) {
              osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
            } else if (result.mac) {
              osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
              osVersion = osVersion.replace(/[_\s]/g, ".");
            } else if (iosdevice) {
              osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
              osVersion = osVersion.replace(/[_\s]/g, ".");
            } else if (android) {
              osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
            } else if (result.webos) {
              osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
            } else if (result.blackberry) {
              osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
            } else if (result.bada) {
              osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
            } else if (result.tizen) {
              osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
            }
            if (osVersion) {
              result.osversion = osVersion;
            }
            var osMajorVersion = !result.windows && osVersion.split(".")[0];
            if (tablet || nexusTablet || iosdevice == "ipad" || android && (osMajorVersion == 3 || osMajorVersion >= 4 && !mobile2) || result.silk) {
              result.tablet = t2;
            } else if (mobile2 || iosdevice == "iphone" || iosdevice == "ipod" || android || nexusMobile || result.blackberry || result.webos || result.bada) {
              result.mobile = t2;
            }
            if (result.msedge || result.msie && result.version >= 10 || result.yandexbrowser && result.version >= 15 || result.vivaldi && result.version >= 1 || result.chrome && result.version >= 20 || result.samsungBrowser && result.version >= 4 || result.whale && compareVersions([result.version, "1.0"]) === 1 || result.mzbrowser && compareVersions([result.version, "6.0"]) === 1 || result.focus && compareVersions([result.version, "1.0"]) === 1 || result.firefox && result.version >= 20 || result.safari && result.version >= 6 || result.opera && result.version >= 10 || result.ios && result.osversion && result.osversion.split(".")[0] >= 6 || result.blackberry && result.version >= 10.1 || result.chromium && result.version >= 20) {
              result.a = t2;
            } else if (result.msie && result.version < 10 || result.chrome && result.version < 20 || result.firefox && result.version < 20 || result.safari && result.version < 6 || result.opera && result.version < 10 || result.ios && result.osversion && result.osversion.split(".")[0] < 6 || result.chromium && result.version < 20) {
              result.c = t2;
            } else
              result.x = t2;
            return result;
          }
          var bowser = detect(typeof navigator !== "undefined" ? navigator.userAgent || "" : "");
          bowser.test = function(browserList) {
            for (var i = 0; i < browserList.length; ++i) {
              var browserItem = browserList[i];
              if (typeof browserItem === "string") {
                if (browserItem in bowser) {
                  return true;
                }
              }
            }
            return false;
          };
          function getVersionPrecision(version2) {
            return version2.split(".").length;
          }
          function map(arr, iterator) {
            var result = [], i;
            if (Array.prototype.map) {
              return Array.prototype.map.call(arr, iterator);
            }
            for (i = 0; i < arr.length; i++) {
              result.push(iterator(arr[i]));
            }
            return result;
          }
          function compareVersions(versions) {
            var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
            var chunks = map(versions, function(version2) {
              var delta = precision - getVersionPrecision(version2);
              version2 = version2 + new Array(delta + 1).join(".0");
              return map(version2.split("."), function(chunk) {
                return new Array(20 - chunk.length).join("0") + chunk;
              }).reverse();
            });
            while (--precision >= 0) {
              if (chunks[0][precision] > chunks[1][precision]) {
                return 1;
              } else if (chunks[0][precision] === chunks[1][precision]) {
                if (precision === 0) {
                  return 0;
                }
              } else {
                return -1;
              }
            }
          }
          function isUnsupportedBrowser(minVersions, strictMode, ua) {
            var _bowser = bowser;
            if (typeof strictMode === "string") {
              ua = strictMode;
              strictMode = void 0;
            }
            if (strictMode === void 0) {
              strictMode = false;
            }
            if (ua) {
              _bowser = detect(ua);
            }
            var version2 = "" + _bowser.version;
            for (var browser2 in minVersions) {
              if (minVersions.hasOwnProperty(browser2)) {
                if (_bowser[browser2]) {
                  if (typeof minVersions[browser2] !== "string") {
                    throw new Error("Browser version in the minVersion map should be a string: " + browser2 + ": " + String(minVersions));
                  }
                  return compareVersions([version2, minVersions[browser2]]) < 0;
                }
              }
            }
            return strictMode;
          }
          function check(minVersions, strictMode, ua) {
            return !isUnsupportedBrowser(minVersions, strictMode, ua);
          }
          bowser.isUnsupportedBrowser = isUnsupportedBrowser;
          bowser.compareVersions = compareVersions;
          bowser.check = check;
          bowser._detect = detect;
          bowser.detect = detect;
          return bowser;
        });
      }, {}], 102: [function(require2, module3, exports3) {
      }, {}], 103: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            var base642 = require2("base64-js");
            var ieee754 = require2("ieee754");
            exports3.Buffer = Buffer3;
            exports3.SlowBuffer = SlowBuffer;
            exports3.INSPECT_MAX_BYTES = 50;
            var K_MAX_LENGTH = 2147483647;
            exports3.kMaxLength = K_MAX_LENGTH;
            Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
              index$2.__f__(
                "error",
                "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:9760",
                "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
              );
            }
            function typedArraySupport() {
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } };
                return arr.foo() === 42;
              } catch (e2) {
                return false;
              }
            }
            Object.defineProperty(Buffer3.prototype, "parent", {
              enumerable: true,
              get: function() {
                if (!Buffer3.isBuffer(this))
                  return void 0;
                return this.buffer;
              }
            });
            Object.defineProperty(Buffer3.prototype, "offset", {
              enumerable: true,
              get: function() {
                if (!Buffer3.isBuffer(this))
                  return void 0;
                return this.byteOffset;
              }
            });
            function createBuffer(length) {
              if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
              }
              var buf = new Uint8Array(length);
              buf.__proto__ = Buffer3.prototype;
              return buf;
            }
            function Buffer3(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                }
                return allocUnsafe(arg);
              }
              return from(arg, encodingOrOffset, length);
            }
            if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer3[Symbol.species] === Buffer3) {
              Object.defineProperty(Buffer3, Symbol.species, {
                value: null,
                configurable: true,
                enumerable: false,
                writable: false
              });
            }
            Buffer3.poolSize = 8192;
            function from(value, encodingOrOffset, length) {
              if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
              }
              if (ArrayBuffer.isView(value)) {
                return fromArrayLike(value);
              }
              if (value == null) {
                throw TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
                );
              }
              if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }
              if (typeof value === "number") {
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              }
              var valueOf = value.valueOf && value.valueOf();
              if (valueOf != null && valueOf !== value) {
                return Buffer3.from(valueOf, encodingOrOffset, length);
              }
              var b = fromObject(value);
              if (b)
                return b;
              if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                return Buffer3.from(
                  value[Symbol.toPrimitive]("string"),
                  encodingOrOffset,
                  length
                );
              }
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
              );
            }
            Buffer3.from = function(value, encodingOrOffset, length) {
              return from(value, encodingOrOffset, length);
            };
            Buffer3.prototype.__proto__ = Uint8Array.prototype;
            Buffer3.__proto__ = Uint8Array;
            function assertSize(size2) {
              if (typeof size2 !== "number") {
                throw new TypeError('"size" argument must be of type number');
              } else if (size2 < 0) {
                throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
              }
            }
            function alloc(size2, fill, encoding) {
              assertSize(size2);
              if (size2 <= 0) {
                return createBuffer(size2);
              }
              if (fill !== void 0) {
                return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
              }
              return createBuffer(size2);
            }
            Buffer3.alloc = function(size2, fill, encoding) {
              return alloc(size2, fill, encoding);
            };
            function allocUnsafe(size2) {
              assertSize(size2);
              return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
            }
            Buffer3.allocUnsafe = function(size2) {
              return allocUnsafe(size2);
            };
            Buffer3.allocUnsafeSlow = function(size2) {
              return allocUnsafe(size2);
            };
            function fromString(string2, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }
              if (!Buffer3.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              var length = byteLength(string2, encoding) | 0;
              var buf = createBuffer(length);
              var actual = buf.write(string2, encoding);
              if (actual !== length) {
                buf = buf.slice(0, actual);
              }
              return buf;
            }
            function fromArrayLike(array2) {
              var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
              var buf = createBuffer(length);
              for (var i = 0; i < length; i += 1) {
                buf[i] = array2[i] & 255;
              }
              return buf;
            }
            function fromArrayBuffer(array2, byteOffset, length) {
              if (byteOffset < 0 || array2.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
              }
              if (array2.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
              }
              var buf;
              if (byteOffset === void 0 && length === void 0) {
                buf = new Uint8Array(array2);
              } else if (length === void 0) {
                buf = new Uint8Array(array2, byteOffset);
              } else {
                buf = new Uint8Array(array2, byteOffset, length);
              }
              buf.__proto__ = Buffer3.prototype;
              return buf;
            }
            function fromObject(obj) {
              if (Buffer3.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                var buf = createBuffer(len);
                if (buf.length === 0) {
                  return buf;
                }
                obj.copy(buf, 0, 0, len);
                return buf;
              }
              if (obj.length !== void 0) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                  return createBuffer(0);
                }
                return fromArrayLike(obj);
              }
              if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
              }
            }
            function checked(length) {
              if (length >= K_MAX_LENGTH) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
              }
              return length | 0;
            }
            function SlowBuffer(length) {
              if (+length != length) {
                length = 0;
              }
              return Buffer3.alloc(+length);
            }
            Buffer3.isBuffer = function isBuffer(b) {
              return b != null && b._isBuffer === true && b !== Buffer3.prototype;
            };
            Buffer3.compare = function compare(a2, b) {
              if (isInstance(a2, Uint8Array))
                a2 = Buffer3.from(a2, a2.offset, a2.byteLength);
              if (isInstance(b, Uint8Array))
                b = Buffer3.from(b, b.offset, b.byteLength);
              if (!Buffer3.isBuffer(a2) || !Buffer3.isBuffer(b)) {
                throw new TypeError(
                  'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                );
              }
              if (a2 === b)
                return 0;
              var x = a2.length;
              var y = b.length;
              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a2[i] !== b[i]) {
                  x = a2[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            Buffer3.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };
            Buffer3.concat = function concat(list2, length) {
              if (!Array.isArray(list2)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              if (list2.length === 0) {
                return Buffer3.alloc(0);
              }
              var i;
              if (length === void 0) {
                length = 0;
                for (i = 0; i < list2.length; ++i) {
                  length += list2[i].length;
                }
              }
              var buffer2 = Buffer3.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list2.length; ++i) {
                var buf = list2[i];
                if (isInstance(buf, Uint8Array)) {
                  buf = Buffer3.from(buf);
                }
                if (!Buffer3.isBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                buf.copy(buffer2, pos);
                pos += buf.length;
              }
              return buffer2;
            };
            function byteLength(string2, encoding) {
              if (Buffer3.isBuffer(string2)) {
                return string2.length;
              }
              if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
                return string2.byteLength;
              }
              if (typeof string2 !== "string") {
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
                );
              }
              var len = string2.length;
              var mustMatch = arguments.length > 2 && arguments[2] === true;
              if (!mustMatch && len === 0)
                return 0;
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string2).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string2).length;
                  default:
                    if (loweredCase) {
                      return mustMatch ? -1 : utf8ToBytes(string2).length;
                    }
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer3.byteLength = byteLength;
            function slowToString(encoding, start, end) {
              var loweredCase = false;
              if (start === void 0 || start < 0) {
                start = 0;
              }
              if (start > this.length) {
                return "";
              }
              if (end === void 0 || end > this.length) {
                end = this.length;
              }
              if (end <= 0) {
                return "";
              }
              end >>>= 0;
              start >>>= 0;
              if (end <= start) {
                return "";
              }
              if (!encoding)
                encoding = "utf8";
              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);
                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);
                  case "ascii":
                    return asciiSlice(this, start, end);
                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);
                  case "base64":
                    return base64Slice(this, start, end);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer3.prototype._isBuffer = true;
            function swap(b, n2, m) {
              var i = b[n2];
              b[n2] = b[m];
              b[m] = i;
            }
            Buffer3.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this;
            };
            Buffer3.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this;
            };
            Buffer3.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this;
            };
            Buffer3.prototype.toString = function toString2() {
              var length = this.length;
              if (length === 0)
                return "";
              if (arguments.length === 0)
                return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };
            Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
            Buffer3.prototype.equals = function equals(b) {
              if (!Buffer3.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              if (this === b)
                return true;
              return Buffer3.compare(this, b) === 0;
            };
            Buffer3.prototype.inspect = function inspect() {
              var str = "";
              var max = exports3.INSPECT_MAX_BYTES;
              str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
              if (this.length > max)
                str += " ... ";
              return "<Buffer " + str + ">";
            };
            Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
              if (isInstance(target, Uint8Array)) {
                target = Buffer3.from(target, target.offset, target.byteLength);
              }
              if (!Buffer3.isBuffer(target)) {
                throw new TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
                );
              }
              if (start === void 0) {
                start = 0;
              }
              if (end === void 0) {
                end = target ? target.length : 0;
              }
              if (thisStart === void 0) {
                thisStart = 0;
              }
              if (thisEnd === void 0) {
                thisEnd = this.length;
              }
              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
              }
              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }
              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target)
                return 0;
              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);
              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);
              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
              if (buffer2.length === 0)
                return -1;
              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
              } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
              }
              byteOffset = +byteOffset;
              if (numberIsNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer2.length - 1;
              }
              if (byteOffset < 0)
                byteOffset = buffer2.length + byteOffset;
              if (byteOffset >= buffer2.length) {
                if (dir)
                  return -1;
                else
                  byteOffset = buffer2.length - 1;
              } else if (byteOffset < 0) {
                if (dir)
                  byteOffset = 0;
                else
                  return -1;
              }
              if (typeof val === "string") {
                val = Buffer3.from(val, encoding);
              }
              if (Buffer3.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 255;
                if (typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
                  }
                }
                return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
              }
              throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;
              if (encoding !== void 0) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }
              function read(buf, i2) {
                if (indexSize === 1) {
                  return buf[i2];
                } else {
                  return buf.readUInt16BE(i2 * indexSize);
                }
              }
              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1)
                      foundIndex = i;
                    if (i - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1)
                      i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }
                  if (found)
                    return i;
                }
              }
              return -1;
            }
            Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };
            Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };
            function hexWrite(buf, string2, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }
              var strLen = string2.length;
              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string2.substr(i * 2, 2), 16);
                if (numberIsNaN(parsed))
                  return i;
                buf[offset + i] = parsed;
              }
              return i;
            }
            function utf8Write(buf, string2, offset, length) {
              return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
            }
            function asciiWrite(buf, string2, offset, length) {
              return blitBuffer(asciiToBytes(string2), buf, offset, length);
            }
            function latin1Write(buf, string2, offset, length) {
              return asciiWrite(buf, string2, offset, length);
            }
            function base64Write(buf, string2, offset, length) {
              return blitBuffer(base64ToBytes(string2), buf, offset, length);
            }
            function ucs2Write(buf, string2, offset, length) {
              return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
            }
            Buffer3.prototype.write = function write3(string2, offset, length, encoding) {
              if (offset === void 0) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
              } else if (length === void 0 && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
              } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                  length = length >>> 0;
                  if (encoding === void 0)
                    encoding = "utf8";
                } else {
                  encoding = length;
                  length = void 0;
                }
              } else {
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              }
              var remaining = this.length - offset;
              if (length === void 0 || length > remaining)
                length = remaining;
              if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }
              if (!encoding)
                encoding = "utf8";
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string2, offset, length);
                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string2, offset, length);
                  case "ascii":
                    return asciiWrite(this, string2, offset, length);
                  case "latin1":
                  case "binary":
                    return latin1Write(this, string2, offset, length);
                  case "base64":
                    return base64Write(this, string2, offset, length);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string2, offset, length);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };
            Buffer3.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            };
            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base642.fromByteArray(buf);
              } else {
                return base642.fromByteArray(buf.slice(start, end));
              }
            }
            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];
              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;
                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 128) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }
                if (codePoint === null) {
                  codePoint = 65533;
                  bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                  codePoint -= 65536;
                  res.push(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i += bytesPerSequence;
              }
              return decodeCodePointsArray(res);
            }
            var MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }
              var res = "";
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res;
            }
            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 127);
              }
              return ret;
            }
            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret;
            }
            function hexSlice(buf, start, end) {
              var len = buf.length;
              if (!start || start < 0)
                start = 0;
              if (!end || end < 0 || end > len)
                end = len;
              var out = "";
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out;
            }
            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res;
            }
            Buffer3.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === void 0 ? len : ~~end;
              if (start < 0) {
                start += len;
                if (start < 0)
                  start = 0;
              } else if (start > len) {
                start = len;
              }
              if (end < 0) {
                end += len;
                if (end < 0)
                  end = 0;
              } else if (end > len) {
                end = len;
              }
              if (end < start)
                end = start;
              var newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer3.prototype;
              return newBuf;
            };
            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0)
                throw new RangeError("offset is not uint");
              if (offset + ext > length)
                throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var val = this[offset];
              var mul2 = 1;
              var i = 0;
              while (++i < byteLength2 && (mul2 *= 256)) {
                val += this[offset + i] * mul2;
              }
              return val;
            };
            Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                checkOffset(offset, byteLength2, this.length);
              }
              var val = this[offset + --byteLength2];
              var mul2 = 1;
              while (byteLength2 > 0 && (mul2 *= 256)) {
                val += this[offset + --byteLength2] * mul2;
              }
              return val;
            };
            Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              return this[offset];
            };
            Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] | this[offset + 1] << 8;
            };
            Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] << 8 | this[offset + 1];
            };
            Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
            };
            Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
            };
            Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var val = this[offset];
              var mul2 = 1;
              var i = 0;
              while (++i < byteLength2 && (mul2 *= 256)) {
                val += this[offset + i] * mul2;
              }
              mul2 *= 128;
              if (val >= mul2)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var i = byteLength2;
              var mul2 = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul2 *= 256)) {
                val += this[offset + --i] * mul2;
              }
              mul2 *= 128;
              if (val >= mul2)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              if (!(this[offset] & 128))
                return this[offset];
              return (255 - this[offset] + 1) * -1;
            };
            Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              var val = this[offset] | this[offset + 1] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | this[offset] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
            };
            Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
            };
            Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };
            Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };
            Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };
            Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };
            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer3.isBuffer(buf))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (value > max || value < min)
                throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
            }
            Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              var mul2 = 1;
              var i = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul2 *= 256)) {
                this[offset + i] = value / mul2 & 255;
              }
              return offset + byteLength2;
            };
            Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              var i = byteLength2 - 1;
              var mul2 = 1;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul2 *= 256)) {
                this[offset + i] = value / mul2 & 255;
              }
              return offset + byteLength2;
            };
            Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 255, 0);
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
              return offset + 4;
            };
            Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              var i = 0;
              var mul2 = 1;
              var sub = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul2 *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul2 >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              var i = byteLength2 - 1;
              var mul2 = 1;
              var sub = 0;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul2 *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul2 >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 127, -128);
              if (value < 0)
                value = 255 + value + 1;
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
              return offset + 4;
            };
            Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              if (value < 0)
                value = 4294967295 + value + 1;
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset < 0)
                throw new RangeError("Index out of range");
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4);
              }
              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }
            Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert);
            };
            Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert);
            };
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8);
              }
              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }
            Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert);
            };
            Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert);
            };
            Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
              if (!Buffer3.isBuffer(target))
                throw new TypeError("argument should be a Buffer");
              if (!start)
                start = 0;
              if (!end && end !== 0)
                end = this.length;
              if (targetStart >= target.length)
                targetStart = target.length;
              if (!targetStart)
                targetStart = 0;
              if (end > 0 && end < start)
                end = start;
              if (end === start)
                return 0;
              if (target.length === 0 || this.length === 0)
                return 0;
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length)
                throw new RangeError("Index out of range");
              if (end < 0)
                throw new RangeError("sourceEnd out of bounds");
              if (end > this.length)
                end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }
              var len = end - start;
              if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                this.copyWithin(targetStart, start, end);
              } else if (this === target && start < targetStart && targetStart < end) {
                for (var i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, end),
                  targetStart
                );
              }
              return len;
            };
            Buffer3.prototype.fill = function fill(val, start, end, encoding) {
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }
                if (encoding !== void 0 && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                  var code2 = val.charCodeAt(0);
                  if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
                    val = code2;
                  }
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }
              if (end <= start) {
                return this;
              }
              start = start >>> 0;
              end = end === void 0 ? this.length : end >>> 0;
              if (!val)
                val = 0;
              var i;
              if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
                var len = bytes.length;
                if (len === 0) {
                  throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }
              return this;
            };
            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
              str = str.split("=")[0];
              str = str.trim().replace(INVALID_BASE64_RE, "");
              if (str.length < 2)
                return "";
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }
            function toHex(n2) {
              if (n2 < 16)
                return "0" + n2.toString(16);
              return n2.toString(16);
            }
            function utf8ToBytes(string2, units) {
              units = units || Infinity;
              var codePoint;
              var length = string2.length;
              var leadSurrogate = null;
              var bytes = [];
              for (var i = 0; i < length; ++i) {
                codePoint = string2.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                  if (!leadSurrogate) {
                    if (codePoint > 56319) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    } else if (i + 1 === length) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    }
                    leadSurrogate = codePoint;
                    continue;
                  }
                  if (codePoint < 56320) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    leadSurrogate = codePoint;
                    continue;
                  }
                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                  if ((units -= 1) < 0)
                    break;
                  bytes.push(codePoint);
                } else if (codePoint < 2048) {
                  if ((units -= 2) < 0)
                    break;
                  bytes.push(
                    codePoint >> 6 | 192,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 65536) {
                  if ((units -= 3) < 0)
                    break;
                  bytes.push(
                    codePoint >> 12 | 224,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 1114112) {
                  if ((units -= 4) < 0)
                    break;
                  bytes.push(
                    codePoint >> 18 | 240,
                    codePoint >> 12 & 63 | 128,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else {
                  throw new Error("Invalid code point");
                }
              }
              return bytes;
            }
            function asciiToBytes(str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 255);
              }
              return byteArray;
            }
            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0)
                  break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }
              return byteArray;
            }
            function base64ToBytes(str) {
              return base642.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length)
                  break;
                dst[i + offset] = src[i];
              }
              return i;
            }
            function isInstance(obj, type) {
              return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
            }
            function numberIsNaN(obj) {
              return obj !== obj;
            }
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "base64-js": 100, "buffer": 103, "ieee754": 400 }], 104: [function(require2, module3, exports3) {
        module3.exports = {
          "100": "Continue",
          "101": "Switching Protocols",
          "102": "Processing",
          "200": "OK",
          "201": "Created",
          "202": "Accepted",
          "203": "Non-Authoritative Information",
          "204": "No Content",
          "205": "Reset Content",
          "206": "Partial Content",
          "207": "Multi-Status",
          "208": "Already Reported",
          "226": "IM Used",
          "300": "Multiple Choices",
          "301": "Moved Permanently",
          "302": "Found",
          "303": "See Other",
          "304": "Not Modified",
          "305": "Use Proxy",
          "307": "Temporary Redirect",
          "308": "Permanent Redirect",
          "400": "Bad Request",
          "401": "Unauthorized",
          "402": "Payment Required",
          "403": "Forbidden",
          "404": "Not Found",
          "405": "Method Not Allowed",
          "406": "Not Acceptable",
          "407": "Proxy Authentication Required",
          "408": "Request Timeout",
          "409": "Conflict",
          "410": "Gone",
          "411": "Length Required",
          "412": "Precondition Failed",
          "413": "Payload Too Large",
          "414": "URI Too Long",
          "415": "Unsupported Media Type",
          "416": "Range Not Satisfiable",
          "417": "Expectation Failed",
          "418": "I'm a teapot",
          "421": "Misdirected Request",
          "422": "Unprocessable Entity",
          "423": "Locked",
          "424": "Failed Dependency",
          "425": "Unordered Collection",
          "426": "Upgrade Required",
          "428": "Precondition Required",
          "429": "Too Many Requests",
          "431": "Request Header Fields Too Large",
          "451": "Unavailable For Legal Reasons",
          "500": "Internal Server Error",
          "501": "Not Implemented",
          "502": "Bad Gateway",
          "503": "Service Unavailable",
          "504": "Gateway Timeout",
          "505": "HTTP Version Not Supported",
          "506": "Variant Also Negotiates",
          "507": "Insufficient Storage",
          "508": "Loop Detected",
          "509": "Bandwidth Limit Exceeded",
          "510": "Not Extended",
          "511": "Network Authentication Required"
        };
      }, {}], 105: [function(require2, module3, exports3) {
        var GetIntrinsic = require2("get-intrinsic");
        var callBind = require2("./");
        var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
        module3.exports = function callBoundIntrinsic(name, allowMissing) {
          var intrinsic = GetIntrinsic(name, !!allowMissing);
          if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
            return callBind(intrinsic);
          }
          return intrinsic;
        };
      }, { "./": 106, "get-intrinsic": 390 }], 106: [function(require2, module3, exports3) {
        var bind = require2("function-bind");
        var GetIntrinsic = require2("get-intrinsic");
        var setFunctionLength = require2("set-function-length");
        var $TypeError = GetIntrinsic("%TypeError%");
        var $apply = GetIntrinsic("%Function.prototype.apply%");
        var $call = GetIntrinsic("%Function.prototype.call%");
        var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
        var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
        var $max = GetIntrinsic("%Math.max%");
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
          } catch (e2) {
            $defineProperty = null;
          }
        }
        module3.exports = function callBind(originalFunction) {
          if (typeof originalFunction !== "function") {
            throw new $TypeError("a function is required");
          }
          var func2 = $reflectApply(bind, $call, arguments);
          return setFunctionLength(
            func2,
            1 + $max(0, originalFunction.length - (arguments.length - 1)),
            true
          );
        };
        var applyBind = function applyBind2() {
          return $reflectApply(bind, $apply, arguments);
        };
        if ($defineProperty) {
          $defineProperty(module3.exports, "apply", { value: applyBind });
        } else {
          module3.exports.apply = applyBind;
        }
      }, { "function-bind": 389, "get-intrinsic": 390, "set-function-length": 466 }], 107: [function(require2, module3, exports3) {
        var slice = Array.prototype.slice;
        module3.exports = Copy;
        function Copy(src, withAccess) {
          if (!(this instanceof Copy))
            return new Copy(src, withAccess);
          this.src = src;
          this._withAccess = withAccess;
        }
        Copy.prototype.withAccess = function(w) {
          this._withAccess = w !== false;
          return this;
        };
        Copy.prototype.pick = function(keys) {
          if (!Array.isArray(keys)) {
            keys = slice.call(arguments);
          }
          if (keys.length) {
            this.keys = keys;
          }
          return this;
        };
        Copy.prototype.to = function(to) {
          to = to || {};
          if (!this.src)
            return to;
          var keys = this.keys || Object.keys(this.src);
          if (!this._withAccess) {
            for (var i = 0; i < keys.length; i++) {
              key = keys[i];
              if (to[key] !== void 0)
                continue;
              to[key] = this.src[key];
            }
            return to;
          }
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!notDefined(to, key))
              continue;
            var getter = this.src.__lookupGetter__(key);
            var setter = this.src.__lookupSetter__(key);
            if (getter)
              to.__defineGetter__(key, getter);
            if (setter)
              to.__defineSetter__(key, setter);
            if (!getter && !setter) {
              to[key] = this.src[key];
            }
          }
          return to;
        };
        Copy.prototype.toCover = function(to) {
          var keys = this.keys || Object.keys(this.src);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            delete to[key];
            var getter = this.src.__lookupGetter__(key);
            var setter = this.src.__lookupSetter__(key);
            if (getter)
              to.__defineGetter__(key, getter);
            if (setter)
              to.__defineSetter__(key, setter);
            if (!getter && !setter) {
              to[key] = this.src[key];
            }
          }
        };
        Copy.prototype.override = Copy.prototype.toCover;
        Copy.prototype.and = function(obj) {
          var src = {};
          this.to(src);
          this.src = obj;
          this.to(src);
          this.src = src;
          return this;
        };
        function notDefined(obj, key) {
          return obj[key] === void 0 && obj.__lookupGetter__(key) === void 0 && obj.__lookupSetter__(key) === void 0;
        }
      }, {}], 108: [function(require2, module3, exports3) {
        var isCallable = require2("../internals/is-callable");
        var tryToString = require2("../internals/try-to-string");
        var $TypeError = TypeError;
        module3.exports = function(argument) {
          if (isCallable(argument))
            return argument;
          throw new $TypeError(tryToString(argument) + " is not a function");
        };
      }, { "../internals/is-callable": 203, "../internals/try-to-string": 293 }], 109: [function(require2, module3, exports3) {
        var isConstructor = require2("../internals/is-constructor");
        var tryToString = require2("../internals/try-to-string");
        var $TypeError = TypeError;
        module3.exports = function(argument) {
          if (isConstructor(argument))
            return argument;
          throw new $TypeError(tryToString(argument) + " is not a constructor");
        };
      }, { "../internals/is-constructor": 204, "../internals/try-to-string": 293 }], 110: [function(require2, module3, exports3) {
        var isPossiblePrototype = require2("../internals/is-possible-prototype");
        var $String = String;
        var $TypeError = TypeError;
        module3.exports = function(argument) {
          if (isPossiblePrototype(argument))
            return argument;
          throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
        };
      }, { "../internals/is-possible-prototype": 209 }], 111: [function(require2, module3, exports3) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var create3 = require2("../internals/object-create");
        var defineProperty = require2("../internals/object-define-property").f;
        var UNSCOPABLES = wellKnownSymbol("unscopables");
        var ArrayPrototype = Array.prototype;
        if (ArrayPrototype[UNSCOPABLES] === void 0) {
          defineProperty(ArrayPrototype, UNSCOPABLES, {
            configurable: true,
            value: create3(null)
          });
        }
        module3.exports = function(key) {
          ArrayPrototype[UNSCOPABLES][key] = true;
        };
      }, { "../internals/object-create": 229, "../internals/object-define-property": 231, "../internals/well-known-symbol": 306 }], 112: [function(require2, module3, exports3) {
        var charAt = require2("../internals/string-multibyte").charAt;
        module3.exports = function(S, index2, unicode) {
          return index2 + (unicode ? charAt(S, index2).length : 1);
        };
      }, { "../internals/string-multibyte": 271 }], 113: [function(require2, module3, exports3) {
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var $TypeError = TypeError;
        module3.exports = function(it, Prototype) {
          if (isPrototypeOf(Prototype, it))
            return it;
          throw new $TypeError("Incorrect invocation");
        };
      }, { "../internals/object-is-prototype-of": 238 }], 114: [function(require2, module3, exports3) {
        var isObject2 = require2("../internals/is-object");
        var $String = String;
        var $TypeError = TypeError;
        module3.exports = function(argument) {
          if (isObject2(argument))
            return argument;
          throw new $TypeError($String(argument) + " is not an object");
        };
      }, { "../internals/is-object": 208 }], 115: [function(require2, module3, exports3) {
        module3.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
      }, {}], 116: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        module3.exports = fails(function() {
          if (typeof ArrayBuffer == "function") {
            var buffer2 = new ArrayBuffer(8);
            if (Object.isExtensible(buffer2))
              Object.defineProperty(buffer2, "a", { value: 8 });
          }
        });
      }, { "../internals/fails": 171 }], 117: [function(require2, module3, exports3) {
        var NATIVE_ARRAY_BUFFER = require2("../internals/array-buffer-basic-detection");
        var DESCRIPTORS = require2("../internals/descriptors");
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var hasOwn2 = require2("../internals/has-own-property");
        var classof = require2("../internals/classof");
        var tryToString = require2("../internals/try-to-string");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var defineBuiltIn = require2("../internals/define-built-in");
        var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var getPrototypeOf = require2("../internals/object-get-prototype-of");
        var setPrototypeOf = require2("../internals/object-set-prototype-of");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var uid2 = require2("../internals/uid");
        var InternalStateModule = require2("../internals/internal-state");
        var enforceInternalState = InternalStateModule.enforce;
        var getInternalState = InternalStateModule.get;
        var Int8Array2 = global3.Int8Array;
        var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
        var Uint8ClampedArray2 = global3.Uint8ClampedArray;
        var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
        var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
        var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
        var ObjectPrototype = Object.prototype;
        var TypeError2 = global3.TypeError;
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var TYPED_ARRAY_TAG = uid2("TYPED_ARRAY_TAG");
        var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
        var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global3.opera) !== "Opera";
        var TYPED_ARRAY_TAG_REQUIRED = false;
        var NAME, Constructor, Prototype;
        var TypedArrayConstructorsList = {
          Int8Array: 1,
          Uint8Array: 1,
          Uint8ClampedArray: 1,
          Int16Array: 2,
          Uint16Array: 2,
          Int32Array: 4,
          Uint32Array: 4,
          Float32Array: 4,
          Float64Array: 8
        };
        var BigIntArrayConstructorsList = {
          BigInt64Array: 8,
          BigUint64Array: 8
        };
        var isView = function isView2(it) {
          if (!isObject2(it))
            return false;
          var klass = classof(it);
          return klass === "DataView" || hasOwn2(TypedArrayConstructorsList, klass) || hasOwn2(BigIntArrayConstructorsList, klass);
        };
        var getTypedArrayConstructor = function(it) {
          var proto = getPrototypeOf(it);
          if (!isObject2(proto))
            return;
          var state = getInternalState(proto);
          return state && hasOwn2(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
        };
        var isTypedArray = function(it) {
          if (!isObject2(it))
            return false;
          var klass = classof(it);
          return hasOwn2(TypedArrayConstructorsList, klass) || hasOwn2(BigIntArrayConstructorsList, klass);
        };
        var aTypedArray = function(it) {
          if (isTypedArray(it))
            return it;
          throw new TypeError2("Target is not a typed array");
        };
        var aTypedArrayConstructor = function(C) {
          if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))
            return C;
          throw new TypeError2(tryToString(C) + " is not a typed array constructor");
        };
        var exportTypedArrayMethod = function(KEY, property, forced, options) {
          if (!DESCRIPTORS)
            return;
          if (forced)
            for (var ARRAY in TypedArrayConstructorsList) {
              var TypedArrayConstructor = global3[ARRAY];
              if (TypedArrayConstructor && hasOwn2(TypedArrayConstructor.prototype, KEY))
                try {
                  delete TypedArrayConstructor.prototype[KEY];
                } catch (error2) {
                  try {
                    TypedArrayConstructor.prototype[KEY] = property;
                  } catch (error22) {
                  }
                }
            }
          if (!TypedArrayPrototype[KEY] || forced) {
            defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
          }
        };
        var exportTypedArrayStaticMethod = function(KEY, property, forced) {
          var ARRAY, TypedArrayConstructor;
          if (!DESCRIPTORS)
            return;
          if (setPrototypeOf) {
            if (forced)
              for (ARRAY in TypedArrayConstructorsList) {
                TypedArrayConstructor = global3[ARRAY];
                if (TypedArrayConstructor && hasOwn2(TypedArrayConstructor, KEY))
                  try {
                    delete TypedArrayConstructor[KEY];
                  } catch (error2) {
                  }
              }
            if (!TypedArray[KEY] || forced) {
              try {
                return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
              } catch (error2) {
              }
            } else
              return;
          }
          for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = global3[ARRAY];
            if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
              defineBuiltIn(TypedArrayConstructor, KEY, property);
            }
          }
        };
        for (NAME in TypedArrayConstructorsList) {
          Constructor = global3[NAME];
          Prototype = Constructor && Constructor.prototype;
          if (Prototype)
            enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
          else
            NATIVE_ARRAY_BUFFER_VIEWS = false;
        }
        for (NAME in BigIntArrayConstructorsList) {
          Constructor = global3[NAME];
          Prototype = Constructor && Constructor.prototype;
          if (Prototype)
            enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
        }
        if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
          TypedArray = function TypedArray2() {
            throw new TypeError2("Incorrect invocation");
          };
          if (NATIVE_ARRAY_BUFFER_VIEWS)
            for (NAME in TypedArrayConstructorsList) {
              if (global3[NAME])
                setPrototypeOf(global3[NAME], TypedArray);
            }
        }
        if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
          TypedArrayPrototype = TypedArray.prototype;
          if (NATIVE_ARRAY_BUFFER_VIEWS)
            for (NAME in TypedArrayConstructorsList) {
              if (global3[NAME])
                setPrototypeOf(global3[NAME].prototype, TypedArrayPrototype);
            }
        }
        if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
          setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
        }
        if (DESCRIPTORS && !hasOwn2(TypedArrayPrototype, TO_STRING_TAG)) {
          TYPED_ARRAY_TAG_REQUIRED = true;
          defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
            configurable: true,
            get: function() {
              return isObject2(this) ? this[TYPED_ARRAY_TAG] : void 0;
            }
          });
          for (NAME in TypedArrayConstructorsList)
            if (global3[NAME]) {
              createNonEnumerableProperty(global3[NAME], TYPED_ARRAY_TAG, NAME);
            }
        }
        module3.exports = {
          NATIVE_ARRAY_BUFFER_VIEWS,
          TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
          aTypedArray,
          aTypedArrayConstructor,
          exportTypedArrayMethod,
          exportTypedArrayStaticMethod,
          getTypedArrayConstructor,
          isView,
          isTypedArray,
          TypedArray,
          TypedArrayPrototype
        };
      }, { "../internals/array-buffer-basic-detection": 115, "../internals/classof": 138, "../internals/create-non-enumerable-property": 145, "../internals/define-built-in": 149, "../internals/define-built-in-accessor": 148, "../internals/descriptors": 153, "../internals/global": 188, "../internals/has-own-property": 189, "../internals/internal-state": 199, "../internals/is-callable": 203, "../internals/is-object": 208, "../internals/object-get-prototype-of": 236, "../internals/object-is-prototype-of": 238, "../internals/object-set-prototype-of": 242, "../internals/try-to-string": 293, "../internals/uid": 299, "../internals/well-known-symbol": 306 }], 118: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var DESCRIPTORS = require2("../internals/descriptors");
        var NATIVE_ARRAY_BUFFER = require2("../internals/array-buffer-basic-detection");
        var FunctionName = require2("../internals/function-name");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
        var defineBuiltIns = require2("../internals/define-built-ins");
        var fails = require2("../internals/fails");
        var anInstance = require2("../internals/an-instance");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var toLength = require2("../internals/to-length");
        var toIndex = require2("../internals/to-index");
        var fround = require2("../internals/math-fround");
        var IEEE754 = require2("../internals/ieee754");
        var getPrototypeOf = require2("../internals/object-get-prototype-of");
        var setPrototypeOf = require2("../internals/object-set-prototype-of");
        var arrayFill = require2("../internals/array-fill");
        var arraySlice = require2("../internals/array-slice");
        var inheritIfRequired = require2("../internals/inherit-if-required");
        var copyConstructorProperties = require2("../internals/copy-constructor-properties");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var InternalStateModule = require2("../internals/internal-state");
        var PROPER_FUNCTION_NAME = FunctionName.PROPER;
        var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
        var ARRAY_BUFFER = "ArrayBuffer";
        var DATA_VIEW = "DataView";
        var PROTOTYPE = "prototype";
        var WRONG_LENGTH = "Wrong length";
        var WRONG_INDEX = "Wrong index";
        var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
        var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
        var setInternalState = InternalStateModule.set;
        var NativeArrayBuffer = global3[ARRAY_BUFFER];
        var $ArrayBuffer = NativeArrayBuffer;
        var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
        var $DataView = global3[DATA_VIEW];
        var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
        var ObjectPrototype = Object.prototype;
        var Array2 = global3.Array;
        var RangeError2 = global3.RangeError;
        var fill = uncurryThis(arrayFill);
        var reverse = uncurryThis([].reverse);
        var packIEEE754 = IEEE754.pack;
        var unpackIEEE754 = IEEE754.unpack;
        var packInt8 = function(number2) {
          return [number2 & 255];
        };
        var packInt16 = function(number2) {
          return [number2 & 255, number2 >> 8 & 255];
        };
        var packInt32 = function(number2) {
          return [number2 & 255, number2 >> 8 & 255, number2 >> 16 & 255, number2 >> 24 & 255];
        };
        var unpackInt32 = function(buffer2) {
          return buffer2[3] << 24 | buffer2[2] << 16 | buffer2[1] << 8 | buffer2[0];
        };
        var packFloat32 = function(number2) {
          return packIEEE754(fround(number2), 23, 4);
        };
        var packFloat64 = function(number2) {
          return packIEEE754(number2, 52, 8);
        };
        var addGetter = function(Constructor, key, getInternalState) {
          defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
            configurable: true,
            get: function() {
              return getInternalState(this)[key];
            }
          });
        };
        var get3 = function(view, count, index2, isLittleEndian) {
          var store = getInternalDataViewState(view);
          var intIndex = toIndex(index2);
          var boolIsLittleEndian = !!isLittleEndian;
          if (intIndex + count > store.byteLength)
            throw new RangeError2(WRONG_INDEX);
          var bytes = store.bytes;
          var start = intIndex + store.byteOffset;
          var pack2 = arraySlice(bytes, start, start + count);
          return boolIsLittleEndian ? pack2 : reverse(pack2);
        };
        var set2 = function(view, count, index2, conversion, value, isLittleEndian) {
          var store = getInternalDataViewState(view);
          var intIndex = toIndex(index2);
          var pack2 = conversion(+value);
          var boolIsLittleEndian = !!isLittleEndian;
          if (intIndex + count > store.byteLength)
            throw new RangeError2(WRONG_INDEX);
          var bytes = store.bytes;
          var start = intIndex + store.byteOffset;
          for (var i = 0; i < count; i++)
            bytes[start + i] = pack2[boolIsLittleEndian ? i : count - i - 1];
        };
        if (!NATIVE_ARRAY_BUFFER) {
          $ArrayBuffer = function ArrayBuffer2(length) {
            anInstance(this, ArrayBufferPrototype);
            var byteLength = toIndex(length);
            setInternalState(this, {
              type: ARRAY_BUFFER,
              bytes: fill(Array2(byteLength), 0),
              byteLength
            });
            if (!DESCRIPTORS) {
              this.byteLength = byteLength;
              this.detached = false;
            }
          };
          ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
          $DataView = function DataView2(buffer2, byteOffset, byteLength) {
            anInstance(this, DataViewPrototype);
            anInstance(buffer2, ArrayBufferPrototype);
            var bufferState = getInternalArrayBufferState(buffer2);
            var bufferLength = bufferState.byteLength;
            var offset = toIntegerOrInfinity(byteOffset);
            if (offset < 0 || offset > bufferLength)
              throw new RangeError2("Wrong offset");
            byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
            if (offset + byteLength > bufferLength)
              throw new RangeError2(WRONG_LENGTH);
            setInternalState(this, {
              type: DATA_VIEW,
              buffer: buffer2,
              byteLength,
              byteOffset: offset,
              bytes: bufferState.bytes
            });
            if (!DESCRIPTORS) {
              this.buffer = buffer2;
              this.byteLength = byteLength;
              this.byteOffset = offset;
            }
          };
          DataViewPrototype = $DataView[PROTOTYPE];
          if (DESCRIPTORS) {
            addGetter($ArrayBuffer, "byteLength", getInternalArrayBufferState);
            addGetter($DataView, "buffer", getInternalDataViewState);
            addGetter($DataView, "byteLength", getInternalDataViewState);
            addGetter($DataView, "byteOffset", getInternalDataViewState);
          }
          defineBuiltIns(DataViewPrototype, {
            getInt8: function getInt8(byteOffset) {
              return get3(this, 1, byteOffset)[0] << 24 >> 24;
            },
            getUint8: function getUint8(byteOffset) {
              return get3(this, 1, byteOffset)[0];
            },
            getInt16: function getInt16(byteOffset) {
              var bytes = get3(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
              return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
            },
            getUint16: function getUint16(byteOffset) {
              var bytes = get3(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
              return bytes[1] << 8 | bytes[0];
            },
            getInt32: function getInt32(byteOffset) {
              return unpackInt32(get3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
            },
            getUint32: function getUint32(byteOffset) {
              return unpackInt32(get3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
            },
            getFloat32: function getFloat32(byteOffset) {
              return unpackIEEE754(get3(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
            },
            getFloat64: function getFloat64(byteOffset) {
              return unpackIEEE754(get3(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
            },
            setInt8: function setInt8(byteOffset, value) {
              set2(this, 1, byteOffset, packInt8, value);
            },
            setUint8: function setUint8(byteOffset, value) {
              set2(this, 1, byteOffset, packInt8, value);
            },
            setInt16: function setInt16(byteOffset, value) {
              set2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
            },
            setUint16: function setUint16(byteOffset, value) {
              set2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
            },
            setInt32: function setInt32(byteOffset, value) {
              set2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
            },
            setUint32: function setUint32(byteOffset, value) {
              set2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
            },
            setFloat32: function setFloat32(byteOffset, value) {
              set2(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
            },
            setFloat64: function setFloat64(byteOffset, value) {
              set2(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
            }
          });
        } else {
          var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
          if (!fails(function() {
            NativeArrayBuffer(1);
          }) || !fails(function() {
            new NativeArrayBuffer(-1);
          }) || fails(function() {
            new NativeArrayBuffer();
            new NativeArrayBuffer(1.5);
            new NativeArrayBuffer(NaN);
            return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
          })) {
            $ArrayBuffer = function ArrayBuffer2(length) {
              anInstance(this, ArrayBufferPrototype);
              return inheritIfRequired(new NativeArrayBuffer(toIndex(length)), this, $ArrayBuffer);
            };
            $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
            ArrayBufferPrototype.constructor = $ArrayBuffer;
            copyConstructorProperties($ArrayBuffer, NativeArrayBuffer);
          } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
          }
          if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
            setPrototypeOf(DataViewPrototype, ObjectPrototype);
          }
          var testView = new $DataView(new $ArrayBuffer(2));
          var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
          testView.setInt8(0, 2147483648);
          testView.setInt8(1, 2147483649);
          if (testView.getInt8(0) || !testView.getInt8(1))
            defineBuiltIns(DataViewPrototype, {
              setInt8: function setInt8(byteOffset, value) {
                $setInt8(this, byteOffset, value << 24 >> 24);
              },
              setUint8: function setUint8(byteOffset, value) {
                $setInt8(this, byteOffset, value << 24 >> 24);
              }
            }, { unsafe: true });
        }
        setToStringTag($ArrayBuffer, ARRAY_BUFFER);
        setToStringTag($DataView, DATA_VIEW);
        module3.exports = {
          ArrayBuffer: $ArrayBuffer,
          DataView: $DataView
        };
      }, { "../internals/an-instance": 113, "../internals/array-buffer-basic-detection": 115, "../internals/array-fill": 120, "../internals/array-slice": 131, "../internals/copy-constructor-properties": 141, "../internals/create-non-enumerable-property": 145, "../internals/define-built-in-accessor": 148, "../internals/define-built-ins": 150, "../internals/descriptors": 153, "../internals/fails": 171, "../internals/function-name": 178, "../internals/function-uncurry-this": 181, "../internals/global": 188, "../internals/ieee754": 194, "../internals/inherit-if-required": 196, "../internals/internal-state": 199, "../internals/math-fround": 222, "../internals/object-get-prototype-of": 236, "../internals/object-set-prototype-of": 242, "../internals/set-to-string-tag": 266, "../internals/to-index": 281, "../internals/to-integer-or-infinity": 283, "../internals/to-length": 284 }], 119: [function(require2, module3, exports3) {
        var toObject = require2("../internals/to-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var deletePropertyOrThrow = require2("../internals/delete-property-or-throw");
        var min = Math.min;
        module3.exports = [].copyWithin || function copyWithin(target, start) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var to = toAbsoluteIndex(target, len);
          var from = toAbsoluteIndex(start, len);
          var end = arguments.length > 2 ? arguments[2] : void 0;
          var count = min((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to);
          var inc = 1;
          if (from < to && to < from + count) {
            inc = -1;
            from += count - 1;
            to += count - 1;
          }
          while (count-- > 0) {
            if (from in O)
              O[to] = O[from];
            else
              deletePropertyOrThrow(O, to);
            to += inc;
            from += inc;
          }
          return O;
        };
      }, { "../internals/delete-property-or-throw": 152, "../internals/length-of-array-like": 219, "../internals/to-absolute-index": 279, "../internals/to-object": 285 }], 120: [function(require2, module3, exports3) {
        var toObject = require2("../internals/to-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        module3.exports = function fill(value) {
          var O = toObject(this);
          var length = lengthOfArrayLike(O);
          var argumentsLength = arguments.length;
          var index2 = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
          var end = argumentsLength > 2 ? arguments[2] : void 0;
          var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
          while (endPos > index2)
            O[index2++] = value;
          return O;
        };
      }, { "../internals/length-of-array-like": 219, "../internals/to-absolute-index": 279, "../internals/to-object": 285 }], 121: [function(require2, module3, exports3) {
        var $forEach = require2("../internals/array-iteration").forEach;
        var arrayMethodIsStrict = require2("../internals/array-method-is-strict");
        var STRICT_METHOD = arrayMethodIsStrict("forEach");
        module3.exports = !STRICT_METHOD ? function forEach3(callbackfn) {
          return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        } : [].forEach;
      }, { "../internals/array-iteration": 125, "../internals/array-method-is-strict": 128 }], 122: [function(require2, module3, exports3) {
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        module3.exports = function(Constructor, list2, $length) {
          var index2 = 0;
          var length = arguments.length > 2 ? $length : lengthOfArrayLike(list2);
          var result = new Constructor(length);
          while (length > index2)
            result[index2] = list2[index2++];
          return result;
        };
      }, { "../internals/length-of-array-like": 219 }], 123: [function(require2, module3, exports3) {
        var bind = require2("../internals/function-bind-context");
        var call = require2("../internals/function-call");
        var toObject = require2("../internals/to-object");
        var callWithSafeIterationClosing = require2("../internals/call-with-safe-iteration-closing");
        var isArrayIteratorMethod = require2("../internals/is-array-iterator-method");
        var isConstructor = require2("../internals/is-constructor");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var createProperty = require2("../internals/create-property");
        var getIterator = require2("../internals/get-iterator");
        var getIteratorMethod = require2("../internals/get-iterator-method");
        var $Array = Array;
        module3.exports = function from(arrayLike) {
          var O = toObject(arrayLike);
          var IS_CONSTRUCTOR = isConstructor(this);
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
          var mapping = mapfn !== void 0;
          if (mapping)
            mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
          var iteratorMethod = getIteratorMethod(O);
          var index2 = 0;
          var length, result, step, iterator, next, value;
          if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
            iterator = getIterator(O, iteratorMethod);
            next = iterator.next;
            result = IS_CONSTRUCTOR ? new this() : [];
            for (; !(step = call(next, iterator)).done; index2++) {
              value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
              createProperty(result, index2, value);
            }
          } else {
            length = lengthOfArrayLike(O);
            result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
            for (; length > index2; index2++) {
              value = mapping ? mapfn(O[index2], index2) : O[index2];
              createProperty(result, index2, value);
            }
          }
          result.length = index2;
          return result;
        };
      }, { "../internals/call-with-safe-iteration-closing": 135, "../internals/create-property": 147, "../internals/function-bind-context": 175, "../internals/function-call": 177, "../internals/get-iterator": 184, "../internals/get-iterator-method": 183, "../internals/is-array-iterator-method": 200, "../internals/is-constructor": 204, "../internals/length-of-array-like": 219, "../internals/to-object": 285 }], 124: [function(require2, module3, exports3) {
        var toIndexedObject = require2("../internals/to-indexed-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var createMethod = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O = toIndexedObject($this);
            var length = lengthOfArrayLike(O);
            var index2 = toAbsoluteIndex(fromIndex, length);
            var value;
            if (IS_INCLUDES && el !== el)
              while (length > index2) {
                value = O[index2++];
                if (value !== value)
                  return true;
              }
            else
              for (; length > index2; index2++) {
                if ((IS_INCLUDES || index2 in O) && O[index2] === el)
                  return IS_INCLUDES || index2 || 0;
              }
            return !IS_INCLUDES && -1;
          };
        };
        module3.exports = {
          // `Array.prototype.includes` method
          // https://tc39.es/ecma262/#sec-array.prototype.includes
          includes: createMethod(true),
          // `Array.prototype.indexOf` method
          // https://tc39.es/ecma262/#sec-array.prototype.indexof
          indexOf: createMethod(false)
        };
      }, { "../internals/length-of-array-like": 219, "../internals/to-absolute-index": 279, "../internals/to-indexed-object": 282 }], 125: [function(require2, module3, exports3) {
        var bind = require2("../internals/function-bind-context");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var IndexedObject = require2("../internals/indexed-object");
        var toObject = require2("../internals/to-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var arraySpeciesCreate = require2("../internals/array-species-create");
        var push = uncurryThis([].push);
        var createMethod = function(TYPE) {
          var IS_MAP = TYPE === 1;
          var IS_FILTER = TYPE === 2;
          var IS_SOME = TYPE === 3;
          var IS_EVERY = TYPE === 4;
          var IS_FIND_INDEX = TYPE === 6;
          var IS_FILTER_REJECT = TYPE === 7;
          var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
          return function($this, callbackfn, that, specificCreate) {
            var O = toObject($this);
            var self2 = IndexedObject(O);
            var length = lengthOfArrayLike(self2);
            var boundFunction = bind(callbackfn, that);
            var index2 = 0;
            var create3 = specificCreate || arraySpeciesCreate;
            var target = IS_MAP ? create3($this, length) : IS_FILTER || IS_FILTER_REJECT ? create3($this, 0) : void 0;
            var value, result;
            for (; length > index2; index2++)
              if (NO_HOLES || index2 in self2) {
                value = self2[index2];
                result = boundFunction(value, index2, O);
                if (TYPE) {
                  if (IS_MAP)
                    target[index2] = result;
                  else if (result)
                    switch (TYPE) {
                      case 3:
                        return true;
                      case 5:
                        return value;
                      case 6:
                        return index2;
                      case 2:
                        push(target, value);
                    }
                  else
                    switch (TYPE) {
                      case 4:
                        return false;
                      case 7:
                        push(target, value);
                    }
                }
              }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
          };
        };
        module3.exports = {
          // `Array.prototype.forEach` method
          // https://tc39.es/ecma262/#sec-array.prototype.foreach
          forEach: createMethod(0),
          // `Array.prototype.map` method
          // https://tc39.es/ecma262/#sec-array.prototype.map
          map: createMethod(1),
          // `Array.prototype.filter` method
          // https://tc39.es/ecma262/#sec-array.prototype.filter
          filter: createMethod(2),
          // `Array.prototype.some` method
          // https://tc39.es/ecma262/#sec-array.prototype.some
          some: createMethod(3),
          // `Array.prototype.every` method
          // https://tc39.es/ecma262/#sec-array.prototype.every
          every: createMethod(4),
          // `Array.prototype.find` method
          // https://tc39.es/ecma262/#sec-array.prototype.find
          find: createMethod(5),
          // `Array.prototype.findIndex` method
          // https://tc39.es/ecma262/#sec-array.prototype.findIndex
          findIndex: createMethod(6),
          // `Array.prototype.filterReject` method
          // https://github.com/tc39/proposal-array-filtering
          filterReject: createMethod(7)
        };
      }, { "../internals/array-species-create": 134, "../internals/function-bind-context": 175, "../internals/function-uncurry-this": 181, "../internals/indexed-object": 195, "../internals/length-of-array-like": 219, "../internals/to-object": 285 }], 126: [function(require2, module3, exports3) {
        var apply = require2("../internals/function-apply");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var arrayMethodIsStrict = require2("../internals/array-method-is-strict");
        var min = Math.min;
        var $lastIndexOf = [].lastIndexOf;
        var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
        var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
        var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
        module3.exports = FORCED ? function lastIndexOf(searchElement) {
          if (NEGATIVE_ZERO)
            return apply($lastIndexOf, this, arguments) || 0;
          var O = toIndexedObject(this);
          var length = lengthOfArrayLike(O);
          var index2 = length - 1;
          if (arguments.length > 1)
            index2 = min(index2, toIntegerOrInfinity(arguments[1]));
          if (index2 < 0)
            index2 = length + index2;
          for (; index2 >= 0; index2--)
            if (index2 in O && O[index2] === searchElement)
              return index2 || 0;
          return -1;
        } : $lastIndexOf;
      }, { "../internals/array-method-is-strict": 128, "../internals/function-apply": 174, "../internals/length-of-array-like": 219, "../internals/to-indexed-object": 282, "../internals/to-integer-or-infinity": 283 }], 127: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var V8_VERSION = require2("../internals/engine-v8-version");
        var SPECIES = wellKnownSymbol("species");
        module3.exports = function(METHOD_NAME) {
          return V8_VERSION >= 51 || !fails(function() {
            var array2 = [];
            var constructor = array2.constructor = {};
            constructor[SPECIES] = function() {
              return { foo: 1 };
            };
            return array2[METHOD_NAME](Boolean).foo !== 1;
          });
        };
      }, { "../internals/engine-v8-version": 167, "../internals/fails": 171, "../internals/well-known-symbol": 306 }], 128: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        module3.exports = function(METHOD_NAME, argument) {
          var method = [][METHOD_NAME];
          return !!method && fails(function() {
            method.call(null, argument || function() {
              return 1;
            }, 1);
          });
        };
      }, { "../internals/fails": 171 }], 129: [function(require2, module3, exports3) {
        var aCallable = require2("../internals/a-callable");
        var toObject = require2("../internals/to-object");
        var IndexedObject = require2("../internals/indexed-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var $TypeError = TypeError;
        var createMethod = function(IS_RIGHT) {
          return function(that, callbackfn, argumentsLength, memo) {
            var O = toObject(that);
            var self2 = IndexedObject(O);
            var length = lengthOfArrayLike(O);
            aCallable(callbackfn);
            var index2 = IS_RIGHT ? length - 1 : 0;
            var i = IS_RIGHT ? -1 : 1;
            if (argumentsLength < 2)
              while (true) {
                if (index2 in self2) {
                  memo = self2[index2];
                  index2 += i;
                  break;
                }
                index2 += i;
                if (IS_RIGHT ? index2 < 0 : length <= index2) {
                  throw new $TypeError("Reduce of empty array with no initial value");
                }
              }
            for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i)
              if (index2 in self2) {
                memo = callbackfn(memo, self2[index2], index2, O);
              }
            return memo;
          };
        };
        module3.exports = {
          // `Array.prototype.reduce` method
          // https://tc39.es/ecma262/#sec-array.prototype.reduce
          left: createMethod(false),
          // `Array.prototype.reduceRight` method
          // https://tc39.es/ecma262/#sec-array.prototype.reduceright
          right: createMethod(true)
        };
      }, { "../internals/a-callable": 108, "../internals/indexed-object": 195, "../internals/length-of-array-like": 219, "../internals/to-object": 285 }], 130: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var isArray2 = require2("../internals/is-array");
        var $TypeError = TypeError;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {
          if (this !== void 0)
            return true;
          try {
            Object.defineProperty([], "length", { writable: false }).length = 1;
          } catch (error2) {
            return error2 instanceof TypeError;
          }
        }();
        module3.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
          if (isArray2(O) && !getOwnPropertyDescriptor(O, "length").writable) {
            throw new $TypeError("Cannot set read only .length");
          }
          return O.length = length;
        } : function(O, length) {
          return O.length = length;
        };
      }, { "../internals/descriptors": 153, "../internals/is-array": 201 }], 131: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        module3.exports = uncurryThis([].slice);
      }, { "../internals/function-uncurry-this": 181 }], 132: [function(require2, module3, exports3) {
        var arraySlice = require2("../internals/array-slice");
        var floor = Math.floor;
        var sort = function(array2, comparefn) {
          var length = array2.length;
          if (length < 8) {
            var i = 1;
            var element, j;
            while (i < length) {
              j = i;
              element = array2[i];
              while (j && comparefn(array2[j - 1], element) > 0) {
                array2[j] = array2[--j];
              }
              if (j !== i++)
                array2[j] = element;
            }
          } else {
            var middle = floor(length / 2);
            var left = sort(arraySlice(array2, 0, middle), comparefn);
            var right = sort(arraySlice(array2, middle), comparefn);
            var llength = left.length;
            var rlength = right.length;
            var lindex = 0;
            var rindex = 0;
            while (lindex < llength || rindex < rlength) {
              array2[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
            }
          }
          return array2;
        };
        module3.exports = sort;
      }, { "../internals/array-slice": 131 }], 133: [function(require2, module3, exports3) {
        var isArray2 = require2("../internals/is-array");
        var isConstructor = require2("../internals/is-constructor");
        var isObject2 = require2("../internals/is-object");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var SPECIES = wellKnownSymbol("species");
        var $Array = Array;
        module3.exports = function(originalArray) {
          var C;
          if (isArray2(originalArray)) {
            C = originalArray.constructor;
            if (isConstructor(C) && (C === $Array || isArray2(C.prototype)))
              C = void 0;
            else if (isObject2(C)) {
              C = C[SPECIES];
              if (C === null)
                C = void 0;
            }
          }
          return C === void 0 ? $Array : C;
        };
      }, { "../internals/is-array": 201, "../internals/is-constructor": 204, "../internals/is-object": 208, "../internals/well-known-symbol": 306 }], 134: [function(require2, module3, exports3) {
        var arraySpeciesConstructor = require2("../internals/array-species-constructor");
        module3.exports = function(originalArray, length) {
          return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
        };
      }, { "../internals/array-species-constructor": 133 }], 135: [function(require2, module3, exports3) {
        var anObject = require2("../internals/an-object");
        var iteratorClose = require2("../internals/iterator-close");
        module3.exports = function(iterator, fn, value, ENTRIES) {
          try {
            return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
          } catch (error2) {
            iteratorClose(iterator, "throw", error2);
          }
        };
      }, { "../internals/an-object": 114, "../internals/iterator-close": 214 }], 136: [function(require2, module3, exports3) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var ITERATOR = wellKnownSymbol("iterator");
        var SAFE_CLOSING = false;
        try {
          var called = 0;
          var iteratorWithReturn = {
            next: function() {
              return { done: !!called++ };
            },
            "return": function() {
              SAFE_CLOSING = true;
            }
          };
          iteratorWithReturn[ITERATOR] = function() {
            return this;
          };
          Array.from(iteratorWithReturn, function() {
            throw 2;
          });
        } catch (error2) {
        }
        module3.exports = function(exec, SKIP_CLOSING) {
          try {
            if (!SKIP_CLOSING && !SAFE_CLOSING)
              return false;
          } catch (error2) {
            return false;
          }
          var ITERATION_SUPPORT = false;
          try {
            var object2 = {};
            object2[ITERATOR] = function() {
              return {
                next: function() {
                  return { done: ITERATION_SUPPORT = true };
                }
              };
            };
            exec(object2);
          } catch (error2) {
          }
          return ITERATION_SUPPORT;
        };
      }, { "../internals/well-known-symbol": 306 }], 137: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toString2 = uncurryThis({}.toString);
        var stringSlice = uncurryThis("".slice);
        module3.exports = function(it) {
          return stringSlice(toString2(it), 8, -1);
        };
      }, { "../internals/function-uncurry-this": 181 }], 138: [function(require2, module3, exports3) {
        var TO_STRING_TAG_SUPPORT = require2("../internals/to-string-tag-support");
        var isCallable = require2("../internals/is-callable");
        var classofRaw = require2("../internals/classof-raw");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var $Object = Object;
        var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
          return arguments;
        }()) === "Arguments";
        var tryGet = function(it, key) {
          try {
            return it[key];
          } catch (error2) {
          }
        };
        module3.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
          var O, tag2, result;
          return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag2 = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag2 : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
        };
      }, { "../internals/classof-raw": 137, "../internals/is-callable": 203, "../internals/to-string-tag-support": 290, "../internals/well-known-symbol": 306 }], 139: [function(require2, module3, exports3) {
        var create3 = require2("../internals/object-create");
        var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
        var defineBuiltIns = require2("../internals/define-built-ins");
        var bind = require2("../internals/function-bind-context");
        var anInstance = require2("../internals/an-instance");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var iterate = require2("../internals/iterate");
        var defineIterator = require2("../internals/iterator-define");
        var createIterResultObject = require2("../internals/create-iter-result-object");
        var setSpecies = require2("../internals/set-species");
        var DESCRIPTORS = require2("../internals/descriptors");
        var fastKey = require2("../internals/internal-metadata").fastKey;
        var InternalStateModule = require2("../internals/internal-state");
        var setInternalState = InternalStateModule.set;
        var internalStateGetterFor = InternalStateModule.getterFor;
        module3.exports = {
          getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
            var Constructor = wrapper(function(that, iterable) {
              anInstance(that, Prototype);
              setInternalState(that, {
                type: CONSTRUCTOR_NAME,
                index: create3(null),
                first: void 0,
                last: void 0,
                size: 0
              });
              if (!DESCRIPTORS)
                that.size = 0;
              if (!isNullOrUndefined(iterable))
                iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
            });
            var Prototype = Constructor.prototype;
            var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
            var define = function(that, key, value) {
              var state = getInternalState(that);
              var entry = getEntry(that, key);
              var previous, index2;
              if (entry) {
                entry.value = value;
              } else {
                state.last = entry = {
                  index: index2 = fastKey(key, true),
                  key,
                  value,
                  previous: previous = state.last,
                  next: void 0,
                  removed: false
                };
                if (!state.first)
                  state.first = entry;
                if (previous)
                  previous.next = entry;
                if (DESCRIPTORS)
                  state.size++;
                else
                  that.size++;
                if (index2 !== "F")
                  state.index[index2] = entry;
              }
              return that;
            };
            var getEntry = function(that, key) {
              var state = getInternalState(that);
              var index2 = fastKey(key);
              var entry;
              if (index2 !== "F")
                return state.index[index2];
              for (entry = state.first; entry; entry = entry.next) {
                if (entry.key === key)
                  return entry;
              }
            };
            defineBuiltIns(Prototype, {
              // `{ Map, Set }.prototype.clear()` methods
              // https://tc39.es/ecma262/#sec-map.prototype.clear
              // https://tc39.es/ecma262/#sec-set.prototype.clear
              clear: function clear2() {
                var that = this;
                var state = getInternalState(that);
                var entry = state.first;
                while (entry) {
                  entry.removed = true;
                  if (entry.previous)
                    entry.previous = entry.previous.next = void 0;
                  entry = entry.next;
                }
                state.first = state.last = void 0;
                state.index = create3(null);
                if (DESCRIPTORS)
                  state.size = 0;
                else
                  that.size = 0;
              },
              // `{ Map, Set }.prototype.delete(key)` methods
              // https://tc39.es/ecma262/#sec-map.prototype.delete
              // https://tc39.es/ecma262/#sec-set.prototype.delete
              "delete": function(key) {
                var that = this;
                var state = getInternalState(that);
                var entry = getEntry(that, key);
                if (entry) {
                  var next = entry.next;
                  var prev = entry.previous;
                  delete state.index[entry.index];
                  entry.removed = true;
                  if (prev)
                    prev.next = next;
                  if (next)
                    next.previous = prev;
                  if (state.first === entry)
                    state.first = next;
                  if (state.last === entry)
                    state.last = prev;
                  if (DESCRIPTORS)
                    state.size--;
                  else
                    that.size--;
                }
                return !!entry;
              },
              // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
              // https://tc39.es/ecma262/#sec-map.prototype.foreach
              // https://tc39.es/ecma262/#sec-set.prototype.foreach
              forEach: function forEach3(callbackfn) {
                var state = getInternalState(this);
                var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                var entry;
                while (entry = entry ? entry.next : state.first) {
                  boundFunction(entry.value, entry.key, this);
                  while (entry && entry.removed)
                    entry = entry.previous;
                }
              },
              // `{ Map, Set}.prototype.has(key)` methods
              // https://tc39.es/ecma262/#sec-map.prototype.has
              // https://tc39.es/ecma262/#sec-set.prototype.has
              has: function has2(key) {
                return !!getEntry(this, key);
              }
            });
            defineBuiltIns(Prototype, IS_MAP ? {
              // `Map.prototype.get(key)` method
              // https://tc39.es/ecma262/#sec-map.prototype.get
              get: function get3(key) {
                var entry = getEntry(this, key);
                return entry && entry.value;
              },
              // `Map.prototype.set(key, value)` method
              // https://tc39.es/ecma262/#sec-map.prototype.set
              set: function set2(key, value) {
                return define(this, key === 0 ? 0 : key, value);
              }
            } : {
              // `Set.prototype.add(value)` method
              // https://tc39.es/ecma262/#sec-set.prototype.add
              add: function add2(value) {
                return define(this, value = value === 0 ? 0 : value, value);
              }
            });
            if (DESCRIPTORS)
              defineBuiltInAccessor(Prototype, "size", {
                configurable: true,
                get: function() {
                  return getInternalState(this).size;
                }
              });
            return Constructor;
          },
          setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
            var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
            var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
            var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
            defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
              setInternalState(this, {
                type: ITERATOR_NAME,
                target: iterated,
                state: getInternalCollectionState(iterated),
                kind,
                last: void 0
              });
            }, function() {
              var state = getInternalIteratorState(this);
              var kind = state.kind;
              var entry = state.last;
              while (entry && entry.removed)
                entry = entry.previous;
              if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                state.target = void 0;
                return createIterResultObject(void 0, true);
              }
              if (kind === "keys")
                return createIterResultObject(entry.key, false);
              if (kind === "values")
                return createIterResultObject(entry.value, false);
              return createIterResultObject([entry.key, entry.value], false);
            }, IS_MAP ? "entries" : "values", !IS_MAP, true);
            setSpecies(CONSTRUCTOR_NAME);
          }
        };
      }, { "../internals/an-instance": 113, "../internals/create-iter-result-object": 144, "../internals/define-built-in-accessor": 148, "../internals/define-built-ins": 150, "../internals/descriptors": 153, "../internals/function-bind-context": 175, "../internals/internal-metadata": 198, "../internals/internal-state": 199, "../internals/is-null-or-undefined": 207, "../internals/iterate": 213, "../internals/iterator-define": 216, "../internals/object-create": 229, "../internals/set-species": 265 }], 140: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isForced = require2("../internals/is-forced");
        var defineBuiltIn = require2("../internals/define-built-in");
        var InternalMetadataModule = require2("../internals/internal-metadata");
        var iterate = require2("../internals/iterate");
        var anInstance = require2("../internals/an-instance");
        var isCallable = require2("../internals/is-callable");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var isObject2 = require2("../internals/is-object");
        var fails = require2("../internals/fails");
        var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var inheritIfRequired = require2("../internals/inherit-if-required");
        module3.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
          var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
          var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
          var ADDER = IS_MAP ? "set" : "add";
          var NativeConstructor = global3[CONSTRUCTOR_NAME];
          var NativePrototype = NativeConstructor && NativeConstructor.prototype;
          var Constructor = NativeConstructor;
          var exported = {};
          var fixMethod = function(KEY) {
            var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
            defineBuiltIn(
              NativePrototype,
              KEY,
              KEY === "add" ? function add2(value) {
                uncurriedNativeMethod(this, value === 0 ? 0 : value);
                return this;
              } : KEY === "delete" ? function(key) {
                return IS_WEAK && !isObject2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
              } : KEY === "get" ? function get3(key) {
                return IS_WEAK && !isObject2(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
              } : KEY === "has" ? function has2(key) {
                return IS_WEAK && !isObject2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
              } : function set2(key, value) {
                uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
                return this;
              }
            );
          };
          var REPLACE = isForced(
            CONSTRUCTOR_NAME,
            !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
              new NativeConstructor().entries().next();
            }))
          );
          if (REPLACE) {
            Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
            InternalMetadataModule.enable();
          } else if (isForced(CONSTRUCTOR_NAME, true)) {
            var instance = new Constructor();
            var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
            var THROWS_ON_PRIMITIVES = fails(function() {
              instance.has(1);
            });
            var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
              new NativeConstructor(iterable);
            });
            var BUGGY_ZERO = !IS_WEAK && fails(function() {
              var $instance = new NativeConstructor();
              var index2 = 5;
              while (index2--)
                $instance[ADDER](index2, index2);
              return !$instance.has(-0);
            });
            if (!ACCEPT_ITERABLES) {
              Constructor = wrapper(function(dummy, iterable) {
                anInstance(dummy, NativePrototype);
                var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                if (!isNullOrUndefined(iterable))
                  iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
                return that;
              });
              Constructor.prototype = NativePrototype;
              NativePrototype.constructor = Constructor;
            }
            if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
              fixMethod("delete");
              fixMethod("has");
              IS_MAP && fixMethod("get");
            }
            if (BUGGY_ZERO || HASNT_CHAINING)
              fixMethod(ADDER);
            if (IS_WEAK && NativePrototype.clear)
              delete NativePrototype.clear;
          }
          exported[CONSTRUCTOR_NAME] = Constructor;
          $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
          setToStringTag(Constructor, CONSTRUCTOR_NAME);
          if (!IS_WEAK)
            common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
          return Constructor;
        };
      }, { "../internals/an-instance": 113, "../internals/check-correctness-of-iteration": 136, "../internals/define-built-in": 149, "../internals/export": 170, "../internals/fails": 171, "../internals/function-uncurry-this": 181, "../internals/global": 188, "../internals/inherit-if-required": 196, "../internals/internal-metadata": 198, "../internals/is-callable": 203, "../internals/is-forced": 205, "../internals/is-null-or-undefined": 207, "../internals/is-object": 208, "../internals/iterate": 213, "../internals/set-to-string-tag": 266 }], 141: [function(require2, module3, exports3) {
        var hasOwn2 = require2("../internals/has-own-property");
        var ownKeys = require2("../internals/own-keys");
        var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
        var definePropertyModule = require2("../internals/object-define-property");
        module3.exports = function(target, source, exceptions) {
          var keys = ownKeys(source);
          var defineProperty = definePropertyModule.f;
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!hasOwn2(target, key) && !(exceptions && hasOwn2(exceptions, key))) {
              defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          }
        };
      }, { "../internals/has-own-property": 189, "../internals/object-define-property": 231, "../internals/object-get-own-property-descriptor": 232, "../internals/own-keys": 246 }], 142: [function(require2, module3, exports3) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var MATCH = wellKnownSymbol("match");
        module3.exports = function(METHOD_NAME) {
          var regexp = /./;
          try {
            "/./"[METHOD_NAME](regexp);
          } catch (error1) {
            try {
              regexp[MATCH] = false;
              return "/./"[METHOD_NAME](regexp);
            } catch (error2) {
            }
          }
          return false;
        };
      }, { "../internals/well-known-symbol": 306 }], 143: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        module3.exports = !fails(function() {
          function F2() {
          }
          F2.prototype.constructor = null;
          return Object.getPrototypeOf(new F2()) !== F2.prototype;
        });
      }, { "../internals/fails": 171 }], 144: [function(require2, module3, exports3) {
        module3.exports = function(value, done) {
          return { value, done };
        };
      }, {}], 145: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var definePropertyModule = require2("../internals/object-define-property");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        module3.exports = DESCRIPTORS ? function(object2, key, value) {
          return definePropertyModule.f(object2, key, createPropertyDescriptor(1, value));
        } : function(object2, key, value) {
          object2[key] = value;
          return object2;
        };
      }, { "../internals/create-property-descriptor": 146, "../internals/descriptors": 153, "../internals/object-define-property": 231 }], 146: [function(require2, module3, exports3) {
        module3.exports = function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value
          };
        };
      }, {}], 147: [function(require2, module3, exports3) {
        var toPropertyKey = require2("../internals/to-property-key");
        var definePropertyModule = require2("../internals/object-define-property");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        module3.exports = function(object2, key, value) {
          var propertyKey = toPropertyKey(key);
          if (propertyKey in object2)
            definePropertyModule.f(object2, propertyKey, createPropertyDescriptor(0, value));
          else
            object2[propertyKey] = value;
        };
      }, { "../internals/create-property-descriptor": 146, "../internals/object-define-property": 231, "../internals/to-property-key": 289 }], 148: [function(require2, module3, exports3) {
        var makeBuiltIn = require2("../internals/make-built-in");
        var defineProperty = require2("../internals/object-define-property");
        module3.exports = function(target, name, descriptor) {
          if (descriptor.get)
            makeBuiltIn(descriptor.get, name, { getter: true });
          if (descriptor.set)
            makeBuiltIn(descriptor.set, name, { setter: true });
          return defineProperty.f(target, name, descriptor);
        };
      }, { "../internals/make-built-in": 220, "../internals/object-define-property": 231 }], 149: [function(require2, module3, exports3) {
        var isCallable = require2("../internals/is-callable");
        var definePropertyModule = require2("../internals/object-define-property");
        var makeBuiltIn = require2("../internals/make-built-in");
        var defineGlobalProperty = require2("../internals/define-global-property");
        module3.exports = function(O, key, value, options) {
          if (!options)
            options = {};
          var simple = options.enumerable;
          var name = options.name !== void 0 ? options.name : key;
          if (isCallable(value))
            makeBuiltIn(value, name, options);
          if (options.global) {
            if (simple)
              O[key] = value;
            else
              defineGlobalProperty(key, value);
          } else {
            try {
              if (!options.unsafe)
                delete O[key];
              else if (O[key])
                simple = true;
            } catch (error2) {
            }
            if (simple)
              O[key] = value;
            else
              definePropertyModule.f(O, key, {
                value,
                enumerable: false,
                configurable: !options.nonConfigurable,
                writable: !options.nonWritable
              });
          }
          return O;
        };
      }, { "../internals/define-global-property": 151, "../internals/is-callable": 203, "../internals/make-built-in": 220, "../internals/object-define-property": 231 }], 150: [function(require2, module3, exports3) {
        var defineBuiltIn = require2("../internals/define-built-in");
        module3.exports = function(target, src, options) {
          for (var key in src)
            defineBuiltIn(target, key, src[key], options);
          return target;
        };
      }, { "../internals/define-built-in": 149 }], 151: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var defineProperty = Object.defineProperty;
        module3.exports = function(key, value) {
          try {
            defineProperty(global3, key, { value, configurable: true, writable: true });
          } catch (error2) {
            global3[key] = value;
          }
          return value;
        };
      }, { "../internals/global": 188 }], 152: [function(require2, module3, exports3) {
        var tryToString = require2("../internals/try-to-string");
        var $TypeError = TypeError;
        module3.exports = function(O, P) {
          if (!delete O[P])
            throw new $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
        };
      }, { "../internals/try-to-string": 293 }], 153: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        module3.exports = !fails(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] !== 7;
        });
      }, { "../internals/fails": 171 }], 154: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var isObject2 = require2("../internals/is-object");
        var document2 = global3.document;
        var EXISTS = isObject2(document2) && isObject2(document2.createElement);
        module3.exports = function(it) {
          return EXISTS ? document2.createElement(it) : {};
        };
      }, { "../internals/global": 188, "../internals/is-object": 208 }], 155: [function(require2, module3, exports3) {
        var $TypeError = TypeError;
        var MAX_SAFE_INTEGER = 9007199254740991;
        module3.exports = function(it) {
          if (it > MAX_SAFE_INTEGER)
            throw $TypeError("Maximum allowed index exceeded");
          return it;
        };
      }, {}], 156: [function(require2, module3, exports3) {
        module3.exports = {
          CSSRuleList: 0,
          CSSStyleDeclaration: 0,
          CSSValueList: 0,
          ClientRectList: 0,
          DOMRectList: 0,
          DOMStringList: 0,
          DOMTokenList: 1,
          DataTransferItemList: 0,
          FileList: 0,
          HTMLAllCollection: 0,
          HTMLCollection: 0,
          HTMLFormElement: 0,
          HTMLSelectElement: 0,
          MediaList: 0,
          MimeTypeArray: 0,
          NamedNodeMap: 0,
          NodeList: 1,
          PaintRequestList: 0,
          Plugin: 0,
          PluginArray: 0,
          SVGLengthList: 0,
          SVGNumberList: 0,
          SVGPathSegList: 0,
          SVGPointList: 0,
          SVGStringList: 0,
          SVGTransformList: 0,
          SourceBufferList: 0,
          StyleSheetList: 0,
          TextTrackCueList: 0,
          TextTrackList: 0,
          TouchList: 0
        };
      }, {}], 157: [function(require2, module3, exports3) {
        var documentCreateElement = require2("../internals/document-create-element");
        var classList = documentCreateElement("span").classList;
        var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
        module3.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
      }, { "../internals/document-create-element": 154 }], 158: [function(require2, module3, exports3) {
        var userAgent = require2("../internals/engine-user-agent");
        var firefox = userAgent.match(/firefox\/(\d+)/i);
        module3.exports = !!firefox && +firefox[1];
      }, { "../internals/engine-user-agent": 166 }], 159: [function(require2, module3, exports3) {
        var IS_DENO = require2("../internals/engine-is-deno");
        var IS_NODE = require2("../internals/engine-is-node");
        module3.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
      }, { "../internals/engine-is-deno": 160, "../internals/engine-is-node": 164 }], 160: [function(require2, module3, exports3) {
        module3.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
      }, {}], 161: [function(require2, module3, exports3) {
        var UA = require2("../internals/engine-user-agent");
        module3.exports = /MSIE|Trident/.test(UA);
      }, { "../internals/engine-user-agent": 166 }], 162: [function(require2, module3, exports3) {
        var userAgent = require2("../internals/engine-user-agent");
        module3.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
      }, { "../internals/engine-user-agent": 166 }], 163: [function(require2, module3, exports3) {
        var userAgent = require2("../internals/engine-user-agent");
        module3.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
      }, { "../internals/engine-user-agent": 166 }], 164: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var classof = require2("../internals/classof-raw");
        module3.exports = classof(global3.process) === "process";
      }, { "../internals/classof-raw": 137, "../internals/global": 188 }], 165: [function(require2, module3, exports3) {
        var userAgent = require2("../internals/engine-user-agent");
        module3.exports = /web0s(?!.*chrome)/i.test(userAgent);
      }, { "../internals/engine-user-agent": 166 }], 166: [function(require2, module3, exports3) {
        module3.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
      }, {}], 167: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var userAgent = require2("../internals/engine-user-agent");
        var process = global3.process;
        var Deno2 = global3.Deno;
        var versions = process && process.versions || Deno2 && Deno2.version;
        var v8 = versions && versions.v8;
        var match, version2;
        if (v8) {
          match = v8.split(".");
          version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
        }
        if (!version2 && userAgent) {
          match = userAgent.match(/Edge\/(\d+)/);
          if (!match || match[1] >= 74) {
            match = userAgent.match(/Chrome\/(\d+)/);
            if (match)
              version2 = +match[1];
          }
        }
        module3.exports = version2;
      }, { "../internals/engine-user-agent": 166, "../internals/global": 188 }], 168: [function(require2, module3, exports3) {
        var userAgent = require2("../internals/engine-user-agent");
        var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
        module3.exports = !!webkit && +webkit[1];
      }, { "../internals/engine-user-agent": 166 }], 169: [function(require2, module3, exports3) {
        module3.exports = [
          "constructor",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf"
        ];
      }, {}], 170: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var getOwnPropertyDescriptor = require2("../internals/object-get-own-property-descriptor").f;
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var defineBuiltIn = require2("../internals/define-built-in");
        var defineGlobalProperty = require2("../internals/define-global-property");
        var copyConstructorProperties = require2("../internals/copy-constructor-properties");
        var isForced = require2("../internals/is-forced");
        module3.exports = function(options, source) {
          var TARGET = options.target;
          var GLOBAL = options.global;
          var STATIC = options.stat;
          var FORCED, target, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target = global3;
          } else if (STATIC) {
            target = global3[TARGET] || defineGlobalProperty(TARGET, {});
          } else {
            target = (global3[TARGET] || {}).prototype;
          }
          if (target)
            for (key in source) {
              sourceProperty = source[key];
              if (options.dontCallGetSet) {
                descriptor = getOwnPropertyDescriptor(target, key);
                targetProperty = descriptor && descriptor.value;
              } else
                targetProperty = target[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
              if (!FORCED && targetProperty !== void 0) {
                if (typeof sourceProperty == typeof targetProperty)
                  continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              if (options.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(sourceProperty, "sham", true);
              }
              defineBuiltIn(target, key, sourceProperty, options);
            }
        };
      }, { "../internals/copy-constructor-properties": 141, "../internals/create-non-enumerable-property": 145, "../internals/define-built-in": 149, "../internals/define-global-property": 151, "../internals/global": 188, "../internals/is-forced": 205, "../internals/object-get-own-property-descriptor": 232 }], 171: [function(require2, module3, exports3) {
        module3.exports = function(exec) {
          try {
            return !!exec();
          } catch (error2) {
            return true;
          }
        };
      }, {}], 172: [function(require2, module3, exports3) {
        require2("../modules/es.regexp.exec");
        var uncurryThis = require2("../internals/function-uncurry-this-clause");
        var defineBuiltIn = require2("../internals/define-built-in");
        var regexpExec = require2("../internals/regexp-exec");
        var fails = require2("../internals/fails");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var SPECIES = wellKnownSymbol("species");
        var RegExpPrototype = RegExp.prototype;
        module3.exports = function(KEY, exec, FORCED, SHAM) {
          var SYMBOL = wellKnownSymbol(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function() {
            var O = {};
            O[SYMBOL] = function() {
              return 7;
            };
            return ""[KEY](O) !== 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
            var execCalled = false;
            var re = /a/;
            if (KEY === "split") {
              re = {};
              re.constructor = {};
              re.constructor[SPECIES] = function() {
                return re;
              };
              re.flags = "";
              re[SYMBOL] = /./[SYMBOL];
            }
            re.exec = function() {
              execCalled = true;
              return null;
            };
            re[SYMBOL]("");
            return !execCalled;
          });
          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
            var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
            var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
              var uncurriedNativeMethod = uncurryThis(nativeMethod);
              var $exec = regexp.exec;
              if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
                }
                return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
              }
              return { done: false };
            });
            defineBuiltIn(String.prototype, KEY, methods[0]);
            defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
          }
          if (SHAM)
            createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
        };
      }, { "../internals/create-non-enumerable-property": 145, "../internals/define-built-in": 149, "../internals/fails": 171, "../internals/function-uncurry-this-clause": 180, "../internals/regexp-exec": 256, "../internals/well-known-symbol": 306, "../modules/es.regexp.exec": 338 }], 173: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        module3.exports = !fails(function() {
          return Object.isExtensible(Object.preventExtensions({}));
        });
      }, { "../internals/fails": 171 }], 174: [function(require2, module3, exports3) {
        var NATIVE_BIND = require2("../internals/function-bind-native");
        var FunctionPrototype = Function.prototype;
        var apply = FunctionPrototype.apply;
        var call = FunctionPrototype.call;
        module3.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
          return call.apply(apply, arguments);
        });
      }, { "../internals/function-bind-native": 176 }], 175: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this-clause");
        var aCallable = require2("../internals/a-callable");
        var NATIVE_BIND = require2("../internals/function-bind-native");
        var bind = uncurryThis(uncurryThis.bind);
        module3.exports = function(fn, that) {
          aCallable(fn);
          return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
            return fn.apply(that, arguments);
          };
        };
      }, { "../internals/a-callable": 108, "../internals/function-bind-native": 176, "../internals/function-uncurry-this-clause": 180 }], 176: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        module3.exports = !fails(function() {
          var test2 = (function() {
          }).bind();
          return typeof test2 != "function" || test2.hasOwnProperty("prototype");
        });
      }, { "../internals/fails": 171 }], 177: [function(require2, module3, exports3) {
        var NATIVE_BIND = require2("../internals/function-bind-native");
        var call = Function.prototype.call;
        module3.exports = NATIVE_BIND ? call.bind(call) : function() {
          return call.apply(call, arguments);
        };
      }, { "../internals/function-bind-native": 176 }], 178: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var hasOwn2 = require2("../internals/has-own-property");
        var FunctionPrototype = Function.prototype;
        var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
        var EXISTS = hasOwn2(FunctionPrototype, "name");
        var PROPER = EXISTS && (function something() {
        }).name === "something";
        var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
        module3.exports = {
          EXISTS,
          PROPER,
          CONFIGURABLE
        };
      }, { "../internals/descriptors": 153, "../internals/has-own-property": 189 }], 179: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var aCallable = require2("../internals/a-callable");
        module3.exports = function(object2, key, method) {
          try {
            return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object2, key)[method]));
          } catch (error2) {
          }
        };
      }, { "../internals/a-callable": 108, "../internals/function-uncurry-this": 181 }], 180: [function(require2, module3, exports3) {
        var classofRaw = require2("../internals/classof-raw");
        var uncurryThis = require2("../internals/function-uncurry-this");
        module3.exports = function(fn) {
          if (classofRaw(fn) === "Function")
            return uncurryThis(fn);
        };
      }, { "../internals/classof-raw": 137, "../internals/function-uncurry-this": 181 }], 181: [function(require2, module3, exports3) {
        var NATIVE_BIND = require2("../internals/function-bind-native");
        var FunctionPrototype = Function.prototype;
        var call = FunctionPrototype.call;
        var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
        module3.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
          return function() {
            return call.apply(fn, arguments);
          };
        };
      }, { "../internals/function-bind-native": 176 }], 182: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var aFunction = function(argument) {
          return isCallable(argument) ? argument : void 0;
        };
        module3.exports = function(namespace, method) {
          return arguments.length < 2 ? aFunction(global3[namespace]) : global3[namespace] && global3[namespace][method];
        };
      }, { "../internals/global": 188, "../internals/is-callable": 203 }], 183: [function(require2, module3, exports3) {
        var classof = require2("../internals/classof");
        var getMethod = require2("../internals/get-method");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var Iterators = require2("../internals/iterators");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var ITERATOR = wellKnownSymbol("iterator");
        module3.exports = function(it) {
          if (!isNullOrUndefined(it))
            return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
        };
      }, { "../internals/classof": 138, "../internals/get-method": 186, "../internals/is-null-or-undefined": 207, "../internals/iterators": 218, "../internals/well-known-symbol": 306 }], 184: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var aCallable = require2("../internals/a-callable");
        var anObject = require2("../internals/an-object");
        var tryToString = require2("../internals/try-to-string");
        var getIteratorMethod = require2("../internals/get-iterator-method");
        var $TypeError = TypeError;
        module3.exports = function(argument, usingIterator) {
          var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
          if (aCallable(iteratorMethod))
            return anObject(call(iteratorMethod, argument));
          throw new $TypeError(tryToString(argument) + " is not iterable");
        };
      }, { "../internals/a-callable": 108, "../internals/an-object": 114, "../internals/function-call": 177, "../internals/get-iterator-method": 183, "../internals/try-to-string": 293 }], 185: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isArray2 = require2("../internals/is-array");
        var isCallable = require2("../internals/is-callable");
        var classof = require2("../internals/classof-raw");
        var toString2 = require2("../internals/to-string");
        var push = uncurryThis([].push);
        module3.exports = function(replacer2) {
          if (isCallable(replacer2))
            return replacer2;
          if (!isArray2(replacer2))
            return;
          var rawLength = replacer2.length;
          var keys = [];
          for (var i = 0; i < rawLength; i++) {
            var element = replacer2[i];
            if (typeof element == "string")
              push(keys, element);
            else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String")
              push(keys, toString2(element));
          }
          var keysLength = keys.length;
          var root = true;
          return function(key, value) {
            if (root) {
              root = false;
              return value;
            }
            if (isArray2(this))
              return value;
            for (var j = 0; j < keysLength; j++)
              if (keys[j] === key)
                return value;
          };
        };
      }, { "../internals/classof-raw": 137, "../internals/function-uncurry-this": 181, "../internals/is-array": 201, "../internals/is-callable": 203, "../internals/to-string": 291 }], 186: [function(require2, module3, exports3) {
        var aCallable = require2("../internals/a-callable");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        module3.exports = function(V2, P) {
          var func2 = V2[P];
          return isNullOrUndefined(func2) ? void 0 : aCallable(func2);
        };
      }, { "../internals/a-callable": 108, "../internals/is-null-or-undefined": 207 }], 187: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toObject = require2("../internals/to-object");
        var floor = Math.floor;
        var charAt = uncurryThis("".charAt);
        var replace = uncurryThis("".replace);
        var stringSlice = uncurryThis("".slice);
        var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
        module3.exports = function(matched, str, position2, captures, namedCaptures, replacement) {
          var tailPos = position2 + matched.length;
          var m = captures.length;
          var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
          if (namedCaptures !== void 0) {
            namedCaptures = toObject(namedCaptures);
            symbols = SUBSTITUTION_SYMBOLS;
          }
          return replace(replacement, symbols, function(match, ch) {
            var capture;
            switch (charAt(ch, 0)) {
              case "$":
                return "$";
              case "&":
                return matched;
              case "`":
                return stringSlice(str, 0, position2);
              case "'":
                return stringSlice(str, tailPos);
              case "<":
                capture = namedCaptures[stringSlice(ch, 1, -1)];
                break;
              default:
                var n2 = +ch;
                if (n2 === 0)
                  return match;
                if (n2 > m) {
                  var f2 = floor(n2 / 10);
                  if (f2 === 0)
                    return match;
                  if (f2 <= m)
                    return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
                  return match;
                }
                capture = captures[n2 - 1];
            }
            return capture === void 0 ? "" : capture;
          });
        };
      }, { "../internals/function-uncurry-this": 181, "../internals/to-object": 285 }], 188: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            var check = function(it) {
              return it && it.Math === Math && it;
            };
            module3.exports = // eslint-disable-next-line es/no-global-this -- safe
            check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
            check(typeof self == "object" && self) || check(typeof global3 == "object" && global3) || check(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
            /* @__PURE__ */ function() {
              return this;
            }() || Function("return this")();
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 189: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toObject = require2("../internals/to-object");
        var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
        module3.exports = Object.hasOwn || function hasOwn2(it, key) {
          return hasOwnProperty2(toObject(it), key);
        };
      }, { "../internals/function-uncurry-this": 181, "../internals/to-object": 285 }], 190: [function(require2, module3, exports3) {
        module3.exports = {};
      }, {}], 191: [function(require2, module3, exports3) {
        module3.exports = function(a2, b) {
          try {
            arguments.length === 1 ? index$2.__f__("error", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:14038", a2) : index$2.__f__("error", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:14038", a2, b);
          } catch (error2) {
          }
        };
      }, {}], 192: [function(require2, module3, exports3) {
        var getBuiltIn = require2("../internals/get-built-in");
        module3.exports = getBuiltIn("document", "documentElement");
      }, { "../internals/get-built-in": 182 }], 193: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var fails = require2("../internals/fails");
        var createElement = require2("../internals/document-create-element");
        module3.exports = !DESCRIPTORS && !fails(function() {
          return Object.defineProperty(createElement("div"), "a", {
            get: function() {
              return 7;
            }
          }).a !== 7;
        });
      }, { "../internals/descriptors": 153, "../internals/document-create-element": 154, "../internals/fails": 171 }], 194: [function(require2, module3, exports3) {
        var $Array = Array;
        var abs = Math.abs;
        var pow = Math.pow;
        var floor = Math.floor;
        var log2 = Math.log;
        var LN2 = Math.LN2;
        var pack2 = function(number2, mantissaLength, bytes) {
          var buffer2 = $Array(bytes);
          var exponentLength = bytes * 8 - mantissaLength - 1;
          var eMax = (1 << exponentLength) - 1;
          var eBias = eMax >> 1;
          var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
          var sign = number2 < 0 || number2 === 0 && 1 / number2 < 0 ? 1 : 0;
          var index2 = 0;
          var exponent, mantissa, c;
          number2 = abs(number2);
          if (number2 !== number2 || number2 === Infinity) {
            mantissa = number2 !== number2 ? 1 : 0;
            exponent = eMax;
          } else {
            exponent = floor(log2(number2) / LN2);
            c = pow(2, -exponent);
            if (number2 * c < 1) {
              exponent--;
              c *= 2;
            }
            if (exponent + eBias >= 1) {
              number2 += rt / c;
            } else {
              number2 += rt * pow(2, 1 - eBias);
            }
            if (number2 * c >= 2) {
              exponent++;
              c /= 2;
            }
            if (exponent + eBias >= eMax) {
              mantissa = 0;
              exponent = eMax;
            } else if (exponent + eBias >= 1) {
              mantissa = (number2 * c - 1) * pow(2, mantissaLength);
              exponent += eBias;
            } else {
              mantissa = number2 * pow(2, eBias - 1) * pow(2, mantissaLength);
              exponent = 0;
            }
          }
          while (mantissaLength >= 8) {
            buffer2[index2++] = mantissa & 255;
            mantissa /= 256;
            mantissaLength -= 8;
          }
          exponent = exponent << mantissaLength | mantissa;
          exponentLength += mantissaLength;
          while (exponentLength > 0) {
            buffer2[index2++] = exponent & 255;
            exponent /= 256;
            exponentLength -= 8;
          }
          buffer2[--index2] |= sign * 128;
          return buffer2;
        };
        var unpack = function(buffer2, mantissaLength) {
          var bytes = buffer2.length;
          var exponentLength = bytes * 8 - mantissaLength - 1;
          var eMax = (1 << exponentLength) - 1;
          var eBias = eMax >> 1;
          var nBits = exponentLength - 7;
          var index2 = bytes - 1;
          var sign = buffer2[index2--];
          var exponent = sign & 127;
          var mantissa;
          sign >>= 7;
          while (nBits > 0) {
            exponent = exponent * 256 + buffer2[index2--];
            nBits -= 8;
          }
          mantissa = exponent & (1 << -nBits) - 1;
          exponent >>= -nBits;
          nBits += mantissaLength;
          while (nBits > 0) {
            mantissa = mantissa * 256 + buffer2[index2--];
            nBits -= 8;
          }
          if (exponent === 0) {
            exponent = 1 - eBias;
          } else if (exponent === eMax) {
            return mantissa ? NaN : sign ? -Infinity : Infinity;
          } else {
            mantissa += pow(2, mantissaLength);
            exponent -= eBias;
          }
          return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
        };
        module3.exports = {
          pack: pack2,
          unpack
        };
      }, {}], 195: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var classof = require2("../internals/classof-raw");
        var $Object = Object;
        var split = uncurryThis("".split);
        module3.exports = fails(function() {
          return !$Object("z").propertyIsEnumerable(0);
        }) ? function(it) {
          return classof(it) === "String" ? split(it, "") : $Object(it);
        } : $Object;
      }, { "../internals/classof-raw": 137, "../internals/fails": 171, "../internals/function-uncurry-this": 181 }], 196: [function(require2, module3, exports3) {
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var setPrototypeOf = require2("../internals/object-set-prototype-of");
        module3.exports = function($this, dummy, Wrapper) {
          var NewTarget, NewTargetPrototype;
          if (
            // it can work only with native `setPrototypeOf`
            setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
            isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
          )
            setPrototypeOf($this, NewTargetPrototype);
          return $this;
        };
      }, { "../internals/is-callable": 203, "../internals/is-object": 208, "../internals/object-set-prototype-of": 242 }], 197: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isCallable = require2("../internals/is-callable");
        var store = require2("../internals/shared-store");
        var functionToString = uncurryThis(Function.toString);
        if (!isCallable(store.inspectSource)) {
          store.inspectSource = function(it) {
            return functionToString(it);
          };
        }
        module3.exports = store.inspectSource;
      }, { "../internals/function-uncurry-this": 181, "../internals/is-callable": 203, "../internals/shared-store": 268 }], 198: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var hiddenKeys = require2("../internals/hidden-keys");
        var isObject2 = require2("../internals/is-object");
        var hasOwn2 = require2("../internals/has-own-property");
        var defineProperty = require2("../internals/object-define-property").f;
        var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
        var getOwnPropertyNamesExternalModule = require2("../internals/object-get-own-property-names-external");
        var isExtensible = require2("../internals/object-is-extensible");
        var uid2 = require2("../internals/uid");
        var FREEZING = require2("../internals/freezing");
        var REQUIRED = false;
        var METADATA = uid2("meta");
        var id = 0;
        var setMetadata = function(it) {
          defineProperty(it, METADATA, { value: {
            objectID: "O" + id++,
            // object ID
            weakData: {}
            // weak collections IDs
          } });
        };
        var fastKey = function(it, create3) {
          if (!isObject2(it))
            return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
          if (!hasOwn2(it, METADATA)) {
            if (!isExtensible(it))
              return "F";
            if (!create3)
              return "E";
            setMetadata(it);
          }
          return it[METADATA].objectID;
        };
        var getWeakData = function(it, create3) {
          if (!hasOwn2(it, METADATA)) {
            if (!isExtensible(it))
              return true;
            if (!create3)
              return false;
            setMetadata(it);
          }
          return it[METADATA].weakData;
        };
        var onFreeze = function(it) {
          if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn2(it, METADATA))
            setMetadata(it);
          return it;
        };
        var enable = function() {
          meta.enable = function() {
          };
          REQUIRED = true;
          var getOwnPropertyNames = getOwnPropertyNamesModule.f;
          var splice = uncurryThis([].splice);
          var test2 = {};
          test2[METADATA] = 1;
          if (getOwnPropertyNames(test2).length) {
            getOwnPropertyNamesModule.f = function(it) {
              var result = getOwnPropertyNames(it);
              for (var i = 0, length = result.length; i < length; i++) {
                if (result[i] === METADATA) {
                  splice(result, i, 1);
                  break;
                }
              }
              return result;
            };
            $({ target: "Object", stat: true, forced: true }, {
              getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
            });
          }
        };
        var meta = module3.exports = {
          enable,
          fastKey,
          getWeakData,
          onFreeze
        };
        hiddenKeys[METADATA] = true;
      }, { "../internals/export": 170, "../internals/freezing": 173, "../internals/function-uncurry-this": 181, "../internals/has-own-property": 189, "../internals/hidden-keys": 190, "../internals/is-object": 208, "../internals/object-define-property": 231, "../internals/object-get-own-property-names": 234, "../internals/object-get-own-property-names-external": 233, "../internals/object-is-extensible": 237, "../internals/uid": 299 }], 199: [function(require2, module3, exports3) {
        var NATIVE_WEAK_MAP = require2("../internals/weak-map-basic-detection");
        var global3 = require2("../internals/global");
        var isObject2 = require2("../internals/is-object");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var hasOwn2 = require2("../internals/has-own-property");
        var shared = require2("../internals/shared-store");
        var sharedKey = require2("../internals/shared-key");
        var hiddenKeys = require2("../internals/hidden-keys");
        var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
        var TypeError2 = global3.TypeError;
        var WeakMap2 = global3.WeakMap;
        var set2, get3, has2;
        var enforce = function(it) {
          return has2(it) ? get3(it) : set2(it, {});
        };
        var getterFor = function(TYPE) {
          return function(it) {
            var state;
            if (!isObject2(it) || (state = get3(it)).type !== TYPE) {
              throw new TypeError2("Incompatible receiver, " + TYPE + " required");
            }
            return state;
          };
        };
        if (NATIVE_WEAK_MAP || shared.state) {
          var store = shared.state || (shared.state = new WeakMap2());
          store.get = store.get;
          store.has = store.has;
          store.set = store.set;
          set2 = function(it, metadata) {
            if (store.has(it))
              throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            store.set(it, metadata);
            return metadata;
          };
          get3 = function(it) {
            return store.get(it) || {};
          };
          has2 = function(it) {
            return store.has(it);
          };
        } else {
          var STATE = sharedKey("state");
          hiddenKeys[STATE] = true;
          set2 = function(it, metadata) {
            if (hasOwn2(it, STATE))
              throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            createNonEnumerableProperty(it, STATE, metadata);
            return metadata;
          };
          get3 = function(it) {
            return hasOwn2(it, STATE) ? it[STATE] : {};
          };
          has2 = function(it) {
            return hasOwn2(it, STATE);
          };
        }
        module3.exports = {
          set: set2,
          get: get3,
          has: has2,
          enforce,
          getterFor
        };
      }, { "../internals/create-non-enumerable-property": 145, "../internals/global": 188, "../internals/has-own-property": 189, "../internals/hidden-keys": 190, "../internals/is-object": 208, "../internals/shared-key": 267, "../internals/shared-store": 268, "../internals/weak-map-basic-detection": 303 }], 200: [function(require2, module3, exports3) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var Iterators = require2("../internals/iterators");
        var ITERATOR = wellKnownSymbol("iterator");
        var ArrayPrototype = Array.prototype;
        module3.exports = function(it) {
          return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
        };
      }, { "../internals/iterators": 218, "../internals/well-known-symbol": 306 }], 201: [function(require2, module3, exports3) {
        var classof = require2("../internals/classof-raw");
        module3.exports = Array.isArray || function isArray2(argument) {
          return classof(argument) === "Array";
        };
      }, { "../internals/classof-raw": 137 }], 202: [function(require2, module3, exports3) {
        var classof = require2("../internals/classof");
        module3.exports = function(it) {
          var klass = classof(it);
          return klass === "BigInt64Array" || klass === "BigUint64Array";
        };
      }, { "../internals/classof": 138 }], 203: [function(require2, module3, exports3) {
        var documentAll = typeof document == "object" && document.all;
        module3.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
          return typeof argument == "function" || argument === documentAll;
        } : function(argument) {
          return typeof argument == "function";
        };
      }, {}], 204: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var isCallable = require2("../internals/is-callable");
        var classof = require2("../internals/classof");
        var getBuiltIn = require2("../internals/get-built-in");
        var inspectSource = require2("../internals/inspect-source");
        var noop2 = function() {
        };
        var empty2 = [];
        var construct = getBuiltIn("Reflect", "construct");
        var constructorRegExp = /^\s*(?:class|function)\b/;
        var exec = uncurryThis(constructorRegExp.exec);
        var INCORRECT_TO_STRING = !constructorRegExp.test(noop2);
        var isConstructorModern = function isConstructor(argument) {
          if (!isCallable(argument))
            return false;
          try {
            construct(noop2, empty2, argument);
            return true;
          } catch (error2) {
            return false;
          }
        };
        var isConstructorLegacy = function isConstructor(argument) {
          if (!isCallable(argument))
            return false;
          switch (classof(argument)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
          } catch (error2) {
            return true;
          }
        };
        isConstructorLegacy.sham = true;
        module3.exports = !construct || fails(function() {
          var called;
          return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
            called = true;
          }) || called;
        }) ? isConstructorLegacy : isConstructorModern;
      }, { "../internals/classof": 138, "../internals/fails": 171, "../internals/function-uncurry-this": 181, "../internals/get-built-in": 182, "../internals/inspect-source": 197, "../internals/is-callable": 203 }], 205: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        var isCallable = require2("../internals/is-callable");
        var replacement = /#|\.prototype\./;
        var isForced = function(feature, detection) {
          var value = data[normalize(feature)];
          return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
        };
        var normalize = isForced.normalize = function(string2) {
          return String(string2).replace(replacement, ".").toLowerCase();
        };
        var data = isForced.data = {};
        var NATIVE = isForced.NATIVE = "N";
        var POLYFILL = isForced.POLYFILL = "P";
        module3.exports = isForced;
      }, { "../internals/fails": 171, "../internals/is-callable": 203 }], 206: [function(require2, module3, exports3) {
        var isObject2 = require2("../internals/is-object");
        var floor = Math.floor;
        module3.exports = Number.isInteger || function isInteger(it) {
          return !isObject2(it) && isFinite(it) && floor(it) === it;
        };
      }, { "../internals/is-object": 208 }], 207: [function(require2, module3, exports3) {
        module3.exports = function(it) {
          return it === null || it === void 0;
        };
      }, {}], 208: [function(require2, module3, exports3) {
        var isCallable = require2("../internals/is-callable");
        module3.exports = function(it) {
          return typeof it == "object" ? it !== null : isCallable(it);
        };
      }, { "../internals/is-callable": 203 }], 209: [function(require2, module3, exports3) {
        var isObject2 = require2("../internals/is-object");
        module3.exports = function(argument) {
          return isObject2(argument) || argument === null;
        };
      }, { "../internals/is-object": 208 }], 210: [function(require2, module3, exports3) {
        module3.exports = false;
      }, {}], 211: [function(require2, module3, exports3) {
        var isObject2 = require2("../internals/is-object");
        var classof = require2("../internals/classof-raw");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var MATCH = wellKnownSymbol("match");
        module3.exports = function(it) {
          var isRegExp;
          return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) === "RegExp");
        };
      }, { "../internals/classof-raw": 137, "../internals/is-object": 208, "../internals/well-known-symbol": 306 }], 212: [function(require2, module3, exports3) {
        var getBuiltIn = require2("../internals/get-built-in");
        var isCallable = require2("../internals/is-callable");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var USE_SYMBOL_AS_UID = require2("../internals/use-symbol-as-uid");
        var $Object = Object;
        module3.exports = USE_SYMBOL_AS_UID ? function(it) {
          return typeof it == "symbol";
        } : function(it) {
          var $Symbol = getBuiltIn("Symbol");
          return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
        };
      }, { "../internals/get-built-in": 182, "../internals/is-callable": 203, "../internals/object-is-prototype-of": 238, "../internals/use-symbol-as-uid": 300 }], 213: [function(require2, module3, exports3) {
        var bind = require2("../internals/function-bind-context");
        var call = require2("../internals/function-call");
        var anObject = require2("../internals/an-object");
        var tryToString = require2("../internals/try-to-string");
        var isArrayIteratorMethod = require2("../internals/is-array-iterator-method");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var getIterator = require2("../internals/get-iterator");
        var getIteratorMethod = require2("../internals/get-iterator-method");
        var iteratorClose = require2("../internals/iterator-close");
        var $TypeError = TypeError;
        var Result = function(stopped, result) {
          this.stopped = stopped;
          this.result = result;
        };
        var ResultPrototype = Result.prototype;
        module3.exports = function(iterable, unboundFunction, options) {
          var that = options && options.that;
          var AS_ENTRIES = !!(options && options.AS_ENTRIES);
          var IS_RECORD = !!(options && options.IS_RECORD);
          var IS_ITERATOR = !!(options && options.IS_ITERATOR);
          var INTERRUPTED = !!(options && options.INTERRUPTED);
          var fn = bind(unboundFunction, that);
          var iterator, iterFn, index2, length, result, next, step;
          var stop = function(condition) {
            if (iterator)
              iteratorClose(iterator, "normal", condition);
            return new Result(true, condition);
          };
          var callFn = function(value) {
            if (AS_ENTRIES) {
              anObject(value);
              return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
            }
            return INTERRUPTED ? fn(value, stop) : fn(value);
          };
          if (IS_RECORD) {
            iterator = iterable.iterator;
          } else if (IS_ITERATOR) {
            iterator = iterable;
          } else {
            iterFn = getIteratorMethod(iterable);
            if (!iterFn)
              throw new $TypeError(tryToString(iterable) + " is not iterable");
            if (isArrayIteratorMethod(iterFn)) {
              for (index2 = 0, length = lengthOfArrayLike(iterable); length > index2; index2++) {
                result = callFn(iterable[index2]);
                if (result && isPrototypeOf(ResultPrototype, result))
                  return result;
              }
              return new Result(false);
            }
            iterator = getIterator(iterable, iterFn);
          }
          next = IS_RECORD ? iterable.next : iterator.next;
          while (!(step = call(next, iterator)).done) {
            try {
              result = callFn(step.value);
            } catch (error2) {
              iteratorClose(iterator, "throw", error2);
            }
            if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        };
      }, { "../internals/an-object": 114, "../internals/function-bind-context": 175, "../internals/function-call": 177, "../internals/get-iterator": 184, "../internals/get-iterator-method": 183, "../internals/is-array-iterator-method": 200, "../internals/iterator-close": 214, "../internals/length-of-array-like": 219, "../internals/object-is-prototype-of": 238, "../internals/try-to-string": 293 }], 214: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var anObject = require2("../internals/an-object");
        var getMethod = require2("../internals/get-method");
        module3.exports = function(iterator, kind, value) {
          var innerResult, innerError;
          anObject(iterator);
          try {
            innerResult = getMethod(iterator, "return");
            if (!innerResult) {
              if (kind === "throw")
                throw value;
              return value;
            }
            innerResult = call(innerResult, iterator);
          } catch (error2) {
            innerError = true;
            innerResult = error2;
          }
          if (kind === "throw")
            throw value;
          if (innerError)
            throw innerResult;
          anObject(innerResult);
          return value;
        };
      }, { "../internals/an-object": 114, "../internals/function-call": 177, "../internals/get-method": 186 }], 215: [function(require2, module3, exports3) {
        var IteratorPrototype = require2("../internals/iterators-core").IteratorPrototype;
        var create3 = require2("../internals/object-create");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var Iterators = require2("../internals/iterators");
        var returnThis = function() {
          return this;
        };
        module3.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
          var TO_STRING_TAG = NAME + " Iterator";
          IteratorConstructor.prototype = create3(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
          setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
          Iterators[TO_STRING_TAG] = returnThis;
          return IteratorConstructor;
        };
      }, { "../internals/create-property-descriptor": 146, "../internals/iterators": 218, "../internals/iterators-core": 217, "../internals/object-create": 229, "../internals/set-to-string-tag": 266 }], 216: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var call = require2("../internals/function-call");
        var IS_PURE = require2("../internals/is-pure");
        var FunctionName = require2("../internals/function-name");
        var isCallable = require2("../internals/is-callable");
        var createIteratorConstructor = require2("../internals/iterator-create-constructor");
        var getPrototypeOf = require2("../internals/object-get-prototype-of");
        var setPrototypeOf = require2("../internals/object-set-prototype-of");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var defineBuiltIn = require2("../internals/define-built-in");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var Iterators = require2("../internals/iterators");
        var IteratorsCore = require2("../internals/iterators-core");
        var PROPER_FUNCTION_NAME = FunctionName.PROPER;
        var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
        var IteratorPrototype = IteratorsCore.IteratorPrototype;
        var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
        var ITERATOR = wellKnownSymbol("iterator");
        var KEYS = "keys";
        var VALUES = "values";
        var ENTRIES = "entries";
        var returnThis = function() {
          return this;
        };
        module3.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT2, IS_SET, FORCED) {
          createIteratorConstructor(IteratorConstructor, NAME, next);
          var getIterationMethod = function(KIND) {
            if (KIND === DEFAULT2 && defaultIterator)
              return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
              return IterablePrototype[KIND];
            switch (KIND) {
              case KEYS:
                return function keys() {
                  return new IteratorConstructor(this, KIND);
                };
              case VALUES:
                return function values() {
                  return new IteratorConstructor(this, KIND);
                };
              case ENTRIES:
                return function entries() {
                  return new IteratorConstructor(this, KIND);
                };
            }
            return function() {
              return new IteratorConstructor(this);
            };
          };
          var TO_STRING_TAG = NAME + " Iterator";
          var INCORRECT_VALUES_NAME = false;
          var IterablePrototype = Iterable.prototype;
          var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT2 && IterablePrototype[DEFAULT2];
          var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT2);
          var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
          var CurrentIteratorPrototype, methods, KEY;
          if (anyNativeIterator) {
            CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
            if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
              if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) {
                  setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                  defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
                }
              }
              setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
              if (IS_PURE)
                Iterators[TO_STRING_TAG] = returnThis;
            }
          }
          if (PROPER_FUNCTION_NAME && DEFAULT2 === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
            if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
              createNonEnumerableProperty(IterablePrototype, "name", VALUES);
            } else {
              INCORRECT_VALUES_NAME = true;
              defaultIterator = function values() {
                return call(nativeIterator, this);
              };
            }
          }
          if (DEFAULT2) {
            methods = {
              values: getIterationMethod(VALUES),
              keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
              entries: getIterationMethod(ENTRIES)
            };
            if (FORCED)
              for (KEY in methods) {
                if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                  defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
                }
              }
            else
              $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
          }
          if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
            defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT2 });
          }
          Iterators[NAME] = defaultIterator;
          return methods;
        };
      }, { "../internals/create-non-enumerable-property": 145, "../internals/define-built-in": 149, "../internals/export": 170, "../internals/function-call": 177, "../internals/function-name": 178, "../internals/is-callable": 203, "../internals/is-pure": 210, "../internals/iterator-create-constructor": 215, "../internals/iterators": 218, "../internals/iterators-core": 217, "../internals/object-get-prototype-of": 236, "../internals/object-set-prototype-of": 242, "../internals/set-to-string-tag": 266, "../internals/well-known-symbol": 306 }], 217: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var create3 = require2("../internals/object-create");
        var getPrototypeOf = require2("../internals/object-get-prototype-of");
        var defineBuiltIn = require2("../internals/define-built-in");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var IS_PURE = require2("../internals/is-pure");
        var ITERATOR = wellKnownSymbol("iterator");
        var BUGGY_SAFARI_ITERATORS = false;
        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
        if ([].keys) {
          arrayIterator = [].keys();
          if (!("next" in arrayIterator))
            BUGGY_SAFARI_ITERATORS = true;
          else {
            PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
              IteratorPrototype = PrototypeOfArrayIteratorPrototype;
          }
        }
        var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails(function() {
          var test2 = {};
          return IteratorPrototype[ITERATOR].call(test2) !== test2;
        });
        if (NEW_ITERATOR_PROTOTYPE)
          IteratorPrototype = {};
        else if (IS_PURE)
          IteratorPrototype = create3(IteratorPrototype);
        if (!isCallable(IteratorPrototype[ITERATOR])) {
          defineBuiltIn(IteratorPrototype, ITERATOR, function() {
            return this;
          });
        }
        module3.exports = {
          IteratorPrototype,
          BUGGY_SAFARI_ITERATORS
        };
      }, { "../internals/define-built-in": 149, "../internals/fails": 171, "../internals/is-callable": 203, "../internals/is-object": 208, "../internals/is-pure": 210, "../internals/object-create": 229, "../internals/object-get-prototype-of": 236, "../internals/well-known-symbol": 306 }], 218: [function(require2, module3, exports3) {
        arguments[4][190][0].apply(exports3, arguments);
      }, { "dup": 190 }], 219: [function(require2, module3, exports3) {
        var toLength = require2("../internals/to-length");
        module3.exports = function(obj) {
          return toLength(obj.length);
        };
      }, { "../internals/to-length": 284 }], 220: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var isCallable = require2("../internals/is-callable");
        var hasOwn2 = require2("../internals/has-own-property");
        var DESCRIPTORS = require2("../internals/descriptors");
        var CONFIGURABLE_FUNCTION_NAME = require2("../internals/function-name").CONFIGURABLE;
        var inspectSource = require2("../internals/inspect-source");
        var InternalStateModule = require2("../internals/internal-state");
        var enforceInternalState = InternalStateModule.enforce;
        var getInternalState = InternalStateModule.get;
        var $String = String;
        var defineProperty = Object.defineProperty;
        var stringSlice = uncurryThis("".slice);
        var replace = uncurryThis("".replace);
        var join = uncurryThis([].join);
        var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
          return defineProperty(function() {
          }, "length", { value: 8 }).length !== 8;
        });
        var TEMPLATE = String(String).split("String");
        var makeBuiltIn = module3.exports = function(value, name, options) {
          if (stringSlice($String(name), 0, 7) === "Symbol(") {
            name = "[" + replace($String(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
          }
          if (options && options.getter)
            name = "get " + name;
          if (options && options.setter)
            name = "set " + name;
          if (!hasOwn2(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
            if (DESCRIPTORS)
              defineProperty(value, "name", { value: name, configurable: true });
            else
              value.name = name;
          }
          if (CONFIGURABLE_LENGTH && options && hasOwn2(options, "arity") && value.length !== options.arity) {
            defineProperty(value, "length", { value: options.arity });
          }
          try {
            if (options && hasOwn2(options, "constructor") && options.constructor) {
              if (DESCRIPTORS)
                defineProperty(value, "prototype", { writable: false });
            } else if (value.prototype)
              value.prototype = void 0;
          } catch (error2) {
          }
          var state = enforceInternalState(value);
          if (!hasOwn2(state, "source")) {
            state.source = join(TEMPLATE, typeof name == "string" ? name : "");
          }
          return value;
        };
        Function.prototype.toString = makeBuiltIn(function toString2() {
          return isCallable(this) && getInternalState(this).source || inspectSource(this);
        }, "toString");
      }, { "../internals/descriptors": 153, "../internals/fails": 171, "../internals/function-name": 178, "../internals/function-uncurry-this": 181, "../internals/has-own-property": 189, "../internals/inspect-source": 197, "../internals/internal-state": 199, "../internals/is-callable": 203 }], 221: [function(require2, module3, exports3) {
        var sign = require2("../internals/math-sign");
        var abs = Math.abs;
        var EPSILON = 2220446049250313e-31;
        var INVERSE_EPSILON = 1 / EPSILON;
        var roundTiesToEven = function(n2) {
          return n2 + INVERSE_EPSILON - INVERSE_EPSILON;
        };
        module3.exports = function(x, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
          var n2 = +x;
          var absolute = abs(n2);
          var s2 = sign(n2);
          if (absolute < FLOAT_MIN_VALUE)
            return s2 * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
          var a2 = (1 + FLOAT_EPSILON / EPSILON) * absolute;
          var result = a2 - (a2 - absolute);
          if (result > FLOAT_MAX_VALUE || result !== result)
            return s2 * Infinity;
          return s2 * result;
        };
      }, { "../internals/math-sign": 223 }], 222: [function(require2, module3, exports3) {
        var floatRound = require2("../internals/math-float-round");
        var FLOAT32_EPSILON = 11920928955078125e-23;
        var FLOAT32_MAX_VALUE = 34028234663852886e22;
        var FLOAT32_MIN_VALUE = 11754943508222875e-54;
        module3.exports = Math.fround || function fround(x) {
          return floatRound(x, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
        };
      }, { "../internals/math-float-round": 221 }], 223: [function(require2, module3, exports3) {
        module3.exports = Math.sign || function sign(x) {
          var n2 = +x;
          return n2 === 0 || n2 !== n2 ? n2 : n2 < 0 ? -1 : 1;
        };
      }, {}], 224: [function(require2, module3, exports3) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module3.exports = Math.trunc || function trunc(x) {
          var n2 = +x;
          return (n2 > 0 ? floor : ceil)(n2);
        };
      }, {}], 225: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var safeGetBuiltIn = require2("../internals/safe-get-built-in");
        var bind = require2("../internals/function-bind-context");
        var macrotask = require2("../internals/task").set;
        var Queue = require2("../internals/queue");
        var IS_IOS = require2("../internals/engine-is-ios");
        var IS_IOS_PEBBLE = require2("../internals/engine-is-ios-pebble");
        var IS_WEBOS_WEBKIT = require2("../internals/engine-is-webos-webkit");
        var IS_NODE = require2("../internals/engine-is-node");
        var MutationObserver = global3.MutationObserver || global3.WebKitMutationObserver;
        var document2 = global3.document;
        var process = global3.process;
        var Promise2 = global3.Promise;
        var microtask = safeGetBuiltIn("queueMicrotask");
        var notify2, toggle, node, promise2, then;
        if (!microtask) {
          var queue2 = new Queue();
          var flush = function() {
            var parent, fn;
            if (IS_NODE && (parent = process.domain))
              parent.exit();
            while (fn = queue2.get())
              try {
                fn();
              } catch (error2) {
                if (queue2.head)
                  notify2();
                throw error2;
              }
            if (parent)
              parent.enter();
          };
          if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
            toggle = true;
            node = document2.createTextNode("");
            new MutationObserver(flush).observe(node, { characterData: true });
            notify2 = function() {
              node.data = toggle = !toggle;
            };
          } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
            promise2 = Promise2.resolve(void 0);
            promise2.constructor = Promise2;
            then = bind(promise2.then, promise2);
            notify2 = function() {
              then(flush);
            };
          } else if (IS_NODE) {
            notify2 = function() {
              process.nextTick(flush);
            };
          } else {
            macrotask = bind(macrotask, global3);
            notify2 = function() {
              macrotask(flush);
            };
          }
          microtask = function(fn) {
            if (!queue2.head)
              notify2();
            queue2.add(fn);
          };
        }
        module3.exports = microtask;
      }, { "../internals/engine-is-ios": 163, "../internals/engine-is-ios-pebble": 162, "../internals/engine-is-node": 164, "../internals/engine-is-webos-webkit": 165, "../internals/function-bind-context": 175, "../internals/global": 188, "../internals/queue": 254, "../internals/safe-get-built-in": 263, "../internals/task": 277 }], 226: [function(require2, module3, exports3) {
        var aCallable = require2("../internals/a-callable");
        var $TypeError = TypeError;
        var PromiseCapability = function(C) {
          var resolve2, reject;
          this.promise = new C(function($$resolve, $$reject) {
            if (resolve2 !== void 0 || reject !== void 0)
              throw new $TypeError("Bad Promise constructor");
            resolve2 = $$resolve;
            reject = $$reject;
          });
          this.resolve = aCallable(resolve2);
          this.reject = aCallable(reject);
        };
        module3.exports.f = function(C) {
          return new PromiseCapability(C);
        };
      }, { "../internals/a-callable": 108 }], 227: [function(require2, module3, exports3) {
        var isRegExp = require2("../internals/is-regexp");
        var $TypeError = TypeError;
        module3.exports = function(it) {
          if (isRegExp(it)) {
            throw new $TypeError("The method doesn't accept regular expressions");
          }
          return it;
        };
      }, { "../internals/is-regexp": 211 }], 228: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var call = require2("../internals/function-call");
        var fails = require2("../internals/fails");
        var objectKeys2 = require2("../internals/object-keys");
        var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
        var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
        var toObject = require2("../internals/to-object");
        var IndexedObject = require2("../internals/indexed-object");
        var $assign = Object.assign;
        var defineProperty = Object.defineProperty;
        var concat = uncurryThis([].concat);
        module3.exports = !$assign || fails(function() {
          if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
            enumerable: true,
            get: function() {
              defineProperty(this, "b", {
                value: 3,
                enumerable: false
              });
            }
          }), { b: 2 })).b !== 1)
            return true;
          var A2 = {};
          var B = {};
          var symbol = Symbol("assign detection");
          var alphabet = "abcdefghijklmnopqrst";
          A2[symbol] = 7;
          alphabet.split("").forEach(function(chr) {
            B[chr] = chr;
          });
          return $assign({}, A2)[symbol] !== 7 || objectKeys2($assign({}, B)).join("") !== alphabet;
        }) ? function assign2(target, source) {
          var T2 = toObject(target);
          var argumentsLength = arguments.length;
          var index2 = 1;
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          var propertyIsEnumerable = propertyIsEnumerableModule.f;
          while (argumentsLength > index2) {
            var S = IndexedObject(arguments[index2++]);
            var keys = getOwnPropertySymbols ? concat(objectKeys2(S), getOwnPropertySymbols(S)) : objectKeys2(S);
            var length = keys.length;
            var j = 0;
            var key;
            while (length > j) {
              key = keys[j++];
              if (!DESCRIPTORS || call(propertyIsEnumerable, S, key))
                T2[key] = S[key];
            }
          }
          return T2;
        } : $assign;
      }, { "../internals/descriptors": 153, "../internals/fails": 171, "../internals/function-call": 177, "../internals/function-uncurry-this": 181, "../internals/indexed-object": 195, "../internals/object-get-own-property-symbols": 235, "../internals/object-keys": 240, "../internals/object-property-is-enumerable": 241, "../internals/to-object": 285 }], 229: [function(require2, module3, exports3) {
        var anObject = require2("../internals/an-object");
        var definePropertiesModule = require2("../internals/object-define-properties");
        var enumBugKeys = require2("../internals/enum-bug-keys");
        var hiddenKeys = require2("../internals/hidden-keys");
        var html = require2("../internals/html");
        var documentCreateElement = require2("../internals/document-create-element");
        var sharedKey = require2("../internals/shared-key");
        var GT = ">";
        var LT = "<";
        var PROTOTYPE = "prototype";
        var SCRIPT = "script";
        var IE_PROTO = sharedKey("IE_PROTO");
        var EmptyConstructor = function() {
        };
        var scriptTag = function(content2) {
          return LT + SCRIPT + GT + content2 + LT + "/" + SCRIPT + GT;
        };
        var NullProtoObjectViaActiveX = function(activeXDocument2) {
          activeXDocument2.write(scriptTag(""));
          activeXDocument2.close();
          var temp = activeXDocument2.parentWindow.Object;
          activeXDocument2 = null;
          return temp;
        };
        var NullProtoObjectViaIFrame = function() {
          var iframe = documentCreateElement("iframe");
          var JS = "java" + SCRIPT + ":";
          var iframeDocument;
          iframe.style.display = "none";
          html.appendChild(iframe);
          iframe.src = String(JS);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(scriptTag("document.F=Object"));
          iframeDocument.close();
          return iframeDocument.F;
        };
        var activeXDocument;
        var NullProtoObject = function() {
          try {
            activeXDocument = new ActiveXObject("htmlfile");
          } catch (error2) {
          }
          NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
          var length = enumBugKeys.length;
          while (length--)
            delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
          return NullProtoObject();
        };
        hiddenKeys[IE_PROTO] = true;
        module3.exports = Object.create || function create3(O, Properties) {
          var result;
          if (O !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else
            result = NullProtoObject();
          return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
        };
      }, { "../internals/an-object": 114, "../internals/document-create-element": 154, "../internals/enum-bug-keys": 169, "../internals/hidden-keys": 190, "../internals/html": 192, "../internals/object-define-properties": 230, "../internals/shared-key": 267 }], 230: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var V8_PROTOTYPE_DEFINE_BUG = require2("../internals/v8-prototype-define-bug");
        var definePropertyModule = require2("../internals/object-define-property");
        var anObject = require2("../internals/an-object");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var objectKeys2 = require2("../internals/object-keys");
        exports3.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var props2 = toIndexedObject(Properties);
          var keys = objectKeys2(Properties);
          var length = keys.length;
          var index2 = 0;
          var key;
          while (length > index2)
            definePropertyModule.f(O, key = keys[index2++], props2[key]);
          return O;
        };
      }, { "../internals/an-object": 114, "../internals/descriptors": 153, "../internals/object-define-property": 231, "../internals/object-keys": 240, "../internals/to-indexed-object": 282, "../internals/v8-prototype-define-bug": 301 }], 231: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var IE8_DOM_DEFINE = require2("../internals/ie8-dom-define");
        var V8_PROTOTYPE_DEFINE_BUG = require2("../internals/v8-prototype-define-bug");
        var anObject = require2("../internals/an-object");
        var toPropertyKey = require2("../internals/to-property-key");
        var $TypeError = TypeError;
        var $defineProperty = Object.defineProperty;
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var ENUMERABLE = "enumerable";
        var CONFIGURABLE = "configurable";
        var WRITABLE = "writable";
        exports3.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPropertyKey(P);
          anObject(Attributes);
          if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
            var current = $getOwnPropertyDescriptor(O, P);
            if (current && current[WRITABLE]) {
              O[P] = Attributes.value;
              Attributes = {
                configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                writable: false
              };
            }
          }
          return $defineProperty(O, P, Attributes);
        } : $defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPropertyKey(P);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return $defineProperty(O, P, Attributes);
            } catch (error2) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw new $TypeError("Accessors not supported");
          if ("value" in Attributes)
            O[P] = Attributes.value;
          return O;
        };
      }, { "../internals/an-object": 114, "../internals/descriptors": 153, "../internals/ie8-dom-define": 193, "../internals/to-property-key": 289, "../internals/v8-prototype-define-bug": 301 }], 232: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var call = require2("../internals/function-call");
        var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var toPropertyKey = require2("../internals/to-property-key");
        var hasOwn2 = require2("../internals/has-own-property");
        var IE8_DOM_DEFINE = require2("../internals/ie8-dom-define");
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        exports3.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
          O = toIndexedObject(O);
          P = toPropertyKey(P);
          if (IE8_DOM_DEFINE)
            try {
              return $getOwnPropertyDescriptor(O, P);
            } catch (error2) {
            }
          if (hasOwn2(O, P))
            return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
        };
      }, { "../internals/create-property-descriptor": 146, "../internals/descriptors": 153, "../internals/function-call": 177, "../internals/has-own-property": 189, "../internals/ie8-dom-define": 193, "../internals/object-property-is-enumerable": 241, "../internals/to-indexed-object": 282, "../internals/to-property-key": 289 }], 233: [function(require2, module3, exports3) {
        var classof = require2("../internals/classof-raw");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var $getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var arraySlice = require2("../internals/array-slice");
        var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        var getWindowNames = function(it) {
          try {
            return $getOwnPropertyNames(it);
          } catch (error2) {
            return arraySlice(windowNames);
          }
        };
        module3.exports.f = function getOwnPropertyNames(it) {
          return windowNames && classof(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
        };
      }, { "../internals/array-slice": 131, "../internals/classof-raw": 137, "../internals/object-get-own-property-names": 234, "../internals/to-indexed-object": 282 }], 234: [function(require2, module3, exports3) {
        var internalObjectKeys = require2("../internals/object-keys-internal");
        var enumBugKeys = require2("../internals/enum-bug-keys");
        var hiddenKeys = enumBugKeys.concat("length", "prototype");
        exports3.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys);
        };
      }, { "../internals/enum-bug-keys": 169, "../internals/object-keys-internal": 239 }], 235: [function(require2, module3, exports3) {
        exports3.f = Object.getOwnPropertySymbols;
      }, {}], 236: [function(require2, module3, exports3) {
        var hasOwn2 = require2("../internals/has-own-property");
        var isCallable = require2("../internals/is-callable");
        var toObject = require2("../internals/to-object");
        var sharedKey = require2("../internals/shared-key");
        var CORRECT_PROTOTYPE_GETTER = require2("../internals/correct-prototype-getter");
        var IE_PROTO = sharedKey("IE_PROTO");
        var $Object = Object;
        var ObjectPrototype = $Object.prototype;
        module3.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
          var object2 = toObject(O);
          if (hasOwn2(object2, IE_PROTO))
            return object2[IE_PROTO];
          var constructor = object2.constructor;
          if (isCallable(constructor) && object2 instanceof constructor) {
            return constructor.prototype;
          }
          return object2 instanceof $Object ? ObjectPrototype : null;
        };
      }, { "../internals/correct-prototype-getter": 143, "../internals/has-own-property": 189, "../internals/is-callable": 203, "../internals/shared-key": 267, "../internals/to-object": 285 }], 237: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        var isObject2 = require2("../internals/is-object");
        var classof = require2("../internals/classof-raw");
        var ARRAY_BUFFER_NON_EXTENSIBLE = require2("../internals/array-buffer-non-extensible");
        var $isExtensible = Object.isExtensible;
        var FAILS_ON_PRIMITIVES = fails(function() {
        });
        module3.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
          if (!isObject2(it))
            return false;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === "ArrayBuffer")
            return false;
          return $isExtensible ? $isExtensible(it) : true;
        } : $isExtensible;
      }, { "../internals/array-buffer-non-extensible": 116, "../internals/classof-raw": 137, "../internals/fails": 171, "../internals/is-object": 208 }], 238: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        module3.exports = uncurryThis({}.isPrototypeOf);
      }, { "../internals/function-uncurry-this": 181 }], 239: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var hasOwn2 = require2("../internals/has-own-property");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var indexOf = require2("../internals/array-includes").indexOf;
        var hiddenKeys = require2("../internals/hidden-keys");
        var push = uncurryThis([].push);
        module3.exports = function(object2, names) {
          var O = toIndexedObject(object2);
          var i = 0;
          var result = [];
          var key;
          for (key in O)
            !hasOwn2(hiddenKeys, key) && hasOwn2(O, key) && push(result, key);
          while (names.length > i)
            if (hasOwn2(O, key = names[i++])) {
              ~indexOf(result, key) || push(result, key);
            }
          return result;
        };
      }, { "../internals/array-includes": 124, "../internals/function-uncurry-this": 181, "../internals/has-own-property": 189, "../internals/hidden-keys": 190, "../internals/to-indexed-object": 282 }], 240: [function(require2, module3, exports3) {
        var internalObjectKeys = require2("../internals/object-keys-internal");
        var enumBugKeys = require2("../internals/enum-bug-keys");
        module3.exports = Object.keys || function keys(O) {
          return internalObjectKeys(O, enumBugKeys);
        };
      }, { "../internals/enum-bug-keys": 169, "../internals/object-keys-internal": 239 }], 241: [function(require2, module3, exports3) {
        var $propertyIsEnumerable = {}.propertyIsEnumerable;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
        exports3.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
          var descriptor = getOwnPropertyDescriptor(this, V2);
          return !!descriptor && descriptor.enumerable;
        } : $propertyIsEnumerable;
      }, {}], 242: [function(require2, module3, exports3) {
        var uncurryThisAccessor = require2("../internals/function-uncurry-this-accessor");
        var anObject = require2("../internals/an-object");
        var aPossiblePrototype = require2("../internals/a-possible-prototype");
        module3.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var CORRECT_SETTER = false;
          var test2 = {};
          var setter;
          try {
            setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
            setter(test2, []);
            CORRECT_SETTER = test2 instanceof Array;
          } catch (error2) {
          }
          return function setPrototypeOf(O, proto) {
            anObject(O);
            aPossiblePrototype(proto);
            if (CORRECT_SETTER)
              setter(O, proto);
            else
              O.__proto__ = proto;
            return O;
          };
        }() : void 0);
      }, { "../internals/a-possible-prototype": 110, "../internals/an-object": 114, "../internals/function-uncurry-this-accessor": 179 }], 243: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var fails = require2("../internals/fails");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var objectGetPrototypeOf = require2("../internals/object-get-prototype-of");
        var objectKeys2 = require2("../internals/object-keys");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var $propertyIsEnumerable = require2("../internals/object-property-is-enumerable").f;
        var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
        var push = uncurryThis([].push);
        var IE_BUG = DESCRIPTORS && fails(function() {
          var O = /* @__PURE__ */ Object.create(null);
          O[2] = 2;
          return !propertyIsEnumerable(O, 2);
        });
        var createMethod = function(TO_ENTRIES) {
          return function(it) {
            var O = toIndexedObject(it);
            var keys = objectKeys2(O);
            var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
            var length = keys.length;
            var i = 0;
            var result = [];
            var key;
            while (length > i) {
              key = keys[i++];
              if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
                push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
              }
            }
            return result;
          };
        };
        module3.exports = {
          // `Object.entries` method
          // https://tc39.es/ecma262/#sec-object.entries
          entries: createMethod(true),
          // `Object.values` method
          // https://tc39.es/ecma262/#sec-object.values
          values: createMethod(false)
        };
      }, { "../internals/descriptors": 153, "../internals/fails": 171, "../internals/function-uncurry-this": 181, "../internals/object-get-prototype-of": 236, "../internals/object-keys": 240, "../internals/object-property-is-enumerable": 241, "../internals/to-indexed-object": 282 }], 244: [function(require2, module3, exports3) {
        var TO_STRING_TAG_SUPPORT = require2("../internals/to-string-tag-support");
        var classof = require2("../internals/classof");
        module3.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString2() {
          return "[object " + classof(this) + "]";
        };
      }, { "../internals/classof": 138, "../internals/to-string-tag-support": 290 }], 245: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var $TypeError = TypeError;
        module3.exports = function(input2, pref) {
          var fn, val;
          if (pref === "string" && isCallable(fn = input2.toString) && !isObject2(val = call(fn, input2)))
            return val;
          if (isCallable(fn = input2.valueOf) && !isObject2(val = call(fn, input2)))
            return val;
          if (pref !== "string" && isCallable(fn = input2.toString) && !isObject2(val = call(fn, input2)))
            return val;
          throw new $TypeError("Can't convert object to primitive value");
        };
      }, { "../internals/function-call": 177, "../internals/is-callable": 203, "../internals/is-object": 208 }], 246: [function(require2, module3, exports3) {
        var getBuiltIn = require2("../internals/get-built-in");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
        var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
        var anObject = require2("../internals/an-object");
        var concat = uncurryThis([].concat);
        module3.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
          var keys = getOwnPropertyNamesModule.f(anObject(it));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
        };
      }, { "../internals/an-object": 114, "../internals/function-uncurry-this": 181, "../internals/get-built-in": 182, "../internals/object-get-own-property-names": 234, "../internals/object-get-own-property-symbols": 235 }], 247: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        module3.exports = global3;
      }, { "../internals/global": 188 }], 248: [function(require2, module3, exports3) {
        module3.exports = function(exec) {
          try {
            return { error: false, value: exec() };
          } catch (error2) {
            return { error: true, value: error2 };
          }
        };
      }, {}], 249: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var isCallable = require2("../internals/is-callable");
        var isForced = require2("../internals/is-forced");
        var inspectSource = require2("../internals/inspect-source");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var IS_BROWSER = require2("../internals/engine-is-browser");
        var IS_DENO = require2("../internals/engine-is-deno");
        var IS_PURE = require2("../internals/is-pure");
        var V8_VERSION = require2("../internals/engine-v8-version");
        var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
        var SPECIES = wellKnownSymbol("species");
        var SUBCLASSING = false;
        var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global3.PromiseRejectionEvent);
        var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
          var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
          var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
          if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
            return true;
          if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
            return true;
          if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
            var promise2 = new NativePromiseConstructor(function(resolve2) {
              resolve2(1);
            });
            var FakePromise = function(exec) {
              exec(function() {
              }, function() {
              });
            };
            var constructor = promise2.constructor = {};
            constructor[SPECIES] = FakePromise;
            SUBCLASSING = promise2.then(function() {
            }) instanceof FakePromise;
            if (!SUBCLASSING)
              return true;
          }
          return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
        });
        module3.exports = {
          CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
          REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
          SUBCLASSING
        };
      }, { "../internals/engine-is-browser": 159, "../internals/engine-is-deno": 160, "../internals/engine-v8-version": 167, "../internals/global": 188, "../internals/inspect-source": 197, "../internals/is-callable": 203, "../internals/is-forced": 205, "../internals/is-pure": 210, "../internals/promise-native-constructor": 250, "../internals/well-known-symbol": 306 }], 250: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        module3.exports = global3.Promise;
      }, { "../internals/global": 188 }], 251: [function(require2, module3, exports3) {
        var anObject = require2("../internals/an-object");
        var isObject2 = require2("../internals/is-object");
        var newPromiseCapability = require2("../internals/new-promise-capability");
        module3.exports = function(C, x) {
          anObject(C);
          if (isObject2(x) && x.constructor === C)
            return x;
          var promiseCapability = newPromiseCapability.f(C);
          var resolve2 = promiseCapability.resolve;
          resolve2(x);
          return promiseCapability.promise;
        };
      }, { "../internals/an-object": 114, "../internals/is-object": 208, "../internals/new-promise-capability": 226 }], 252: [function(require2, module3, exports3) {
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
        var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
        module3.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
          NativePromiseConstructor.all(iterable).then(void 0, function() {
          });
        });
      }, { "../internals/check-correctness-of-iteration": 136, "../internals/promise-constructor-detection": 249, "../internals/promise-native-constructor": 250 }], 253: [function(require2, module3, exports3) {
        var defineProperty = require2("../internals/object-define-property").f;
        module3.exports = function(Target, Source, key) {
          key in Target || defineProperty(Target, key, {
            configurable: true,
            get: function() {
              return Source[key];
            },
            set: function(it) {
              Source[key] = it;
            }
          });
        };
      }, { "../internals/object-define-property": 231 }], 254: [function(require2, module3, exports3) {
        var Queue = function() {
          this.head = null;
          this.tail = null;
        };
        Queue.prototype = {
          add: function(item) {
            var entry = { item, next: null };
            var tail = this.tail;
            if (tail)
              tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
          },
          get: function() {
            var entry = this.head;
            if (entry) {
              var next = this.head = entry.next;
              if (next === null)
                this.tail = null;
              return entry.item;
            }
          }
        };
        module3.exports = Queue;
      }, {}], 255: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var anObject = require2("../internals/an-object");
        var isCallable = require2("../internals/is-callable");
        var classof = require2("../internals/classof-raw");
        var regexpExec = require2("../internals/regexp-exec");
        var $TypeError = TypeError;
        module3.exports = function(R, S) {
          var exec = R.exec;
          if (isCallable(exec)) {
            var result = call(exec, R, S);
            if (result !== null)
              anObject(result);
            return result;
          }
          if (classof(R) === "RegExp")
            return call(regexpExec, R, S);
          throw new $TypeError("RegExp#exec called on incompatible receiver");
        };
      }, { "../internals/an-object": 114, "../internals/classof-raw": 137, "../internals/function-call": 177, "../internals/is-callable": 203, "../internals/regexp-exec": 256 }], 256: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toString2 = require2("../internals/to-string");
        var regexpFlags = require2("../internals/regexp-flags");
        var stickyHelpers = require2("../internals/regexp-sticky-helpers");
        var shared = require2("../internals/shared");
        var create3 = require2("../internals/object-create");
        var getInternalState = require2("../internals/internal-state").get;
        var UNSUPPORTED_DOT_ALL = require2("../internals/regexp-unsupported-dot-all");
        var UNSUPPORTED_NCG = require2("../internals/regexp-unsupported-ncg");
        var nativeReplace = shared("native-string-replace", String.prototype.replace);
        var nativeExec = RegExp.prototype.exec;
        var patchedExec = nativeExec;
        var charAt = uncurryThis("".charAt);
        var indexOf = uncurryThis("".indexOf);
        var replace = uncurryThis("".replace);
        var stringSlice = uncurryThis("".slice);
        var UPDATES_LAST_INDEX_WRONG = function() {
          var re1 = /a/;
          var re2 = /b*/g;
          call(nativeExec, re1, "a");
          call(nativeExec, re2, "a");
          return re1.lastIndex !== 0 || re2.lastIndex !== 0;
        }();
        var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
        var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
        if (PATCH) {
          patchedExec = function exec(string2) {
            var re = this;
            var state = getInternalState(re);
            var str = toString2(string2);
            var raw = state.raw;
            var result, reCopy, lastIndex, match, i, object2, group;
            if (raw) {
              raw.lastIndex = re.lastIndex;
              result = call(patchedExec, raw, str);
              re.lastIndex = raw.lastIndex;
              return result;
            }
            var groups = state.groups;
            var sticky2 = UNSUPPORTED_Y && re.sticky;
            var flags = call(regexpFlags, re);
            var source = re.source;
            var charsAdded = 0;
            var strCopy = str;
            if (sticky2) {
              flags = replace(flags, "y", "");
              if (indexOf(flags, "g") === -1) {
                flags += "g";
              }
              strCopy = stringSlice(str, re.lastIndex);
              if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
                source = "(?: " + source + ")";
                strCopy = " " + strCopy;
                charsAdded++;
              }
              reCopy = new RegExp("^(?:" + source + ")", flags);
            }
            if (NPCG_INCLUDED) {
              reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
            }
            if (UPDATES_LAST_INDEX_WRONG)
              lastIndex = re.lastIndex;
            match = call(nativeExec, sticky2 ? reCopy : re, strCopy);
            if (sticky2) {
              if (match) {
                match.input = stringSlice(match.input, charsAdded);
                match[0] = stringSlice(match[0], charsAdded);
                match.index = re.lastIndex;
                re.lastIndex += match[0].length;
              } else
                re.lastIndex = 0;
            } else if (UPDATES_LAST_INDEX_WRONG && match) {
              re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match && match.length > 1) {
              call(nativeReplace, match[0], reCopy, function() {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === void 0)
                    match[i] = void 0;
                }
              });
            }
            if (match && groups) {
              match.groups = object2 = create3(null);
              for (i = 0; i < groups.length; i++) {
                group = groups[i];
                object2[group[0]] = match[group[1]];
              }
            }
            return match;
          };
        }
        module3.exports = patchedExec;
      }, { "../internals/function-call": 177, "../internals/function-uncurry-this": 181, "../internals/internal-state": 199, "../internals/object-create": 229, "../internals/regexp-flags": 257, "../internals/regexp-sticky-helpers": 259, "../internals/regexp-unsupported-dot-all": 260, "../internals/regexp-unsupported-ncg": 261, "../internals/shared": 269, "../internals/to-string": 291 }], 257: [function(require2, module3, exports3) {
        var anObject = require2("../internals/an-object");
        module3.exports = function() {
          var that = anObject(this);
          var result = "";
          if (that.hasIndices)
            result += "d";
          if (that.global)
            result += "g";
          if (that.ignoreCase)
            result += "i";
          if (that.multiline)
            result += "m";
          if (that.dotAll)
            result += "s";
          if (that.unicode)
            result += "u";
          if (that.unicodeSets)
            result += "v";
          if (that.sticky)
            result += "y";
          return result;
        };
      }, { "../internals/an-object": 114 }], 258: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var hasOwn2 = require2("../internals/has-own-property");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var regExpFlags = require2("../internals/regexp-flags");
        var RegExpPrototype = RegExp.prototype;
        module3.exports = function(R) {
          var flags = R.flags;
          return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn2(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
        };
      }, { "../internals/function-call": 177, "../internals/has-own-property": 189, "../internals/object-is-prototype-of": 238, "../internals/regexp-flags": 257 }], 259: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var $RegExp = global3.RegExp;
        var UNSUPPORTED_Y = fails(function() {
          var re = $RegExp("a", "y");
          re.lastIndex = 2;
          return re.exec("abcd") !== null;
        });
        var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
          return !$RegExp("a", "y").sticky;
        });
        var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
          var re = $RegExp("^r", "gy");
          re.lastIndex = 2;
          return re.exec("str") !== null;
        });
        module3.exports = {
          BROKEN_CARET,
          MISSED_STICKY,
          UNSUPPORTED_Y
        };
      }, { "../internals/fails": 171, "../internals/global": 188 }], 260: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var $RegExp = global3.RegExp;
        module3.exports = fails(function() {
          var re = $RegExp(".", "s");
          return !(re.dotAll && re.test("\n") && re.flags === "s");
        });
      }, { "../internals/fails": 171, "../internals/global": 188 }], 261: [function(require2, module3, exports3) {
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var $RegExp = global3.RegExp;
        module3.exports = fails(function() {
          var re = $RegExp("(?<a>b)", "g");
          return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
        });
      }, { "../internals/fails": 171, "../internals/global": 188 }], 262: [function(require2, module3, exports3) {
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var $TypeError = TypeError;
        module3.exports = function(it) {
          if (isNullOrUndefined(it))
            throw new $TypeError("Can't call method on " + it);
          return it;
        };
      }, { "../internals/is-null-or-undefined": 207 }], 263: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var DESCRIPTORS = require2("../internals/descriptors");
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        module3.exports = function(name) {
          if (!DESCRIPTORS)
            return global3[name];
          var descriptor = getOwnPropertyDescriptor(global3, name);
          return descriptor && descriptor.value;
        };
      }, { "../internals/descriptors": 153, "../internals/global": 188 }], 264: [function(require2, module3, exports3) {
        module3.exports = Object.is || function is(x, y) {
          return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
        };
      }, {}], 265: [function(require2, module3, exports3) {
        var getBuiltIn = require2("../internals/get-built-in");
        var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var DESCRIPTORS = require2("../internals/descriptors");
        var SPECIES = wellKnownSymbol("species");
        module3.exports = function(CONSTRUCTOR_NAME) {
          var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
          if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
            defineBuiltInAccessor(Constructor, SPECIES, {
              configurable: true,
              get: function() {
                return this;
              }
            });
          }
        };
      }, { "../internals/define-built-in-accessor": 148, "../internals/descriptors": 153, "../internals/get-built-in": 182, "../internals/well-known-symbol": 306 }], 266: [function(require2, module3, exports3) {
        var defineProperty = require2("../internals/object-define-property").f;
        var hasOwn2 = require2("../internals/has-own-property");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        module3.exports = function(target, TAG, STATIC) {
          if (target && !STATIC)
            target = target.prototype;
          if (target && !hasOwn2(target, TO_STRING_TAG)) {
            defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
          }
        };
      }, { "../internals/has-own-property": 189, "../internals/object-define-property": 231, "../internals/well-known-symbol": 306 }], 267: [function(require2, module3, exports3) {
        var shared = require2("../internals/shared");
        var uid2 = require2("../internals/uid");
        var keys = shared("keys");
        module3.exports = function(key) {
          return keys[key] || (keys[key] = uid2(key));
        };
      }, { "../internals/shared": 269, "../internals/uid": 299 }], 268: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var defineGlobalProperty = require2("../internals/define-global-property");
        var SHARED = "__core-js_shared__";
        var store = global3[SHARED] || defineGlobalProperty(SHARED, {});
        module3.exports = store;
      }, { "../internals/define-global-property": 151, "../internals/global": 188 }], 269: [function(require2, module3, exports3) {
        var IS_PURE = require2("../internals/is-pure");
        var store = require2("../internals/shared-store");
        (module3.exports = function(key, value) {
          return store[key] || (store[key] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: "3.35.0",
          mode: IS_PURE ? "pure" : "global",
          copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)",
          license: "https://github.com/zloirock/core-js/blob/v3.35.0/LICENSE",
          source: "https://github.com/zloirock/core-js"
        });
      }, { "../internals/is-pure": 210, "../internals/shared-store": 268 }], 270: [function(require2, module3, exports3) {
        var anObject = require2("../internals/an-object");
        var aConstructor = require2("../internals/a-constructor");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var SPECIES = wellKnownSymbol("species");
        module3.exports = function(O, defaultConstructor) {
          var C = anObject(O).constructor;
          var S;
          return C === void 0 || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
        };
      }, { "../internals/a-constructor": 109, "../internals/an-object": 114, "../internals/is-null-or-undefined": 207, "../internals/well-known-symbol": 306 }], 271: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var toString2 = require2("../internals/to-string");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var charAt = uncurryThis("".charAt);
        var charCodeAt = uncurryThis("".charCodeAt);
        var stringSlice = uncurryThis("".slice);
        var createMethod = function(CONVERT_TO_STRING) {
          return function($this, pos) {
            var S = toString2(requireObjectCoercible($this));
            var position2 = toIntegerOrInfinity(pos);
            var size2 = S.length;
            var first, second;
            if (position2 < 0 || position2 >= size2)
              return CONVERT_TO_STRING ? "" : void 0;
            first = charCodeAt(S, position2);
            return first < 55296 || first > 56319 || position2 + 1 === size2 || (second = charCodeAt(S, position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position2) : first : CONVERT_TO_STRING ? stringSlice(S, position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
          };
        };
        module3.exports = {
          // `String.prototype.codePointAt` method
          // https://tc39.es/ecma262/#sec-string.prototype.codepointat
          codeAt: createMethod(false),
          // `String.prototype.at` method
          // https://github.com/mathiasbynens/String.prototype.at
          charAt: createMethod(true)
        };
      }, { "../internals/function-uncurry-this": 181, "../internals/require-object-coercible": 262, "../internals/to-integer-or-infinity": 283, "../internals/to-string": 291 }], 272: [function(require2, module3, exports3) {
        var PROPER_FUNCTION_NAME = require2("../internals/function-name").PROPER;
        var fails = require2("../internals/fails");
        var whitespaces = require2("../internals/whitespaces");
        var non = "";
        module3.exports = function(METHOD_NAME) {
          return fails(function() {
            return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
          });
        };
      }, { "../internals/fails": 171, "../internals/function-name": 178, "../internals/whitespaces": 307 }], 273: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var toString2 = require2("../internals/to-string");
        var whitespaces = require2("../internals/whitespaces");
        var replace = uncurryThis("".replace);
        var ltrim = RegExp("^[" + whitespaces + "]+");
        var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
        var createMethod = function(TYPE) {
          return function($this) {
            var string2 = toString2(requireObjectCoercible($this));
            if (TYPE & 1)
              string2 = replace(string2, ltrim, "");
            if (TYPE & 2)
              string2 = replace(string2, rtrim, "$1");
            return string2;
          };
        };
        module3.exports = {
          // `String.prototype.{ trimLeft, trimStart }` methods
          // https://tc39.es/ecma262/#sec-string.prototype.trimstart
          start: createMethod(1),
          // `String.prototype.{ trimRight, trimEnd }` methods
          // https://tc39.es/ecma262/#sec-string.prototype.trimend
          end: createMethod(2),
          // `String.prototype.trim` method
          // https://tc39.es/ecma262/#sec-string.prototype.trim
          trim: createMethod(3)
        };
      }, { "../internals/function-uncurry-this": 181, "../internals/require-object-coercible": 262, "../internals/to-string": 291, "../internals/whitespaces": 307 }], 274: [function(require2, module3, exports3) {
        var V8_VERSION = require2("../internals/engine-v8-version");
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var $String = global3.String;
        module3.exports = !!Object.getOwnPropertySymbols && !fails(function() {
          var symbol = Symbol("symbol detection");
          return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
          !Symbol.sham && V8_VERSION && V8_VERSION < 41;
        });
      }, { "../internals/engine-v8-version": 167, "../internals/fails": 171, "../internals/global": 188 }], 275: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var getBuiltIn = require2("../internals/get-built-in");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var defineBuiltIn = require2("../internals/define-built-in");
        module3.exports = function() {
          var Symbol2 = getBuiltIn("Symbol");
          var SymbolPrototype = Symbol2 && Symbol2.prototype;
          var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
          var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
          if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
            defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
              return call(valueOf, this);
            }, { arity: 1 });
          }
        };
      }, { "../internals/define-built-in": 149, "../internals/function-call": 177, "../internals/get-built-in": 182, "../internals/well-known-symbol": 306 }], 276: [function(require2, module3, exports3) {
        var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
        module3.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
      }, { "../internals/symbol-constructor-detection": 274 }], 277: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var apply = require2("../internals/function-apply");
        var bind = require2("../internals/function-bind-context");
        var isCallable = require2("../internals/is-callable");
        var hasOwn2 = require2("../internals/has-own-property");
        var fails = require2("../internals/fails");
        var html = require2("../internals/html");
        var arraySlice = require2("../internals/array-slice");
        var createElement = require2("../internals/document-create-element");
        var validateArgumentsLength = require2("../internals/validate-arguments-length");
        var IS_IOS = require2("../internals/engine-is-ios");
        var IS_NODE = require2("../internals/engine-is-node");
        var set2 = global3.setImmediate;
        var clear2 = global3.clearImmediate;
        var process = global3.process;
        var Dispatch = global3.Dispatch;
        var Function2 = global3.Function;
        var MessageChannel = global3.MessageChannel;
        var String2 = global3.String;
        var counter = 0;
        var queue2 = {};
        var ONREADYSTATECHANGE = "onreadystatechange";
        var $location, defer, channel, port;
        fails(function() {
          $location = global3.location;
        });
        var run = function(id) {
          if (hasOwn2(queue2, id)) {
            var fn = queue2[id];
            delete queue2[id];
            fn();
          }
        };
        var runner = function(id) {
          return function() {
            run(id);
          };
        };
        var eventListener = function(event) {
          run(event.data);
        };
        var globalPostMessageDefer = function(id) {
          global3.postMessage(String2(id), $location.protocol + "//" + $location.host);
        };
        if (!set2 || !clear2) {
          set2 = function setImmediate(handler) {
            validateArgumentsLength(arguments.length, 1);
            var fn = isCallable(handler) ? handler : Function2(handler);
            var args = arraySlice(arguments, 1);
            queue2[++counter] = function() {
              apply(fn, void 0, args);
            };
            defer(counter);
            return counter;
          };
          clear2 = function clearImmediate(id) {
            delete queue2[id];
          };
          if (IS_NODE) {
            defer = function(id) {
              process.nextTick(runner(id));
            };
          } else if (Dispatch && Dispatch.now) {
            defer = function(id) {
              Dispatch.now(runner(id));
            };
          } else if (MessageChannel && !IS_IOS) {
            channel = new MessageChannel();
            port = channel.port2;
            channel.port1.onmessage = eventListener;
            defer = bind(port.postMessage, port);
          } else if (global3.addEventListener && isCallable(global3.postMessage) && !global3.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
            defer = globalPostMessageDefer;
            global3.addEventListener("message", eventListener, false);
          } else if (ONREADYSTATECHANGE in createElement("script")) {
            defer = function(id) {
              html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
                html.removeChild(this);
                run(id);
              };
            };
          } else {
            defer = function(id) {
              setTimeout(runner(id), 0);
            };
          }
        }
        module3.exports = {
          set: set2,
          clear: clear2
        };
      }, { "../internals/array-slice": 131, "../internals/document-create-element": 154, "../internals/engine-is-ios": 163, "../internals/engine-is-node": 164, "../internals/fails": 171, "../internals/function-apply": 174, "../internals/function-bind-context": 175, "../internals/global": 188, "../internals/has-own-property": 189, "../internals/html": 192, "../internals/is-callable": 203, "../internals/validate-arguments-length": 302 }], 278: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        module3.exports = uncurryThis(1 .valueOf);
      }, { "../internals/function-uncurry-this": 181 }], 279: [function(require2, module3, exports3) {
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var max = Math.max;
        var min = Math.min;
        module3.exports = function(index2, length) {
          var integer = toIntegerOrInfinity(index2);
          return integer < 0 ? max(integer + length, 0) : min(integer, length);
        };
      }, { "../internals/to-integer-or-infinity": 283 }], 280: [function(require2, module3, exports3) {
        var toPrimitive = require2("../internals/to-primitive");
        var $TypeError = TypeError;
        module3.exports = function(argument) {
          var prim = toPrimitive(argument, "number");
          if (typeof prim == "number")
            throw new $TypeError("Can't convert number to bigint");
          return BigInt(prim);
        };
      }, { "../internals/to-primitive": 288 }], 281: [function(require2, module3, exports3) {
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var toLength = require2("../internals/to-length");
        var $RangeError = RangeError;
        module3.exports = function(it) {
          if (it === void 0)
            return 0;
          var number2 = toIntegerOrInfinity(it);
          var length = toLength(number2);
          if (number2 !== length)
            throw new $RangeError("Wrong length or index");
          return length;
        };
      }, { "../internals/to-integer-or-infinity": 283, "../internals/to-length": 284 }], 282: [function(require2, module3, exports3) {
        var IndexedObject = require2("../internals/indexed-object");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        module3.exports = function(it) {
          return IndexedObject(requireObjectCoercible(it));
        };
      }, { "../internals/indexed-object": 195, "../internals/require-object-coercible": 262 }], 283: [function(require2, module3, exports3) {
        var trunc = require2("../internals/math-trunc");
        module3.exports = function(argument) {
          var number2 = +argument;
          return number2 !== number2 || number2 === 0 ? 0 : trunc(number2);
        };
      }, { "../internals/math-trunc": 224 }], 284: [function(require2, module3, exports3) {
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var min = Math.min;
        module3.exports = function(argument) {
          return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
        };
      }, { "../internals/to-integer-or-infinity": 283 }], 285: [function(require2, module3, exports3) {
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var $Object = Object;
        module3.exports = function(argument) {
          return $Object(requireObjectCoercible(argument));
        };
      }, { "../internals/require-object-coercible": 262 }], 286: [function(require2, module3, exports3) {
        var toPositiveInteger = require2("../internals/to-positive-integer");
        var $RangeError = RangeError;
        module3.exports = function(it, BYTES) {
          var offset = toPositiveInteger(it);
          if (offset % BYTES)
            throw new $RangeError("Wrong offset");
          return offset;
        };
      }, { "../internals/to-positive-integer": 287 }], 287: [function(require2, module3, exports3) {
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var $RangeError = RangeError;
        module3.exports = function(it) {
          var result = toIntegerOrInfinity(it);
          if (result < 0)
            throw new $RangeError("The argument can't be less than 0");
          return result;
        };
      }, { "../internals/to-integer-or-infinity": 283 }], 288: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var isObject2 = require2("../internals/is-object");
        var isSymbol2 = require2("../internals/is-symbol");
        var getMethod = require2("../internals/get-method");
        var ordinaryToPrimitive = require2("../internals/ordinary-to-primitive");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var $TypeError = TypeError;
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        module3.exports = function(input2, pref) {
          if (!isObject2(input2) || isSymbol2(input2))
            return input2;
          var exoticToPrim = getMethod(input2, TO_PRIMITIVE);
          var result;
          if (exoticToPrim) {
            if (pref === void 0)
              pref = "default";
            result = call(exoticToPrim, input2, pref);
            if (!isObject2(result) || isSymbol2(result))
              return result;
            throw new $TypeError("Can't convert object to primitive value");
          }
          if (pref === void 0)
            pref = "number";
          return ordinaryToPrimitive(input2, pref);
        };
      }, { "../internals/function-call": 177, "../internals/get-method": 186, "../internals/is-object": 208, "../internals/is-symbol": 212, "../internals/ordinary-to-primitive": 245, "../internals/well-known-symbol": 306 }], 289: [function(require2, module3, exports3) {
        var toPrimitive = require2("../internals/to-primitive");
        var isSymbol2 = require2("../internals/is-symbol");
        module3.exports = function(argument) {
          var key = toPrimitive(argument, "string");
          return isSymbol2(key) ? key : key + "";
        };
      }, { "../internals/is-symbol": 212, "../internals/to-primitive": 288 }], 290: [function(require2, module3, exports3) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var test2 = {};
        test2[TO_STRING_TAG] = "z";
        module3.exports = String(test2) === "[object z]";
      }, { "../internals/well-known-symbol": 306 }], 291: [function(require2, module3, exports3) {
        var classof = require2("../internals/classof");
        var $String = String;
        module3.exports = function(argument) {
          if (classof(argument) === "Symbol")
            throw new TypeError("Cannot convert a Symbol value to a string");
          return $String(argument);
        };
      }, { "../internals/classof": 138 }], 292: [function(require2, module3, exports3) {
        var round2 = Math.round;
        module3.exports = function(it) {
          var value = round2(it);
          return value < 0 ? 0 : value > 255 ? 255 : value & 255;
        };
      }, {}], 293: [function(require2, module3, exports3) {
        var $String = String;
        module3.exports = function(argument) {
          try {
            return $String(argument);
          } catch (error2) {
            return "Object";
          }
        };
      }, {}], 294: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var DESCRIPTORS = require2("../internals/descriptors");
        var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require2("../internals/typed-array-constructors-require-wrappers");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var ArrayBufferModule = require2("../internals/array-buffer");
        var anInstance = require2("../internals/an-instance");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var isIntegralNumber = require2("../internals/is-integral-number");
        var toLength = require2("../internals/to-length");
        var toIndex = require2("../internals/to-index");
        var toOffset = require2("../internals/to-offset");
        var toUint8Clamped = require2("../internals/to-uint8-clamped");
        var toPropertyKey = require2("../internals/to-property-key");
        var hasOwn2 = require2("../internals/has-own-property");
        var classof = require2("../internals/classof");
        var isObject2 = require2("../internals/is-object");
        var isSymbol2 = require2("../internals/is-symbol");
        var create3 = require2("../internals/object-create");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var setPrototypeOf = require2("../internals/object-set-prototype-of");
        var getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var typedArrayFrom = require2("../internals/typed-array-from");
        var forEach3 = require2("../internals/array-iteration").forEach;
        var setSpecies = require2("../internals/set-species");
        var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
        var definePropertyModule = require2("../internals/object-define-property");
        var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
        var arrayFromConstructorAndList = require2("../internals/array-from-constructor-and-list");
        var InternalStateModule = require2("../internals/internal-state");
        var inheritIfRequired = require2("../internals/inherit-if-required");
        var getInternalState = InternalStateModule.get;
        var setInternalState = InternalStateModule.set;
        var enforceInternalState = InternalStateModule.enforce;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var RangeError2 = global3.RangeError;
        var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
        var ArrayBufferPrototype = ArrayBuffer2.prototype;
        var DataView2 = ArrayBufferModule.DataView;
        var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
        var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
        var TypedArray = ArrayBufferViewCore.TypedArray;
        var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
        var isTypedArray = ArrayBufferViewCore.isTypedArray;
        var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
        var WRONG_LENGTH = "Wrong length";
        var addGetter = function(it, key) {
          defineBuiltInAccessor(it, key, {
            configurable: true,
            get: function() {
              return getInternalState(this)[key];
            }
          });
        };
        var isArrayBuffer = function(it) {
          var klass;
          return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) === "ArrayBuffer" || klass === "SharedArrayBuffer";
        };
        var isTypedArrayIndex = function(target, key) {
          return isTypedArray(target) && !isSymbol2(key) && key in target && isIntegralNumber(+key) && key >= 0;
        };
        var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
          key = toPropertyKey(key);
          return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
        };
        var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
          key = toPropertyKey(key);
          if (isTypedArrayIndex(target, key) && isObject2(descriptor) && hasOwn2(descriptor, "value") && !hasOwn2(descriptor, "get") && !hasOwn2(descriptor, "set") && !descriptor.configurable && (!hasOwn2(descriptor, "writable") || descriptor.writable) && (!hasOwn2(descriptor, "enumerable") || descriptor.enumerable)) {
            target[key] = descriptor.value;
            return target;
          }
          return nativeDefineProperty(target, key, descriptor);
        };
        if (DESCRIPTORS) {
          if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
            definePropertyModule.f = wrappedDefineProperty;
            addGetter(TypedArrayPrototype, "buffer");
            addGetter(TypedArrayPrototype, "byteOffset");
            addGetter(TypedArrayPrototype, "byteLength");
            addGetter(TypedArrayPrototype, "length");
          }
          $({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
            getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
            defineProperty: wrappedDefineProperty
          });
          module3.exports = function(TYPE, wrapper, CLAMPED) {
            var BYTES = TYPE.match(/\d+/)[0] / 8;
            var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
            var GETTER = "get" + TYPE;
            var SETTER = "set" + TYPE;
            var NativeTypedArrayConstructor = global3[CONSTRUCTOR_NAME];
            var TypedArrayConstructor = NativeTypedArrayConstructor;
            var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
            var exported = {};
            var getter = function(that, index2) {
              var data = getInternalState(that);
              return data.view[GETTER](index2 * BYTES + data.byteOffset, true);
            };
            var setter = function(that, index2, value) {
              var data = getInternalState(that);
              data.view[SETTER](index2 * BYTES + data.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
            };
            var addElement = function(that, index2) {
              nativeDefineProperty(that, index2, {
                get: function() {
                  return getter(this, index2);
                },
                set: function(value) {
                  return setter(this, index2, value);
                },
                enumerable: true
              });
            };
            if (!NATIVE_ARRAY_BUFFER_VIEWS) {
              TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
                anInstance(that, TypedArrayConstructorPrototype);
                var index2 = 0;
                var byteOffset = 0;
                var buffer2, byteLength, length;
                if (!isObject2(data)) {
                  length = toIndex(data);
                  byteLength = length * BYTES;
                  buffer2 = new ArrayBuffer2(byteLength);
                } else if (isArrayBuffer(data)) {
                  buffer2 = data;
                  byteOffset = toOffset(offset, BYTES);
                  var $len = data.byteLength;
                  if ($length === void 0) {
                    if ($len % BYTES)
                      throw new RangeError2(WRONG_LENGTH);
                    byteLength = $len - byteOffset;
                    if (byteLength < 0)
                      throw new RangeError2(WRONG_LENGTH);
                  } else {
                    byteLength = toLength($length) * BYTES;
                    if (byteLength + byteOffset > $len)
                      throw new RangeError2(WRONG_LENGTH);
                  }
                  length = byteLength / BYTES;
                } else if (isTypedArray(data)) {
                  return arrayFromConstructorAndList(TypedArrayConstructor, data);
                } else {
                  return call(typedArrayFrom, TypedArrayConstructor, data);
                }
                setInternalState(that, {
                  buffer: buffer2,
                  byteOffset,
                  byteLength,
                  length,
                  view: new DataView2(buffer2)
                });
                while (index2 < length)
                  addElement(that, index2++);
              });
              if (setPrototypeOf)
                setPrototypeOf(TypedArrayConstructor, TypedArray);
              TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create3(TypedArrayPrototype);
            } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
              TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                anInstance(dummy, TypedArrayConstructorPrototype);
                return inheritIfRequired(function() {
                  if (!isObject2(data))
                    return new NativeTypedArrayConstructor(toIndex(data));
                  if (isArrayBuffer(data))
                    return $length !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                  if (isTypedArray(data))
                    return arrayFromConstructorAndList(TypedArrayConstructor, data);
                  return call(typedArrayFrom, TypedArrayConstructor, data);
                }(), dummy, TypedArrayConstructor);
              });
              if (setPrototypeOf)
                setPrototypeOf(TypedArrayConstructor, TypedArray);
              forEach3(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                if (!(key in TypedArrayConstructor)) {
                  createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
                }
              });
              TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
            }
            if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
            }
            enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;
            if (TYPED_ARRAY_TAG) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
            }
            var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;
            exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
            $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);
            if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
              createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
            }
            if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
            }
            setSpecies(CONSTRUCTOR_NAME);
          };
        } else
          module3.exports = function() {
          };
      }, { "../internals/an-instance": 113, "../internals/array-buffer": 118, "../internals/array-buffer-view-core": 117, "../internals/array-from-constructor-and-list": 122, "../internals/array-iteration": 125, "../internals/classof": 138, "../internals/create-non-enumerable-property": 145, "../internals/create-property-descriptor": 146, "../internals/define-built-in-accessor": 148, "../internals/descriptors": 153, "../internals/export": 170, "../internals/function-call": 177, "../internals/global": 188, "../internals/has-own-property": 189, "../internals/inherit-if-required": 196, "../internals/internal-state": 199, "../internals/is-integral-number": 206, "../internals/is-object": 208, "../internals/is-symbol": 212, "../internals/object-create": 229, "../internals/object-define-property": 231, "../internals/object-get-own-property-descriptor": 232, "../internals/object-get-own-property-names": 234, "../internals/object-is-prototype-of": 238, "../internals/object-set-prototype-of": 242, "../internals/set-species": 265, "../internals/to-index": 281, "../internals/to-length": 284, "../internals/to-offset": 286, "../internals/to-property-key": 289, "../internals/to-uint8-clamped": 292, "../internals/typed-array-constructors-require-wrappers": 295, "../internals/typed-array-from": 297 }], 295: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var fails = require2("../internals/fails");
        var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
        var NATIVE_ARRAY_BUFFER_VIEWS = require2("../internals/array-buffer-view-core").NATIVE_ARRAY_BUFFER_VIEWS;
        var ArrayBuffer2 = global3.ArrayBuffer;
        var Int8Array2 = global3.Int8Array;
        module3.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
          Int8Array2(1);
        }) || !fails(function() {
          new Int8Array2(-1);
        }) || !checkCorrectnessOfIteration(function(iterable) {
          new Int8Array2();
          new Int8Array2(null);
          new Int8Array2(1.5);
          new Int8Array2(iterable);
        }, true) || fails(function() {
          return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/check-correctness-of-iteration": 136, "../internals/fails": 171, "../internals/global": 188 }], 296: [function(require2, module3, exports3) {
        var arrayFromConstructorAndList = require2("../internals/array-from-constructor-and-list");
        var typedArraySpeciesConstructor = require2("../internals/typed-array-species-constructor");
        module3.exports = function(instance, list2) {
          return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list2);
        };
      }, { "../internals/array-from-constructor-and-list": 122, "../internals/typed-array-species-constructor": 298 }], 297: [function(require2, module3, exports3) {
        var bind = require2("../internals/function-bind-context");
        var call = require2("../internals/function-call");
        var aConstructor = require2("../internals/a-constructor");
        var toObject = require2("../internals/to-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var getIterator = require2("../internals/get-iterator");
        var getIteratorMethod = require2("../internals/get-iterator-method");
        var isArrayIteratorMethod = require2("../internals/is-array-iterator-method");
        var isBigIntArray = require2("../internals/is-big-int-array");
        var aTypedArrayConstructor = require2("../internals/array-buffer-view-core").aTypedArrayConstructor;
        var toBigInt = require2("../internals/to-big-int");
        module3.exports = function from(source) {
          var C = aConstructor(this);
          var O = toObject(source);
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
          var mapping = mapfn !== void 0;
          var iteratorMethod = getIteratorMethod(O);
          var i, length, result, thisIsBigIntArray, value, step, iterator, next;
          if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
            iterator = getIterator(O, iteratorMethod);
            next = iterator.next;
            O = [];
            while (!(step = call(next, iterator)).done) {
              O.push(step.value);
            }
          }
          if (mapping && argumentsLength > 2) {
            mapfn = bind(mapfn, arguments[2]);
          }
          length = lengthOfArrayLike(O);
          result = new (aTypedArrayConstructor(C))(length);
          thisIsBigIntArray = isBigIntArray(result);
          for (i = 0; length > i; i++) {
            value = mapping ? mapfn(O[i], i) : O[i];
            result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
          }
          return result;
        };
      }, { "../internals/a-constructor": 109, "../internals/array-buffer-view-core": 117, "../internals/function-bind-context": 175, "../internals/function-call": 177, "../internals/get-iterator": 184, "../internals/get-iterator-method": 183, "../internals/is-array-iterator-method": 200, "../internals/is-big-int-array": 202, "../internals/length-of-array-like": 219, "../internals/to-big-int": 280, "../internals/to-object": 285 }], 298: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var speciesConstructor = require2("../internals/species-constructor");
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
        module3.exports = function(originalArray) {
          return aTypedArrayConstructor(speciesConstructor(originalArray, getTypedArrayConstructor(originalArray)));
        };
      }, { "../internals/array-buffer-view-core": 117, "../internals/species-constructor": 270 }], 299: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var id = 0;
        var postfix = Math.random();
        var toString2 = uncurryThis(1 .toString);
        module3.exports = function(key) {
          return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
        };
      }, { "../internals/function-uncurry-this": 181 }], 300: [function(require2, module3, exports3) {
        var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
        module3.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
      }, { "../internals/symbol-constructor-detection": 274 }], 301: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var fails = require2("../internals/fails");
        module3.exports = DESCRIPTORS && fails(function() {
          return Object.defineProperty(function() {
          }, "prototype", {
            value: 42,
            writable: false
          }).prototype !== 42;
        });
      }, { "../internals/descriptors": 153, "../internals/fails": 171 }], 302: [function(require2, module3, exports3) {
        var $TypeError = TypeError;
        module3.exports = function(passed, required) {
          if (passed < required)
            throw new $TypeError("Not enough arguments");
          return passed;
        };
      }, {}], 303: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var isCallable = require2("../internals/is-callable");
        var WeakMap2 = global3.WeakMap;
        module3.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
      }, { "../internals/global": 188, "../internals/is-callable": 203 }], 304: [function(require2, module3, exports3) {
        var path = require2("../internals/path");
        var hasOwn2 = require2("../internals/has-own-property");
        var wrappedWellKnownSymbolModule = require2("../internals/well-known-symbol-wrapped");
        var defineProperty = require2("../internals/object-define-property").f;
        module3.exports = function(NAME) {
          var Symbol2 = path.Symbol || (path.Symbol = {});
          if (!hasOwn2(Symbol2, NAME))
            defineProperty(Symbol2, NAME, {
              value: wrappedWellKnownSymbolModule.f(NAME)
            });
        };
      }, { "../internals/has-own-property": 189, "../internals/object-define-property": 231, "../internals/path": 247, "../internals/well-known-symbol-wrapped": 305 }], 305: [function(require2, module3, exports3) {
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        exports3.f = wellKnownSymbol;
      }, { "../internals/well-known-symbol": 306 }], 306: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var shared = require2("../internals/shared");
        var hasOwn2 = require2("../internals/has-own-property");
        var uid2 = require2("../internals/uid");
        var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
        var USE_SYMBOL_AS_UID = require2("../internals/use-symbol-as-uid");
        var Symbol2 = global3.Symbol;
        var WellKnownSymbolsStore = shared("wks");
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
        module3.exports = function(name) {
          if (!hasOwn2(WellKnownSymbolsStore, name)) {
            WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn2(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
          }
          return WellKnownSymbolsStore[name];
        };
      }, { "../internals/global": 188, "../internals/has-own-property": 189, "../internals/shared": 269, "../internals/symbol-constructor-detection": 274, "../internals/uid": 299, "../internals/use-symbol-as-uid": 300 }], 307: [function(require2, module3, exports3) {
        module3.exports = "	\n\v\f\r \u2028\u2029\uFEFF";
      }, {}], 308: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var global3 = require2("../internals/global");
        var arrayBufferModule = require2("../internals/array-buffer");
        var setSpecies = require2("../internals/set-species");
        var ARRAY_BUFFER = "ArrayBuffer";
        var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
        var NativeArrayBuffer = global3[ARRAY_BUFFER];
        $({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer2 }, {
          ArrayBuffer: ArrayBuffer2
        });
        setSpecies(ARRAY_BUFFER);
      }, { "../internals/array-buffer": 118, "../internals/export": 170, "../internals/global": 188, "../internals/set-species": 265 }], 309: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this-clause");
        var fails = require2("../internals/fails");
        var ArrayBufferModule = require2("../internals/array-buffer");
        var anObject = require2("../internals/an-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var toLength = require2("../internals/to-length");
        var speciesConstructor = require2("../internals/species-constructor");
        var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
        var DataView2 = ArrayBufferModule.DataView;
        var DataViewPrototype = DataView2.prototype;
        var nativeArrayBufferSlice = uncurryThis(ArrayBuffer2.prototype.slice);
        var getUint8 = uncurryThis(DataViewPrototype.getUint8);
        var setUint8 = uncurryThis(DataViewPrototype.setUint8);
        var INCORRECT_SLICE = fails(function() {
          return !new ArrayBuffer2(2).slice(1, void 0).byteLength;
        });
        $({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
          slice: function slice(start, end) {
            if (nativeArrayBufferSlice && end === void 0) {
              return nativeArrayBufferSlice(anObject(this), start);
            }
            var length = anObject(this).byteLength;
            var first = toAbsoluteIndex(start, length);
            var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
            var result = new (speciesConstructor(this, ArrayBuffer2))(toLength(fin - first));
            var viewSource = new DataView2(this);
            var viewTarget = new DataView2(result);
            var index2 = 0;
            while (first < fin) {
              setUint8(viewTarget, index2++, getUint8(viewSource, first++));
            }
            return result;
          }
        });
      }, { "../internals/an-object": 114, "../internals/array-buffer": 118, "../internals/export": 170, "../internals/fails": 171, "../internals/function-uncurry-this-clause": 180, "../internals/species-constructor": 270, "../internals/to-absolute-index": 279, "../internals/to-length": 284 }], 310: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var fails = require2("../internals/fails");
        var isArray2 = require2("../internals/is-array");
        var isObject2 = require2("../internals/is-object");
        var toObject = require2("../internals/to-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var doesNotExceedSafeInteger = require2("../internals/does-not-exceed-safe-integer");
        var createProperty = require2("../internals/create-property");
        var arraySpeciesCreate = require2("../internals/array-species-create");
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var V8_VERSION = require2("../internals/engine-v8-version");
        var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
        var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
          var array2 = [];
          array2[IS_CONCAT_SPREADABLE] = false;
          return array2.concat()[0] !== array2;
        });
        var isConcatSpreadable = function(O) {
          if (!isObject2(O))
            return false;
          var spreadable = O[IS_CONCAT_SPREADABLE];
          return spreadable !== void 0 ? !!spreadable : isArray2(O);
        };
        var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
        $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          concat: function concat(arg) {
            var O = toObject(this);
            var A2 = arraySpeciesCreate(O, 0);
            var n2 = 0;
            var i, k, length, len, E2;
            for (i = -1, length = arguments.length; i < length; i++) {
              E2 = i === -1 ? O : arguments[i];
              if (isConcatSpreadable(E2)) {
                len = lengthOfArrayLike(E2);
                doesNotExceedSafeInteger(n2 + len);
                for (k = 0; k < len; k++, n2++)
                  if (k in E2)
                    createProperty(A2, n2, E2[k]);
              } else {
                doesNotExceedSafeInteger(n2 + 1);
                createProperty(A2, n2++, E2);
              }
            }
            A2.length = n2;
            return A2;
          }
        });
      }, { "../internals/array-method-has-species-support": 127, "../internals/array-species-create": 134, "../internals/create-property": 147, "../internals/does-not-exceed-safe-integer": 155, "../internals/engine-v8-version": 167, "../internals/export": 170, "../internals/fails": 171, "../internals/is-array": 201, "../internals/is-object": 208, "../internals/length-of-array-like": 219, "../internals/to-object": 285, "../internals/well-known-symbol": 306 }], 311: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var fill = require2("../internals/array-fill");
        var addToUnscopables = require2("../internals/add-to-unscopables");
        $({ target: "Array", proto: true }, {
          fill
        });
        addToUnscopables("fill");
      }, { "../internals/add-to-unscopables": 111, "../internals/array-fill": 120, "../internals/export": 170 }], 312: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var $filter = require2("../internals/array-iteration").filter;
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
          filter: function filter(callbackfn) {
            return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      }, { "../internals/array-iteration": 125, "../internals/array-method-has-species-support": 127, "../internals/export": 170 }], 313: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var $find = require2("../internals/array-iteration").find;
        var addToUnscopables = require2("../internals/add-to-unscopables");
        var FIND = "find";
        var SKIPS_HOLES = true;
        if (FIND in [])
          Array(1)[FIND](function() {
            SKIPS_HOLES = false;
          });
        $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
          find: function find2(callbackfn) {
            return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
        addToUnscopables(FIND);
      }, { "../internals/add-to-unscopables": 111, "../internals/array-iteration": 125, "../internals/export": 170 }], 314: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var from = require2("../internals/array-from");
        var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
        var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
          Array.from(iterable);
        });
        $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
          from
        });
      }, { "../internals/array-from": 123, "../internals/check-correctness-of-iteration": 136, "../internals/export": 170 }], 315: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var $includes = require2("../internals/array-includes").includes;
        var fails = require2("../internals/fails");
        var addToUnscopables = require2("../internals/add-to-unscopables");
        var BROKEN_ON_SPARSE = fails(function() {
          return !Array(1).includes();
        });
        $({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
          includes: function includes(el) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
        addToUnscopables("includes");
      }, { "../internals/add-to-unscopables": 111, "../internals/array-includes": 124, "../internals/export": 170, "../internals/fails": 171 }], 316: [function(require2, module3, exports3) {
        var toIndexedObject = require2("../internals/to-indexed-object");
        var addToUnscopables = require2("../internals/add-to-unscopables");
        var Iterators = require2("../internals/iterators");
        var InternalStateModule = require2("../internals/internal-state");
        var defineProperty = require2("../internals/object-define-property").f;
        var defineIterator = require2("../internals/iterator-define");
        var createIterResultObject = require2("../internals/create-iter-result-object");
        var IS_PURE = require2("../internals/is-pure");
        var DESCRIPTORS = require2("../internals/descriptors");
        var ARRAY_ITERATOR = "Array Iterator";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
        module3.exports = defineIterator(Array, "Array", function(iterated, kind) {
          setInternalState(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated),
            // target
            index: 0,
            // next index
            kind
            // kind
          });
        }, function() {
          var state = getInternalState(this);
          var target = state.target;
          var index2 = state.index++;
          if (!target || index2 >= target.length) {
            state.target = void 0;
            return createIterResultObject(void 0, true);
          }
          switch (state.kind) {
            case "keys":
              return createIterResultObject(index2, false);
            case "values":
              return createIterResultObject(target[index2], false);
          }
          return createIterResultObject([index2, target[index2]], false);
        }, "values");
        var values = Iterators.Arguments = Iterators.Array;
        addToUnscopables("keys");
        addToUnscopables("values");
        addToUnscopables("entries");
        if (!IS_PURE && DESCRIPTORS && values.name !== "values")
          try {
            defineProperty(values, "name", { value: "values" });
          } catch (error2) {
          }
      }, { "../internals/add-to-unscopables": 111, "../internals/create-iter-result-object": 144, "../internals/descriptors": 153, "../internals/internal-state": 199, "../internals/is-pure": 210, "../internals/iterator-define": 216, "../internals/iterators": 218, "../internals/object-define-property": 231, "../internals/to-indexed-object": 282 }], 317: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var IndexedObject = require2("../internals/indexed-object");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var arrayMethodIsStrict = require2("../internals/array-method-is-strict");
        var nativeJoin = uncurryThis([].join);
        var ES3_STRINGS = IndexedObject !== Object;
        var FORCED = ES3_STRINGS || !arrayMethodIsStrict("join", ",");
        $({ target: "Array", proto: true, forced: FORCED }, {
          join: function join(separator) {
            return nativeJoin(toIndexedObject(this), separator === void 0 ? "," : separator);
          }
        });
      }, { "../internals/array-method-is-strict": 128, "../internals/export": 170, "../internals/function-uncurry-this": 181, "../internals/indexed-object": 195, "../internals/to-indexed-object": 282 }], 318: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var $map = require2("../internals/array-iteration").map;
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
          map: function map(callbackfn) {
            return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      }, { "../internals/array-iteration": 125, "../internals/array-method-has-species-support": 127, "../internals/export": 170 }], 319: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var isArray2 = require2("../internals/is-array");
        var isConstructor = require2("../internals/is-constructor");
        var isObject2 = require2("../internals/is-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var createProperty = require2("../internals/create-property");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var nativeSlice = require2("../internals/array-slice");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
        var SPECIES = wellKnownSymbol("species");
        var $Array = Array;
        var max = Math.max;
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
          slice: function slice(start, end) {
            var O = toIndexedObject(this);
            var length = lengthOfArrayLike(O);
            var k = toAbsoluteIndex(start, length);
            var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
            var Constructor, result, n2;
            if (isArray2(O)) {
              Constructor = O.constructor;
              if (isConstructor(Constructor) && (Constructor === $Array || isArray2(Constructor.prototype))) {
                Constructor = void 0;
              } else if (isObject2(Constructor)) {
                Constructor = Constructor[SPECIES];
                if (Constructor === null)
                  Constructor = void 0;
              }
              if (Constructor === $Array || Constructor === void 0) {
                return nativeSlice(O, k, fin);
              }
            }
            result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k, 0));
            for (n2 = 0; k < fin; k++, n2++)
              if (k in O)
                createProperty(result, n2, O[k]);
            result.length = n2;
            return result;
          }
        });
      }, { "../internals/array-method-has-species-support": 127, "../internals/array-slice": 131, "../internals/create-property": 147, "../internals/export": 170, "../internals/is-array": 201, "../internals/is-constructor": 204, "../internals/is-object": 208, "../internals/length-of-array-like": 219, "../internals/to-absolute-index": 279, "../internals/to-indexed-object": 282, "../internals/well-known-symbol": 306 }], 320: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var aCallable = require2("../internals/a-callable");
        var toObject = require2("../internals/to-object");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var deletePropertyOrThrow = require2("../internals/delete-property-or-throw");
        var toString2 = require2("../internals/to-string");
        var fails = require2("../internals/fails");
        var internalSort = require2("../internals/array-sort");
        var arrayMethodIsStrict = require2("../internals/array-method-is-strict");
        var FF = require2("../internals/engine-ff-version");
        var IE_OR_EDGE = require2("../internals/engine-is-ie-or-edge");
        var V8 = require2("../internals/engine-v8-version");
        var WEBKIT = require2("../internals/engine-webkit-version");
        var test2 = [];
        var nativeSort = uncurryThis(test2.sort);
        var push = uncurryThis(test2.push);
        var FAILS_ON_UNDEFINED = fails(function() {
          test2.sort(void 0);
        });
        var FAILS_ON_NULL = fails(function() {
          test2.sort(null);
        });
        var STRICT_METHOD = arrayMethodIsStrict("sort");
        var STABLE_SORT = !fails(function() {
          if (V8)
            return V8 < 70;
          if (FF && FF > 3)
            return;
          if (IE_OR_EDGE)
            return true;
          if (WEBKIT)
            return WEBKIT < 603;
          var result = "";
          var code2, chr, value, index2;
          for (code2 = 65; code2 < 76; code2++) {
            chr = String.fromCharCode(code2);
            switch (code2) {
              case 66:
              case 69:
              case 70:
              case 72:
                value = 3;
                break;
              case 68:
              case 71:
                value = 4;
                break;
              default:
                value = 2;
            }
            for (index2 = 0; index2 < 47; index2++) {
              test2.push({ k: chr + index2, v: value });
            }
          }
          test2.sort(function(a2, b) {
            return b.v - a2.v;
          });
          for (index2 = 0; index2 < test2.length; index2++) {
            chr = test2[index2].k.charAt(0);
            if (result.charAt(result.length - 1) !== chr)
              result += chr;
          }
          return result !== "DGBEFHACIJK";
        });
        var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
        var getSortCompare = function(comparefn) {
          return function(x, y) {
            if (y === void 0)
              return -1;
            if (x === void 0)
              return 1;
            if (comparefn !== void 0)
              return +comparefn(x, y) || 0;
            return toString2(x) > toString2(y) ? 1 : -1;
          };
        };
        $({ target: "Array", proto: true, forced: FORCED }, {
          sort: function sort(comparefn) {
            if (comparefn !== void 0)
              aCallable(comparefn);
            var array2 = toObject(this);
            if (STABLE_SORT)
              return comparefn === void 0 ? nativeSort(array2) : nativeSort(array2, comparefn);
            var items = [];
            var arrayLength = lengthOfArrayLike(array2);
            var itemsLength, index2;
            for (index2 = 0; index2 < arrayLength; index2++) {
              if (index2 in array2)
                push(items, array2[index2]);
            }
            internalSort(items, getSortCompare(comparefn));
            itemsLength = lengthOfArrayLike(items);
            index2 = 0;
            while (index2 < itemsLength)
              array2[index2] = items[index2++];
            while (index2 < arrayLength)
              deletePropertyOrThrow(array2, index2++);
            return array2;
          }
        });
      }, { "../internals/a-callable": 108, "../internals/array-method-is-strict": 128, "../internals/array-sort": 132, "../internals/delete-property-or-throw": 152, "../internals/engine-ff-version": 158, "../internals/engine-is-ie-or-edge": 161, "../internals/engine-v8-version": 167, "../internals/engine-webkit-version": 168, "../internals/export": 170, "../internals/fails": 171, "../internals/function-uncurry-this": 181, "../internals/length-of-array-like": 219, "../internals/to-object": 285, "../internals/to-string": 291 }], 321: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var toObject = require2("../internals/to-object");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var setArrayLength = require2("../internals/array-set-length");
        var doesNotExceedSafeInteger = require2("../internals/does-not-exceed-safe-integer");
        var arraySpeciesCreate = require2("../internals/array-species-create");
        var createProperty = require2("../internals/create-property");
        var deletePropertyOrThrow = require2("../internals/delete-property-or-throw");
        var arrayMethodHasSpeciesSupport = require2("../internals/array-method-has-species-support");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
        var max = Math.max;
        var min = Math.min;
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
          splice: function splice(start, deleteCount) {
            var O = toObject(this);
            var len = lengthOfArrayLike(O);
            var actualStart = toAbsoluteIndex(start, len);
            var argumentsLength = arguments.length;
            var insertCount, actualDeleteCount, A2, k, from, to;
            if (argumentsLength === 0) {
              insertCount = actualDeleteCount = 0;
            } else if (argumentsLength === 1) {
              insertCount = 0;
              actualDeleteCount = len - actualStart;
            } else {
              insertCount = argumentsLength - 2;
              actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
            }
            doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
            A2 = arraySpeciesCreate(O, actualDeleteCount);
            for (k = 0; k < actualDeleteCount; k++) {
              from = actualStart + k;
              if (from in O)
                createProperty(A2, k, O[from]);
            }
            A2.length = actualDeleteCount;
            if (insertCount < actualDeleteCount) {
              for (k = actualStart; k < len - actualDeleteCount; k++) {
                from = k + actualDeleteCount;
                to = k + insertCount;
                if (from in O)
                  O[to] = O[from];
                else
                  deletePropertyOrThrow(O, to);
              }
              for (k = len; k > len - actualDeleteCount + insertCount; k--)
                deletePropertyOrThrow(O, k - 1);
            } else if (insertCount > actualDeleteCount) {
              for (k = len - actualDeleteCount; k > actualStart; k--) {
                from = k + actualDeleteCount - 1;
                to = k + insertCount - 1;
                if (from in O)
                  O[to] = O[from];
                else
                  deletePropertyOrThrow(O, to);
              }
            }
            for (k = 0; k < insertCount; k++) {
              O[k + actualStart] = arguments[k + 2];
            }
            setArrayLength(O, len - actualDeleteCount + insertCount);
            return A2;
          }
        });
      }, { "../internals/array-method-has-species-support": 127, "../internals/array-set-length": 130, "../internals/array-species-create": 134, "../internals/create-property": 147, "../internals/delete-property-or-throw": 152, "../internals/does-not-exceed-safe-integer": 155, "../internals/export": 170, "../internals/length-of-array-like": 219, "../internals/to-absolute-index": 279, "../internals/to-integer-or-infinity": 283, "../internals/to-object": 285 }], 322: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var FUNCTION_NAME_EXISTS = require2("../internals/function-name").EXISTS;
        var uncurryThis = require2("../internals/function-uncurry-this");
        var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
        var FunctionPrototype = Function.prototype;
        var functionToString = uncurryThis(FunctionPrototype.toString);
        var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
        var regExpExec = uncurryThis(nameRE.exec);
        var NAME = "name";
        if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
          defineBuiltInAccessor(FunctionPrototype, NAME, {
            configurable: true,
            get: function() {
              try {
                return regExpExec(nameRE, functionToString(this))[1];
              } catch (error2) {
                return "";
              }
            }
          });
        }
      }, { "../internals/define-built-in-accessor": 148, "../internals/descriptors": 153, "../internals/function-name": 178, "../internals/function-uncurry-this": 181 }], 323: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var getBuiltIn = require2("../internals/get-built-in");
        var apply = require2("../internals/function-apply");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var isCallable = require2("../internals/is-callable");
        var isSymbol2 = require2("../internals/is-symbol");
        var arraySlice = require2("../internals/array-slice");
        var getReplacerFunction = require2("../internals/get-json-replacer-function");
        var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
        var $String = String;
        var $stringify = getBuiltIn("JSON", "stringify");
        var exec = uncurryThis(/./.exec);
        var charAt = uncurryThis("".charAt);
        var charCodeAt = uncurryThis("".charCodeAt);
        var replace = uncurryThis("".replace);
        var numberToString = uncurryThis(1 .toString);
        var tester = /[\uD800-\uDFFF]/g;
        var low = /^[\uD800-\uDBFF]$/;
        var hi = /^[\uDC00-\uDFFF]$/;
        var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
          var symbol = getBuiltIn("Symbol")("stringify detection");
          return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
        });
        var ILL_FORMED_UNICODE = fails(function() {
          return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
        });
        var stringifyWithSymbolsFix = function(it, replacer2) {
          var args = arraySlice(arguments);
          var $replacer = getReplacerFunction(replacer2);
          if (!isCallable($replacer) && (it === void 0 || isSymbol2(it)))
            return;
          args[1] = function(key, value) {
            if (isCallable($replacer))
              value = call($replacer, this, $String(key), value);
            if (!isSymbol2(value))
              return value;
          };
          return apply($stringify, null, args);
        };
        var fixIllFormed = function(match, offset, string2) {
          var prev = charAt(string2, offset - 1);
          var next = charAt(string2, offset + 1);
          if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
            return "\\u" + numberToString(charCodeAt(match, 0), 16);
          }
          return match;
        };
        if ($stringify) {
          $({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
            // eslint-disable-next-line no-unused-vars -- required for `.length`
            stringify: function stringify2(it, replacer2, space) {
              var args = arraySlice(arguments);
              var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
              return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
            }
          });
        }
      }, { "../internals/array-slice": 131, "../internals/export": 170, "../internals/fails": 171, "../internals/function-apply": 174, "../internals/function-call": 177, "../internals/function-uncurry-this": 181, "../internals/get-built-in": 182, "../internals/get-json-replacer-function": 185, "../internals/is-callable": 203, "../internals/is-symbol": 212, "../internals/symbol-constructor-detection": 274 }], 324: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var IS_PURE = require2("../internals/is-pure");
        var DESCRIPTORS = require2("../internals/descriptors");
        var global3 = require2("../internals/global");
        var path = require2("../internals/path");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isForced = require2("../internals/is-forced");
        var hasOwn2 = require2("../internals/has-own-property");
        var inheritIfRequired = require2("../internals/inherit-if-required");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var isSymbol2 = require2("../internals/is-symbol");
        var toPrimitive = require2("../internals/to-primitive");
        var fails = require2("../internals/fails");
        var getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var getOwnPropertyDescriptor = require2("../internals/object-get-own-property-descriptor").f;
        var defineProperty = require2("../internals/object-define-property").f;
        var thisNumberValue = require2("../internals/this-number-value");
        var trim2 = require2("../internals/string-trim").trim;
        var NUMBER = "Number";
        var NativeNumber = global3[NUMBER];
        var PureNumberNamespace = path[NUMBER];
        var NumberPrototype = NativeNumber.prototype;
        var TypeError2 = global3.TypeError;
        var stringSlice = uncurryThis("".slice);
        var charCodeAt = uncurryThis("".charCodeAt);
        var toNumeric = function(value) {
          var primValue = toPrimitive(value, "number");
          return typeof primValue == "bigint" ? primValue : toNumber(primValue);
        };
        var toNumber = function(argument) {
          var it = toPrimitive(argument, "number");
          var first, third, radix, maxCode, digits2, length, index2, code2;
          if (isSymbol2(it))
            throw new TypeError2("Cannot convert a Symbol value to a number");
          if (typeof it == "string" && it.length > 2) {
            it = trim2(it);
            first = charCodeAt(it, 0);
            if (first === 43 || first === 45) {
              third = charCodeAt(it, 2);
              if (third === 88 || third === 120)
                return NaN;
            } else if (first === 48) {
              switch (charCodeAt(it, 1)) {
                case 66:
                case 98:
                  radix = 2;
                  maxCode = 49;
                  break;
                case 79:
                case 111:
                  radix = 8;
                  maxCode = 55;
                  break;
                default:
                  return +it;
              }
              digits2 = stringSlice(it, 2);
              length = digits2.length;
              for (index2 = 0; index2 < length; index2++) {
                code2 = charCodeAt(digits2, index2);
                if (code2 < 48 || code2 > maxCode)
                  return NaN;
              }
              return parseInt(digits2, radix);
            }
          }
          return +it;
        };
        var FORCED = isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"));
        var calledWithNew = function(dummy) {
          return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
            thisNumberValue(dummy);
          });
        };
        var NumberWrapper = function Number2(value) {
          var n2 = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
          return calledWithNew(this) ? inheritIfRequired(Object(n2), this, NumberWrapper) : n2;
        };
        NumberWrapper.prototype = NumberPrototype;
        if (FORCED && !IS_PURE)
          NumberPrototype.constructor = NumberWrapper;
        $({ global: true, constructor: true, wrap: true, forced: FORCED }, {
          Number: NumberWrapper
        });
        var copyConstructorProperties = function(target, source) {
          for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
            // ES3:
            "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
          ), j = 0, key; keys.length > j; j++) {
            if (hasOwn2(source, key = keys[j]) && !hasOwn2(target, key)) {
              defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          }
        };
        if (IS_PURE && PureNumberNamespace)
          copyConstructorProperties(path[NUMBER], PureNumberNamespace);
        if (FORCED || IS_PURE)
          copyConstructorProperties(path[NUMBER], NativeNumber);
      }, { "../internals/descriptors": 153, "../internals/export": 170, "../internals/fails": 171, "../internals/function-uncurry-this": 181, "../internals/global": 188, "../internals/has-own-property": 189, "../internals/inherit-if-required": 196, "../internals/is-forced": 205, "../internals/is-pure": 210, "../internals/is-symbol": 212, "../internals/object-define-property": 231, "../internals/object-get-own-property-descriptor": 232, "../internals/object-get-own-property-names": 234, "../internals/object-is-prototype-of": 238, "../internals/path": 247, "../internals/string-trim": 273, "../internals/this-number-value": 278, "../internals/to-primitive": 288 }], 325: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var assign2 = require2("../internals/object-assign");
        $({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 }, {
          assign: assign2
        });
      }, { "../internals/export": 170, "../internals/object-assign": 228 }], 326: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var $entries = require2("../internals/object-to-array").entries;
        $({ target: "Object", stat: true }, {
          entries: function entries(O) {
            return $entries(O);
          }
        });
      }, { "../internals/export": 170, "../internals/object-to-array": 243 }], 327: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
        var fails = require2("../internals/fails");
        var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
        var toObject = require2("../internals/to-object");
        var FORCED = !NATIVE_SYMBOL || fails(function() {
          getOwnPropertySymbolsModule.f(1);
        });
        $({ target: "Object", stat: true, forced: FORCED }, {
          getOwnPropertySymbols: function getOwnPropertySymbols(it) {
            var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
          }
        });
      }, { "../internals/export": 170, "../internals/fails": 171, "../internals/object-get-own-property-symbols": 235, "../internals/symbol-constructor-detection": 274, "../internals/to-object": 285 }], 328: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var toObject = require2("../internals/to-object");
        var nativeKeys = require2("../internals/object-keys");
        var fails = require2("../internals/fails");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeKeys(1);
        });
        $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
          keys: function keys(it) {
            return nativeKeys(toObject(it));
          }
        });
      }, { "../internals/export": 170, "../internals/fails": 171, "../internals/object-keys": 240, "../internals/to-object": 285 }], 329: [function(require2, module3, exports3) {
        var TO_STRING_TAG_SUPPORT = require2("../internals/to-string-tag-support");
        var defineBuiltIn = require2("../internals/define-built-in");
        var toString2 = require2("../internals/object-to-string");
        if (!TO_STRING_TAG_SUPPORT) {
          defineBuiltIn(Object.prototype, "toString", toString2, { unsafe: true });
        }
      }, { "../internals/define-built-in": 149, "../internals/object-to-string": 244, "../internals/to-string-tag-support": 290 }], 330: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var call = require2("../internals/function-call");
        var aCallable = require2("../internals/a-callable");
        var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
        var perform = require2("../internals/perform");
        var iterate = require2("../internals/iterate");
        var PROMISE_STATICS_INCORRECT_ITERATION = require2("../internals/promise-statics-incorrect-iteration");
        $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
          all: function all(iterable) {
            var C = this;
            var capability = newPromiseCapabilityModule.f(C);
            var resolve2 = capability.resolve;
            var reject = capability.reject;
            var result = perform(function() {
              var $promiseResolve = aCallable(C.resolve);
              var values = [];
              var counter = 0;
              var remaining = 1;
              iterate(iterable, function(promise2) {
                var index2 = counter++;
                var alreadyCalled = false;
                remaining++;
                call($promiseResolve, C, promise2).then(function(value) {
                  if (alreadyCalled)
                    return;
                  alreadyCalled = true;
                  values[index2] = value;
                  --remaining || resolve2(values);
                }, reject);
              });
              --remaining || resolve2(values);
            });
            if (result.error)
              reject(result.value);
            return capability.promise;
          }
        });
      }, { "../internals/a-callable": 108, "../internals/export": 170, "../internals/function-call": 177, "../internals/iterate": 213, "../internals/new-promise-capability": 226, "../internals/perform": 248, "../internals/promise-statics-incorrect-iteration": 252 }], 331: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var IS_PURE = require2("../internals/is-pure");
        var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var getBuiltIn = require2("../internals/get-built-in");
        var isCallable = require2("../internals/is-callable");
        var defineBuiltIn = require2("../internals/define-built-in");
        var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
        $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
          "catch": function(onRejected) {
            return this.then(void 0, onRejected);
          }
        });
        if (!IS_PURE && isCallable(NativePromiseConstructor)) {
          var method = getBuiltIn("Promise").prototype["catch"];
          if (NativePromisePrototype["catch"] !== method) {
            defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
          }
        }
      }, { "../internals/define-built-in": 149, "../internals/export": 170, "../internals/get-built-in": 182, "../internals/is-callable": 203, "../internals/is-pure": 210, "../internals/promise-constructor-detection": 249, "../internals/promise-native-constructor": 250 }], 332: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var IS_PURE = require2("../internals/is-pure");
        var IS_NODE = require2("../internals/engine-is-node");
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var defineBuiltIn = require2("../internals/define-built-in");
        var setPrototypeOf = require2("../internals/object-set-prototype-of");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var setSpecies = require2("../internals/set-species");
        var aCallable = require2("../internals/a-callable");
        var isCallable = require2("../internals/is-callable");
        var isObject2 = require2("../internals/is-object");
        var anInstance = require2("../internals/an-instance");
        var speciesConstructor = require2("../internals/species-constructor");
        var task = require2("../internals/task").set;
        var microtask = require2("../internals/microtask");
        var hostReportErrors = require2("../internals/host-report-errors");
        var perform = require2("../internals/perform");
        var Queue = require2("../internals/queue");
        var InternalStateModule = require2("../internals/internal-state");
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var PromiseConstructorDetection = require2("../internals/promise-constructor-detection");
        var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
        var PROMISE = "Promise";
        var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
        var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
        var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
        var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
        var setInternalState = InternalStateModule.set;
        var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
        var PromiseConstructor = NativePromiseConstructor;
        var PromisePrototype = NativePromisePrototype;
        var TypeError2 = global3.TypeError;
        var document2 = global3.document;
        var process = global3.process;
        var newPromiseCapability = newPromiseCapabilityModule.f;
        var newGenericPromiseCapability = newPromiseCapability;
        var DISPATCH_EVENT = !!(document2 && document2.createEvent && global3.dispatchEvent);
        var UNHANDLED_REJECTION = "unhandledrejection";
        var REJECTION_HANDLED = "rejectionhandled";
        var PENDING = 0;
        var FULFILLED = 1;
        var REJECTED = 2;
        var HANDLED = 1;
        var UNHANDLED = 2;
        var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
        var isThenable = function(it) {
          var then;
          return isObject2(it) && isCallable(then = it.then) ? then : false;
        };
        var callReaction = function(reaction, state) {
          var value = state.value;
          var ok = state.state === FULFILLED;
          var handler = ok ? reaction.ok : reaction.fail;
          var resolve2 = reaction.resolve;
          var reject = reaction.reject;
          var domain = reaction.domain;
          var result, then, exited;
          try {
            if (handler) {
              if (!ok) {
                if (state.rejection === UNHANDLED)
                  onHandleUnhandled(state);
                state.rejection = HANDLED;
              }
              if (handler === true)
                result = value;
              else {
                if (domain)
                  domain.enter();
                result = handler(value);
                if (domain) {
                  domain.exit();
                  exited = true;
                }
              }
              if (result === reaction.promise) {
                reject(new TypeError2("Promise-chain cycle"));
              } else if (then = isThenable(result)) {
                call(then, result, resolve2, reject);
              } else
                resolve2(result);
            } else
              reject(value);
          } catch (error2) {
            if (domain && !exited)
              domain.exit();
            reject(error2);
          }
        };
        var notify2 = function(state, isReject) {
          if (state.notified)
            return;
          state.notified = true;
          microtask(function() {
            var reactions = state.reactions;
            var reaction;
            while (reaction = reactions.get()) {
              callReaction(reaction, state);
            }
            state.notified = false;
            if (isReject && !state.rejection)
              onUnhandled(state);
          });
        };
        var dispatchEvent = function(name, promise2, reason) {
          var event, handler;
          if (DISPATCH_EVENT) {
            event = document2.createEvent("Event");
            event.promise = promise2;
            event.reason = reason;
            event.initEvent(name, false, true);
            global3.dispatchEvent(event);
          } else
            event = { promise: promise2, reason };
          if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global3["on" + name]))
            handler(event);
          else if (name === UNHANDLED_REJECTION)
            hostReportErrors("Unhandled promise rejection", reason);
        };
        var onUnhandled = function(state) {
          call(task, global3, function() {
            var promise2 = state.facade;
            var value = state.value;
            var IS_UNHANDLED = isUnhandled(state);
            var result;
            if (IS_UNHANDLED) {
              result = perform(function() {
                if (IS_NODE) {
                  process.emit("unhandledRejection", value, promise2);
                } else
                  dispatchEvent(UNHANDLED_REJECTION, promise2, value);
              });
              state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
              if (result.error)
                throw result.value;
            }
          });
        };
        var isUnhandled = function(state) {
          return state.rejection !== HANDLED && !state.parent;
        };
        var onHandleUnhandled = function(state) {
          call(task, global3, function() {
            var promise2 = state.facade;
            if (IS_NODE) {
              process.emit("rejectionHandled", promise2);
            } else
              dispatchEvent(REJECTION_HANDLED, promise2, state.value);
          });
        };
        var bind = function(fn, state, unwrap) {
          return function(value) {
            fn(state, value, unwrap);
          };
        };
        var internalReject = function(state, value, unwrap) {
          if (state.done)
            return;
          state.done = true;
          if (unwrap)
            state = unwrap;
          state.value = value;
          state.state = REJECTED;
          notify2(state, true);
        };
        var internalResolve = function(state, value, unwrap) {
          if (state.done)
            return;
          state.done = true;
          if (unwrap)
            state = unwrap;
          try {
            if (state.facade === value)
              throw new TypeError2("Promise can't be resolved itself");
            var then = isThenable(value);
            if (then) {
              microtask(function() {
                var wrapper = { done: false };
                try {
                  call(
                    then,
                    value,
                    bind(internalResolve, wrapper, state),
                    bind(internalReject, wrapper, state)
                  );
                } catch (error2) {
                  internalReject(wrapper, error2, state);
                }
              });
            } else {
              state.value = value;
              state.state = FULFILLED;
              notify2(state, false);
            }
          } catch (error2) {
            internalReject({ done: false }, error2, state);
          }
        };
        if (FORCED_PROMISE_CONSTRUCTOR) {
          PromiseConstructor = function Promise2(executor) {
            anInstance(this, PromisePrototype);
            aCallable(executor);
            call(Internal, this);
            var state = getInternalPromiseState(this);
            try {
              executor(bind(internalResolve, state), bind(internalReject, state));
            } catch (error2) {
              internalReject(state, error2);
            }
          };
          PromisePrototype = PromiseConstructor.prototype;
          Internal = function Promise2(executor) {
            setInternalState(this, {
              type: PROMISE,
              done: false,
              notified: false,
              parent: false,
              reactions: new Queue(),
              rejection: false,
              state: PENDING,
              value: void 0
            });
          };
          Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
            var state = getInternalPromiseState(this);
            var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
            state.parent = true;
            reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
            reaction.fail = isCallable(onRejected) && onRejected;
            reaction.domain = IS_NODE ? process.domain : void 0;
            if (state.state === PENDING)
              state.reactions.add(reaction);
            else
              microtask(function() {
                callReaction(reaction, state);
              });
            return reaction.promise;
          });
          OwnPromiseCapability = function() {
            var promise2 = new Internal();
            var state = getInternalPromiseState(promise2);
            this.promise = promise2;
            this.resolve = bind(internalResolve, state);
            this.reject = bind(internalReject, state);
          };
          newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
            return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
          };
          if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
            nativeThen = NativePromisePrototype.then;
            if (!NATIVE_PROMISE_SUBCLASSING) {
              defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
                var that = this;
                return new PromiseConstructor(function(resolve2, reject) {
                  call(nativeThen, that, resolve2, reject);
                }).then(onFulfilled, onRejected);
              }, { unsafe: true });
            }
            try {
              delete NativePromisePrototype.constructor;
            } catch (error2) {
            }
            if (setPrototypeOf) {
              setPrototypeOf(NativePromisePrototype, PromisePrototype);
            }
          }
        }
        $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
          Promise: PromiseConstructor
        });
        setToStringTag(PromiseConstructor, PROMISE, false, true);
        setSpecies(PROMISE);
      }, { "../internals/a-callable": 108, "../internals/an-instance": 113, "../internals/define-built-in": 149, "../internals/engine-is-node": 164, "../internals/export": 170, "../internals/function-call": 177, "../internals/global": 188, "../internals/host-report-errors": 191, "../internals/internal-state": 199, "../internals/is-callable": 203, "../internals/is-object": 208, "../internals/is-pure": 210, "../internals/microtask": 225, "../internals/new-promise-capability": 226, "../internals/object-set-prototype-of": 242, "../internals/perform": 248, "../internals/promise-constructor-detection": 249, "../internals/promise-native-constructor": 250, "../internals/queue": 254, "../internals/set-species": 265, "../internals/set-to-string-tag": 266, "../internals/species-constructor": 270, "../internals/task": 277 }], 333: [function(require2, module3, exports3) {
        require2("../modules/es.promise.constructor");
        require2("../modules/es.promise.all");
        require2("../modules/es.promise.catch");
        require2("../modules/es.promise.race");
        require2("../modules/es.promise.reject");
        require2("../modules/es.promise.resolve");
      }, { "../modules/es.promise.all": 330, "../modules/es.promise.catch": 331, "../modules/es.promise.constructor": 332, "../modules/es.promise.race": 334, "../modules/es.promise.reject": 335, "../modules/es.promise.resolve": 336 }], 334: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var call = require2("../internals/function-call");
        var aCallable = require2("../internals/a-callable");
        var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
        var perform = require2("../internals/perform");
        var iterate = require2("../internals/iterate");
        var PROMISE_STATICS_INCORRECT_ITERATION = require2("../internals/promise-statics-incorrect-iteration");
        $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
          race: function race(iterable) {
            var C = this;
            var capability = newPromiseCapabilityModule.f(C);
            var reject = capability.reject;
            var result = perform(function() {
              var $promiseResolve = aCallable(C.resolve);
              iterate(iterable, function(promise2) {
                call($promiseResolve, C, promise2).then(capability.resolve, reject);
              });
            });
            if (result.error)
              reject(result.value);
            return capability.promise;
          }
        });
      }, { "../internals/a-callable": 108, "../internals/export": 170, "../internals/function-call": 177, "../internals/iterate": 213, "../internals/new-promise-capability": 226, "../internals/perform": 248, "../internals/promise-statics-incorrect-iteration": 252 }], 335: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
        var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
        $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
          reject: function reject(r) {
            var capability = newPromiseCapabilityModule.f(this);
            var capabilityReject = capability.reject;
            capabilityReject(r);
            return capability.promise;
          }
        });
      }, { "../internals/export": 170, "../internals/new-promise-capability": 226, "../internals/promise-constructor-detection": 249 }], 336: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var getBuiltIn = require2("../internals/get-built-in");
        var IS_PURE = require2("../internals/is-pure");
        var NativePromiseConstructor = require2("../internals/promise-native-constructor");
        var FORCED_PROMISE_CONSTRUCTOR = require2("../internals/promise-constructor-detection").CONSTRUCTOR;
        var promiseResolve = require2("../internals/promise-resolve");
        var PromiseConstructorWrapper = getBuiltIn("Promise");
        var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
        $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
          resolve: function resolve2(x) {
            return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
          }
        });
      }, { "../internals/export": 170, "../internals/get-built-in": 182, "../internals/is-pure": 210, "../internals/promise-constructor-detection": 249, "../internals/promise-native-constructor": 250, "../internals/promise-resolve": 251 }], 337: [function(require2, module3, exports3) {
        var DESCRIPTORS = require2("../internals/descriptors");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var isForced = require2("../internals/is-forced");
        var inheritIfRequired = require2("../internals/inherit-if-required");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var create3 = require2("../internals/object-create");
        var getOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var isRegExp = require2("../internals/is-regexp");
        var toString2 = require2("../internals/to-string");
        var getRegExpFlags = require2("../internals/regexp-get-flags");
        var stickyHelpers = require2("../internals/regexp-sticky-helpers");
        var proxyAccessor = require2("../internals/proxy-accessor");
        var defineBuiltIn = require2("../internals/define-built-in");
        var fails = require2("../internals/fails");
        var hasOwn2 = require2("../internals/has-own-property");
        var enforceInternalState = require2("../internals/internal-state").enforce;
        var setSpecies = require2("../internals/set-species");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var UNSUPPORTED_DOT_ALL = require2("../internals/regexp-unsupported-dot-all");
        var UNSUPPORTED_NCG = require2("../internals/regexp-unsupported-ncg");
        var MATCH = wellKnownSymbol("match");
        var NativeRegExp = global3.RegExp;
        var RegExpPrototype = NativeRegExp.prototype;
        var SyntaxError2 = global3.SyntaxError;
        var exec = uncurryThis(RegExpPrototype.exec);
        var charAt = uncurryThis("".charAt);
        var replace = uncurryThis("".replace);
        var stringIndexOf = uncurryThis("".indexOf);
        var stringSlice = uncurryThis("".slice);
        var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
        var re1 = /a/g;
        var re2 = /a/g;
        var CORRECT_NEW = new NativeRegExp(re1) !== re1;
        var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
        var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
        var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
          re2[MATCH] = false;
          return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, "i")) !== "/a/i";
        }));
        var handleDotAll = function(string2) {
          var length = string2.length;
          var index3 = 0;
          var result = "";
          var brackets = false;
          var chr;
          for (; index3 <= length; index3++) {
            chr = charAt(string2, index3);
            if (chr === "\\") {
              result += chr + charAt(string2, ++index3);
              continue;
            }
            if (!brackets && chr === ".") {
              result += "[\\s\\S]";
            } else {
              if (chr === "[") {
                brackets = true;
              } else if (chr === "]") {
                brackets = false;
              }
              result += chr;
            }
          }
          return result;
        };
        var handleNCG = function(string2) {
          var length = string2.length;
          var index3 = 0;
          var result = "";
          var named = [];
          var names = create3(null);
          var brackets = false;
          var ncg = false;
          var groupid = 0;
          var groupname = "";
          var chr;
          for (; index3 <= length; index3++) {
            chr = charAt(string2, index3);
            if (chr === "\\") {
              chr += charAt(string2, ++index3);
            } else if (chr === "]") {
              brackets = false;
            } else if (!brackets)
              switch (true) {
                case chr === "[":
                  brackets = true;
                  break;
                case chr === "(":
                  if (exec(IS_NCG, stringSlice(string2, index3 + 1))) {
                    index3 += 2;
                    ncg = true;
                  }
                  result += chr;
                  groupid++;
                  continue;
                case (chr === ">" && ncg):
                  if (groupname === "" || hasOwn2(names, groupname)) {
                    throw new SyntaxError2("Invalid capture group name");
                  }
                  names[groupname] = true;
                  named[named.length] = [groupname, groupid];
                  ncg = false;
                  groupname = "";
                  continue;
              }
            if (ncg)
              groupname += chr;
            else
              result += chr;
          }
          return [result, named];
        };
        if (isForced("RegExp", BASE_FORCED)) {
          var RegExpWrapper = function RegExp2(pattern, flags) {
            var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
            var patternIsRegExp = isRegExp(pattern);
            var flagsAreUndefined = flags === void 0;
            var groups = [];
            var rawPattern = pattern;
            var rawFlags, dotAll, sticky2, handled, result, state;
            if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
              return pattern;
            }
            if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
              pattern = pattern.source;
              if (flagsAreUndefined)
                flags = getRegExpFlags(rawPattern);
            }
            pattern = pattern === void 0 ? "" : toString2(pattern);
            flags = flags === void 0 ? "" : toString2(flags);
            rawPattern = pattern;
            if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
              dotAll = !!flags && stringIndexOf(flags, "s") > -1;
              if (dotAll)
                flags = replace(flags, /s/g, "");
            }
            rawFlags = flags;
            if (MISSED_STICKY && "sticky" in re1) {
              sticky2 = !!flags && stringIndexOf(flags, "y") > -1;
              if (sticky2 && UNSUPPORTED_Y)
                flags = replace(flags, /y/g, "");
            }
            if (UNSUPPORTED_NCG) {
              handled = handleNCG(pattern);
              pattern = handled[0];
              groups = handled[1];
            }
            result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
            if (dotAll || sticky2 || groups.length) {
              state = enforceInternalState(result);
              if (dotAll) {
                state.dotAll = true;
                state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
              }
              if (sticky2)
                state.sticky = true;
              if (groups.length)
                state.groups = groups;
            }
            if (pattern !== rawPattern)
              try {
                createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
              } catch (error2) {
              }
            return result;
          };
          for (var keys = getOwnPropertyNames(NativeRegExp), index2 = 0; keys.length > index2; ) {
            proxyAccessor(RegExpWrapper, NativeRegExp, keys[index2++]);
          }
          RegExpPrototype.constructor = RegExpWrapper;
          RegExpWrapper.prototype = RegExpPrototype;
          defineBuiltIn(global3, "RegExp", RegExpWrapper, { constructor: true });
        }
        setSpecies("RegExp");
      }, { "../internals/create-non-enumerable-property": 145, "../internals/define-built-in": 149, "../internals/descriptors": 153, "../internals/fails": 171, "../internals/function-uncurry-this": 181, "../internals/global": 188, "../internals/has-own-property": 189, "../internals/inherit-if-required": 196, "../internals/internal-state": 199, "../internals/is-forced": 205, "../internals/is-regexp": 211, "../internals/object-create": 229, "../internals/object-get-own-property-names": 234, "../internals/object-is-prototype-of": 238, "../internals/proxy-accessor": 253, "../internals/regexp-get-flags": 258, "../internals/regexp-sticky-helpers": 259, "../internals/regexp-unsupported-dot-all": 260, "../internals/regexp-unsupported-ncg": 261, "../internals/set-species": 265, "../internals/to-string": 291, "../internals/well-known-symbol": 306 }], 338: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var exec = require2("../internals/regexp-exec");
        $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
          exec
        });
      }, { "../internals/export": 170, "../internals/regexp-exec": 256 }], 339: [function(require2, module3, exports3) {
        var PROPER_FUNCTION_NAME = require2("../internals/function-name").PROPER;
        var defineBuiltIn = require2("../internals/define-built-in");
        var anObject = require2("../internals/an-object");
        var $toString = require2("../internals/to-string");
        var fails = require2("../internals/fails");
        var getRegExpFlags = require2("../internals/regexp-get-flags");
        var TO_STRING = "toString";
        var RegExpPrototype = RegExp.prototype;
        var nativeToString = RegExpPrototype[TO_STRING];
        var NOT_GENERIC = fails(function() {
          return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
        });
        var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
        if (NOT_GENERIC || INCORRECT_NAME) {
          defineBuiltIn(RegExpPrototype, TO_STRING, function toString2() {
            var R = anObject(this);
            var pattern = $toString(R.source);
            var flags = $toString(getRegExpFlags(R));
            return "/" + pattern + "/" + flags;
          }, { unsafe: true });
        }
      }, { "../internals/an-object": 114, "../internals/define-built-in": 149, "../internals/fails": 171, "../internals/function-name": 178, "../internals/regexp-get-flags": 258, "../internals/to-string": 291 }], 340: [function(require2, module3, exports3) {
        var collection = require2("../internals/collection");
        var collectionStrong = require2("../internals/collection-strong");
        collection("Set", function(init) {
          return function Set2() {
            return init(this, arguments.length ? arguments[0] : void 0);
          };
        }, collectionStrong);
      }, { "../internals/collection": 140, "../internals/collection-strong": 139 }], 341: [function(require2, module3, exports3) {
        require2("../modules/es.set.constructor");
      }, { "../modules/es.set.constructor": 340 }], 342: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var notARegExp = require2("../internals/not-a-regexp");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var toString2 = require2("../internals/to-string");
        var correctIsRegExpLogic = require2("../internals/correct-is-regexp-logic");
        var stringIndexOf = uncurryThis("".indexOf);
        $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
          includes: function includes(searchString) {
            return !!~stringIndexOf(
              toString2(requireObjectCoercible(this)),
              toString2(notARegExp(searchString)),
              arguments.length > 1 ? arguments[1] : void 0
            );
          }
        });
      }, { "../internals/correct-is-regexp-logic": 142, "../internals/export": 170, "../internals/function-uncurry-this": 181, "../internals/not-a-regexp": 227, "../internals/require-object-coercible": 262, "../internals/to-string": 291 }], 343: [function(require2, module3, exports3) {
        var charAt = require2("../internals/string-multibyte").charAt;
        var toString2 = require2("../internals/to-string");
        var InternalStateModule = require2("../internals/internal-state");
        var defineIterator = require2("../internals/iterator-define");
        var createIterResultObject = require2("../internals/create-iter-result-object");
        var STRING_ITERATOR = "String Iterator";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
        defineIterator(String, "String", function(iterated) {
          setInternalState(this, {
            type: STRING_ITERATOR,
            string: toString2(iterated),
            index: 0
          });
        }, function next() {
          var state = getInternalState(this);
          var string2 = state.string;
          var index2 = state.index;
          var point;
          if (index2 >= string2.length)
            return createIterResultObject(void 0, true);
          point = charAt(string2, index2);
          state.index += point.length;
          return createIterResultObject(point, false);
        });
      }, { "../internals/create-iter-result-object": 144, "../internals/internal-state": 199, "../internals/iterator-define": 216, "../internals/string-multibyte": 271, "../internals/to-string": 291 }], 344: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var fixRegExpWellKnownSymbolLogic = require2("../internals/fix-regexp-well-known-symbol-logic");
        var anObject = require2("../internals/an-object");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var toLength = require2("../internals/to-length");
        var toString2 = require2("../internals/to-string");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var getMethod = require2("../internals/get-method");
        var advanceStringIndex = require2("../internals/advance-string-index");
        var regExpExec = require2("../internals/regexp-exec-abstract");
        fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
          return [
            // `String.prototype.match` method
            // https://tc39.es/ecma262/#sec-string.prototype.match
            function match(regexp) {
              var O = requireObjectCoercible(this);
              var matcher = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, MATCH);
              return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString2(O));
            },
            // `RegExp.prototype[@@match]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
            function(string2) {
              var rx = anObject(this);
              var S = toString2(string2);
              var res = maybeCallNative(nativeMatch, rx, S);
              if (res.done)
                return res.value;
              if (!rx.global)
                return regExpExec(rx, S);
              var fullUnicode = rx.unicode;
              rx.lastIndex = 0;
              var A2 = [];
              var n2 = 0;
              var result;
              while ((result = regExpExec(rx, S)) !== null) {
                var matchStr = toString2(result[0]);
                A2[n2] = matchStr;
                if (matchStr === "")
                  rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                n2++;
              }
              return n2 === 0 ? null : A2;
            }
          ];
        });
      }, { "../internals/advance-string-index": 112, "../internals/an-object": 114, "../internals/fix-regexp-well-known-symbol-logic": 172, "../internals/function-call": 177, "../internals/get-method": 186, "../internals/is-null-or-undefined": 207, "../internals/regexp-exec-abstract": 255, "../internals/require-object-coercible": 262, "../internals/to-length": 284, "../internals/to-string": 291 }], 345: [function(require2, module3, exports3) {
        var apply = require2("../internals/function-apply");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fixRegExpWellKnownSymbolLogic = require2("../internals/fix-regexp-well-known-symbol-logic");
        var fails = require2("../internals/fails");
        var anObject = require2("../internals/an-object");
        var isCallable = require2("../internals/is-callable");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var toIntegerOrInfinity = require2("../internals/to-integer-or-infinity");
        var toLength = require2("../internals/to-length");
        var toString2 = require2("../internals/to-string");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var advanceStringIndex = require2("../internals/advance-string-index");
        var getMethod = require2("../internals/get-method");
        var getSubstitution = require2("../internals/get-substitution");
        var regExpExec = require2("../internals/regexp-exec-abstract");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var REPLACE = wellKnownSymbol("replace");
        var max = Math.max;
        var min = Math.min;
        var concat = uncurryThis([].concat);
        var push = uncurryThis([].push);
        var stringIndexOf = uncurryThis("".indexOf);
        var stringSlice = uncurryThis("".slice);
        var maybeToString = function(it) {
          return it === void 0 ? it : String(it);
        };
        var REPLACE_KEEPS_$0 = function() {
          return "a".replace(/./, "$0") === "$0";
        }();
        var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
          if (/./[REPLACE]) {
            return /./[REPLACE]("a", "$0") === "";
          }
          return false;
        }();
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
          var re = /./;
          re.exec = function() {
            var result = [];
            result.groups = { a: "7" };
            return result;
          };
          return "".replace(re, "$<a>") !== "7";
        });
        fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
          var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
          return [
            // `String.prototype.replace` method
            // https://tc39.es/ecma262/#sec-string.prototype.replace
            function replace(searchValue, replaceValue) {
              var O = requireObjectCoercible(this);
              var replacer2 = isNullOrUndefined(searchValue) ? void 0 : getMethod(searchValue, REPLACE);
              return replacer2 ? call(replacer2, searchValue, O, replaceValue) : call(nativeReplace, toString2(O), searchValue, replaceValue);
            },
            // `RegExp.prototype[@@replace]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
            function(string2, replaceValue) {
              var rx = anObject(this);
              var S = toString2(string2);
              if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
                var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
                if (res.done)
                  return res.value;
              }
              var functionalReplace = isCallable(replaceValue);
              if (!functionalReplace)
                replaceValue = toString2(replaceValue);
              var global3 = rx.global;
              var fullUnicode;
              if (global3) {
                fullUnicode = rx.unicode;
                rx.lastIndex = 0;
              }
              var results = [];
              var result;
              while (true) {
                result = regExpExec(rx, S);
                if (result === null)
                  break;
                push(results, result);
                if (!global3)
                  break;
                var matchStr = toString2(result[0]);
                if (matchStr === "")
                  rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
              }
              var accumulatedResult = "";
              var nextSourcePosition = 0;
              for (var i = 0; i < results.length; i++) {
                result = results[i];
                var matched = toString2(result[0]);
                var position2 = max(min(toIntegerOrInfinity(result.index), S.length), 0);
                var captures = [];
                var replacement;
                for (var j = 1; j < result.length; j++)
                  push(captures, maybeToString(result[j]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                  var replacerArgs = concat([matched], captures, position2, S);
                  if (namedCaptures !== void 0)
                    push(replacerArgs, namedCaptures);
                  replacement = toString2(apply(replaceValue, void 0, replacerArgs));
                } else {
                  replacement = getSubstitution(matched, S, position2, captures, namedCaptures, replaceValue);
                }
                if (position2 >= nextSourcePosition) {
                  accumulatedResult += stringSlice(S, nextSourcePosition, position2) + replacement;
                  nextSourcePosition = position2 + matched.length;
                }
              }
              return accumulatedResult + stringSlice(S, nextSourcePosition);
            }
          ];
        }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
      }, { "../internals/advance-string-index": 112, "../internals/an-object": 114, "../internals/fails": 171, "../internals/fix-regexp-well-known-symbol-logic": 172, "../internals/function-apply": 174, "../internals/function-call": 177, "../internals/function-uncurry-this": 181, "../internals/get-method": 186, "../internals/get-substitution": 187, "../internals/is-callable": 203, "../internals/is-null-or-undefined": 207, "../internals/regexp-exec-abstract": 255, "../internals/require-object-coercible": 262, "../internals/to-integer-or-infinity": 283, "../internals/to-length": 284, "../internals/to-string": 291, "../internals/well-known-symbol": 306 }], 346: [function(require2, module3, exports3) {
        var call = require2("../internals/function-call");
        var fixRegExpWellKnownSymbolLogic = require2("../internals/fix-regexp-well-known-symbol-logic");
        var anObject = require2("../internals/an-object");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var sameValue = require2("../internals/same-value");
        var toString2 = require2("../internals/to-string");
        var getMethod = require2("../internals/get-method");
        var regExpExec = require2("../internals/regexp-exec-abstract");
        fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
          return [
            // `String.prototype.search` method
            // https://tc39.es/ecma262/#sec-string.prototype.search
            function search2(regexp) {
              var O = requireObjectCoercible(this);
              var searcher = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, SEARCH);
              return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString2(O));
            },
            // `RegExp.prototype[@@search]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
            function(string2) {
              var rx = anObject(this);
              var S = toString2(string2);
              var res = maybeCallNative(nativeSearch, rx, S);
              if (res.done)
                return res.value;
              var previousLastIndex = rx.lastIndex;
              if (!sameValue(previousLastIndex, 0))
                rx.lastIndex = 0;
              var result = regExpExec(rx, S);
              if (!sameValue(rx.lastIndex, previousLastIndex))
                rx.lastIndex = previousLastIndex;
              return result === null ? -1 : result.index;
            }
          ];
        });
      }, { "../internals/an-object": 114, "../internals/fix-regexp-well-known-symbol-logic": 172, "../internals/function-call": 177, "../internals/get-method": 186, "../internals/is-null-or-undefined": 207, "../internals/regexp-exec-abstract": 255, "../internals/require-object-coercible": 262, "../internals/same-value": 264, "../internals/to-string": 291 }], 347: [function(require2, module3, exports3) {
        var apply = require2("../internals/function-apply");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fixRegExpWellKnownSymbolLogic = require2("../internals/fix-regexp-well-known-symbol-logic");
        var anObject = require2("../internals/an-object");
        var isNullOrUndefined = require2("../internals/is-null-or-undefined");
        var isRegExp = require2("../internals/is-regexp");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var speciesConstructor = require2("../internals/species-constructor");
        var advanceStringIndex = require2("../internals/advance-string-index");
        var toLength = require2("../internals/to-length");
        var toString2 = require2("../internals/to-string");
        var getMethod = require2("../internals/get-method");
        var arraySlice = require2("../internals/array-slice");
        var callRegExpExec = require2("../internals/regexp-exec-abstract");
        var regexpExec = require2("../internals/regexp-exec");
        var stickyHelpers = require2("../internals/regexp-sticky-helpers");
        var fails = require2("../internals/fails");
        var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
        var MAX_UINT32 = 4294967295;
        var min = Math.min;
        var $push = [].push;
        var exec = uncurryThis(/./.exec);
        var push = uncurryThis($push);
        var stringSlice = uncurryThis("".slice);
        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
          var re = /(?:)/;
          var originalExec = re.exec;
          re.exec = function() {
            return originalExec.apply(this, arguments);
          };
          var result = "ab".split(re);
          return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
        });
        fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
          var internalSplit;
          if ("abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
          "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
          ".".split(/()()/).length > 1 || "".split(/.?/).length) {
            internalSplit = function(separator, limit) {
              var string2 = toString2(requireObjectCoercible(this));
              var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
              if (lim === 0)
                return [];
              if (separator === void 0)
                return [string2];
              if (!isRegExp(separator)) {
                return call(nativeSplit, string2, separator, lim);
              }
              var output = [];
              var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
              var lastLastIndex = 0;
              var separatorCopy = new RegExp(separator.source, flags + "g");
              var match, lastIndex, lastLength;
              while (match = call(regexpExec, separatorCopy, string2)) {
                lastIndex = separatorCopy.lastIndex;
                if (lastIndex > lastLastIndex) {
                  push(output, stringSlice(string2, lastLastIndex, match.index));
                  if (match.length > 1 && match.index < string2.length)
                    apply($push, output, arraySlice(match, 1));
                  lastLength = match[0].length;
                  lastLastIndex = lastIndex;
                  if (output.length >= lim)
                    break;
                }
                if (separatorCopy.lastIndex === match.index)
                  separatorCopy.lastIndex++;
              }
              if (lastLastIndex === string2.length) {
                if (lastLength || !exec(separatorCopy, ""))
                  push(output, "");
              } else
                push(output, stringSlice(string2, lastLastIndex));
              return output.length > lim ? arraySlice(output, 0, lim) : output;
            };
          } else if ("0".split(void 0, 0).length) {
            internalSplit = function(separator, limit) {
              return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
            };
          } else
            internalSplit = nativeSplit;
          return [
            // `String.prototype.split` method
            // https://tc39.es/ecma262/#sec-string.prototype.split
            function split(separator, limit) {
              var O = requireObjectCoercible(this);
              var splitter = isNullOrUndefined(separator) ? void 0 : getMethod(separator, SPLIT);
              return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString2(O), separator, limit);
            },
            // `RegExp.prototype[@@split]` method
            // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
            //
            // NOTE: This cannot be properly polyfilled in engines that don't support
            // the 'y' flag.
            function(string2, limit) {
              var rx = anObject(this);
              var S = toString2(string2);
              var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
              if (res.done)
                return res.value;
              var C = speciesConstructor(rx, RegExp);
              var unicodeMatching = rx.unicode;
              var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
              var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
              var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
              if (lim === 0)
                return [];
              if (S.length === 0)
                return callRegExpExec(splitter, S) === null ? [S] : [];
              var p2 = 0;
              var q = 0;
              var A2 = [];
              while (q < S.length) {
                splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
                var z2 = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
                var e2;
                if (z2 === null || (e2 = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p2) {
                  q = advanceStringIndex(S, q, unicodeMatching);
                } else {
                  push(A2, stringSlice(S, p2, q));
                  if (A2.length === lim)
                    return A2;
                  for (var i = 1; i <= z2.length - 1; i++) {
                    push(A2, z2[i]);
                    if (A2.length === lim)
                      return A2;
                  }
                  q = p2 = e2;
                }
              }
              push(A2, stringSlice(S, p2));
              return A2;
            }
          ];
        }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
      }, { "../internals/advance-string-index": 112, "../internals/an-object": 114, "../internals/array-slice": 131, "../internals/fails": 171, "../internals/fix-regexp-well-known-symbol-logic": 172, "../internals/function-apply": 174, "../internals/function-call": 177, "../internals/function-uncurry-this": 181, "../internals/get-method": 186, "../internals/is-null-or-undefined": 207, "../internals/is-regexp": 211, "../internals/regexp-exec": 256, "../internals/regexp-exec-abstract": 255, "../internals/regexp-sticky-helpers": 259, "../internals/require-object-coercible": 262, "../internals/species-constructor": 270, "../internals/to-length": 284, "../internals/to-string": 291 }], 348: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var uncurryThis = require2("../internals/function-uncurry-this-clause");
        var getOwnPropertyDescriptor = require2("../internals/object-get-own-property-descriptor").f;
        var toLength = require2("../internals/to-length");
        var toString2 = require2("../internals/to-string");
        var notARegExp = require2("../internals/not-a-regexp");
        var requireObjectCoercible = require2("../internals/require-object-coercible");
        var correctIsRegExpLogic = require2("../internals/correct-is-regexp-logic");
        var IS_PURE = require2("../internals/is-pure");
        var stringSlice = uncurryThis("".slice);
        var min = Math.min;
        var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
        var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
          var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
          return descriptor && !descriptor.writable;
        }();
        $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
          startsWith: function startsWith2(searchString) {
            var that = toString2(requireObjectCoercible(this));
            notARegExp(searchString);
            var index2 = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
            var search2 = toString2(searchString);
            return stringSlice(that, index2, index2 + search2.length) === search2;
          }
        });
      }, { "../internals/correct-is-regexp-logic": 142, "../internals/export": 170, "../internals/function-uncurry-this-clause": 180, "../internals/is-pure": 210, "../internals/not-a-regexp": 227, "../internals/object-get-own-property-descriptor": 232, "../internals/require-object-coercible": 262, "../internals/to-length": 284, "../internals/to-string": 291 }], 349: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var $trim = require2("../internals/string-trim").trim;
        var forcedStringTrimMethod = require2("../internals/string-trim-forced");
        $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
          trim: function trim2() {
            return $trim(this);
          }
        });
      }, { "../internals/export": 170, "../internals/string-trim": 273, "../internals/string-trim-forced": 272 }], 350: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var IS_PURE = require2("../internals/is-pure");
        var DESCRIPTORS = require2("../internals/descriptors");
        var NATIVE_SYMBOL = require2("../internals/symbol-constructor-detection");
        var fails = require2("../internals/fails");
        var hasOwn2 = require2("../internals/has-own-property");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var anObject = require2("../internals/an-object");
        var toIndexedObject = require2("../internals/to-indexed-object");
        var toPropertyKey = require2("../internals/to-property-key");
        var $toString = require2("../internals/to-string");
        var createPropertyDescriptor = require2("../internals/create-property-descriptor");
        var nativeObjectCreate = require2("../internals/object-create");
        var objectKeys2 = require2("../internals/object-keys");
        var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
        var getOwnPropertyNamesExternal = require2("../internals/object-get-own-property-names-external");
        var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
        var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
        var definePropertyModule = require2("../internals/object-define-property");
        var definePropertiesModule = require2("../internals/object-define-properties");
        var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
        var defineBuiltIn = require2("../internals/define-built-in");
        var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
        var shared = require2("../internals/shared");
        var sharedKey = require2("../internals/shared-key");
        var hiddenKeys = require2("../internals/hidden-keys");
        var uid2 = require2("../internals/uid");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var wrappedWellKnownSymbolModule = require2("../internals/well-known-symbol-wrapped");
        var defineWellKnownSymbol = require2("../internals/well-known-symbol-define");
        var defineSymbolToPrimitive = require2("../internals/symbol-define-to-primitive");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var InternalStateModule = require2("../internals/internal-state");
        var $forEach = require2("../internals/array-iteration").forEach;
        var HIDDEN = sharedKey("hidden");
        var SYMBOL = "Symbol";
        var PROTOTYPE = "prototype";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(SYMBOL);
        var ObjectPrototype = Object[PROTOTYPE];
        var $Symbol = global3.Symbol;
        var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
        var RangeError2 = global3.RangeError;
        var TypeError2 = global3.TypeError;
        var QObject = global3.QObject;
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
        var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
        var push = uncurryThis([].push);
        var AllSymbols = shared("symbols");
        var ObjectPrototypeSymbols = shared("op-symbols");
        var WellKnownSymbolsStore = shared("wks");
        var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
        var fallbackDefineProperty = function(O, P, Attributes) {
          var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
          if (ObjectPrototypeDescriptor)
            delete ObjectPrototype[P];
          nativeDefineProperty(O, P, Attributes);
          if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
            nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
          }
        };
        var setSymbolDescriptor = DESCRIPTORS && fails(function() {
          return nativeObjectCreate(nativeDefineProperty({}, "a", {
            get: function() {
              return nativeDefineProperty(this, "a", { value: 7 }).a;
            }
          })).a !== 7;
        }) ? fallbackDefineProperty : nativeDefineProperty;
        var wrap = function(tag2, description) {
          var symbol = AllSymbols[tag2] = nativeObjectCreate(SymbolPrototype);
          setInternalState(symbol, {
            type: SYMBOL,
            tag: tag2,
            description
          });
          if (!DESCRIPTORS)
            symbol.description = description;
          return symbol;
        };
        var $defineProperty = function defineProperty(O, P, Attributes) {
          if (O === ObjectPrototype)
            $defineProperty(ObjectPrototypeSymbols, P, Attributes);
          anObject(O);
          var key = toPropertyKey(P);
          anObject(Attributes);
          if (hasOwn2(AllSymbols, key)) {
            if (!Attributes.enumerable) {
              if (!hasOwn2(O, HIDDEN))
                nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
              O[HIDDEN][key] = true;
            } else {
              if (hasOwn2(O, HIDDEN) && O[HIDDEN][key])
                O[HIDDEN][key] = false;
              Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
            }
            return setSymbolDescriptor(O, key, Attributes);
          }
          return nativeDefineProperty(O, key, Attributes);
        };
        var $defineProperties = function defineProperties(O, Properties) {
          anObject(O);
          var properties = toIndexedObject(Properties);
          var keys = objectKeys2(properties).concat($getOwnPropertySymbols(properties));
          $forEach(keys, function(key) {
            if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
              $defineProperty(O, key, properties[key]);
          });
          return O;
        };
        var $create = function create3(O, Properties) {
          return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
        };
        var $propertyIsEnumerable = function propertyIsEnumerable(V2) {
          var P = toPropertyKey(V2);
          var enumerable = call(nativePropertyIsEnumerable, this, P);
          if (this === ObjectPrototype && hasOwn2(AllSymbols, P) && !hasOwn2(ObjectPrototypeSymbols, P))
            return false;
          return enumerable || !hasOwn2(this, P) || !hasOwn2(AllSymbols, P) || hasOwn2(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
          var it = toIndexedObject(O);
          var key = toPropertyKey(P);
          if (it === ObjectPrototype && hasOwn2(AllSymbols, key) && !hasOwn2(ObjectPrototypeSymbols, key))
            return;
          var descriptor = nativeGetOwnPropertyDescriptor(it, key);
          if (descriptor && hasOwn2(AllSymbols, key) && !(hasOwn2(it, HIDDEN) && it[HIDDEN][key])) {
            descriptor.enumerable = true;
          }
          return descriptor;
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(O) {
          var names = nativeGetOwnPropertyNames(toIndexedObject(O));
          var result = [];
          $forEach(names, function(key) {
            if (!hasOwn2(AllSymbols, key) && !hasOwn2(hiddenKeys, key))
              push(result, key);
          });
          return result;
        };
        var $getOwnPropertySymbols = function(O) {
          var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
          var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
          var result = [];
          $forEach(names, function(key) {
            if (hasOwn2(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn2(ObjectPrototype, key))) {
              push(result, AllSymbols[key]);
            }
          });
          return result;
        };
        if (!NATIVE_SYMBOL) {
          $Symbol = function Symbol2() {
            if (isPrototypeOf(SymbolPrototype, this))
              throw new TypeError2("Symbol is not a constructor");
            var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
            var tag2 = uid2(description);
            var setter = function(value) {
              var $this = this === void 0 ? global3 : this;
              if ($this === ObjectPrototype)
                call(setter, ObjectPrototypeSymbols, value);
              if (hasOwn2($this, HIDDEN) && hasOwn2($this[HIDDEN], tag2))
                $this[HIDDEN][tag2] = false;
              var descriptor = createPropertyDescriptor(1, value);
              try {
                setSymbolDescriptor($this, tag2, descriptor);
              } catch (error2) {
                if (!(error2 instanceof RangeError2))
                  throw error2;
                fallbackDefineProperty($this, tag2, descriptor);
              }
            };
            if (DESCRIPTORS && USE_SETTER)
              setSymbolDescriptor(ObjectPrototype, tag2, { configurable: true, set: setter });
            return wrap(tag2, description);
          };
          SymbolPrototype = $Symbol[PROTOTYPE];
          defineBuiltIn(SymbolPrototype, "toString", function toString2() {
            return getInternalState(this).tag;
          });
          defineBuiltIn($Symbol, "withoutSetter", function(description) {
            return wrap(uid2(description), description);
          });
          propertyIsEnumerableModule.f = $propertyIsEnumerable;
          definePropertyModule.f = $defineProperty;
          definePropertiesModule.f = $defineProperties;
          getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
          getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
          getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
          wrappedWellKnownSymbolModule.f = function(name) {
            return wrap(wellKnownSymbol(name), name);
          };
          if (DESCRIPTORS) {
            defineBuiltInAccessor(SymbolPrototype, "description", {
              configurable: true,
              get: function description() {
                return getInternalState(this).description;
              }
            });
            if (!IS_PURE) {
              defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
            }
          }
        }
        $({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
          Symbol: $Symbol
        });
        $forEach(objectKeys2(WellKnownSymbolsStore), function(name) {
          defineWellKnownSymbol(name);
        });
        $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
          useSetter: function() {
            USE_SETTER = true;
          },
          useSimple: function() {
            USE_SETTER = false;
          }
        });
        $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
          // `Object.create` method
          // https://tc39.es/ecma262/#sec-object.create
          create: $create,
          // `Object.defineProperty` method
          // https://tc39.es/ecma262/#sec-object.defineproperty
          defineProperty: $defineProperty,
          // `Object.defineProperties` method
          // https://tc39.es/ecma262/#sec-object.defineproperties
          defineProperties: $defineProperties,
          // `Object.getOwnPropertyDescriptor` method
          // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor
        });
        $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
          // `Object.getOwnPropertyNames` method
          // https://tc39.es/ecma262/#sec-object.getownpropertynames
          getOwnPropertyNames: $getOwnPropertyNames
        });
        defineSymbolToPrimitive();
        setToStringTag($Symbol, SYMBOL);
        hiddenKeys[HIDDEN] = true;
      }, { "../internals/an-object": 114, "../internals/array-iteration": 125, "../internals/create-property-descriptor": 146, "../internals/define-built-in": 149, "../internals/define-built-in-accessor": 148, "../internals/descriptors": 153, "../internals/export": 170, "../internals/fails": 171, "../internals/function-call": 177, "../internals/function-uncurry-this": 181, "../internals/global": 188, "../internals/has-own-property": 189, "../internals/hidden-keys": 190, "../internals/internal-state": 199, "../internals/is-pure": 210, "../internals/object-create": 229, "../internals/object-define-properties": 230, "../internals/object-define-property": 231, "../internals/object-get-own-property-descriptor": 232, "../internals/object-get-own-property-names": 234, "../internals/object-get-own-property-names-external": 233, "../internals/object-get-own-property-symbols": 235, "../internals/object-is-prototype-of": 238, "../internals/object-keys": 240, "../internals/object-property-is-enumerable": 241, "../internals/set-to-string-tag": 266, "../internals/shared": 269, "../internals/shared-key": 267, "../internals/symbol-constructor-detection": 274, "../internals/symbol-define-to-primitive": 275, "../internals/to-indexed-object": 282, "../internals/to-property-key": 289, "../internals/to-string": 291, "../internals/uid": 299, "../internals/well-known-symbol": 306, "../internals/well-known-symbol-define": 304, "../internals/well-known-symbol-wrapped": 305 }], 351: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var DESCRIPTORS = require2("../internals/descriptors");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var hasOwn2 = require2("../internals/has-own-property");
        var isCallable = require2("../internals/is-callable");
        var isPrototypeOf = require2("../internals/object-is-prototype-of");
        var toString2 = require2("../internals/to-string");
        var defineBuiltInAccessor = require2("../internals/define-built-in-accessor");
        var copyConstructorProperties = require2("../internals/copy-constructor-properties");
        var NativeSymbol = global3.Symbol;
        var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
        if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
        NativeSymbol().description !== void 0)) {
          var EmptyStringDescriptionStore = {};
          var SymbolWrapper = function Symbol2() {
            var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString2(arguments[0]);
            var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
            if (description === "")
              EmptyStringDescriptionStore[result] = true;
            return result;
          };
          copyConstructorProperties(SymbolWrapper, NativeSymbol);
          SymbolWrapper.prototype = SymbolPrototype;
          SymbolPrototype.constructor = SymbolWrapper;
          var NATIVE_SYMBOL = String(NativeSymbol("description detection")) === "Symbol(description detection)";
          var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
          var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
          var regexp = /^Symbol\((.*)\)[^)]+$/;
          var replace = uncurryThis("".replace);
          var stringSlice = uncurryThis("".slice);
          defineBuiltInAccessor(SymbolPrototype, "description", {
            configurable: true,
            get: function description() {
              var symbol = thisSymbolValue(this);
              if (hasOwn2(EmptyStringDescriptionStore, symbol))
                return "";
              var string2 = symbolDescriptiveString(symbol);
              var desc = NATIVE_SYMBOL ? stringSlice(string2, 7, -1) : replace(string2, regexp, "$1");
              return desc === "" ? void 0 : desc;
            }
          });
          $({ global: true, constructor: true, forced: true }, {
            Symbol: SymbolWrapper
          });
        }
      }, { "../internals/copy-constructor-properties": 141, "../internals/define-built-in-accessor": 148, "../internals/descriptors": 153, "../internals/export": 170, "../internals/function-uncurry-this": 181, "../internals/global": 188, "../internals/has-own-property": 189, "../internals/is-callable": 203, "../internals/object-is-prototype-of": 238, "../internals/to-string": 291 }], 352: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var getBuiltIn = require2("../internals/get-built-in");
        var hasOwn2 = require2("../internals/has-own-property");
        var toString2 = require2("../internals/to-string");
        var shared = require2("../internals/shared");
        var NATIVE_SYMBOL_REGISTRY = require2("../internals/symbol-registry-detection");
        var StringToSymbolRegistry = shared("string-to-symbol-registry");
        var SymbolToStringRegistry = shared("symbol-to-string-registry");
        $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
          "for": function(key) {
            var string2 = toString2(key);
            if (hasOwn2(StringToSymbolRegistry, string2))
              return StringToSymbolRegistry[string2];
            var symbol = getBuiltIn("Symbol")(string2);
            StringToSymbolRegistry[string2] = symbol;
            SymbolToStringRegistry[symbol] = string2;
            return symbol;
          }
        });
      }, { "../internals/export": 170, "../internals/get-built-in": 182, "../internals/has-own-property": 189, "../internals/shared": 269, "../internals/symbol-registry-detection": 276, "../internals/to-string": 291 }], 353: [function(require2, module3, exports3) {
        var defineWellKnownSymbol = require2("../internals/well-known-symbol-define");
        defineWellKnownSymbol("iterator");
      }, { "../internals/well-known-symbol-define": 304 }], 354: [function(require2, module3, exports3) {
        require2("../modules/es.symbol.constructor");
        require2("../modules/es.symbol.for");
        require2("../modules/es.symbol.key-for");
        require2("../modules/es.json.stringify");
        require2("../modules/es.object.get-own-property-symbols");
      }, { "../modules/es.json.stringify": 323, "../modules/es.object.get-own-property-symbols": 327, "../modules/es.symbol.constructor": 350, "../modules/es.symbol.for": 352, "../modules/es.symbol.key-for": 355 }], 355: [function(require2, module3, exports3) {
        var $ = require2("../internals/export");
        var hasOwn2 = require2("../internals/has-own-property");
        var isSymbol2 = require2("../internals/is-symbol");
        var tryToString = require2("../internals/try-to-string");
        var shared = require2("../internals/shared");
        var NATIVE_SYMBOL_REGISTRY = require2("../internals/symbol-registry-detection");
        var SymbolToStringRegistry = shared("symbol-to-string-registry");
        $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
          keyFor: function keyFor(sym) {
            if (!isSymbol2(sym))
              throw new TypeError(tryToString(sym) + " is not a symbol");
            if (hasOwn2(SymbolToStringRegistry, sym))
              return SymbolToStringRegistry[sym];
          }
        });
      }, { "../internals/export": 170, "../internals/has-own-property": 189, "../internals/is-symbol": 212, "../internals/shared": 269, "../internals/symbol-registry-detection": 276, "../internals/try-to-string": 293 }], 356: [function(require2, module3, exports3) {
        var uncurryThis = require2("../internals/function-uncurry-this");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $ArrayCopyWithin = require2("../internals/array-copy-within");
        var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("copyWithin", function copyWithin(target, start) {
          return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-copy-within": 119, "../internals/function-uncurry-this": 181 }], 357: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $every = require2("../internals/array-iteration").every;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("every", function every(callbackfn) {
          return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-iteration": 125 }], 358: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $fill = require2("../internals/array-fill");
        var toBigInt = require2("../internals/to-big-int");
        var classof = require2("../internals/classof");
        var call = require2("../internals/function-call");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var fails = require2("../internals/fails");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var slice = uncurryThis("".slice);
        var CONVERSION_BUG = fails(function() {
          var count = 0;
          new Int8Array(2).fill({ valueOf: function() {
            return count++;
          } });
          return count !== 1;
        });
        exportTypedArrayMethod("fill", function fill(value) {
          var length = arguments.length;
          aTypedArray(this);
          var actualValue = slice(classof(this), 0, 3) === "Big" ? toBigInt(value) : +value;
          return call($fill, this, actualValue, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
        }, CONVERSION_BUG);
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-fill": 120, "../internals/classof": 138, "../internals/fails": 171, "../internals/function-call": 177, "../internals/function-uncurry-this": 181, "../internals/to-big-int": 280 }], 359: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $filter = require2("../internals/array-iteration").filter;
        var fromSpeciesAndList = require2("../internals/typed-array-from-species-and-list");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("filter", function filter(callbackfn) {
          var list2 = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          return fromSpeciesAndList(this, list2);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-iteration": 125, "../internals/typed-array-from-species-and-list": 296 }], 360: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $findIndex = require2("../internals/array-iteration").findIndex;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("findIndex", function findIndex(predicate) {
          return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-iteration": 125 }], 361: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $find = require2("../internals/array-iteration").find;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("find", function find2(predicate) {
          return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-iteration": 125 }], 362: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $forEach = require2("../internals/array-iteration").forEach;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("forEach", function forEach3(callbackfn) {
          $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-iteration": 125 }], 363: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $includes = require2("../internals/array-includes").includes;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("includes", function includes(searchElement) {
          return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-includes": 124 }], 364: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $indexOf = require2("../internals/array-includes").indexOf;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
          return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-includes": 124 }], 365: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var fails = require2("../internals/fails");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var ArrayIterators = require2("../modules/es.array.iterator");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var ITERATOR = wellKnownSymbol("iterator");
        var Uint8Array2 = global3.Uint8Array;
        var arrayValues = uncurryThis(ArrayIterators.values);
        var arrayKeys = uncurryThis(ArrayIterators.keys);
        var arrayEntries = uncurryThis(ArrayIterators.entries);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var TypedArrayPrototype = Uint8Array2 && Uint8Array2.prototype;
        var GENERIC = !fails(function() {
          TypedArrayPrototype[ITERATOR].call([1]);
        });
        var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
        var typedArrayValues = function values() {
          return arrayValues(aTypedArray(this));
        };
        exportTypedArrayMethod("entries", function entries() {
          return arrayEntries(aTypedArray(this));
        }, GENERIC);
        exportTypedArrayMethod("keys", function keys() {
          return arrayKeys(aTypedArray(this));
        }, GENERIC);
        exportTypedArrayMethod("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
        exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
      }, { "../internals/array-buffer-view-core": 117, "../internals/fails": 171, "../internals/function-uncurry-this": 181, "../internals/global": 188, "../internals/well-known-symbol": 306, "../modules/es.array.iterator": 316 }], 366: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $join = uncurryThis([].join);
        exportTypedArrayMethod("join", function join(separator) {
          return $join(aTypedArray(this), separator);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/function-uncurry-this": 181 }], 367: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var apply = require2("../internals/function-apply");
        var $lastIndexOf = require2("../internals/array-last-index-of");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
          var length = arguments.length;
          return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-last-index-of": 126, "../internals/function-apply": 174 }], 368: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $map = require2("../internals/array-iteration").map;
        var typedArraySpeciesConstructor = require2("../internals/typed-array-species-constructor");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("map", function map(mapfn) {
          return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
            return new (typedArraySpeciesConstructor(O))(length);
          });
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-iteration": 125, "../internals/typed-array-species-constructor": 298 }], 369: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $reduceRight = require2("../internals/array-reduce").right;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
          var length = arguments.length;
          return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-reduce": 129 }], 370: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $reduce = require2("../internals/array-reduce").left;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("reduce", function reduce(callbackfn) {
          var length = arguments.length;
          return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-reduce": 129 }], 371: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var floor = Math.floor;
        exportTypedArrayMethod("reverse", function reverse() {
          var that = this;
          var length = aTypedArray(that).length;
          var middle = floor(length / 2);
          var index2 = 0;
          var value;
          while (index2 < middle) {
            value = that[index2];
            that[index2++] = that[--length];
            that[length] = value;
          }
          return that;
        });
      }, { "../internals/array-buffer-view-core": 117 }], 372: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var call = require2("../internals/function-call");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var lengthOfArrayLike = require2("../internals/length-of-array-like");
        var toOffset = require2("../internals/to-offset");
        var toIndexedObject = require2("../internals/to-object");
        var fails = require2("../internals/fails");
        var RangeError2 = global3.RangeError;
        var Int8Array2 = global3.Int8Array;
        var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
        var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function() {
          var array2 = new Uint8ClampedArray(2);
          call($set, array2, { length: 1, 0: 3 }, 1);
          return array2[1] !== 3;
        });
        var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
          var array2 = new Int8Array2(2);
          array2.set(1);
          array2.set("2", 1);
          return array2[0] !== 0 || array2[1] !== 2;
        });
        exportTypedArrayMethod("set", function set2(arrayLike) {
          aTypedArray(this);
          var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
          var src = toIndexedObject(arrayLike);
          if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS)
            return call($set, this, src, offset);
          var length = this.length;
          var len = lengthOfArrayLike(src);
          var index2 = 0;
          if (len + offset > length)
            throw new RangeError2("Wrong length");
          while (index2 < len)
            this[offset + index2] = src[index2++];
        }, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
      }, { "../internals/array-buffer-view-core": 117, "../internals/fails": 171, "../internals/function-call": 177, "../internals/global": 188, "../internals/length-of-array-like": 219, "../internals/to-object": 285, "../internals/to-offset": 286 }], 373: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var typedArraySpeciesConstructor = require2("../internals/typed-array-species-constructor");
        var fails = require2("../internals/fails");
        var arraySlice = require2("../internals/array-slice");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var FORCED = fails(function() {
          new Int8Array(1).slice();
        });
        exportTypedArrayMethod("slice", function slice(start, end) {
          var list2 = arraySlice(aTypedArray(this), start, end);
          var C = typedArraySpeciesConstructor(this);
          var index2 = 0;
          var length = list2.length;
          var result = new C(length);
          while (length > index2)
            result[index2] = list2[index2++];
          return result;
        }, FORCED);
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-slice": 131, "../internals/fails": 171, "../internals/typed-array-species-constructor": 298 }], 374: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var $some = require2("../internals/array-iteration").some;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("some", function some(callbackfn) {
          return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-iteration": 125 }], 375: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this-clause");
        var fails = require2("../internals/fails");
        var aCallable = require2("../internals/a-callable");
        var internalSort = require2("../internals/array-sort");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var FF = require2("../internals/engine-ff-version");
        var IE_OR_EDGE = require2("../internals/engine-is-ie-or-edge");
        var V8 = require2("../internals/engine-v8-version");
        var WEBKIT = require2("../internals/engine-webkit-version");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var Uint16Array2 = global3.Uint16Array;
        var nativeSort = Uint16Array2 && uncurryThis(Uint16Array2.prototype.sort);
        var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function() {
          nativeSort(new Uint16Array2(2), null);
        }) && fails(function() {
          nativeSort(new Uint16Array2(2), {});
        }));
        var STABLE_SORT = !!nativeSort && !fails(function() {
          if (V8)
            return V8 < 74;
          if (FF)
            return FF < 67;
          if (IE_OR_EDGE)
            return true;
          if (WEBKIT)
            return WEBKIT < 602;
          var array2 = new Uint16Array2(516);
          var expected = Array(516);
          var index2, mod;
          for (index2 = 0; index2 < 516; index2++) {
            mod = index2 % 4;
            array2[index2] = 515 - index2;
            expected[index2] = index2 - 2 * mod + 3;
          }
          nativeSort(array2, function(a2, b) {
            return (a2 / 4 | 0) - (b / 4 | 0);
          });
          for (index2 = 0; index2 < 516; index2++) {
            if (array2[index2] !== expected[index2])
              return true;
          }
        });
        var getSortCompare = function(comparefn) {
          return function(x, y) {
            if (comparefn !== void 0)
              return +comparefn(x, y) || 0;
            if (y !== y)
              return -1;
            if (x !== x)
              return 1;
            if (x === 0 && y === 0)
              return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
            return x > y;
          };
        };
        exportTypedArrayMethod("sort", function sort(comparefn) {
          if (comparefn !== void 0)
            aCallable(comparefn);
          if (STABLE_SORT)
            return nativeSort(this, comparefn);
          return internalSort(aTypedArray(this), getSortCompare(comparefn));
        }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
      }, { "../internals/a-callable": 108, "../internals/array-buffer-view-core": 117, "../internals/array-sort": 132, "../internals/engine-ff-version": 158, "../internals/engine-is-ie-or-edge": 161, "../internals/engine-v8-version": 167, "../internals/engine-webkit-version": 168, "../internals/fails": 171, "../internals/function-uncurry-this-clause": 180, "../internals/global": 188 }], 376: [function(require2, module3, exports3) {
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var toLength = require2("../internals/to-length");
        var toAbsoluteIndex = require2("../internals/to-absolute-index");
        var typedArraySpeciesConstructor = require2("../internals/typed-array-species-constructor");
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        exportTypedArrayMethod("subarray", function subarray(begin, end) {
          var O = aTypedArray(this);
          var length = O.length;
          var beginIndex = toAbsoluteIndex(begin, length);
          var C = typedArraySpeciesConstructor(O);
          return new C(
            O.buffer,
            O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
            toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - beginIndex)
          );
        });
      }, { "../internals/array-buffer-view-core": 117, "../internals/to-absolute-index": 279, "../internals/to-length": 284, "../internals/typed-array-species-constructor": 298 }], 377: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var apply = require2("../internals/function-apply");
        var ArrayBufferViewCore = require2("../internals/array-buffer-view-core");
        var fails = require2("../internals/fails");
        var arraySlice = require2("../internals/array-slice");
        var Int8Array2 = global3.Int8Array;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $toLocaleString = [].toLocaleString;
        var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
          $toLocaleString.call(new Int8Array2(1));
        });
        var FORCED = fails(function() {
          return [1, 2].toLocaleString() !== new Int8Array2([1, 2]).toLocaleString();
        }) || !fails(function() {
          Int8Array2.prototype.toLocaleString.call([1, 2]);
        });
        exportTypedArrayMethod("toLocaleString", function toLocaleString() {
          return apply(
            $toLocaleString,
            TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
            arraySlice(arguments)
          );
        }, FORCED);
      }, { "../internals/array-buffer-view-core": 117, "../internals/array-slice": 131, "../internals/fails": 171, "../internals/function-apply": 174, "../internals/global": 188 }], 378: [function(require2, module3, exports3) {
        var exportTypedArrayMethod = require2("../internals/array-buffer-view-core").exportTypedArrayMethod;
        var fails = require2("../internals/fails");
        var global3 = require2("../internals/global");
        var uncurryThis = require2("../internals/function-uncurry-this");
        var Uint8Array2 = global3.Uint8Array;
        var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
        var arrayToString = [].toString;
        var join = uncurryThis([].join);
        if (fails(function() {
          arrayToString.call({});
        })) {
          arrayToString = function toString2() {
            return join(this);
          };
        }
        var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;
        exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
      }, { "../internals/array-buffer-view-core": 117, "../internals/fails": 171, "../internals/function-uncurry-this": 181, "../internals/global": 188 }], 379: [function(require2, module3, exports3) {
        var createTypedArrayConstructor = require2("../internals/typed-array-constructor");
        createTypedArrayConstructor("Uint8", function(init) {
          return function Uint8Array2(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      }, { "../internals/typed-array-constructor": 294 }], 380: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var DOMIterables = require2("../internals/dom-iterables");
        var DOMTokenListPrototype = require2("../internals/dom-token-list-prototype");
        var forEach3 = require2("../internals/array-for-each");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var handlePrototype = function(CollectionPrototype) {
          if (CollectionPrototype && CollectionPrototype.forEach !== forEach3)
            try {
              createNonEnumerableProperty(CollectionPrototype, "forEach", forEach3);
            } catch (error2) {
              CollectionPrototype.forEach = forEach3;
            }
        };
        for (var COLLECTION_NAME in DOMIterables) {
          if (DOMIterables[COLLECTION_NAME]) {
            handlePrototype(global3[COLLECTION_NAME] && global3[COLLECTION_NAME].prototype);
          }
        }
        handlePrototype(DOMTokenListPrototype);
      }, { "../internals/array-for-each": 121, "../internals/create-non-enumerable-property": 145, "../internals/dom-iterables": 156, "../internals/dom-token-list-prototype": 157, "../internals/global": 188 }], 381: [function(require2, module3, exports3) {
        var global3 = require2("../internals/global");
        var DOMIterables = require2("../internals/dom-iterables");
        var DOMTokenListPrototype = require2("../internals/dom-token-list-prototype");
        var ArrayIteratorMethods = require2("../modules/es.array.iterator");
        var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
        var setToStringTag = require2("../internals/set-to-string-tag");
        var wellKnownSymbol = require2("../internals/well-known-symbol");
        var ITERATOR = wellKnownSymbol("iterator");
        var ArrayValues = ArrayIteratorMethods.values;
        var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
          if (CollectionPrototype) {
            if (CollectionPrototype[ITERATOR] !== ArrayValues)
              try {
                createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
              } catch (error2) {
                CollectionPrototype[ITERATOR] = ArrayValues;
              }
            setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
            if (DOMIterables[COLLECTION_NAME2])
              for (var METHOD_NAME in ArrayIteratorMethods) {
                if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                  try {
                    createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                  } catch (error2) {
                    CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                  }
              }
          }
        };
        for (var COLLECTION_NAME in DOMIterables) {
          handlePrototype(global3[COLLECTION_NAME] && global3[COLLECTION_NAME].prototype, COLLECTION_NAME);
        }
        handlePrototype(DOMTokenListPrototype, "DOMTokenList");
      }, { "../internals/create-non-enumerable-property": 145, "../internals/dom-iterables": 156, "../internals/dom-token-list-prototype": 157, "../internals/global": 188, "../internals/set-to-string-tag": 266, "../internals/well-known-symbol": 306, "../modules/es.array.iterator": 316 }], 382: [function(require2, module3, exports3) {
        function isArray2(arg) {
          if (Array.isArray) {
            return Array.isArray(arg);
          }
          return objectToString2(arg) === "[object Array]";
        }
        exports3.isArray = isArray2;
        function isBoolean2(arg) {
          return typeof arg === "boolean";
        }
        exports3.isBoolean = isBoolean2;
        function isNull(arg) {
          return arg === null;
        }
        exports3.isNull = isNull;
        function isNullOrUndefined(arg) {
          return arg == null;
        }
        exports3.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
          return typeof arg === "number";
        }
        exports3.isNumber = isNumber;
        function isString2(arg) {
          return typeof arg === "string";
        }
        exports3.isString = isString2;
        function isSymbol2(arg) {
          return typeof arg === "symbol";
        }
        exports3.isSymbol = isSymbol2;
        function isUndefined2(arg) {
          return arg === void 0;
        }
        exports3.isUndefined = isUndefined2;
        function isRegExp(re) {
          return objectToString2(re) === "[object RegExp]";
        }
        exports3.isRegExp = isRegExp;
        function isObject2(arg) {
          return typeof arg === "object" && arg !== null;
        }
        exports3.isObject = isObject2;
        function isDate2(d) {
          return objectToString2(d) === "[object Date]";
        }
        exports3.isDate = isDate2;
        function isError(e2) {
          return objectToString2(e2) === "[object Error]" || e2 instanceof Error;
        }
        exports3.isError = isError;
        function isFunction2(arg) {
          return typeof arg === "function";
        }
        exports3.isFunction = isFunction2;
        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
          typeof arg === "undefined";
        }
        exports3.isPrimitive = isPrimitive;
        exports3.isBuffer = require2("buffer").Buffer.isBuffer;
        function objectToString2(o2) {
          return Object.prototype.toString.call(o2);
        }
      }, { "buffer": 103 }], 383: [function(require2, module3, exports3) {
        (function(global3) {
          var dateFormat = /* @__PURE__ */ function() {
            var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g;
            var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
            var timezoneClip = /[^-+\dA-Z]/g;
            return function(date2, mask, utc, gmt) {
              if (arguments.length === 1 && kindOf(date2) === "string" && !/\d/.test(date2)) {
                mask = date2;
                date2 = void 0;
              }
              date2 = date2 || /* @__PURE__ */ new Date();
              if (!(date2 instanceof Date)) {
                date2 = new Date(date2);
              }
              if (isNaN(date2)) {
                throw TypeError("Invalid date");
              }
              mask = String(dateFormat.masks[mask] || mask || dateFormat.masks["default"]);
              var maskSlice = mask.slice(0, 4);
              if (maskSlice === "UTC:" || maskSlice === "GMT:") {
                mask = mask.slice(4);
                utc = true;
                if (maskSlice === "GMT:") {
                  gmt = true;
                }
              }
              var _ = utc ? "getUTC" : "get";
              var d = date2[_ + "Date"]();
              var D = date2[_ + "Day"]();
              var m = date2[_ + "Month"]();
              var y = date2[_ + "FullYear"]();
              var H = date2[_ + "Hours"]();
              var M = date2[_ + "Minutes"]();
              var s2 = date2[_ + "Seconds"]();
              var L2 = date2[_ + "Milliseconds"]();
              var o2 = utc ? 0 : date2.getTimezoneOffset();
              var W = getWeek(date2);
              var N = getDayOfWeek(date2);
              var flags = {
                d,
                dd: pad2(d),
                ddd: dateFormat.i18n.dayNames[D],
                dddd: dateFormat.i18n.dayNames[D + 7],
                m: m + 1,
                mm: pad2(m + 1),
                mmm: dateFormat.i18n.monthNames[m],
                mmmm: dateFormat.i18n.monthNames[m + 12],
                yy: String(y).slice(2),
                yyyy: y,
                h: H % 12 || 12,
                hh: pad2(H % 12 || 12),
                H,
                HH: pad2(H),
                M,
                MM: pad2(M),
                s: s2,
                ss: pad2(s2),
                l: pad2(L2, 3),
                L: pad2(Math.round(L2 / 10)),
                t: H < 12 ? "a" : "p",
                tt: H < 12 ? "am" : "pm",
                T: H < 12 ? "A" : "P",
                TT: H < 12 ? "AM" : "PM",
                Z: gmt ? "GMT" : utc ? "UTC" : (String(date2).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o: (o2 > 0 ? "-" : "+") + pad2(Math.floor(Math.abs(o2) / 60) * 100 + Math.abs(o2) % 60, 4),
                S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
                W,
                N
              };
              return mask.replace(token, function(match) {
                if (match in flags) {
                  return flags[match];
                }
                return match.slice(1, match.length - 1);
              });
            };
          }();
          dateFormat.masks = {
            "default": "ddd mmm dd yyyy HH:MM:ss",
            "shortDate": "m/d/yy",
            "mediumDate": "mmm d, yyyy",
            "longDate": "mmmm d, yyyy",
            "fullDate": "dddd, mmmm d, yyyy",
            "shortTime": "h:MM TT",
            "mediumTime": "h:MM:ss TT",
            "longTime": "h:MM:ss TT Z",
            "isoDate": "yyyy-mm-dd",
            "isoTime": "HH:MM:ss",
            "isoDateTime": "yyyy-mm-dd'T'HH:MM:sso",
            "isoUtcDateTime": "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
            "expiresHeaderFormat": "ddd, dd mmm yyyy HH:MM:ss Z"
          };
          dateFormat.i18n = {
            dayNames: [
              "Sun",
              "Mon",
              "Tue",
              "Wed",
              "Thu",
              "Fri",
              "Sat",
              "Sunday",
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday"
            ],
            monthNames: [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec",
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ]
          };
          function pad2(val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) {
              val = "0" + val;
            }
            return val;
          }
          function getWeek(date2) {
            var targetThursday = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);
            var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
            firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
            var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
            targetThursday.setHours(targetThursday.getHours() - ds);
            var weekDiff = (targetThursday - firstThursday) / (864e5 * 7);
            return 1 + Math.floor(weekDiff);
          }
          function getDayOfWeek(date2) {
            var dow = date2.getDay();
            if (dow === 0) {
              dow = 7;
            }
            return dow;
          }
          function kindOf(val) {
            if (val === null) {
              return "null";
            }
            if (val === void 0) {
              return "undefined";
            }
            if (typeof val !== "object") {
              return typeof val;
            }
            if (Array.isArray(val)) {
              return "array";
            }
            return {}.toString.call(val).slice(8, -1).toLowerCase();
          }
          if (typeof exports3 === "object") {
            module3.exports = dateFormat;
          } else {
            global3.dateFormat = dateFormat;
          }
        })(this);
      }, {}], 384: [function(require2, module3, exports3) {
        var hasPropertyDescriptors = require2("has-property-descriptors")();
        var GetIntrinsic = require2("get-intrinsic");
        var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
          } catch (e2) {
            $defineProperty = false;
          }
        }
        var $SyntaxError = GetIntrinsic("%SyntaxError%");
        var $TypeError = GetIntrinsic("%TypeError%");
        var gopd = require2("gopd");
        module3.exports = function defineDataProperty(obj, property, value) {
          if (!obj || typeof obj !== "object" && typeof obj !== "function") {
            throw new $TypeError("`obj` must be an object or a function`");
          }
          if (typeof property !== "string" && typeof property !== "symbol") {
            throw new $TypeError("`property` must be a string or a symbol`");
          }
          if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
            throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
          }
          if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
            throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
          }
          if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
            throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
          }
          if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
            throw new $TypeError("`loose`, if provided, must be a boolean");
          }
          var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
          var nonWritable = arguments.length > 4 ? arguments[4] : null;
          var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
          var loose = arguments.length > 6 ? arguments[6] : false;
          var desc = !!gopd && gopd(obj, property);
          if ($defineProperty) {
            $defineProperty(obj, property, {
              configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
              enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
              value,
              writable: nonWritable === null && desc ? desc.writable : !nonWritable
            });
          } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
            obj[property] = value;
          } else {
            throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
          }
        };
      }, { "get-intrinsic": 390, "gopd": 391, "has-property-descriptors": 392 }], 385: [function(require2, module3, exports3) {
        var matchHtmlRegExp = /["'&<>]/;
        module3.exports = escapeHtml;
        function escapeHtml(string2) {
          var str = "" + string2;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape2;
          var html = "";
          var index2 = 0;
          var lastIndex = 0;
          for (index2 = match.index; index2 < str.length; index2++) {
            switch (str.charCodeAt(index2)) {
              case 34:
                escape2 = "&quot;";
                break;
              case 38:
                escape2 = "&amp;";
                break;
              case 39:
                escape2 = "&#39;";
                break;
              case 60:
                escape2 = "&lt;";
                break;
              case 62:
                escape2 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index2) {
              html += str.substring(lastIndex, index2);
            }
            lastIndex = index2 + 1;
            html += escape2;
          }
          return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
        }
      }, {}], 386: [function(require2, module3, exports3) {
        var R = typeof Reflect === "object" ? Reflect : null;
        var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
          return Function.prototype.apply.call(target, receiver, args);
        };
        var ReflectOwnKeys;
        if (R && typeof R.ownKeys === "function") {
          ReflectOwnKeys = R.ownKeys;
        } else if (Object.getOwnPropertySymbols) {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
          };
        } else {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target);
          };
        }
        function ProcessEmitWarning(warning) {
          if (console && console.warn)
            index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:20571", warning);
        }
        var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
          return value !== value;
        };
        function EventEmitter() {
          EventEmitter.init.call(this);
        }
        module3.exports = EventEmitter;
        module3.exports.once = once2;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = void 0;
        EventEmitter.prototype._eventsCount = 0;
        EventEmitter.prototype._maxListeners = void 0;
        var defaultMaxListeners = 10;
        function checkListener(listener) {
          if (typeof listener !== "function") {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
        }
        Object.defineProperty(EventEmitter, "defaultMaxListeners", {
          enumerable: true,
          get: function() {
            return defaultMaxListeners;
          },
          set: function(arg) {
            if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
            }
            defaultMaxListeners = arg;
          }
        });
        EventEmitter.init = function() {
          if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        };
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
          if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
          }
          this._maxListeners = n2;
          return this;
        };
        function _getMaxListeners(that) {
          if (that._maxListeners === void 0)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this);
        };
        EventEmitter.prototype.emit = function emit2(type) {
          var args = [];
          for (var i = 1; i < arguments.length; i++)
            args.push(arguments[i]);
          var doError = type === "error";
          var events = this._events;
          if (events !== void 0)
            doError = doError && events.error === void 0;
          else if (!doError)
            return false;
          if (doError) {
            var er;
            if (args.length > 0)
              er = args[0];
            if (er instanceof Error) {
              throw er;
            }
            var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
            err.context = er;
            throw err;
          }
          var handler = events[type];
          if (handler === void 0)
            return false;
          if (typeof handler === "function") {
            ReflectApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              ReflectApply(listeners[i], this, args);
          }
          return true;
        };
        function _addListener(target, type, listener, prepend) {
          var m;
          var events;
          var existing;
          checkListener(listener);
          events = target._events;
          if (events === void 0) {
            events = target._events = /* @__PURE__ */ Object.create(null);
            target._eventsCount = 0;
          } else {
            if (events.newListener !== void 0) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              );
              events = target._events;
            }
            existing = events[type];
          }
          if (existing === void 0) {
            existing = events[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            } else if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
            m = _getMaxListeners(target);
            if (m > 0 && existing.length > m && !existing.warned) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              ProcessEmitWarning(w);
            }
          }
          return target;
        }
        EventEmitter.prototype.addListener = function addListener(type, listener) {
          return _addListener(this, type, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };
        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            if (arguments.length === 0)
              return this.listener.call(this.target);
            return this.listener.apply(this.target, arguments);
          }
        }
        function _onceWrap(target, type, listener) {
          var state = { fired: false, wrapFn: void 0, target, type, listener };
          var wrapped = onceWrapper.bind(state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }
        EventEmitter.prototype.once = function once3(type, listener) {
          checkListener(listener);
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
          checkListener(listener);
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
          var list2, events, position2, i, originalListener;
          checkListener(listener);
          events = this._events;
          if (events === void 0)
            return this;
          list2 = events[type];
          if (list2 === void 0)
            return this;
          if (list2 === listener || list2.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit("removeListener", type, list2.listener || listener);
            }
          } else if (typeof list2 !== "function") {
            position2 = -1;
            for (i = list2.length - 1; i >= 0; i--) {
              if (list2[i] === listener || list2[i].listener === listener) {
                originalListener = list2[i].listener;
                position2 = i;
                break;
              }
            }
            if (position2 < 0)
              return this;
            if (position2 === 0)
              list2.shift();
            else {
              spliceOne(list2, position2);
            }
            if (list2.length === 1)
              events[type] = list2[0];
            if (events.removeListener !== void 0)
              this.emit("removeListener", type, originalListener || listener);
          }
          return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
          var listeners, events, i;
          events = this._events;
          if (events === void 0)
            return this;
          if (events.removeListener === void 0) {
            if (arguments.length === 0) {
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
            } else if (events[type] !== void 0) {
              if (--this._eventsCount === 0)
                this._events = /* @__PURE__ */ Object.create(null);
              else
                delete events[type];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "removeListener")
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
            return this;
          }
          listeners = events[type];
          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners !== void 0) {
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }
          return this;
        };
        function _listeners(target, type, unwrap) {
          var events = target._events;
          if (events === void 0)
            return [];
          var evlistener = events[type];
          if (evlistener === void 0)
            return [];
          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];
          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };
        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;
          if (events !== void 0) {
            var evlistener = events[type];
            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener !== void 0) {
              return evlistener.length;
            }
          }
          return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
        };
        function arrayClone(arr, n2) {
          var copy = new Array(n2);
          for (var i = 0; i < n2; ++i)
            copy[i] = arr[i];
          return copy;
        }
        function spliceOne(list2, index2) {
          for (; index2 + 1 < list2.length; index2++)
            list2[index2] = list2[index2 + 1];
          list2.pop();
        }
        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }
        function once2(emitter, name) {
          return new Promise(function(resolve2, reject) {
            function errorListener(err) {
              emitter.removeListener(name, resolver);
              reject(err);
            }
            function resolver() {
              if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
              }
              resolve2([].slice.call(arguments));
            }
            eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
            if (name !== "error") {
              addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
            }
          });
        }
        function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
          if (typeof emitter.on === "function") {
            eventTargetAgnosticAddListener(emitter, "error", handler, flags);
          }
        }
        function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
          if (typeof emitter.on === "function") {
            if (flags.once) {
              emitter.once(name, listener);
            } else {
              emitter.on(name, listener);
            }
          } else if (typeof emitter.addEventListener === "function") {
            emitter.addEventListener(name, function wrapListener(arg) {
              if (flags.once) {
                emitter.removeEventListener(name, wrapListener);
              }
              listener(arg);
            });
          } else {
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
          }
        }
      }, {}], 387: [function(require2, module3, exports3) {
        var isCallable = require2("is-callable");
        var toStr = Object.prototype.toString;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var forEachArray = function forEachArray2(array2, iterator, receiver) {
          for (var i = 0, len = array2.length; i < len; i++) {
            if (hasOwnProperty2.call(array2, i)) {
              if (receiver == null) {
                iterator(array2[i], i, array2);
              } else {
                iterator.call(receiver, array2[i], i, array2);
              }
            }
          }
        };
        var forEachString = function forEachString2(string2, iterator, receiver) {
          for (var i = 0, len = string2.length; i < len; i++) {
            if (receiver == null) {
              iterator(string2.charAt(i), i, string2);
            } else {
              iterator.call(receiver, string2.charAt(i), i, string2);
            }
          }
        };
        var forEachObject = function forEachObject2(object2, iterator, receiver) {
          for (var k in object2) {
            if (hasOwnProperty2.call(object2, k)) {
              if (receiver == null) {
                iterator(object2[k], k, object2);
              } else {
                iterator.call(receiver, object2[k], k, object2);
              }
            }
          }
        };
        var forEach3 = function forEach4(list2, iterator, thisArg) {
          if (!isCallable(iterator)) {
            throw new TypeError("iterator must be a function");
          }
          var receiver;
          if (arguments.length >= 3) {
            receiver = thisArg;
          }
          if (toStr.call(list2) === "[object Array]") {
            forEachArray(list2, iterator, receiver);
          } else if (typeof list2 === "string") {
            forEachString(list2, iterator, receiver);
          } else {
            forEachObject(list2, iterator, receiver);
          }
        };
        module3.exports = forEach3;
      }, { "is-callable": 410 }], 388: [function(require2, module3, exports3) {
        var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
        var toStr = Object.prototype.toString;
        var max = Math.max;
        var funcType = "[object Function]";
        var concatty = function concatty2(a2, b) {
          var arr = [];
          for (var i = 0; i < a2.length; i += 1) {
            arr[i] = a2[i];
          }
          for (var j = 0; j < b.length; j += 1) {
            arr[j + a2.length] = b[j];
          }
          return arr;
        };
        var slicy = function slicy2(arrLike, offset) {
          var arr = [];
          for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
            arr[j] = arrLike[i];
          }
          return arr;
        };
        var joiny = function(arr, joiner) {
          var str = "";
          for (var i = 0; i < arr.length; i += 1) {
            str += arr[i];
            if (i + 1 < arr.length) {
              str += joiner;
            }
          }
          return str;
        };
        module3.exports = function bind(that) {
          var target = this;
          if (typeof target !== "function" || toStr.apply(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
          }
          var args = slicy(arguments, 1);
          var bound;
          var binder = function() {
            if (this instanceof bound) {
              var result = target.apply(
                this,
                concatty(args, arguments)
              );
              if (Object(result) === result) {
                return result;
              }
              return this;
            }
            return target.apply(
              that,
              concatty(args, arguments)
            );
          };
          var boundLength = max(0, target.length - args.length);
          var boundArgs = [];
          for (var i = 0; i < boundLength; i++) {
            boundArgs[i] = "$" + i;
          }
          bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
          if (target.prototype) {
            var Empty = function Empty2() {
            };
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        };
      }, {}], 389: [function(require2, module3, exports3) {
        var implementation = require2("./implementation");
        module3.exports = Function.prototype.bind || implementation;
      }, { "./implementation": 388 }], 390: [function(require2, module3, exports3) {
        var undefined$1;
        var $SyntaxError = SyntaxError;
        var $Function = Function;
        var $TypeError = TypeError;
        var getEvalledConstructor = function(expressionSyntax) {
          try {
            return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
          } catch (e2) {
          }
        };
        var $gOPD = Object.getOwnPropertyDescriptor;
        if ($gOPD) {
          try {
            $gOPD({}, "");
          } catch (e2) {
            $gOPD = null;
          }
        }
        var throwTypeError = function() {
          throw new $TypeError();
        };
        var ThrowTypeError = $gOPD ? function() {
          try {
            arguments.callee;
            return throwTypeError;
          } catch (calleeThrows) {
            try {
              return $gOPD(arguments, "callee").get;
            } catch (gOPDthrows) {
              return throwTypeError;
            }
          }
        }() : throwTypeError;
        var hasSymbols = require2("has-symbols")();
        var hasProto = require2("has-proto")();
        var getProto2 = Object.getPrototypeOf || (hasProto ? function(x) {
          return x.__proto__;
        } : null);
        var needsEval = {};
        var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
        var INTRINSICS = {
          "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
          "%Array%": Array,
          "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
          "%ArrayIteratorPrototype%": hasSymbols && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
          "%AsyncFromSyncIteratorPrototype%": undefined$1,
          "%AsyncFunction%": needsEval,
          "%AsyncGenerator%": needsEval,
          "%AsyncGeneratorFunction%": needsEval,
          "%AsyncIteratorPrototype%": needsEval,
          "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
          "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
          "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
          "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
          "%Boolean%": Boolean,
          "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
          "%Date%": Date,
          "%decodeURI%": decodeURI,
          "%decodeURIComponent%": decodeURIComponent,
          "%encodeURI%": encodeURI,
          "%encodeURIComponent%": encodeURIComponent,
          "%Error%": Error,
          "%eval%": eval,
          // eslint-disable-line no-eval
          "%EvalError%": EvalError,
          "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
          "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
          "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
          "%Function%": $Function,
          "%GeneratorFunction%": needsEval,
          "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
          "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
          "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
          "%isFinite%": isFinite,
          "%isNaN%": isNaN,
          "%IteratorPrototype%": hasSymbols && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
          "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
          "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
          "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
          "%Math%": Math,
          "%Number%": Number,
          "%Object%": Object,
          "%parseFloat%": parseFloat,
          "%parseInt%": parseInt,
          "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
          "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
          "%RangeError%": RangeError,
          "%ReferenceError%": ReferenceError,
          "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
          "%RegExp%": RegExp,
          "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
          "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
          "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
          "%String%": String,
          "%StringIteratorPrototype%": hasSymbols && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
          "%Symbol%": hasSymbols ? Symbol : undefined$1,
          "%SyntaxError%": $SyntaxError,
          "%ThrowTypeError%": ThrowTypeError,
          "%TypedArray%": TypedArray,
          "%TypeError%": $TypeError,
          "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
          "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
          "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
          "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
          "%URIError%": URIError,
          "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
          "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
          "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
        };
        if (getProto2) {
          try {
            null.error;
          } catch (e2) {
            var errorProto = getProto2(getProto2(e2));
            INTRINSICS["%Error.prototype%"] = errorProto;
          }
        }
        var doEval = function doEval2(name) {
          var value;
          if (name === "%AsyncFunction%") {
            value = getEvalledConstructor("async function () {}");
          } else if (name === "%GeneratorFunction%") {
            value = getEvalledConstructor("function* () {}");
          } else if (name === "%AsyncGeneratorFunction%") {
            value = getEvalledConstructor("async function* () {}");
          } else if (name === "%AsyncGenerator%") {
            var fn = doEval2("%AsyncGeneratorFunction%");
            if (fn) {
              value = fn.prototype;
            }
          } else if (name === "%AsyncIteratorPrototype%") {
            var gen = doEval2("%AsyncGenerator%");
            if (gen && getProto2) {
              value = getProto2(gen.prototype);
            }
          }
          INTRINSICS[name] = value;
          return value;
        };
        var LEGACY_ALIASES = {
          "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
          "%ArrayPrototype%": ["Array", "prototype"],
          "%ArrayProto_entries%": ["Array", "prototype", "entries"],
          "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
          "%ArrayProto_keys%": ["Array", "prototype", "keys"],
          "%ArrayProto_values%": ["Array", "prototype", "values"],
          "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
          "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
          "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
          "%BooleanPrototype%": ["Boolean", "prototype"],
          "%DataViewPrototype%": ["DataView", "prototype"],
          "%DatePrototype%": ["Date", "prototype"],
          "%ErrorPrototype%": ["Error", "prototype"],
          "%EvalErrorPrototype%": ["EvalError", "prototype"],
          "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
          "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
          "%FunctionPrototype%": ["Function", "prototype"],
          "%Generator%": ["GeneratorFunction", "prototype"],
          "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
          "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
          "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
          "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
          "%JSONParse%": ["JSON", "parse"],
          "%JSONStringify%": ["JSON", "stringify"],
          "%MapPrototype%": ["Map", "prototype"],
          "%NumberPrototype%": ["Number", "prototype"],
          "%ObjectPrototype%": ["Object", "prototype"],
          "%ObjProto_toString%": ["Object", "prototype", "toString"],
          "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
          "%PromisePrototype%": ["Promise", "prototype"],
          "%PromiseProto_then%": ["Promise", "prototype", "then"],
          "%Promise_all%": ["Promise", "all"],
          "%Promise_reject%": ["Promise", "reject"],
          "%Promise_resolve%": ["Promise", "resolve"],
          "%RangeErrorPrototype%": ["RangeError", "prototype"],
          "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
          "%RegExpPrototype%": ["RegExp", "prototype"],
          "%SetPrototype%": ["Set", "prototype"],
          "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
          "%StringPrototype%": ["String", "prototype"],
          "%SymbolPrototype%": ["Symbol", "prototype"],
          "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
          "%TypedArrayPrototype%": ["TypedArray", "prototype"],
          "%TypeErrorPrototype%": ["TypeError", "prototype"],
          "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
          "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
          "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
          "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
          "%URIErrorPrototype%": ["URIError", "prototype"],
          "%WeakMapPrototype%": ["WeakMap", "prototype"],
          "%WeakSetPrototype%": ["WeakSet", "prototype"]
        };
        var bind = require2("function-bind");
        var hasOwn2 = require2("hasown");
        var $concat = bind.call(Function.call, Array.prototype.concat);
        var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
        var $replace = bind.call(Function.call, String.prototype.replace);
        var $strSlice = bind.call(Function.call, String.prototype.slice);
        var $exec = bind.call(Function.call, RegExp.prototype.exec);
        var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar = /\\(\\)?/g;
        var stringToPath = function stringToPath2(string2) {
          var first = $strSlice(string2, 0, 1);
          var last = $strSlice(string2, -1);
          if (first === "%" && last !== "%") {
            throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
          } else if (last === "%" && first !== "%") {
            throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
          }
          var result = [];
          $replace(string2, rePropName, function(match, number2, quote, subString) {
            result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
          });
          return result;
        };
        var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
          var intrinsicName = name;
          var alias;
          if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
            alias = LEGACY_ALIASES[intrinsicName];
            intrinsicName = "%" + alias[0] + "%";
          }
          if (hasOwn2(INTRINSICS, intrinsicName)) {
            var value = INTRINSICS[intrinsicName];
            if (value === needsEval) {
              value = doEval(intrinsicName);
            }
            if (typeof value === "undefined" && !allowMissing) {
              throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
            }
            return {
              alias,
              name: intrinsicName,
              value
            };
          }
          throw new $SyntaxError("intrinsic " + name + " does not exist!");
        };
        module3.exports = function GetIntrinsic(name, allowMissing) {
          if (typeof name !== "string" || name.length === 0) {
            throw new $TypeError("intrinsic name must be a non-empty string");
          }
          if (arguments.length > 1 && typeof allowMissing !== "boolean") {
            throw new $TypeError('"allowMissing" argument must be a boolean');
          }
          if ($exec(/^%?[^%]*%?$/, name) === null) {
            throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
          }
          var parts = stringToPath(name);
          var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
          var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
          var intrinsicRealName = intrinsic.name;
          var value = intrinsic.value;
          var skipFurtherCaching = false;
          var alias = intrinsic.alias;
          if (alias) {
            intrinsicBaseName = alias[0];
            $spliceApply(parts, $concat([0, 1], alias));
          }
          for (var i = 1, isOwn = true; i < parts.length; i += 1) {
            var part = parts[i];
            var first = $strSlice(part, 0, 1);
            var last = $strSlice(part, -1);
            if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
              throw new $SyntaxError("property names with quotes must have matching quotes");
            }
            if (part === "constructor" || !isOwn) {
              skipFurtherCaching = true;
            }
            intrinsicBaseName += "." + part;
            intrinsicRealName = "%" + intrinsicBaseName + "%";
            if (hasOwn2(INTRINSICS, intrinsicRealName)) {
              value = INTRINSICS[intrinsicRealName];
            } else if (value != null) {
              if (!(part in value)) {
                if (!allowMissing) {
                  throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                }
                return void 0;
              }
              if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                  value = desc.get;
                } else {
                  value = value[part];
                }
              } else {
                isOwn = hasOwn2(value, part);
                value = value[part];
              }
              if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
              }
            }
          }
          return value;
        };
      }, { "function-bind": 389, "has-proto": 393, "has-symbols": 394, "hasown": 397 }], 391: [function(require2, module3, exports3) {
        var GetIntrinsic = require2("get-intrinsic");
        var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
        if ($gOPD) {
          try {
            $gOPD([], "length");
          } catch (e2) {
            $gOPD = null;
          }
        }
        module3.exports = $gOPD;
      }, { "get-intrinsic": 390 }], 392: [function(require2, module3, exports3) {
        var GetIntrinsic = require2("get-intrinsic");
        var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
        var hasPropertyDescriptors = function hasPropertyDescriptors2() {
          if ($defineProperty) {
            try {
              $defineProperty({}, "a", { value: 1 });
              return true;
            } catch (e2) {
              return false;
            }
          }
          return false;
        };
        hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
          if (!hasPropertyDescriptors()) {
            return null;
          }
          try {
            return $defineProperty([], "length", { value: 1 }).length !== 1;
          } catch (e2) {
            return true;
          }
        };
        module3.exports = hasPropertyDescriptors;
      }, { "get-intrinsic": 390 }], 393: [function(require2, module3, exports3) {
        var test2 = {
          foo: {}
        };
        var $Object = Object;
        module3.exports = function hasProto() {
          return { __proto__: test2 }.foo === test2.foo && !({ __proto__: null } instanceof $Object);
        };
      }, {}], 394: [function(require2, module3, exports3) {
        var origSymbol = typeof Symbol !== "undefined" && Symbol;
        var hasSymbolSham = require2("./shams");
        module3.exports = function hasNativeSymbols() {
          if (typeof origSymbol !== "function") {
            return false;
          }
          if (typeof Symbol !== "function") {
            return false;
          }
          if (typeof origSymbol("foo") !== "symbol") {
            return false;
          }
          if (typeof Symbol("bar") !== "symbol") {
            return false;
          }
          return hasSymbolSham();
        };
      }, { "./shams": 395 }], 395: [function(require2, module3, exports3) {
        module3.exports = function hasSymbols() {
          if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
            return false;
          }
          if (typeof Symbol.iterator === "symbol") {
            return true;
          }
          var obj = {};
          var sym = Symbol("test");
          var symObj = Object(sym);
          if (typeof sym === "string") {
            return false;
          }
          if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
            return false;
          }
          if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
            return false;
          }
          var symVal = 42;
          obj[sym] = symVal;
          for (sym in obj) {
            return false;
          }
          if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
            return false;
          }
          if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
            return false;
          }
          var syms = Object.getOwnPropertySymbols(obj);
          if (syms.length !== 1 || syms[0] !== sym) {
            return false;
          }
          if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
            return false;
          }
          if (typeof Object.getOwnPropertyDescriptor === "function") {
            var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
            if (descriptor.value !== symVal || descriptor.enumerable !== true) {
              return false;
            }
          }
          return true;
        };
      }, {}], 396: [function(require2, module3, exports3) {
        var hasSymbols = require2("has-symbols/shams");
        module3.exports = function hasToStringTagShams() {
          return hasSymbols() && !!Symbol.toStringTag;
        };
      }, { "has-symbols/shams": 395 }], 397: [function(require2, module3, exports3) {
        var call = Function.prototype.call;
        var $hasOwn = Object.prototype.hasOwnProperty;
        var bind = require2("function-bind");
        module3.exports = bind.call(call, $hasOwn);
      }, { "function-bind": 389 }], 398: [function(require2, module3, exports3) {
        var http = require2("http");
        var url2 = require2("url");
        var https = module3.exports;
        for (var key in http) {
          if (http.hasOwnProperty(key))
            https[key] = http[key];
        }
        https.request = function(params, cb) {
          params = validateParams(params);
          return http.request.call(this, params, cb);
        };
        https.get = function(params, cb) {
          params = validateParams(params);
          return http.get.call(this, params, cb);
        };
        function validateParams(params) {
          if (typeof params === "string") {
            params = url2.parse(params);
          }
          if (!params.protocol) {
            params.protocol = "https:";
          }
          if (params.protocol !== "https:") {
            throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
          }
          return params;
        }
      }, { "http": 539, "url": 543 }], 399: [function(require2, module3, exports3) {
        var util = require2("util");
        var ms = require2("ms");
        module3.exports = function(t2) {
          if (typeof t2 === "number")
            return t2;
          var r = ms(t2);
          if (r === void 0) {
            var err = new Error(util.format("humanize-ms(%j) result undefined", t2));
            index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:21732", err.stack);
          }
          return r;
        };
      }, { "ms": 432, "util": 489 }], 400: [function(require2, module3, exports3) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        exports3.read = function(buffer2, offset, isLE, mLen, nBytes) {
          var e2, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s2 = buffer2[offset + i];
          i += d;
          e2 = s2 & (1 << -nBits) - 1;
          s2 >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
          }
          m = e2 & (1 << -nBits) - 1;
          e2 >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
          }
          if (e2 === 0) {
            e2 = 1 - eBias;
          } else if (e2 === eMax) {
            return m ? NaN : (s2 ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e2 = e2 - eBias;
          }
          return (s2 ? -1 : 1) * m * Math.pow(2, e2 - mLen);
        };
        exports3.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
          var e2, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e2 = eMax;
          } else {
            e2 = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e2)) < 1) {
              e2--;
              c *= 2;
            }
            if (e2 + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e2++;
              c /= 2;
            }
            if (e2 + eBias >= eMax) {
              m = 0;
              e2 = eMax;
            } else if (e2 + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e2 = e2 + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e2 = 0;
            }
          }
          for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e2 = e2 << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer2[offset + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {
          }
          buffer2[offset + i - d] |= s2 * 128;
        };
      }, {}], 401: [function(require2, module3, exports3) {
        var types = [
          require2("./nextTick"),
          require2("./queueMicrotask"),
          require2("./mutation.js"),
          require2("./messageChannel"),
          require2("./stateChange"),
          require2("./timeout")
        ];
        var draining;
        var currentQueue;
        var queueIndex = -1;
        var queue2 = [];
        var scheduled = false;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue2 = currentQueue.concat(queue2);
          } else {
            queueIndex = -1;
          }
          if (queue2.length) {
            nextTick2();
          }
        }
        function nextTick2() {
          if (draining) {
            return;
          }
          scheduled = false;
          draining = true;
          var len2 = queue2.length;
          var timeout2 = setTimeout(cleanUpNextTick);
          while (len2) {
            currentQueue = queue2;
            queue2 = [];
            while (currentQueue && ++queueIndex < len2) {
              currentQueue[queueIndex].run();
            }
            queueIndex = -1;
            len2 = queue2.length;
          }
          currentQueue = null;
          queueIndex = -1;
          draining = false;
          clearTimeout(timeout2);
        }
        var scheduleDrain;
        var i = -1;
        var len = types.length;
        while (++i < len) {
          if (types[i] && types[i].test && types[i].test()) {
            scheduleDrain = types[i].install(nextTick2);
            break;
          }
        }
        function Item(fun, array2) {
          this.fun = fun;
          this.array = array2;
        }
        Item.prototype.run = function() {
          var fun = this.fun;
          var array2 = this.array;
          switch (array2.length) {
            case 0:
              return fun();
            case 1:
              return fun(array2[0]);
            case 2:
              return fun(array2[0], array2[1]);
            case 3:
              return fun(array2[0], array2[1], array2[2]);
            default:
              return fun.apply(null, array2);
          }
        };
        module3.exports = immediate;
        function immediate(task) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              args[i2 - 1] = arguments[i2];
            }
          }
          queue2.push(new Item(task, args));
          if (!scheduled && !draining) {
            scheduled = true;
            scheduleDrain();
          }
        }
      }, { "./messageChannel": 402, "./mutation.js": 403, "./nextTick": 102, "./queueMicrotask": 404, "./stateChange": 405, "./timeout": 406 }], 402: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            exports3.test = function() {
              if (global3.setImmediate) {
                return false;
              }
              return typeof global3.MessageChannel !== "undefined";
            };
            exports3.install = function(func2) {
              var channel = new global3.MessageChannel();
              channel.port1.onmessage = func2;
              return function() {
                channel.port2.postMessage(0);
              };
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 403: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            var Mutation = global3.MutationObserver || global3.WebKitMutationObserver;
            exports3.test = function() {
              return Mutation;
            };
            exports3.install = function(handle) {
              var called = 0;
              var observer = new Mutation(handle);
              var element = global3.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              return function() {
                element.data = called = ++called % 2;
              };
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 404: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            exports3.test = function() {
              return typeof global3.queueMicrotask === "function";
            };
            exports3.install = function(func2) {
              return function() {
                global3.queueMicrotask(func2);
              };
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 405: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            exports3.test = function() {
              return "document" in global3 && "onreadystatechange" in global3.document.createElement("script");
            };
            exports3.install = function(handle) {
              return function() {
                var scriptEl = global3.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  handle();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global3.document.documentElement.appendChild(scriptEl);
                return handle;
              };
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 406: [function(require2, module3, exports3) {
        exports3.test = function() {
          return true;
        };
        exports3.install = function(t2) {
          return function() {
            setTimeout(t2, 0);
          };
        };
      }, {}], 407: [function(require2, module3, exports3) {
        if (typeof Object.create === "function") {
          module3.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            }
          };
        } else {
          module3.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
          };
        }
      }, {}], 408: [function(require2, module3, exports3) {
        var hasToStringTag = require2("has-tostringtag/shams")();
        var callBound = require2("call-bind/callBound");
        var $toString = callBound("Object.prototype.toString");
        var isStandardArguments = function isArguments(value) {
          if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
            return false;
          }
          return $toString(value) === "[object Arguments]";
        };
        var isLegacyArguments = function isArguments(value) {
          if (isStandardArguments(value)) {
            return true;
          }
          return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
        };
        var supportsStandardArguments = function() {
          return isStandardArguments(arguments);
        }();
        isStandardArguments.isLegacyArguments = isLegacyArguments;
        module3.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
      }, { "call-bind/callBound": 105, "has-tostringtag/shams": 396 }], 409: [function(require2, module3, exports3) {
        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */
        module3.exports = function(obj) {
          return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
        }
      }, {}], 410: [function(require2, module3, exports3) {
        var fnToStr = Function.prototype.toString;
        var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
        var badArrayLike;
        var isCallableMarker;
        if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
          try {
            badArrayLike = Object.defineProperty({}, "length", {
              get: function() {
                throw isCallableMarker;
              }
            });
            isCallableMarker = {};
            reflectApply(function() {
              throw 42;
            }, null, badArrayLike);
          } catch (_) {
            if (_ !== isCallableMarker) {
              reflectApply = null;
            }
          }
        } else {
          reflectApply = null;
        }
        var constructorRegex = /^\s*class\b/;
        var isES6ClassFn = function isES6ClassFunction(value) {
          try {
            var fnStr = fnToStr.call(value);
            return constructorRegex.test(fnStr);
          } catch (e2) {
            return false;
          }
        };
        var tryFunctionObject = function tryFunctionToStr(value) {
          try {
            if (isES6ClassFn(value)) {
              return false;
            }
            fnToStr.call(value);
            return true;
          } catch (e2) {
            return false;
          }
        };
        var toStr = Object.prototype.toString;
        var objectClass = "[object Object]";
        var fnClass = "[object Function]";
        var genClass = "[object GeneratorFunction]";
        var ddaClass = "[object HTMLAllCollection]";
        var ddaClass2 = "[object HTML document.all class]";
        var ddaClass3 = "[object HTMLCollection]";
        var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
        var isIE68 = !(0 in [,]);
        var isDDA = function isDocumentDotAll() {
          return false;
        };
        if (typeof document === "object") {
          var all = document.all;
          if (toStr.call(all) === toStr.call(document.all)) {
            isDDA = function isDocumentDotAll(value) {
              if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
                try {
                  var str = toStr.call(value);
                  return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
                } catch (e2) {
                }
              }
              return false;
            };
          }
        }
        module3.exports = reflectApply ? function isCallable(value) {
          if (isDDA(value)) {
            return true;
          }
          if (!value) {
            return false;
          }
          if (typeof value !== "function" && typeof value !== "object") {
            return false;
          }
          try {
            reflectApply(value, null, badArrayLike);
          } catch (e2) {
            if (e2 !== isCallableMarker) {
              return false;
            }
          }
          return !isES6ClassFn(value) && tryFunctionObject(value);
        } : function isCallable(value) {
          if (isDDA(value)) {
            return true;
          }
          if (!value) {
            return false;
          }
          if (typeof value !== "function" && typeof value !== "object") {
            return false;
          }
          if (hasToStringTag) {
            return tryFunctionObject(value);
          }
          if (isES6ClassFn(value)) {
            return false;
          }
          var strClass = toStr.call(value);
          if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
            return false;
          }
          return tryFunctionObject(value);
        };
      }, {}], 411: [function(require2, module3, exports3) {
        var toStr = Object.prototype.toString;
        var fnToStr = Function.prototype.toString;
        var isFnRegex = /^\s*(?:function)?\*/;
        var hasToStringTag = require2("has-tostringtag/shams")();
        var getProto2 = Object.getPrototypeOf;
        var getGeneratorFunc = function() {
          if (!hasToStringTag) {
            return false;
          }
          try {
            return Function("return function*() {}")();
          } catch (e2) {
          }
        };
        var GeneratorFunction;
        module3.exports = function isGeneratorFunction(fn) {
          if (typeof fn !== "function") {
            return false;
          }
          if (isFnRegex.test(fnToStr.call(fn))) {
            return true;
          }
          if (!hasToStringTag) {
            var str = toStr.call(fn);
            return str === "[object GeneratorFunction]";
          }
          if (!getProto2) {
            return false;
          }
          if (typeof GeneratorFunction === "undefined") {
            var generatorFunc = getGeneratorFunc();
            GeneratorFunction = generatorFunc ? getProto2(generatorFunc) : false;
          }
          return getProto2(fn) === GeneratorFunction;
        };
      }, { "has-tostringtag/shams": 396 }], 412: [function(require2, module3, exports3) {
        var whichTypedArray = require2("which-typed-array");
        module3.exports = function isTypedArray(value) {
          return !!whichTypedArray(value);
        };
      }, { "which-typed-array": 490 }], 413: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            (function(global4, factory) {
              typeof exports3 === "object" && typeof module3 !== "undefined" ? module3.exports = factory(global4) : factory(global4);
            })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global3 !== "undefined" ? global3 : this, function(global4) {
              global4 = global4 || {};
              var _Base64 = global4.Base64;
              var version2 = "2.6.4";
              var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
              var b64tab = function(bin) {
                var t2 = {};
                for (var i = 0, l = bin.length; i < l; i++)
                  t2[bin.charAt(i)] = i;
                return t2;
              }(b64chars);
              var fromCharCode = String.fromCharCode;
              var cb_utob = function(c) {
                if (c.length < 2) {
                  var cc = c.charCodeAt(0);
                  return cc < 128 ? c : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
                } else {
                  var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
                  return fromCharCode(240 | cc >>> 18 & 7) + fromCharCode(128 | cc >>> 12 & 63) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
                }
              };
              var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
              var utob = function(u2) {
                return u2.replace(re_utob, cb_utob);
              };
              var cb_encode = function(ccc) {
                var padlen = [0, 2, 1][ccc.length % 3], ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0), chars2 = [
                  b64chars.charAt(ord >>> 18),
                  b64chars.charAt(ord >>> 12 & 63),
                  padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63),
                  padlen >= 1 ? "=" : b64chars.charAt(ord & 63)
                ];
                return chars2.join("");
              };
              var btoa = global4.btoa && typeof global4.btoa == "function" ? function(b) {
                return global4.btoa(b);
              } : function(b) {
                if (b.match(/[^\x00-\xFF]/))
                  throw new RangeError(
                    "The string contains invalid characters."
                  );
                return b.replace(/[\s\S]{1,3}/g, cb_encode);
              };
              var _encode = function(u2) {
                return btoa(utob(String(u2)));
              };
              var mkUriSafe = function(b642) {
                return b642.replace(/[+\/]/g, function(m0) {
                  return m0 == "+" ? "-" : "_";
                }).replace(/=/g, "");
              };
              var encode3 = function(u2, urisafe) {
                return urisafe ? mkUriSafe(_encode(u2)) : _encode(u2);
              };
              var encodeURI2 = function(u2) {
                return encode3(u2, true);
              };
              var fromUint8Array;
              if (global4.Uint8Array)
                fromUint8Array = function(a2, urisafe) {
                  var b642 = "";
                  for (var i = 0, l = a2.length; i < l; i += 3) {
                    var a0 = a2[i], a1 = a2[i + 1], a22 = a2[i + 2];
                    var ord = a0 << 16 | a1 << 8 | a22;
                    b642 += b64chars.charAt(ord >>> 18) + b64chars.charAt(ord >>> 12 & 63) + (typeof a1 != "undefined" ? b64chars.charAt(ord >>> 6 & 63) : "=") + (typeof a22 != "undefined" ? b64chars.charAt(ord & 63) : "=");
                  }
                  return urisafe ? mkUriSafe(b642) : b642;
                };
              var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
              var cb_btou = function(cccc) {
                switch (cccc.length) {
                  case 4:
                    var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
                    return fromCharCode((offset >>> 10) + 55296) + fromCharCode((offset & 1023) + 56320);
                  case 3:
                    return fromCharCode(
                      (15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2)
                    );
                  default:
                    return fromCharCode(
                      (31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1)
                    );
                }
              };
              var btou = function(b) {
                return b.replace(re_btou, cb_btou);
              };
              var cb_decode = function(cccc) {
                var len = cccc.length, padlen = len % 4, n2 = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0), chars2 = [
                  fromCharCode(n2 >>> 16),
                  fromCharCode(n2 >>> 8 & 255),
                  fromCharCode(n2 & 255)
                ];
                chars2.length -= [0, 0, 2, 1][padlen];
                return chars2.join("");
              };
              var _atob = global4.atob && typeof global4.atob == "function" ? function(a2) {
                return global4.atob(a2);
              } : function(a2) {
                return a2.replace(/\S{1,4}/g, cb_decode);
              };
              var atob2 = function(a2) {
                return _atob(String(a2).replace(/[^A-Za-z0-9\+\/]/g, ""));
              };
              var _decode = function(a2) {
                return btou(_atob(a2));
              };
              var _fromURI = function(a2) {
                return String(a2).replace(/[-_]/g, function(m0) {
                  return m0 == "-" ? "+" : "/";
                }).replace(/[^A-Za-z0-9\+\/]/g, "");
              };
              var decode2 = function(a2) {
                return _decode(_fromURI(a2));
              };
              var toUint8Array;
              if (global4.Uint8Array)
                toUint8Array = function(a2) {
                  return Uint8Array.from(atob2(_fromURI(a2)), function(c) {
                    return c.charCodeAt(0);
                  });
                };
              var noConflict = function() {
                var Base642 = global4.Base64;
                global4.Base64 = _Base64;
                return Base642;
              };
              global4.Base64 = {
                VERSION: version2,
                atob: atob2,
                btoa,
                fromBase64: decode2,
                toBase64: encode3,
                utob,
                encode: encode3,
                encodeURI: encodeURI2,
                btou,
                decode: decode2,
                noConflict,
                fromUint8Array,
                toUint8Array
              };
              if (typeof Object.defineProperty === "function") {
                var noEnum = function(v) {
                  return { value: v, enumerable: false, writable: true, configurable: true };
                };
                global4.Base64.extendString = function() {
                  Object.defineProperty(
                    String.prototype,
                    "fromBase64",
                    noEnum(function() {
                      return decode2(this);
                    })
                  );
                  Object.defineProperty(
                    String.prototype,
                    "toBase64",
                    noEnum(function(urisafe) {
                      return encode3(this, urisafe);
                    })
                  );
                  Object.defineProperty(
                    String.prototype,
                    "toBase64URI",
                    noEnum(function() {
                      return encode3(this, true);
                    })
                  );
                };
              }
              if (global4["Meteor"]) {
                Base64 = global4.Base64;
              }
              if (typeof module3 !== "undefined" && module3.exports) {
                module3.exports.Base64 = global4.Base64;
              }
              return { Base64: global4.Base64 };
            });
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 414: [function(require2, module3, exports3) {
        var root = require2("./_root");
        var Symbol2 = root.Symbol;
        module3.exports = Symbol2;
      }, { "./_root": 421 }], 415: [function(require2, module3, exports3) {
        function arrayMap(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array2[index2], index2, array2);
          }
          return result;
        }
        module3.exports = arrayMap;
      }, {}], 416: [function(require2, module3, exports3) {
        var Symbol2 = require2("./_Symbol"), getRawTag = require2("./_getRawTag"), objectToString2 = require2("./_objectToString");
        var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
        var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
        }
        module3.exports = baseGetTag;
      }, { "./_Symbol": 414, "./_getRawTag": 419, "./_objectToString": 420 }], 417: [function(require2, module3, exports3) {
        var Symbol2 = require2("./_Symbol"), arrayMap = require2("./_arrayMap"), isArray2 = require2("./isArray"), isSymbol2 = require2("./isSymbol");
        var INFINITY = 1 / 0;
        var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol2(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        module3.exports = baseToString;
      }, { "./_Symbol": 414, "./_arrayMap": 415, "./isArray": 422, "./isSymbol": 426 }], 418: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            var freeGlobal = typeof global3 == "object" && global3 && global3.Object === Object && global3;
            module3.exports = freeGlobal;
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 419: [function(require2, module3, exports3) {
        var Symbol2 = require2("./_Symbol");
        var objectProto = Object.prototype;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag2 = value[symToStringTag];
          try {
            value[symToStringTag] = void 0;
            var unmasked = true;
          } catch (e2) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag2;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }
        module3.exports = getRawTag;
      }, { "./_Symbol": 414 }], 420: [function(require2, module3, exports3) {
        var objectProto = Object.prototype;
        var nativeObjectToString = objectProto.toString;
        function objectToString2(value) {
          return nativeObjectToString.call(value);
        }
        module3.exports = objectToString2;
      }, {}], 421: [function(require2, module3, exports3) {
        var freeGlobal = require2("./_freeGlobal");
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        module3.exports = root;
      }, { "./_freeGlobal": 418 }], 422: [function(require2, module3, exports3) {
        var isArray2 = Array.isArray;
        module3.exports = isArray2;
      }, {}], 423: [function(require2, module3, exports3) {
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        module3.exports = isObject2;
      }, {}], 424: [function(require2, module3, exports3) {
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        module3.exports = isObjectLike;
      }, {}], 425: [function(require2, module3, exports3) {
        var baseGetTag = require2("./_baseGetTag"), isArray2 = require2("./isArray"), isObjectLike = require2("./isObjectLike");
        var stringTag = "[object String]";
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        module3.exports = isString2;
      }, { "./_baseGetTag": 416, "./isArray": 422, "./isObjectLike": 424 }], 426: [function(require2, module3, exports3) {
        var baseGetTag = require2("./_baseGetTag"), isObjectLike = require2("./isObjectLike");
        var symbolTag = "[object Symbol]";
        function isSymbol2(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        module3.exports = isSymbol2;
      }, { "./_baseGetTag": 416, "./isObjectLike": 424 }], 427: [function(require2, module3, exports3) {
        var baseToString = require2("./_baseToString");
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        module3.exports = toString2;
      }, { "./_baseToString": 417 }], 428: [function(require2, module3, exports3) {
        module3.exports = merge;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        function merge(dest, src, redefine) {
          if (!dest) {
            throw new TypeError("argument dest is required");
          }
          if (!src) {
            throw new TypeError("argument src is required");
          }
          if (redefine === void 0) {
            redefine = true;
          }
          Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
            if (!redefine && hasOwnProperty2.call(dest, name)) {
              return;
            }
            var descriptor = Object.getOwnPropertyDescriptor(src, name);
            Object.defineProperty(dest, name, descriptor);
          });
          return dest;
        }
      }, {}], 429: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.map.js");
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.regexp.constructor.js");
        require2("core-js/modules/es.regexp.to-string.js");
        function Mime() {
          this._types = /* @__PURE__ */ Object.create(null);
          this._extensions = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < arguments.length; i++) {
            this.define(arguments[i]);
          }
          this.define = this.define.bind(this);
          this.getType = this.getType.bind(this);
          this.getExtension = this.getExtension.bind(this);
        }
        Mime.prototype.define = function(typeMap, force) {
          for (var type in typeMap) {
            var extensions = typeMap[type].map(function(t2) {
              return t2.toLowerCase();
            });
            type = type.toLowerCase();
            for (var i = 0; i < extensions.length; i++) {
              var ext = extensions[i];
              if (ext[0] === "*") {
                continue;
              }
              if (!force && ext in this._types) {
                throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
              }
              this._types[ext] = type;
            }
            if (force || !this._extensions[type]) {
              var _ext = extensions[0];
              this._extensions[type] = _ext[0] !== "*" ? _ext : _ext.substr(1);
            }
          }
        };
        Mime.prototype.getType = function(path) {
          path = String(path);
          var last = path.replace(/^.*[/\\]/, "").toLowerCase();
          var ext = last.replace(/^.*\./, "").toLowerCase();
          var hasPath = last.length < path.length;
          var hasDot = ext.length < last.length - 1;
          return (hasDot || !hasPath) && this._types[ext] || null;
        };
        Mime.prototype.getExtension = function(type) {
          type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
          return type && this._extensions[type.toLowerCase()] || null;
        };
        module3.exports = Mime;
      }, { "core-js/modules/es.array.map.js": 318, "core-js/modules/es.regexp.constructor.js": 337, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/es.string.replace.js": 345 }], 430: [function(require2, module3, exports3) {
        var Mime = require2("./Mime");
        module3.exports = new Mime(require2("./types/standard"));
      }, { "./Mime": 429, "./types/standard": 431 }], 431: [function(require2, module3, exports3) {
        module3.exports = {
          "application/andrew-inset": ["ez"],
          "application/applixware": ["aw"],
          "application/atom+xml": ["atom"],
          "application/atomcat+xml": ["atomcat"],
          "application/atomdeleted+xml": ["atomdeleted"],
          "application/atomsvc+xml": ["atomsvc"],
          "application/atsc-dwd+xml": ["dwd"],
          "application/atsc-held+xml": ["held"],
          "application/atsc-rsat+xml": ["rsat"],
          "application/bdoc": ["bdoc"],
          "application/calendar+xml": ["xcs"],
          "application/ccxml+xml": ["ccxml"],
          "application/cdfx+xml": ["cdfx"],
          "application/cdmi-capability": ["cdmia"],
          "application/cdmi-container": ["cdmic"],
          "application/cdmi-domain": ["cdmid"],
          "application/cdmi-object": ["cdmio"],
          "application/cdmi-queue": ["cdmiq"],
          "application/cu-seeme": ["cu"],
          "application/dash+xml": ["mpd"],
          "application/davmount+xml": ["davmount"],
          "application/docbook+xml": ["dbk"],
          "application/dssc+der": ["dssc"],
          "application/dssc+xml": ["xdssc"],
          "application/ecmascript": ["es", "ecma"],
          "application/emma+xml": ["emma"],
          "application/emotionml+xml": ["emotionml"],
          "application/epub+zip": ["epub"],
          "application/exi": ["exi"],
          "application/express": ["exp"],
          "application/fdt+xml": ["fdt"],
          "application/font-tdpfr": ["pfr"],
          "application/geo+json": ["geojson"],
          "application/gml+xml": ["gml"],
          "application/gpx+xml": ["gpx"],
          "application/gxf": ["gxf"],
          "application/gzip": ["gz"],
          "application/hjson": ["hjson"],
          "application/hyperstudio": ["stk"],
          "application/inkml+xml": ["ink", "inkml"],
          "application/ipfix": ["ipfix"],
          "application/its+xml": ["its"],
          "application/java-archive": ["jar", "war", "ear"],
          "application/java-serialized-object": ["ser"],
          "application/java-vm": ["class"],
          "application/javascript": ["js", "mjs"],
          "application/json": ["json", "map"],
          "application/json5": ["json5"],
          "application/jsonml+json": ["jsonml"],
          "application/ld+json": ["jsonld"],
          "application/lgr+xml": ["lgr"],
          "application/lost+xml": ["lostxml"],
          "application/mac-binhex40": ["hqx"],
          "application/mac-compactpro": ["cpt"],
          "application/mads+xml": ["mads"],
          "application/manifest+json": ["webmanifest"],
          "application/marc": ["mrc"],
          "application/marcxml+xml": ["mrcx"],
          "application/mathematica": ["ma", "nb", "mb"],
          "application/mathml+xml": ["mathml"],
          "application/mbox": ["mbox"],
          "application/mediaservercontrol+xml": ["mscml"],
          "application/metalink+xml": ["metalink"],
          "application/metalink4+xml": ["meta4"],
          "application/mets+xml": ["mets"],
          "application/mmt-aei+xml": ["maei"],
          "application/mmt-usd+xml": ["musd"],
          "application/mods+xml": ["mods"],
          "application/mp21": ["m21", "mp21"],
          "application/mp4": ["mp4s", "m4p"],
          "application/msword": ["doc", "dot"],
          "application/mxf": ["mxf"],
          "application/n-quads": ["nq"],
          "application/n-triples": ["nt"],
          "application/node": ["cjs"],
          "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"],
          "application/oda": ["oda"],
          "application/oebps-package+xml": ["opf"],
          "application/ogg": ["ogx"],
          "application/omdoc+xml": ["omdoc"],
          "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
          "application/oxps": ["oxps"],
          "application/p2p-overlay+xml": ["relo"],
          "application/patch-ops-error+xml": ["xer"],
          "application/pdf": ["pdf"],
          "application/pgp-encrypted": ["pgp"],
          "application/pgp-signature": ["asc", "sig"],
          "application/pics-rules": ["prf"],
          "application/pkcs10": ["p10"],
          "application/pkcs7-mime": ["p7m", "p7c"],
          "application/pkcs7-signature": ["p7s"],
          "application/pkcs8": ["p8"],
          "application/pkix-attr-cert": ["ac"],
          "application/pkix-cert": ["cer"],
          "application/pkix-crl": ["crl"],
          "application/pkix-pkipath": ["pkipath"],
          "application/pkixcmp": ["pki"],
          "application/pls+xml": ["pls"],
          "application/postscript": ["ai", "eps", "ps"],
          "application/provenance+xml": ["provx"],
          "application/pskc+xml": ["pskcxml"],
          "application/raml+yaml": ["raml"],
          "application/rdf+xml": ["rdf", "owl"],
          "application/reginfo+xml": ["rif"],
          "application/relax-ng-compact-syntax": ["rnc"],
          "application/resource-lists+xml": ["rl"],
          "application/resource-lists-diff+xml": ["rld"],
          "application/rls-services+xml": ["rs"],
          "application/route-apd+xml": ["rapd"],
          "application/route-s-tsid+xml": ["sls"],
          "application/route-usd+xml": ["rusd"],
          "application/rpki-ghostbusters": ["gbr"],
          "application/rpki-manifest": ["mft"],
          "application/rpki-roa": ["roa"],
          "application/rsd+xml": ["rsd"],
          "application/rss+xml": ["rss"],
          "application/rtf": ["rtf"],
          "application/sbml+xml": ["sbml"],
          "application/scvp-cv-request": ["scq"],
          "application/scvp-cv-response": ["scs"],
          "application/scvp-vp-request": ["spq"],
          "application/scvp-vp-response": ["spp"],
          "application/sdp": ["sdp"],
          "application/senml+xml": ["senmlx"],
          "application/sensml+xml": ["sensmlx"],
          "application/set-payment-initiation": ["setpay"],
          "application/set-registration-initiation": ["setreg"],
          "application/shf+xml": ["shf"],
          "application/sieve": ["siv", "sieve"],
          "application/smil+xml": ["smi", "smil"],
          "application/sparql-query": ["rq"],
          "application/sparql-results+xml": ["srx"],
          "application/srgs": ["gram"],
          "application/srgs+xml": ["grxml"],
          "application/sru+xml": ["sru"],
          "application/ssdl+xml": ["ssdl"],
          "application/ssml+xml": ["ssml"],
          "application/swid+xml": ["swidtag"],
          "application/tei+xml": ["tei", "teicorpus"],
          "application/thraud+xml": ["tfi"],
          "application/timestamped-data": ["tsd"],
          "application/toml": ["toml"],
          "application/trig": ["trig"],
          "application/ttml+xml": ["ttml"],
          "application/ubjson": ["ubj"],
          "application/urc-ressheet+xml": ["rsheet"],
          "application/urc-targetdesc+xml": ["td"],
          "application/voicexml+xml": ["vxml"],
          "application/wasm": ["wasm"],
          "application/widget": ["wgt"],
          "application/winhlp": ["hlp"],
          "application/wsdl+xml": ["wsdl"],
          "application/wspolicy+xml": ["wspolicy"],
          "application/xaml+xml": ["xaml"],
          "application/xcap-att+xml": ["xav"],
          "application/xcap-caps+xml": ["xca"],
          "application/xcap-diff+xml": ["xdf"],
          "application/xcap-el+xml": ["xel"],
          "application/xcap-ns+xml": ["xns"],
          "application/xenc+xml": ["xenc"],
          "application/xhtml+xml": ["xhtml", "xht"],
          "application/xliff+xml": ["xlf"],
          "application/xml": ["xml", "xsl", "xsd", "rng"],
          "application/xml-dtd": ["dtd"],
          "application/xop+xml": ["xop"],
          "application/xproc+xml": ["xpl"],
          "application/xslt+xml": ["*xsl", "xslt"],
          "application/xspf+xml": ["xspf"],
          "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
          "application/yang": ["yang"],
          "application/yin+xml": ["yin"],
          "application/zip": ["zip"],
          "audio/3gpp": ["*3gpp"],
          "audio/adpcm": ["adp"],
          "audio/amr": ["amr"],
          "audio/basic": ["au", "snd"],
          "audio/midi": ["mid", "midi", "kar", "rmi"],
          "audio/mobile-xmf": ["mxmf"],
          "audio/mp3": ["*mp3"],
          "audio/mp4": ["m4a", "mp4a"],
          "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
          "audio/ogg": ["oga", "ogg", "spx", "opus"],
          "audio/s3m": ["s3m"],
          "audio/silk": ["sil"],
          "audio/wav": ["wav"],
          "audio/wave": ["*wav"],
          "audio/webm": ["weba"],
          "audio/xm": ["xm"],
          "font/collection": ["ttc"],
          "font/otf": ["otf"],
          "font/ttf": ["ttf"],
          "font/woff": ["woff"],
          "font/woff2": ["woff2"],
          "image/aces": ["exr"],
          "image/apng": ["apng"],
          "image/avif": ["avif"],
          "image/bmp": ["bmp"],
          "image/cgm": ["cgm"],
          "image/dicom-rle": ["drle"],
          "image/emf": ["emf"],
          "image/fits": ["fits"],
          "image/g3fax": ["g3"],
          "image/gif": ["gif"],
          "image/heic": ["heic"],
          "image/heic-sequence": ["heics"],
          "image/heif": ["heif"],
          "image/heif-sequence": ["heifs"],
          "image/hej2k": ["hej2"],
          "image/hsj2": ["hsj2"],
          "image/ief": ["ief"],
          "image/jls": ["jls"],
          "image/jp2": ["jp2", "jpg2"],
          "image/jpeg": ["jpeg", "jpg", "jpe"],
          "image/jph": ["jph"],
          "image/jphc": ["jhc"],
          "image/jpm": ["jpm"],
          "image/jpx": ["jpx", "jpf"],
          "image/jxr": ["jxr"],
          "image/jxra": ["jxra"],
          "image/jxrs": ["jxrs"],
          "image/jxs": ["jxs"],
          "image/jxsc": ["jxsc"],
          "image/jxsi": ["jxsi"],
          "image/jxss": ["jxss"],
          "image/ktx": ["ktx"],
          "image/ktx2": ["ktx2"],
          "image/png": ["png"],
          "image/sgi": ["sgi"],
          "image/svg+xml": ["svg", "svgz"],
          "image/t38": ["t38"],
          "image/tiff": ["tif", "tiff"],
          "image/tiff-fx": ["tfx"],
          "image/webp": ["webp"],
          "image/wmf": ["wmf"],
          "message/disposition-notification": ["disposition-notification"],
          "message/global": ["u8msg"],
          "message/global-delivery-status": ["u8dsn"],
          "message/global-disposition-notification": ["u8mdn"],
          "message/global-headers": ["u8hdr"],
          "message/rfc822": ["eml", "mime"],
          "model/3mf": ["3mf"],
          "model/gltf+json": ["gltf"],
          "model/gltf-binary": ["glb"],
          "model/iges": ["igs", "iges"],
          "model/mesh": ["msh", "mesh", "silo"],
          "model/mtl": ["mtl"],
          "model/obj": ["obj"],
          "model/step+xml": ["stpx"],
          "model/step+zip": ["stpz"],
          "model/step-xml+zip": ["stpxz"],
          "model/stl": ["stl"],
          "model/vrml": ["wrl", "vrml"],
          "model/x3d+binary": ["*x3db", "x3dbz"],
          "model/x3d+fastinfoset": ["x3db"],
          "model/x3d+vrml": ["*x3dv", "x3dvz"],
          "model/x3d+xml": ["x3d", "x3dz"],
          "model/x3d-vrml": ["x3dv"],
          "text/cache-manifest": ["appcache", "manifest"],
          "text/calendar": ["ics", "ifb"],
          "text/coffeescript": ["coffee", "litcoffee"],
          "text/css": ["css"],
          "text/csv": ["csv"],
          "text/html": ["html", "htm", "shtml"],
          "text/jade": ["jade"],
          "text/jsx": ["jsx"],
          "text/less": ["less"],
          "text/markdown": ["markdown", "md"],
          "text/mathml": ["mml"],
          "text/mdx": ["mdx"],
          "text/n3": ["n3"],
          "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
          "text/richtext": ["rtx"],
          "text/rtf": ["*rtf"],
          "text/sgml": ["sgml", "sgm"],
          "text/shex": ["shex"],
          "text/slim": ["slim", "slm"],
          "text/spdx": ["spdx"],
          "text/stylus": ["stylus", "styl"],
          "text/tab-separated-values": ["tsv"],
          "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
          "text/turtle": ["ttl"],
          "text/uri-list": ["uri", "uris", "urls"],
          "text/vcard": ["vcard"],
          "text/vtt": ["vtt"],
          "text/xml": ["*xml"],
          "text/yaml": ["yaml", "yml"],
          "video/3gpp": ["3gp", "3gpp"],
          "video/3gpp2": ["3g2"],
          "video/h261": ["h261"],
          "video/h263": ["h263"],
          "video/h264": ["h264"],
          "video/iso.segment": ["m4s"],
          "video/jpeg": ["jpgv"],
          "video/jpm": ["*jpm", "jpgm"],
          "video/mj2": ["mj2", "mjp2"],
          "video/mp2t": ["ts"],
          "video/mp4": ["mp4", "mp4v", "mpg4"],
          "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
          "video/ogg": ["ogv"],
          "video/quicktime": ["qt", "mov"],
          "video/webm": ["webm"]
        };
      }, {}], 432: [function(require2, module3, exports3) {
        var s2 = 1e3;
        var m = s2 * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module3.exports = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse2(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse2(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n2 = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n2 * y;
            case "weeks":
            case "week":
            case "w":
              return n2 * w;
            case "days":
            case "day":
            case "d":
              return n2 * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n2 * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n2 * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n2 * s2;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n2;
            default:
              return void 0;
          }
        }
        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s2) {
            return Math.round(ms / s2) + "s";
          }
          return ms + "ms";
        }
        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s2) {
            return plural(ms, msAbs, s2, "second");
          }
          return ms + " ms";
        }
        function plural(ms, msAbs, n2, name) {
          var isPlural = msAbs >= n2 * 1.5;
          return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
        }
      }, {}], 433: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            var hasMap = typeof Map === "function" && Map.prototype;
            var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
            var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
            var mapForEach = hasMap && Map.prototype.forEach;
            var hasSet = typeof Set === "function" && Set.prototype;
            var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
            var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
            var setForEach = hasSet && Set.prototype.forEach;
            var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
            var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
            var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
            var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
            var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
            var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
            var booleanValueOf = Boolean.prototype.valueOf;
            var objectToString2 = Object.prototype.toString;
            var functionToString = Function.prototype.toString;
            var $match = String.prototype.match;
            var $slice = String.prototype.slice;
            var $replace = String.prototype.replace;
            var $toUpperCase = String.prototype.toUpperCase;
            var $toLowerCase = String.prototype.toLowerCase;
            var $test = RegExp.prototype.test;
            var $concat = Array.prototype.concat;
            var $join = Array.prototype.join;
            var $arrSlice = Array.prototype.slice;
            var $floor = Math.floor;
            var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
            var gOPS = Object.getOwnPropertySymbols;
            var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
            var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
            var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
            var isEnumerable = Object.prototype.propertyIsEnumerable;
            var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
              return O.__proto__;
            } : null);
            function addNumericSeparator(num, str) {
              if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
                return str;
              }
              var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
              if (typeof num === "number") {
                var int = num < 0 ? -$floor(-num) : $floor(num);
                if (int !== num) {
                  var intStr = String(int);
                  var dec = $slice.call(str, intStr.length + 1);
                  return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
                }
              }
              return $replace.call(str, sepRegex, "$&_");
            }
            var utilInspect = require2("./util.inspect");
            var inspectCustom = utilInspect.custom;
            var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
            module3.exports = function inspect_(obj, options, depth, seen) {
              var opts = options || {};
              if (has2(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
                throw new TypeError('option "quoteStyle" must be "single" or "double"');
              }
              if (has2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
                throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
              }
              var customInspect = has2(opts, "customInspect") ? opts.customInspect : true;
              if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
                throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
              }
              if (has2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
                throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
              }
              if (has2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
                throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
              }
              var numericSeparator = opts.numericSeparator;
              if (typeof obj === "undefined") {
                return "undefined";
              }
              if (obj === null) {
                return "null";
              }
              if (typeof obj === "boolean") {
                return obj ? "true" : "false";
              }
              if (typeof obj === "string") {
                return inspectString(obj, opts);
              }
              if (typeof obj === "number") {
                if (obj === 0) {
                  return Infinity / obj > 0 ? "0" : "-0";
                }
                var str = String(obj);
                return numericSeparator ? addNumericSeparator(obj, str) : str;
              }
              if (typeof obj === "bigint") {
                var bigIntStr = String(obj) + "n";
                return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
              }
              var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
              if (typeof depth === "undefined") {
                depth = 0;
              }
              if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
                return isArray2(obj) ? "[Array]" : "[Object]";
              }
              var indent = getIndent(opts, depth);
              if (typeof seen === "undefined") {
                seen = [];
              } else if (indexOf(seen, obj) >= 0) {
                return "[Circular]";
              }
              function inspect(value, from, noIndent) {
                if (from) {
                  seen = $arrSlice.call(seen);
                  seen.push(from);
                }
                if (noIndent) {
                  var newOpts = {
                    depth: opts.depth
                  };
                  if (has2(opts, "quoteStyle")) {
                    newOpts.quoteStyle = opts.quoteStyle;
                  }
                  return inspect_(value, newOpts, depth + 1, seen);
                }
                return inspect_(value, opts, depth + 1, seen);
              }
              if (typeof obj === "function" && !isRegExp(obj)) {
                var name = nameOf(obj);
                var keys = arrObjKeys(obj, inspect);
                return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
              }
              if (isSymbol2(obj)) {
                var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
                return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
              }
              if (isElement(obj)) {
                var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
                var attrs = obj.attributes || [];
                for (var i = 0; i < attrs.length; i++) {
                  s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
                }
                s2 += ">";
                if (obj.childNodes && obj.childNodes.length) {
                  s2 += "...";
                }
                s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
                return s2;
              }
              if (isArray2(obj)) {
                if (obj.length === 0) {
                  return "[]";
                }
                var xs = arrObjKeys(obj, inspect);
                if (indent && !singleLineValues(xs)) {
                  return "[" + indentedJoin(xs, indent) + "]";
                }
                return "[ " + $join.call(xs, ", ") + " ]";
              }
              if (isError(obj)) {
                var parts = arrObjKeys(obj, inspect);
                if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
                  return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
                }
                if (parts.length === 0) {
                  return "[" + String(obj) + "]";
                }
                return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
              }
              if (typeof obj === "object" && customInspect) {
                if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
                  return utilInspect(obj, { depth: maxDepth - depth });
                } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
                  return obj.inspect();
                }
              }
              if (isMap2(obj)) {
                var mapParts = [];
                if (mapForEach) {
                  mapForEach.call(obj, function(value, key) {
                    mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
                  });
                }
                return collectionOf("Map", mapSize.call(obj), mapParts, indent);
              }
              if (isSet2(obj)) {
                var setParts = [];
                if (setForEach) {
                  setForEach.call(obj, function(value) {
                    setParts.push(inspect(value, obj));
                  });
                }
                return collectionOf("Set", setSize.call(obj), setParts, indent);
              }
              if (isWeakMap(obj)) {
                return weakCollectionOf("WeakMap");
              }
              if (isWeakSet(obj)) {
                return weakCollectionOf("WeakSet");
              }
              if (isWeakRef(obj)) {
                return weakCollectionOf("WeakRef");
              }
              if (isNumber(obj)) {
                return markBoxed(inspect(Number(obj)));
              }
              if (isBigInt(obj)) {
                return markBoxed(inspect(bigIntValueOf.call(obj)));
              }
              if (isBoolean2(obj)) {
                return markBoxed(booleanValueOf.call(obj));
              }
              if (isString2(obj)) {
                return markBoxed(inspect(String(obj)));
              }
              if (typeof window !== "undefined" && obj === window) {
                return "{ [object Window] }";
              }
              if (obj === global3) {
                return "{ [object globalThis] }";
              }
              if (!isDate2(obj) && !isRegExp(obj)) {
                var ys = arrObjKeys(obj, inspect);
                var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
                var protoTag = obj instanceof Object ? "" : "null prototype";
                var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
                var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
                var tag2 = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
                if (ys.length === 0) {
                  return tag2 + "{}";
                }
                if (indent) {
                  return tag2 + "{" + indentedJoin(ys, indent) + "}";
                }
                return tag2 + "{ " + $join.call(ys, ", ") + " }";
              }
              return String(obj);
            };
            function wrapQuotes(s2, defaultStyle, opts) {
              var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
              return quoteChar + s2 + quoteChar;
            }
            function quote(s2) {
              return $replace.call(String(s2), /"/g, "&quot;");
            }
            function isArray2(obj) {
              return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
            }
            function isDate2(obj) {
              return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
            }
            function isRegExp(obj) {
              return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
            }
            function isError(obj) {
              return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
            }
            function isString2(obj) {
              return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
            }
            function isNumber(obj) {
              return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
            }
            function isBoolean2(obj) {
              return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
            }
            function isSymbol2(obj) {
              if (hasShammedSymbols) {
                return obj && typeof obj === "object" && obj instanceof Symbol;
              }
              if (typeof obj === "symbol") {
                return true;
              }
              if (!obj || typeof obj !== "object" || !symToString) {
                return false;
              }
              try {
                symToString.call(obj);
                return true;
              } catch (e2) {
              }
              return false;
            }
            function isBigInt(obj) {
              if (!obj || typeof obj !== "object" || !bigIntValueOf) {
                return false;
              }
              try {
                bigIntValueOf.call(obj);
                return true;
              } catch (e2) {
              }
              return false;
            }
            var hasOwn2 = Object.prototype.hasOwnProperty || function(key) {
              return key in this;
            };
            function has2(obj, key) {
              return hasOwn2.call(obj, key);
            }
            function toStr(obj) {
              return objectToString2.call(obj);
            }
            function nameOf(f2) {
              if (f2.name) {
                return f2.name;
              }
              var m = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
              if (m) {
                return m[1];
              }
              return null;
            }
            function indexOf(xs, x) {
              if (xs.indexOf) {
                return xs.indexOf(x);
              }
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) {
                  return i;
                }
              }
              return -1;
            }
            function isMap2(x) {
              if (!mapSize || !x || typeof x !== "object") {
                return false;
              }
              try {
                mapSize.call(x);
                try {
                  setSize.call(x);
                } catch (s2) {
                  return true;
                }
                return x instanceof Map;
              } catch (e2) {
              }
              return false;
            }
            function isWeakMap(x) {
              if (!weakMapHas || !x || typeof x !== "object") {
                return false;
              }
              try {
                weakMapHas.call(x, weakMapHas);
                try {
                  weakSetHas.call(x, weakSetHas);
                } catch (s2) {
                  return true;
                }
                return x instanceof WeakMap;
              } catch (e2) {
              }
              return false;
            }
            function isWeakRef(x) {
              if (!weakRefDeref || !x || typeof x !== "object") {
                return false;
              }
              try {
                weakRefDeref.call(x);
                return true;
              } catch (e2) {
              }
              return false;
            }
            function isSet2(x) {
              if (!setSize || !x || typeof x !== "object") {
                return false;
              }
              try {
                setSize.call(x);
                try {
                  mapSize.call(x);
                } catch (m) {
                  return true;
                }
                return x instanceof Set;
              } catch (e2) {
              }
              return false;
            }
            function isWeakSet(x) {
              if (!weakSetHas || !x || typeof x !== "object") {
                return false;
              }
              try {
                weakSetHas.call(x, weakSetHas);
                try {
                  weakMapHas.call(x, weakMapHas);
                } catch (s2) {
                  return true;
                }
                return x instanceof WeakSet;
              } catch (e2) {
              }
              return false;
            }
            function isElement(x) {
              if (!x || typeof x !== "object") {
                return false;
              }
              if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
                return true;
              }
              return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
            }
            function inspectString(str, opts) {
              if (str.length > opts.maxStringLength) {
                var remaining = str.length - opts.maxStringLength;
                var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
                return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
              }
              var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
              return wrapQuotes(s2, "single", opts);
            }
            function lowbyte(c) {
              var n2 = c.charCodeAt(0);
              var x = {
                8: "b",
                9: "t",
                10: "n",
                12: "f",
                13: "r"
              }[n2];
              if (x) {
                return "\\" + x;
              }
              return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
            }
            function markBoxed(str) {
              return "Object(" + str + ")";
            }
            function weakCollectionOf(type) {
              return type + " { ? }";
            }
            function collectionOf(type, size2, entries, indent) {
              var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
              return type + " (" + size2 + ") {" + joinedEntries + "}";
            }
            function singleLineValues(xs) {
              for (var i = 0; i < xs.length; i++) {
                if (indexOf(xs[i], "\n") >= 0) {
                  return false;
                }
              }
              return true;
            }
            function getIndent(opts, depth) {
              var baseIndent;
              if (opts.indent === "	") {
                baseIndent = "	";
              } else if (typeof opts.indent === "number" && opts.indent > 0) {
                baseIndent = $join.call(Array(opts.indent + 1), " ");
              } else {
                return null;
              }
              return {
                base: baseIndent,
                prev: $join.call(Array(depth + 1), baseIndent)
              };
            }
            function indentedJoin(xs, indent) {
              if (xs.length === 0) {
                return "";
              }
              var lineJoiner = "\n" + indent.prev + indent.base;
              return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
            }
            function arrObjKeys(obj, inspect) {
              var isArr = isArray2(obj);
              var xs = [];
              if (isArr) {
                xs.length = obj.length;
                for (var i = 0; i < obj.length; i++) {
                  xs[i] = has2(obj, i) ? inspect(obj[i], obj) : "";
                }
              }
              var syms = typeof gOPS === "function" ? gOPS(obj) : [];
              var symMap;
              if (hasShammedSymbols) {
                symMap = {};
                for (var k = 0; k < syms.length; k++) {
                  symMap["$" + syms[k]] = syms[k];
                }
              }
              for (var key in obj) {
                if (!has2(obj, key)) {
                  continue;
                }
                if (isArr && String(Number(key)) === key && key < obj.length) {
                  continue;
                }
                if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
                  continue;
                } else if ($test.call(/[^\w$]/, key)) {
                  xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
                } else {
                  xs.push(key + ": " + inspect(obj[key], obj));
                }
              }
              if (typeof gOPS === "function") {
                for (var j = 0; j < syms.length; j++) {
                  if (isEnumerable.call(obj, syms[j])) {
                    xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
                  }
                }
              }
              return xs;
            }
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./util.inspect": 102 }], 434: [function(require2, module3, exports3) {
        var keysShim;
        if (!Object.keys) {
          var has2 = Object.prototype.hasOwnProperty;
          var toStr = Object.prototype.toString;
          var isArgs = require2("./isArguments");
          var isEnumerable = Object.prototype.propertyIsEnumerable;
          var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
          var hasProtoEnumBug = isEnumerable.call(function() {
          }, "prototype");
          var dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
          ];
          var equalsConstructorPrototype = function(o2) {
            var ctor = o2.constructor;
            return ctor && ctor.prototype === o2;
          };
          var excludedKeys = {
            $applicationCache: true,
            $console: true,
            $external: true,
            $frame: true,
            $frameElement: true,
            $frames: true,
            $innerHeight: true,
            $innerWidth: true,
            $onmozfullscreenchange: true,
            $onmozfullscreenerror: true,
            $outerHeight: true,
            $outerWidth: true,
            $pageXOffset: true,
            $pageYOffset: true,
            $parent: true,
            $scrollLeft: true,
            $scrollTop: true,
            $scrollX: true,
            $scrollY: true,
            $self: true,
            $webkitIndexedDB: true,
            $webkitStorageInfo: true,
            $window: true
          };
          var hasAutomationEqualityBug = function() {
            if (typeof window === "undefined") {
              return false;
            }
            for (var k in window) {
              try {
                if (!excludedKeys["$" + k] && has2.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                  try {
                    equalsConstructorPrototype(window[k]);
                  } catch (e2) {
                    return true;
                  }
                }
              } catch (e2) {
                return true;
              }
            }
            return false;
          }();
          var equalsConstructorPrototypeIfNotBuggy = function(o2) {
            if (typeof window === "undefined" || !hasAutomationEqualityBug) {
              return equalsConstructorPrototype(o2);
            }
            try {
              return equalsConstructorPrototype(o2);
            } catch (e2) {
              return false;
            }
          };
          keysShim = function keys(object2) {
            var isObject2 = object2 !== null && typeof object2 === "object";
            var isFunction2 = toStr.call(object2) === "[object Function]";
            var isArguments = isArgs(object2);
            var isString2 = isObject2 && toStr.call(object2) === "[object String]";
            var theKeys = [];
            if (!isObject2 && !isFunction2 && !isArguments) {
              throw new TypeError("Object.keys called on a non-object");
            }
            var skipProto = hasProtoEnumBug && isFunction2;
            if (isString2 && object2.length > 0 && !has2.call(object2, 0)) {
              for (var i = 0; i < object2.length; ++i) {
                theKeys.push(String(i));
              }
            }
            if (isArguments && object2.length > 0) {
              for (var j = 0; j < object2.length; ++j) {
                theKeys.push(String(j));
              }
            } else {
              for (var name in object2) {
                if (!(skipProto && name === "prototype") && has2.call(object2, name)) {
                  theKeys.push(String(name));
                }
              }
            }
            if (hasDontEnumBug) {
              var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
              for (var k = 0; k < dontEnums.length; ++k) {
                if (!(skipConstructor && dontEnums[k] === "constructor") && has2.call(object2, dontEnums[k])) {
                  theKeys.push(dontEnums[k]);
                }
              }
            }
            return theKeys;
          };
        }
        module3.exports = keysShim;
      }, { "./isArguments": 436 }], 435: [function(require2, module3, exports3) {
        var slice = Array.prototype.slice;
        var isArgs = require2("./isArguments");
        var origKeys = Object.keys;
        var keysShim = origKeys ? function keys(o2) {
          return origKeys(o2);
        } : require2("./implementation");
        var originalKeys = Object.keys;
        keysShim.shim = function shimObjectKeys() {
          if (Object.keys) {
            var keysWorksWithArguments = function() {
              var args = Object.keys(arguments);
              return args && args.length === arguments.length;
            }(1, 2);
            if (!keysWorksWithArguments) {
              Object.keys = function keys(object2) {
                if (isArgs(object2)) {
                  return originalKeys(slice.call(object2));
                }
                return originalKeys(object2);
              };
            }
          } else {
            Object.keys = keysShim;
          }
          return Object.keys || keysShim;
        };
        module3.exports = keysShim;
      }, { "./implementation": 434, "./isArguments": 436 }], 436: [function(require2, module3, exports3) {
        var toStr = Object.prototype.toString;
        module3.exports = function isArguments(value) {
          var str = toStr.call(value);
          var isArgs = str === "[object Arguments]";
          if (!isArgs) {
            isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
          }
          return isArgs;
        };
      }, {}], 437: [function(require2, module3, exports3) {
        var objectKeys2 = require2("object-keys");
        var hasSymbols = require2("has-symbols/shams")();
        var callBound = require2("call-bind/callBound");
        var toObject = Object;
        var $push = callBound("Array.prototype.push");
        var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
        var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
        module3.exports = function assign2(target, source1) {
          if (target == null) {
            throw new TypeError("target must be an object");
          }
          var to = toObject(target);
          if (arguments.length === 1) {
            return to;
          }
          for (var s2 = 1; s2 < arguments.length; ++s2) {
            var from = toObject(arguments[s2]);
            var keys = objectKeys2(from);
            var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
            if (getSymbols) {
              var syms = getSymbols(from);
              for (var j = 0; j < syms.length; ++j) {
                var key = syms[j];
                if ($propIsEnumerable(from, key)) {
                  $push(keys, key);
                }
              }
            }
            for (var i = 0; i < keys.length; ++i) {
              var nextKey = keys[i];
              if ($propIsEnumerable(from, nextKey)) {
                var propValue = from[nextKey];
                to[nextKey] = propValue;
              }
            }
          }
          return to;
        };
      }, { "call-bind/callBound": 105, "has-symbols/shams": 395, "object-keys": 435 }], 438: [function(require2, module3, exports3) {
        var implementation = require2("./implementation");
        var lacksProperEnumerationOrder = function() {
          if (!Object.assign) {
            return false;
          }
          var str = "abcdefghijklmnopqrst";
          var letters = str.split("");
          var map = {};
          for (var i = 0; i < letters.length; ++i) {
            map[letters[i]] = letters[i];
          }
          var obj = Object.assign({}, map);
          var actual = "";
          for (var k in obj) {
            actual += k;
          }
          return str !== actual;
        };
        var assignHasPendingExceptions = function() {
          if (!Object.assign || !Object.preventExtensions) {
            return false;
          }
          var thrower = Object.preventExtensions({ 1: 2 });
          try {
            Object.assign(thrower, "xy");
          } catch (e2) {
            return thrower[1] === "y";
          }
          return false;
        };
        module3.exports = function getPolyfill() {
          if (!Object.assign) {
            return implementation;
          }
          if (lacksProperEnumerationOrder()) {
            return implementation;
          }
          if (assignHasPendingExceptions()) {
            return implementation;
          }
          return Object.assign;
        };
      }, { "./implementation": 437 }], 439: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            function assertPath(path) {
              if (typeof path !== "string") {
                throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
              }
            }
            function normalizeStringPosix(path, allowAboveRoot) {
              var res = "";
              var lastSegmentLength = 0;
              var lastSlash = -1;
              var dots = 0;
              var code2;
              for (var i = 0; i <= path.length; ++i) {
                if (i < path.length)
                  code2 = path.charCodeAt(i);
                else if (code2 === 47)
                  break;
                else
                  code2 = 47;
                if (code2 === 47) {
                  if (lastSlash === i - 1 || dots === 1)
                    ;
                  else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                      if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                          if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                          } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                          }
                          lastSlash = i;
                          dots = 0;
                          continue;
                        }
                      } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                      }
                    }
                    if (allowAboveRoot) {
                      if (res.length > 0)
                        res += "/..";
                      else
                        res = "..";
                      lastSegmentLength = 2;
                    }
                  } else {
                    if (res.length > 0)
                      res += "/" + path.slice(lastSlash + 1, i);
                    else
                      res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                  }
                  lastSlash = i;
                  dots = 0;
                } else if (code2 === 46 && dots !== -1) {
                  ++dots;
                } else {
                  dots = -1;
                }
              }
              return res;
            }
            function _format(sep, pathObject) {
              var dir = pathObject.dir || pathObject.root;
              var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
              if (!dir) {
                return base;
              }
              if (dir === pathObject.root) {
                return dir + base;
              }
              return dir + sep + base;
            }
            var posix = {
              // path.resolve([from ...], to)
              resolve: function resolve2() {
                var resolvedPath = "";
                var resolvedAbsolute = false;
                var cwd;
                for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                  var path;
                  if (i >= 0)
                    path = arguments[i];
                  else {
                    if (cwd === void 0)
                      cwd = process.cwd();
                    path = cwd;
                  }
                  assertPath(path);
                  if (path.length === 0) {
                    continue;
                  }
                  resolvedPath = path + "/" + resolvedPath;
                  resolvedAbsolute = path.charCodeAt(0) === 47;
                }
                resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
                if (resolvedAbsolute) {
                  if (resolvedPath.length > 0)
                    return "/" + resolvedPath;
                  else
                    return "/";
                } else if (resolvedPath.length > 0) {
                  return resolvedPath;
                } else {
                  return ".";
                }
              },
              normalize: function normalize(path) {
                assertPath(path);
                if (path.length === 0)
                  return ".";
                var isAbsolute = path.charCodeAt(0) === 47;
                var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
                path = normalizeStringPosix(path, !isAbsolute);
                if (path.length === 0 && !isAbsolute)
                  path = ".";
                if (path.length > 0 && trailingSeparator)
                  path += "/";
                if (isAbsolute)
                  return "/" + path;
                return path;
              },
              isAbsolute: function isAbsolute(path) {
                assertPath(path);
                return path.length > 0 && path.charCodeAt(0) === 47;
              },
              join: function join() {
                if (arguments.length === 0)
                  return ".";
                var joined;
                for (var i = 0; i < arguments.length; ++i) {
                  var arg = arguments[i];
                  assertPath(arg);
                  if (arg.length > 0) {
                    if (joined === void 0)
                      joined = arg;
                    else
                      joined += "/" + arg;
                  }
                }
                if (joined === void 0)
                  return ".";
                return posix.normalize(joined);
              },
              relative: function relative(from, to) {
                assertPath(from);
                assertPath(to);
                if (from === to)
                  return "";
                from = posix.resolve(from);
                to = posix.resolve(to);
                if (from === to)
                  return "";
                var fromStart = 1;
                for (; fromStart < from.length; ++fromStart) {
                  if (from.charCodeAt(fromStart) !== 47)
                    break;
                }
                var fromEnd = from.length;
                var fromLen = fromEnd - fromStart;
                var toStart = 1;
                for (; toStart < to.length; ++toStart) {
                  if (to.charCodeAt(toStart) !== 47)
                    break;
                }
                var toEnd = to.length;
                var toLen = toEnd - toStart;
                var length = fromLen < toLen ? fromLen : toLen;
                var lastCommonSep = -1;
                var i = 0;
                for (; i <= length; ++i) {
                  if (i === length) {
                    if (toLen > length) {
                      if (to.charCodeAt(toStart + i) === 47) {
                        return to.slice(toStart + i + 1);
                      } else if (i === 0) {
                        return to.slice(toStart + i);
                      }
                    } else if (fromLen > length) {
                      if (from.charCodeAt(fromStart + i) === 47) {
                        lastCommonSep = i;
                      } else if (i === 0) {
                        lastCommonSep = 0;
                      }
                    }
                    break;
                  }
                  var fromCode = from.charCodeAt(fromStart + i);
                  var toCode = to.charCodeAt(toStart + i);
                  if (fromCode !== toCode)
                    break;
                  else if (fromCode === 47)
                    lastCommonSep = i;
                }
                var out = "";
                for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                  if (i === fromEnd || from.charCodeAt(i) === 47) {
                    if (out.length === 0)
                      out += "..";
                    else
                      out += "/..";
                  }
                }
                if (out.length > 0)
                  return out + to.slice(toStart + lastCommonSep);
                else {
                  toStart += lastCommonSep;
                  if (to.charCodeAt(toStart) === 47)
                    ++toStart;
                  return to.slice(toStart);
                }
              },
              _makeLong: function _makeLong(path) {
                return path;
              },
              dirname: function dirname(path) {
                assertPath(path);
                if (path.length === 0)
                  return ".";
                var code2 = path.charCodeAt(0);
                var hasRoot = code2 === 47;
                var end = -1;
                var matchedSlash = true;
                for (var i = path.length - 1; i >= 1; --i) {
                  code2 = path.charCodeAt(i);
                  if (code2 === 47) {
                    if (!matchedSlash) {
                      end = i;
                      break;
                    }
                  } else {
                    matchedSlash = false;
                  }
                }
                if (end === -1)
                  return hasRoot ? "/" : ".";
                if (hasRoot && end === 1)
                  return "//";
                return path.slice(0, end);
              },
              basename: function basename(path, ext) {
                if (ext !== void 0 && typeof ext !== "string")
                  throw new TypeError('"ext" argument must be a string');
                assertPath(path);
                var start = 0;
                var end = -1;
                var matchedSlash = true;
                var i;
                if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
                  if (ext.length === path.length && ext === path)
                    return "";
                  var extIdx = ext.length - 1;
                  var firstNonSlashEnd = -1;
                  for (i = path.length - 1; i >= 0; --i) {
                    var code2 = path.charCodeAt(i);
                    if (code2 === 47) {
                      if (!matchedSlash) {
                        start = i + 1;
                        break;
                      }
                    } else {
                      if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                      }
                      if (extIdx >= 0) {
                        if (code2 === ext.charCodeAt(extIdx)) {
                          if (--extIdx === -1) {
                            end = i;
                          }
                        } else {
                          extIdx = -1;
                          end = firstNonSlashEnd;
                        }
                      }
                    }
                  }
                  if (start === end)
                    end = firstNonSlashEnd;
                  else if (end === -1)
                    end = path.length;
                  return path.slice(start, end);
                } else {
                  for (i = path.length - 1; i >= 0; --i) {
                    if (path.charCodeAt(i) === 47) {
                      if (!matchedSlash) {
                        start = i + 1;
                        break;
                      }
                    } else if (end === -1) {
                      matchedSlash = false;
                      end = i + 1;
                    }
                  }
                  if (end === -1)
                    return "";
                  return path.slice(start, end);
                }
              },
              extname: function extname(path) {
                assertPath(path);
                var startDot = -1;
                var startPart = 0;
                var end = -1;
                var matchedSlash = true;
                var preDotState = 0;
                for (var i = path.length - 1; i >= 0; --i) {
                  var code2 = path.charCodeAt(i);
                  if (code2 === 47) {
                    if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                    continue;
                  }
                  if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                  }
                  if (code2 === 46) {
                    if (startDot === -1)
                      startDot = i;
                    else if (preDotState !== 1)
                      preDotState = 1;
                  } else if (startDot !== -1) {
                    preDotState = -1;
                  }
                }
                if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
                preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                  return "";
                }
                return path.slice(startDot, end);
              },
              format: function format(pathObject) {
                if (pathObject === null || typeof pathObject !== "object") {
                  throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
                }
                return _format("/", pathObject);
              },
              parse: function parse2(path) {
                assertPath(path);
                var ret = { root: "", dir: "", base: "", ext: "", name: "" };
                if (path.length === 0)
                  return ret;
                var code2 = path.charCodeAt(0);
                var isAbsolute = code2 === 47;
                var start;
                if (isAbsolute) {
                  ret.root = "/";
                  start = 1;
                } else {
                  start = 0;
                }
                var startDot = -1;
                var startPart = 0;
                var end = -1;
                var matchedSlash = true;
                var i = path.length - 1;
                var preDotState = 0;
                for (; i >= start; --i) {
                  code2 = path.charCodeAt(i);
                  if (code2 === 47) {
                    if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                    continue;
                  }
                  if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                  }
                  if (code2 === 46) {
                    if (startDot === -1)
                      startDot = i;
                    else if (preDotState !== 1)
                      preDotState = 1;
                  } else if (startDot !== -1) {
                    preDotState = -1;
                  }
                }
                if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
                preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                  if (end !== -1) {
                    if (startPart === 0 && isAbsolute)
                      ret.base = ret.name = path.slice(1, end);
                    else
                      ret.base = ret.name = path.slice(startPart, end);
                  }
                } else {
                  if (startPart === 0 && isAbsolute) {
                    ret.name = path.slice(1, startDot);
                    ret.base = path.slice(1, end);
                  } else {
                    ret.name = path.slice(startPart, startDot);
                    ret.base = path.slice(startPart, end);
                  }
                  ret.ext = path.slice(startDot, end);
                }
                if (startPart > 0)
                  ret.dir = path.slice(0, startPart - 1);
                else if (isAbsolute)
                  ret.dir = "/";
                return ret;
              },
              sep: "/",
              delimiter: ":",
              win32: null,
              posix: null
            };
            posix.posix = posix;
            module3.exports = posix;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 538 }], 440: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            (function() {
              var objectTypes = {
                "function": true,
                "object": true
              };
              var root = objectTypes[typeof window] && window || this;
              var freeExports = objectTypes[typeof exports3] && exports3;
              var freeModule = objectTypes[typeof module3] && module3 && !module3.nodeType && module3;
              var freeGlobal = freeExports && freeModule && typeof global3 == "object" && global3;
              if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
                root = freeGlobal;
              }
              var maxSafeInteger = Math.pow(2, 53) - 1;
              var reOpera = /\bOpera/;
              var objectProto = Object.prototype;
              var hasOwnProperty2 = objectProto.hasOwnProperty;
              var toString2 = objectProto.toString;
              function capitalize2(string2) {
                string2 = String(string2);
                return string2.charAt(0).toUpperCase() + string2.slice(1);
              }
              function cleanupOS(os2, pattern, label) {
                var data = {
                  "10.0": "10",
                  "6.4": "10 Technical Preview",
                  "6.3": "8.1",
                  "6.2": "8",
                  "6.1": "Server 2008 R2 / 7",
                  "6.0": "Server 2008 / Vista",
                  "5.2": "Server 2003 / XP 64-bit",
                  "5.1": "XP",
                  "5.01": "2000 SP1",
                  "5.0": "2000",
                  "4.0": "NT",
                  "4.90": "ME"
                };
                if (pattern && label && /^Win/i.test(os2) && !/^Windows Phone /i.test(os2) && (data = data[/[\d.]+$/.exec(os2)])) {
                  os2 = "Windows " + data;
                }
                os2 = String(os2);
                if (pattern && label) {
                  os2 = os2.replace(RegExp(pattern, "i"), label);
                }
                os2 = format(
                  os2.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
                );
                return os2;
              }
              function each(object2, callback) {
                var index2 = -1, length = object2 ? object2.length : 0;
                if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
                  while (++index2 < length) {
                    callback(object2[index2], index2, object2);
                  }
                } else {
                  forOwn(object2, callback);
                }
              }
              function format(string2) {
                string2 = trim2(string2);
                return /^(?:webOS|i(?:OS|P))/.test(string2) ? string2 : capitalize2(string2);
              }
              function forOwn(object2, callback) {
                for (var key in object2) {
                  if (hasOwnProperty2.call(object2, key)) {
                    callback(object2[key], key, object2);
                  }
                }
              }
              function getClassOf(value) {
                return value == null ? capitalize2(value) : toString2.call(value).slice(8, -1);
              }
              function isHostType(object2, property) {
                var type = object2 != null ? typeof object2[property] : "number";
                return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object2[property] : true);
              }
              function qualify(string2) {
                return String(string2).replace(/([ -])(?!$)/g, "$1?");
              }
              function reduce(array2, callback) {
                var accumulator = null;
                each(array2, function(value, index2) {
                  accumulator = callback(accumulator, value, index2, array2);
                });
                return accumulator;
              }
              function trim2(string2) {
                return String(string2).replace(/^ +| +$/g, "");
              }
              function parse2(ua) {
                var context = root;
                var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
                if (isCustomContext) {
                  context = ua;
                  ua = null;
                }
                var nav = context.navigator || {};
                var userAgent = nav.userAgent || "";
                ua || (ua = userAgent);
                var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString2.toString());
                var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
                var java = /\bJava/.test(javaClass) && context.java;
                var rhino = java && getClassOf(context.environment) == enviroClass;
                var alpha = java ? "a" : "";
                var beta = java ? "b" : "";
                var doc = context.document || {};
                var opera = context.operamini || context.opera;
                var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
                var data;
                var arch = ua;
                var description = [];
                var prerelease = null;
                var useFeatures = ua == userAgent;
                var version2 = useFeatures && opera && typeof opera.version == "function" && opera.version();
                var isSpecialCasedOS;
                var layout = getLayout([
                  { "label": "EdgeHTML", "pattern": "Edge" },
                  "Trident",
                  { "label": "WebKit", "pattern": "AppleWebKit" },
                  "iCab",
                  "Presto",
                  "NetFront",
                  "Tasman",
                  "KHTML",
                  "Gecko"
                ]);
                var name = getName([
                  "Adobe AIR",
                  "Arora",
                  "Avant Browser",
                  "Breach",
                  "Camino",
                  "Electron",
                  "Epiphany",
                  "Fennec",
                  "Flock",
                  "Galeon",
                  "GreenBrowser",
                  "iCab",
                  "Iceweasel",
                  "K-Meleon",
                  "Konqueror",
                  "Lunascape",
                  "Maxthon",
                  { "label": "Microsoft Edge", "pattern": "(?:Edge|Edg|EdgA|EdgiOS)" },
                  "Midori",
                  "Nook Browser",
                  "PaleMoon",
                  "PhantomJS",
                  "Raven",
                  "Rekonq",
                  "RockMelt",
                  { "label": "Samsung Internet", "pattern": "SamsungBrowser" },
                  "SeaMonkey",
                  { "label": "Silk", "pattern": "(?:Cloud9|Silk-Accelerated)" },
                  "Sleipnir",
                  "SlimBrowser",
                  { "label": "SRWare Iron", "pattern": "Iron" },
                  "Sunrise",
                  "Swiftfox",
                  "Vivaldi",
                  "Waterfox",
                  "WebPositive",
                  { "label": "Yandex Browser", "pattern": "YaBrowser" },
                  { "label": "UC Browser", "pattern": "UCBrowser" },
                  "Opera Mini",
                  { "label": "Opera Mini", "pattern": "OPiOS" },
                  "Opera",
                  { "label": "Opera", "pattern": "OPR" },
                  "Chromium",
                  "Chrome",
                  { "label": "Chrome", "pattern": "(?:HeadlessChrome)" },
                  { "label": "Chrome Mobile", "pattern": "(?:CriOS|CrMo)" },
                  { "label": "Firefox", "pattern": "(?:Firefox|Minefield)" },
                  { "label": "Firefox for iOS", "pattern": "FxiOS" },
                  { "label": "IE", "pattern": "IEMobile" },
                  { "label": "IE", "pattern": "MSIE" },
                  "Safari"
                ]);
                var product = getProduct([
                  { "label": "BlackBerry", "pattern": "BB10" },
                  "BlackBerry",
                  { "label": "Galaxy S", "pattern": "GT-I9000" },
                  { "label": "Galaxy S2", "pattern": "GT-I9100" },
                  { "label": "Galaxy S3", "pattern": "GT-I9300" },
                  { "label": "Galaxy S4", "pattern": "GT-I9500" },
                  { "label": "Galaxy S5", "pattern": "SM-G900" },
                  { "label": "Galaxy S6", "pattern": "SM-G920" },
                  { "label": "Galaxy S6 Edge", "pattern": "SM-G925" },
                  { "label": "Galaxy S7", "pattern": "SM-G930" },
                  { "label": "Galaxy S7 Edge", "pattern": "SM-G935" },
                  "Google TV",
                  "Lumia",
                  "iPad",
                  "iPod",
                  "iPhone",
                  "Kindle",
                  { "label": "Kindle Fire", "pattern": "(?:Cloud9|Silk-Accelerated)" },
                  "Nexus",
                  "Nook",
                  "PlayBook",
                  "PlayStation Vita",
                  "PlayStation",
                  "TouchPad",
                  "Transformer",
                  { "label": "Wii U", "pattern": "WiiU" },
                  "Wii",
                  "Xbox One",
                  { "label": "Xbox 360", "pattern": "Xbox" },
                  "Xoom"
                ]);
                var manufacturer = getManufacturer({
                  "Apple": { "iPad": 1, "iPhone": 1, "iPod": 1 },
                  "Alcatel": {},
                  "Archos": {},
                  "Amazon": { "Kindle": 1, "Kindle Fire": 1 },
                  "Asus": { "Transformer": 1 },
                  "Barnes & Noble": { "Nook": 1 },
                  "BlackBerry": { "PlayBook": 1 },
                  "Google": { "Google TV": 1, "Nexus": 1 },
                  "HP": { "TouchPad": 1 },
                  "HTC": {},
                  "Huawei": {},
                  "Lenovo": {},
                  "LG": {},
                  "Microsoft": { "Xbox": 1, "Xbox One": 1 },
                  "Motorola": { "Xoom": 1 },
                  "Nintendo": { "Wii U": 1, "Wii": 1 },
                  "Nokia": { "Lumia": 1 },
                  "Oppo": {},
                  "Samsung": { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
                  "Sony": { "PlayStation": 1, "PlayStation Vita": 1 },
                  "Xiaomi": { "Mi": 1, "Redmi": 1 }
                });
                var os2 = getOS([
                  "Windows Phone",
                  "KaiOS",
                  "Android",
                  "CentOS",
                  { "label": "Chrome OS", "pattern": "CrOS" },
                  "Debian",
                  { "label": "DragonFly BSD", "pattern": "DragonFly" },
                  "Fedora",
                  "FreeBSD",
                  "Gentoo",
                  "Haiku",
                  "Kubuntu",
                  "Linux Mint",
                  "OpenBSD",
                  "Red Hat",
                  "SuSE",
                  "Ubuntu",
                  "Xubuntu",
                  "Cygwin",
                  "Symbian OS",
                  "hpwOS",
                  "webOS ",
                  "webOS",
                  "Tablet OS",
                  "Tizen",
                  "Linux",
                  "Mac OS X",
                  "Macintosh",
                  "Mac",
                  "Windows 98;",
                  "Windows "
                ]);
                function getLayout(guesses) {
                  return reduce(guesses, function(result, guess) {
                    return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                  });
                }
                function getManufacturer(guesses) {
                  return reduce(guesses, function(result, value, key) {
                    return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
                  });
                }
                function getName(guesses) {
                  return reduce(guesses, function(result, guess) {
                    return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                  });
                }
                function getOS(guesses) {
                  return reduce(guesses, function(result, guess) {
                    var pattern = guess.pattern || qualify(guess);
                    if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
                      result = cleanupOS(result, pattern, guess.label || guess);
                    }
                    return result;
                  });
                }
                function getProduct(guesses) {
                  return reduce(guesses, function(result, guess) {
                    var pattern = guess.pattern || qualify(guess);
                    if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
                      if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
                        result[0] += " " + result[1];
                      }
                      guess = guess.label || guess;
                      result = format(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
                    }
                    return result;
                  });
                }
                function getVersion(patterns) {
                  return reduce(patterns, function(result, pattern) {
                    return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
                  });
                }
                function toStringPlatform() {
                  return this.description || "";
                }
                layout && (layout = [layout]);
                if (/\bAndroid\b/.test(os2) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
                  product = trim2(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
                }
                if (manufacturer && !product) {
                  product = getProduct([manufacturer]);
                } else if (manufacturer && product) {
                  product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
                }
                if (data = /\bGoogle TV\b/.exec(product)) {
                  product = data[0];
                }
                if (/\bSimulator\b/i.test(ua)) {
                  product = (product ? product + " " : "") + "Simulator";
                }
                if (name == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
                  description.push("running in Turbo/Uncompressed mode");
                }
                if (name == "IE" && /\blike iPhone OS\b/.test(ua)) {
                  data = parse2(ua.replace(/like iPhone OS/, ""));
                  manufacturer = data.manufacturer;
                  product = data.product;
                } else if (/^iP/.test(product)) {
                  name || (name = "Safari");
                  os2 = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
                } else if (name == "Konqueror" && /^Linux\b/i.test(os2)) {
                  os2 = "Kubuntu";
                } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os2) && /^Chrome/.test(name) && /\bVersion\//i.test(ua)) {
                  name = "Android Browser";
                  os2 = /\bAndroid\b/.test(os2) ? os2 : "Android";
                } else if (name == "Silk") {
                  if (!/\bMobi/i.test(ua)) {
                    os2 = "Android";
                    description.unshift("desktop mode");
                  }
                  if (/Accelerated *= *true/i.test(ua)) {
                    description.unshift("accelerated");
                  }
                } else if (name == "UC Browser" && /\bUCWEB\b/.test(ua)) {
                  description.push("speed mode");
                } else if (name == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
                  description.push("identifying as Firefox " + data[1]);
                } else if (name == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
                  os2 || (os2 = "Firefox OS");
                  product || (product = data[1]);
                } else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
                  if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
                    name = null;
                  }
                  if ((data = product || manufacturer || os2) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os2))) {
                    name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os2) ? os2 : data) + " Browser";
                  }
                } else if (name == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
                  description.push("Chromium " + data);
                }
                if (!version2) {
                  version2 = getVersion([
                    "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
                    "Version",
                    qualify(name),
                    "(?:Firefox|Minefield|NetFront)"
                  ]);
                }
                if (data = layout == "iCab" && parseFloat(version2) > 3 && "WebKit" || /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os2 == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name) && "NetFront") {
                  layout = [data];
                }
                if (name == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
                  name += " Mobile";
                  os2 = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
                  description.unshift("desktop mode");
                } else if (/\bWPDesktop\b/i.test(ua)) {
                  name = "IE Mobile";
                  os2 = "Windows Phone 8.x";
                  description.unshift("desktop mode");
                  version2 || (version2 = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
                } else if (name != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
                  if (name) {
                    description.push("identifying as " + name + (version2 ? " " + version2 : ""));
                  }
                  name = "IE";
                  version2 = data[1];
                }
                if (useFeatures) {
                  if (isHostType(context, "global")) {
                    if (java) {
                      data = java.lang.System;
                      arch = data.getProperty("os.arch");
                      os2 = os2 || data.getProperty("os.name") + " " + data.getProperty("os.version");
                    }
                    if (rhino) {
                      try {
                        version2 = context.require("ringo/engine").version.join(".");
                        name = "RingoJS";
                      } catch (e2) {
                        if ((data = context.system) && data.global.system == context.system) {
                          name = "Narwhal";
                          os2 || (os2 = data[0].os || null);
                        }
                      }
                      if (!name) {
                        name = "Rhino";
                      }
                    } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
                      if (typeof data.versions == "object") {
                        if (typeof data.versions.electron == "string") {
                          description.push("Node " + data.versions.node);
                          name = "Electron";
                          version2 = data.versions.electron;
                        } else if (typeof data.versions.nw == "string") {
                          description.push("Chromium " + version2, "Node " + data.versions.node);
                          name = "NW.js";
                          version2 = data.versions.nw;
                        }
                      }
                      if (!name) {
                        name = "Node.js";
                        arch = data.arch;
                        os2 = data.platform;
                        version2 = /[\d.]+/.exec(data.version);
                        version2 = version2 ? version2[0] : null;
                      }
                    }
                  } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
                    name = "Adobe AIR";
                    os2 = data.flash.system.Capabilities.os;
                  } else if (getClassOf(data = context.phantom) == phantomClass) {
                    name = "PhantomJS";
                    version2 = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
                  } else if (typeof doc.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
                    version2 = [version2, doc.documentMode];
                    if ((data = +data[1] + 4) != version2[1]) {
                      description.push("IE " + version2[1] + " mode");
                      layout && (layout[1] = "");
                      version2[1] = data;
                    }
                    version2 = name == "IE" ? String(version2[1].toFixed(1)) : version2[0];
                  } else if (typeof doc.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name)) {
                    description.push("masking as " + name + " " + version2);
                    name = "IE";
                    version2 = "11.0";
                    layout = ["Trident"];
                    os2 = "Windows";
                  }
                  os2 = os2 && format(os2);
                }
                if (version2 && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version2) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
                  prerelease = /b/i.test(data) ? "beta" : "alpha";
                  version2 = version2.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
                }
                if (name == "Fennec" || name == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os2)) {
                  name = "Firefox Mobile";
                } else if (name == "Maxthon" && version2) {
                  version2 = version2.replace(/\.[\d.]+/, ".x");
                } else if (/\bXbox\b/i.test(product)) {
                  if (product == "Xbox 360") {
                    os2 = null;
                  }
                  if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
                    description.unshift("mobile mode");
                  }
                } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os2 == "Windows CE" || /Mobi/i.test(ua))) {
                  name += " Mobile";
                } else if (name == "IE" && useFeatures) {
                  try {
                    if (context.external === null) {
                      description.unshift("platform preview");
                    }
                  } catch (e2) {
                    description.unshift("embedded");
                  }
                } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version2)) {
                  data = [data, /BB10/.test(ua)];
                  os2 = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
                  version2 = null;
                } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os2) || name == "IE" && (os2 && !/^Win/.test(os2) && version2 > 5.5 || /\bWindows XP\b/.test(os2) && version2 > 8 || version2 == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse2.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
                  data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
                  if (reOpera.test(name)) {
                    if (/\bIE\b/.test(data) && os2 == "Mac OS") {
                      os2 = null;
                    }
                    data = "identify" + data;
                  } else {
                    data = "mask" + data;
                    if (operaClass) {
                      name = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
                    } else {
                      name = "Opera";
                    }
                    if (/\bIE\b/.test(data)) {
                      os2 = null;
                    }
                    if (!useFeatures) {
                      version2 = null;
                    }
                  }
                  layout = ["Presto"];
                  description.push(data);
                }
                if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
                  data = [parseFloat(data.replace(/\.(\d)$/, ".0$1")), data];
                  if (name == "Safari" && data[1].slice(-1) == "+") {
                    name = "WebKit Nightly";
                    prerelease = "alpha";
                    version2 = data[1].slice(0, -1);
                  } else if (version2 == data[1] || version2 == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
                    version2 = null;
                  }
                  data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
                  if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
                    layout = ["Blink"];
                  }
                  if (!useFeatures || !likeChrome && !data[1]) {
                    layout && (layout[1] = "like Safari");
                    data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
                  } else {
                    layout && (layout[1] = "like Chrome");
                    data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
                  }
                  layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
                  if (name == "Safari" && (!version2 || parseInt(version2) > 45)) {
                    version2 = data;
                  } else if (name == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
                    description.unshift("headless");
                  }
                }
                if (name == "Opera" && (data = /\bzbov|zvav$/.exec(os2))) {
                  name += " ";
                  description.unshift("desktop mode");
                  if (data == "zvav") {
                    name += "Mini";
                    version2 = null;
                  } else {
                    name += "Mobile";
                  }
                  os2 = os2.replace(RegExp(" *" + data + "$"), "");
                } else if (name == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
                  description.unshift("desktop mode");
                  name = "Chrome Mobile";
                  version2 = null;
                  if (/\bOS X\b/.test(os2)) {
                    manufacturer = "Apple";
                    os2 = "iOS 4.3+";
                  } else {
                    os2 = null;
                  }
                } else if (/\bSRWare Iron\b/.test(name) && !version2) {
                  version2 = getVersion("Chrome");
                }
                if (version2 && version2.indexOf(data = /[\d.]+$/.exec(os2)) == 0 && ua.indexOf("/" + data + "-") > -1) {
                  os2 = trim2(os2.replace(data, ""));
                }
                if (os2 && os2.indexOf(name) != -1 && !RegExp(name + " OS").test(os2)) {
                  os2 = os2.replace(RegExp(" *" + qualify(name) + " *"), "");
                }
                if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != "Safari" && /^iOS/.test(os2) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {
                  (data = layout[layout.length - 1]) && description.push(data);
                }
                if (description.length) {
                  description = ["(" + description.join("; ") + ")"];
                }
                if (manufacturer && product && product.indexOf(manufacturer) < 0) {
                  description.push("on " + manufacturer);
                }
                if (product) {
                  description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
                }
                if (os2) {
                  data = / ([\d.+]+)$/.exec(os2);
                  isSpecialCasedOS = data && os2.charAt(os2.length - data[0].length - 1) == "/";
                  os2 = {
                    "architecture": 32,
                    "family": data && !isSpecialCasedOS ? os2.replace(data[0], "") : os2,
                    "version": data ? data[1] : null,
                    "toString": function() {
                      var version3 = this.version;
                      return this.family + (version3 && !isSpecialCasedOS ? " " + version3 : "") + (this.architecture == 64 ? " 64-bit" : "");
                    }
                  };
                }
                if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
                  if (os2) {
                    os2.architecture = 64;
                    os2.family = os2.family.replace(RegExp(" *" + data), "");
                  }
                  if (name && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
                    description.unshift("32-bit");
                  }
                } else if (os2 && /^OS X/.test(os2.family) && name == "Chrome" && parseFloat(version2) >= 39) {
                  os2.architecture = 64;
                }
                ua || (ua = null);
                var platform3 = {};
                platform3.description = ua;
                platform3.layout = layout && layout[0];
                platform3.manufacturer = manufacturer;
                platform3.name = name;
                platform3.prerelease = prerelease;
                platform3.product = product;
                platform3.ua = ua;
                platform3.version = name && version2;
                platform3.os = os2 || {
                  /**
                   * The CPU architecture the OS is built for.
                   *
                   * @memberOf platform.os
                   * @type number|null
                   */
                  "architecture": null,
                  /**
                   * The family of the OS.
                   *
                   * Common values include:
                   * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
                   * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
                   * "SuSE", "Android", "iOS" and "Windows Phone"
                   *
                   * @memberOf platform.os
                   * @type string|null
                   */
                  "family": null,
                  /**
                   * The version of the OS.
                   *
                   * @memberOf platform.os
                   * @type string|null
                   */
                  "version": null,
                  /**
                   * Returns the OS string.
                   *
                   * @memberOf platform.os
                   * @returns {string} The OS string.
                   */
                  "toString": function() {
                    return "null";
                  }
                };
                platform3.parse = parse2;
                platform3.toString = toStringPlatform;
                if (platform3.version) {
                  description.unshift(version2);
                }
                if (platform3.name) {
                  description.unshift(name);
                }
                if (os2 && name && !(os2 == String(os2).split(" ")[0] && (os2 == name.split(" ")[0] || product))) {
                  description.push(product ? "(" + os2 + ")" : "on " + os2);
                }
                if (description.length) {
                  platform3.description = description.join(" ");
                }
                return platform3;
              }
              var platform2 = parse2();
              if (freeExports && freeModule) {
                forOwn(platform2, function(value, key) {
                  freeExports[key] = value;
                });
              } else {
                root.platform = platform2;
              }
            }).call(this);
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 441: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
              module3.exports = { nextTick: nextTick2 };
            } else {
              module3.exports = process;
            }
            function nextTick2(fn, arg1, arg2, arg3) {
              if (typeof fn !== "function") {
                throw new TypeError('"callback" argument must be a function');
              }
              var len = arguments.length;
              var args, i;
              switch (len) {
                case 0:
                case 1:
                  return process.nextTick(fn);
                case 2:
                  return process.nextTick(function afterTickOne() {
                    fn.call(null, arg1);
                  });
                case 3:
                  return process.nextTick(function afterTickTwo() {
                    fn.call(null, arg1, arg2);
                  });
                case 4:
                  return process.nextTick(function afterTickThree() {
                    fn.call(null, arg1, arg2, arg3);
                  });
                default:
                  args = new Array(len - 1);
                  i = 0;
                  while (i < args.length) {
                    args[i++] = arguments[i];
                  }
                  return process.nextTick(function afterTick() {
                    fn.apply(null, args);
                  });
              }
            }
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 538 }], 442: [function(require2, module3, exports3) {
        var process = module3.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e2) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e2) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e2) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e3) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e2) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e3) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue2 = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue2 = currentQueue.concat(queue2);
          } else {
            queueIndex = -1;
          }
          if (queue2.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout2 = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue2.length;
          while (len) {
            currentQueue = queue2;
            queue2 = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue2.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout2);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue2.push(new Item(fun, args));
          if (queue2.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array2) {
          this.fun = fun;
          this.array = array2;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop2() {
        }
        process.on = noop2;
        process.addListener = noop2;
        process.once = noop2;
        process.off = noop2;
        process.removeListener = noop2;
        process.removeAllListeners = noop2;
        process.emit = noop2;
        process.prependListener = noop2;
        process.prependOnceListener = noop2;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 443: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            (function(root) {
              var freeExports = typeof exports3 == "object" && exports3 && !exports3.nodeType && exports3;
              var freeModule = typeof module3 == "object" && module3 && !module3.nodeType && module3;
              var freeGlobal = typeof global3 == "object" && global3;
              if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                root = freeGlobal;
              }
              var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                "overflow": "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
              }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
              function error2(type) {
                throw new RangeError(errors[type]);
              }
              function map(array2, fn) {
                var length = array2.length;
                var result = [];
                while (length--) {
                  result[length] = fn(array2[length]);
                }
                return result;
              }
              function mapDomain(string2, fn) {
                var parts = string2.split("@");
                var result = "";
                if (parts.length > 1) {
                  result = parts[0] + "@";
                  string2 = parts[1];
                }
                string2 = string2.replace(regexSeparators, ".");
                var labels = string2.split(".");
                var encoded = map(labels, fn).join(".");
                return result + encoded;
              }
              function ucs2decode(string2) {
                var output = [], counter = 0, length = string2.length, value, extra;
                while (counter < length) {
                  value = string2.charCodeAt(counter++);
                  if (value >= 55296 && value <= 56319 && counter < length) {
                    extra = string2.charCodeAt(counter++);
                    if ((extra & 64512) == 56320) {
                      output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                    } else {
                      output.push(value);
                      counter--;
                    }
                  } else {
                    output.push(value);
                  }
                }
                return output;
              }
              function ucs2encode(array2) {
                return map(array2, function(value) {
                  var output = "";
                  if (value > 65535) {
                    value -= 65536;
                    output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                    value = 56320 | value & 1023;
                  }
                  output += stringFromCharCode(value);
                  return output;
                }).join("");
              }
              function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) {
                  return codePoint - 22;
                }
                if (codePoint - 65 < 26) {
                  return codePoint - 65;
                }
                if (codePoint - 97 < 26) {
                  return codePoint - 97;
                }
                return base;
              }
              function digitToBasic(digit, flag2) {
                return digit + 22 + 75 * (digit < 26) - ((flag2 != 0) << 5);
              }
              function adapt(delta, numPoints, firstTime) {
                var k = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                  delta = floor(delta / baseMinusTMin);
                }
                return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
              }
              function decode2(input2) {
                var output = [], inputLength = input2.length, out, i = 0, n2 = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t2, baseMinusT;
                basic = input2.lastIndexOf(delimiter);
                if (basic < 0) {
                  basic = 0;
                }
                for (j = 0; j < basic; ++j) {
                  if (input2.charCodeAt(j) >= 128) {
                    error2("not-basic");
                  }
                  output.push(input2.charCodeAt(j));
                }
                for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
                  for (oldi = i, w = 1, k = base; ; k += base) {
                    if (index2 >= inputLength) {
                      error2("invalid-input");
                    }
                    digit = basicToDigit(input2.charCodeAt(index2++));
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                      error2("overflow");
                    }
                    i += digit * w;
                    t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (digit < t2) {
                      break;
                    }
                    baseMinusT = base - t2;
                    if (w > floor(maxInt / baseMinusT)) {
                      error2("overflow");
                    }
                    w *= baseMinusT;
                  }
                  out = output.length + 1;
                  bias = adapt(i - oldi, out, oldi == 0);
                  if (floor(i / out) > maxInt - n2) {
                    error2("overflow");
                  }
                  n2 += floor(i / out);
                  i %= out;
                  output.splice(i++, 0, n2);
                }
                return ucs2encode(output);
              }
              function encode3(input2) {
                var n2, delta, handledCPCount, basicLength, bias, j, m, q, k, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                input2 = ucs2decode(input2);
                inputLength = input2.length;
                n2 = initialN;
                delta = 0;
                bias = initialBias;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input2[j];
                  if (currentValue < 128) {
                    output.push(stringFromCharCode(currentValue));
                  }
                }
                handledCPCount = basicLength = output.length;
                if (basicLength) {
                  output.push(delimiter);
                }
                while (handledCPCount < inputLength) {
                  for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input2[j];
                    if (currentValue >= n2 && currentValue < m) {
                      m = currentValue;
                    }
                  }
                  handledCPCountPlusOne = handledCPCount + 1;
                  if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error2("overflow");
                  }
                  delta += (m - n2) * handledCPCountPlusOne;
                  n2 = m;
                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input2[j];
                    if (currentValue < n2 && ++delta > maxInt) {
                      error2("overflow");
                    }
                    if (currentValue == n2) {
                      for (q = delta, k = base; ; k += base) {
                        t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t2) {
                          break;
                        }
                        qMinusT = q - t2;
                        baseMinusT = base - t2;
                        output.push(
                          stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                        );
                        q = floor(qMinusT / baseMinusT);
                      }
                      output.push(stringFromCharCode(digitToBasic(q, 0)));
                      bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                      delta = 0;
                      ++handledCPCount;
                    }
                  }
                  ++delta;
                  ++n2;
                }
                return output.join("");
              }
              function toUnicode(input2) {
                return mapDomain(input2, function(string2) {
                  return regexPunycode.test(string2) ? decode2(string2.slice(4).toLowerCase()) : string2;
                });
              }
              function toASCII(input2) {
                return mapDomain(input2, function(string2) {
                  return regexNonASCII.test(string2) ? "xn--" + encode3(string2) : string2;
                });
              }
              punycode = {
                /**
                 * A string representing the current Punycode.js version number.
                 * @memberOf punycode
                 * @type String
                 */
                "version": "1.4.1",
                /**
                 * An object of methods to convert from JavaScript's internal character
                 * representation (UCS-2) to Unicode code points, and back.
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode
                 * @type Object
                 */
                "ucs2": {
                  "decode": ucs2decode,
                  "encode": ucs2encode
                },
                "decode": decode2,
                "encode": encode3,
                "toASCII": toASCII,
                "toUnicode": toUnicode
              };
              if (freeExports && freeModule) {
                if (module3.exports == freeExports) {
                  freeModule.exports = punycode;
                } else {
                  for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                  }
                }
              } else {
                root.punycode = punycode;
              }
            })(this);
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 444: [function(require2, module3, exports3) {
        var replace = String.prototype.replace;
        var percentTwenties = /%20/g;
        var Format = {
          RFC1738: "RFC1738",
          RFC3986: "RFC3986"
        };
        module3.exports = {
          "default": Format.RFC3986,
          formatters: {
            RFC1738: function(value) {
              return replace.call(value, percentTwenties, "+");
            },
            RFC3986: function(value) {
              return String(value);
            }
          },
          RFC1738: Format.RFC1738,
          RFC3986: Format.RFC3986
        };
      }, {}], 445: [function(require2, module3, exports3) {
        var stringify2 = require2("./stringify");
        var parse2 = require2("./parse");
        var formats = require2("./formats");
        module3.exports = {
          formats,
          parse: parse2,
          stringify: stringify2
        };
      }, { "./formats": 444, "./parse": 446, "./stringify": 447 }], 446: [function(require2, module3, exports3) {
        var utils2 = require2("./utils");
        var has2 = Object.prototype.hasOwnProperty;
        var isArray2 = Array.isArray;
        var defaults2 = {
          allowDots: false,
          allowPrototypes: false,
          allowSparse: false,
          arrayLimit: 20,
          charset: "utf-8",
          charsetSentinel: false,
          comma: false,
          decoder: utils2.decode,
          delimiter: "&",
          depth: 5,
          ignoreQueryPrefix: false,
          interpretNumericEntities: false,
          parameterLimit: 1e3,
          parseArrays: true,
          plainObjects: false,
          strictNullHandling: false
        };
        var interpretNumericEntities = function(str) {
          return str.replace(/&#(\d+);/g, function($0, numberStr) {
            return String.fromCharCode(parseInt(numberStr, 10));
          });
        };
        var parseArrayValue = function(val, options) {
          if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
            return val.split(",");
          }
          return val;
        };
        var isoSentinel = "utf8=%26%2310003%3B";
        var charsetSentinel = "utf8=%E2%9C%93";
        var parseValues = function parseQueryStringValues(str, options) {
          var obj = { __proto__: null };
          var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
          var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
          var parts = cleanStr.split(options.delimiter, limit);
          var skipIndex = -1;
          var i;
          var charset = options.charset;
          if (options.charsetSentinel) {
            for (i = 0; i < parts.length; ++i) {
              if (parts[i].indexOf("utf8=") === 0) {
                if (parts[i] === charsetSentinel) {
                  charset = "utf-8";
                } else if (parts[i] === isoSentinel) {
                  charset = "iso-8859-1";
                }
                skipIndex = i;
                i = parts.length;
              }
            }
          }
          for (i = 0; i < parts.length; ++i) {
            if (i === skipIndex) {
              continue;
            }
            var part = parts[i];
            var bracketEqualsPos = part.indexOf("]=");
            var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
            var key, val;
            if (pos === -1) {
              key = options.decoder(part, defaults2.decoder, charset, "key");
              val = options.strictNullHandling ? null : "";
            } else {
              key = options.decoder(part.slice(0, pos), defaults2.decoder, charset, "key");
              val = utils2.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function(encodedVal) {
                  return options.decoder(encodedVal, defaults2.decoder, charset, "value");
                }
              );
            }
            if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
              val = interpretNumericEntities(val);
            }
            if (part.indexOf("[]=") > -1) {
              val = isArray2(val) ? [val] : val;
            }
            if (has2.call(obj, key)) {
              obj[key] = utils2.combine(obj[key], val);
            } else {
              obj[key] = val;
            }
          }
          return obj;
        };
        var parseObject = function(chain, val, options, valuesParsed) {
          var leaf = valuesParsed ? val : parseArrayValue(val, options);
          for (var i = chain.length - 1; i >= 0; --i) {
            var obj;
            var root = chain[i];
            if (root === "[]" && options.parseArrays) {
              obj = [].concat(leaf);
            } else {
              obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
              var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
              var index2 = parseInt(cleanRoot, 10);
              if (!options.parseArrays && cleanRoot === "") {
                obj = { 0: leaf };
              } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
                obj = [];
                obj[index2] = leaf;
              } else if (cleanRoot !== "__proto__") {
                obj[cleanRoot] = leaf;
              }
            }
            leaf = obj;
          }
          return leaf;
        };
        var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
          if (!givenKey) {
            return;
          }
          var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
          var brackets = /(\[[^[\]]*])/;
          var child = /(\[[^[\]]*])/g;
          var segment = options.depth > 0 && brackets.exec(key);
          var parent = segment ? key.slice(0, segment.index) : key;
          var keys = [];
          if (parent) {
            if (!options.plainObjects && has2.call(Object.prototype, parent)) {
              if (!options.allowPrototypes) {
                return;
              }
            }
            keys.push(parent);
          }
          var i = 0;
          while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
            i += 1;
            if (!options.plainObjects && has2.call(Object.prototype, segment[1].slice(1, -1))) {
              if (!options.allowPrototypes) {
                return;
              }
            }
            keys.push(segment[1]);
          }
          if (segment) {
            keys.push("[" + key.slice(segment.index) + "]");
          }
          return parseObject(keys, val, options, valuesParsed);
        };
        var normalizeParseOptions = function normalizeParseOptions2(opts) {
          if (!opts) {
            return defaults2;
          }
          if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
            throw new TypeError("Decoder has to be a function.");
          }
          if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
            throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
          }
          var charset = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
          return {
            allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
            allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
            allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
            arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
            charset,
            charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
            comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
            decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
            delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
            // eslint-disable-next-line no-implicit-coercion, no-extra-parens
            depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
            ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
            interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
            parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
            parseArrays: opts.parseArrays !== false,
            plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
            strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
          };
        };
        module3.exports = function(str, opts) {
          var options = normalizeParseOptions(opts);
          if (str === "" || str === null || typeof str === "undefined") {
            return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          }
          var tempObj = typeof str === "string" ? parseValues(str, options) : str;
          var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var keys = Object.keys(tempObj);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
            obj = utils2.merge(obj, newObj, options);
          }
          if (options.allowSparse === true) {
            return obj;
          }
          return utils2.compact(obj);
        };
      }, { "./utils": 448 }], 447: [function(require2, module3, exports3) {
        var getSideChannel = require2("side-channel");
        var utils2 = require2("./utils");
        var formats = require2("./formats");
        var has2 = Object.prototype.hasOwnProperty;
        var arrayPrefixGenerators = {
          brackets: function brackets(prefix) {
            return prefix + "[]";
          },
          comma: "comma",
          indices: function indices(prefix, key) {
            return prefix + "[" + key + "]";
          },
          repeat: function repeat2(prefix) {
            return prefix;
          }
        };
        var isArray2 = Array.isArray;
        var push = Array.prototype.push;
        var pushToArray = function(arr, valueOrArray) {
          push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
        };
        var toISO = Date.prototype.toISOString;
        var defaultFormat = formats["default"];
        var defaults2 = {
          addQueryPrefix: false,
          allowDots: false,
          charset: "utf-8",
          charsetSentinel: false,
          delimiter: "&",
          encode: true,
          encoder: utils2.encode,
          encodeValuesOnly: false,
          format: defaultFormat,
          formatter: formats.formatters[defaultFormat],
          // deprecated
          indices: false,
          serializeDate: function serializeDate(date2) {
            return toISO.call(date2);
          },
          skipNulls: false,
          strictNullHandling: false
        };
        var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
          return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
        };
        var sentinel = {};
        var stringify2 = function stringify3(object2, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
          var obj = object2;
          var tmpSc = sideChannel;
          var step = 0;
          var findFlag = false;
          while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
            var pos = tmpSc.get(object2);
            step += 1;
            if (typeof pos !== "undefined") {
              if (pos === step) {
                throw new RangeError("Cyclic object value");
              } else {
                findFlag = true;
              }
            }
            if (typeof tmpSc.get(sentinel) === "undefined") {
              step = 0;
            }
          }
          if (typeof filter === "function") {
            obj = filter(prefix, obj);
          } else if (obj instanceof Date) {
            obj = serializeDate(obj);
          } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
            obj = utils2.maybeMap(obj, function(value2) {
              if (value2 instanceof Date) {
                return serializeDate(value2);
              }
              return value2;
            });
          }
          if (obj === null) {
            if (strictNullHandling) {
              return encoder && !encodeValuesOnly ? encoder(prefix, defaults2.encoder, charset, "key", format) : prefix;
            }
            obj = "";
          }
          if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
            if (encoder) {
              var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults2.encoder, charset, "key", format);
              return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults2.encoder, charset, "value", format))];
            }
            return [formatter(prefix) + "=" + formatter(String(obj))];
          }
          var values = [];
          if (typeof obj === "undefined") {
            return values;
          }
          var objKeys;
          if (generateArrayPrefix === "comma" && isArray2(obj)) {
            if (encodeValuesOnly && encoder) {
              obj = utils2.maybeMap(obj, encoder);
            }
            objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
          } else if (isArray2(filter)) {
            objKeys = filter;
          } else {
            var keys = Object.keys(obj);
            objKeys = sort ? keys.sort(sort) : keys;
          }
          var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
          for (var j = 0; j < objKeys.length; ++j) {
            var key = objKeys[j];
            var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
            if (skipNulls && value === null) {
              continue;
            }
            var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
            sideChannel.set(object2, step);
            var valueSideChannel = getSideChannel();
            valueSideChannel.set(sentinel, sideChannel);
            pushToArray(values, stringify3(
              value,
              keyPrefix,
              generateArrayPrefix,
              commaRoundTrip,
              strictNullHandling,
              skipNulls,
              generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
              filter,
              sort,
              allowDots,
              serializeDate,
              format,
              formatter,
              encodeValuesOnly,
              charset,
              valueSideChannel
            ));
          }
          return values;
        };
        var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
          if (!opts) {
            return defaults2;
          }
          if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
            throw new TypeError("Encoder has to be a function.");
          }
          var charset = opts.charset || defaults2.charset;
          if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
            throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
          }
          var format = formats["default"];
          if (typeof opts.format !== "undefined") {
            if (!has2.call(formats.formatters, opts.format)) {
              throw new TypeError("Unknown format option provided.");
            }
            format = opts.format;
          }
          var formatter = formats.formatters[format];
          var filter = defaults2.filter;
          if (typeof opts.filter === "function" || isArray2(opts.filter)) {
            filter = opts.filter;
          }
          return {
            addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
            allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
            charset,
            charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
            delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
            encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
            encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
            encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
            filter,
            format,
            formatter,
            serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
            skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
            sort: typeof opts.sort === "function" ? opts.sort : null,
            strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
          };
        };
        module3.exports = function(object2, opts) {
          var obj = object2;
          var options = normalizeStringifyOptions(opts);
          var objKeys;
          var filter;
          if (typeof options.filter === "function") {
            filter = options.filter;
            obj = filter("", obj);
          } else if (isArray2(options.filter)) {
            filter = options.filter;
            objKeys = filter;
          }
          var keys = [];
          if (typeof obj !== "object" || obj === null) {
            return "";
          }
          var arrayFormat;
          if (opts && opts.arrayFormat in arrayPrefixGenerators) {
            arrayFormat = opts.arrayFormat;
          } else if (opts && "indices" in opts) {
            arrayFormat = opts.indices ? "indices" : "repeat";
          } else {
            arrayFormat = "indices";
          }
          var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
          if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
            throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
          }
          var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
          if (!objKeys) {
            objKeys = Object.keys(obj);
          }
          if (options.sort) {
            objKeys.sort(options.sort);
          }
          var sideChannel = getSideChannel();
          for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];
            if (options.skipNulls && obj[key] === null) {
              continue;
            }
            pushToArray(keys, stringify2(
              obj[key],
              key,
              generateArrayPrefix,
              commaRoundTrip,
              options.strictNullHandling,
              options.skipNulls,
              options.encode ? options.encoder : null,
              options.filter,
              options.sort,
              options.allowDots,
              options.serializeDate,
              options.format,
              options.formatter,
              options.encodeValuesOnly,
              options.charset,
              sideChannel
            ));
          }
          var joined = keys.join(options.delimiter);
          var prefix = options.addQueryPrefix === true ? "?" : "";
          if (options.charsetSentinel) {
            if (options.charset === "iso-8859-1") {
              prefix += "utf8=%26%2310003%3B&";
            } else {
              prefix += "utf8=%E2%9C%93&";
            }
          }
          return joined.length > 0 ? prefix + joined : "";
        };
      }, { "./formats": 444, "./utils": 448, "side-channel": 467 }], 448: [function(require2, module3, exports3) {
        var formats = require2("./formats");
        var has2 = Object.prototype.hasOwnProperty;
        var isArray2 = Array.isArray;
        var hexTable = function() {
          var array2 = [];
          for (var i = 0; i < 256; ++i) {
            array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
          }
          return array2;
        }();
        var compactQueue = function compactQueue2(queue2) {
          while (queue2.length > 1) {
            var item = queue2.pop();
            var obj = item.obj[item.prop];
            if (isArray2(obj)) {
              var compacted = [];
              for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== "undefined") {
                  compacted.push(obj[j]);
                }
              }
              item.obj[item.prop] = compacted;
            }
          }
        };
        var arrayToObject = function arrayToObject2(source, options) {
          var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          for (var i = 0; i < source.length; ++i) {
            if (typeof source[i] !== "undefined") {
              obj[i] = source[i];
            }
          }
          return obj;
        };
        var merge = function merge2(target, source, options) {
          if (!source) {
            return target;
          }
          if (typeof source !== "object") {
            if (isArray2(target)) {
              target.push(source);
            } else if (target && typeof target === "object") {
              if (options && (options.plainObjects || options.allowPrototypes) || !has2.call(Object.prototype, source)) {
                target[source] = true;
              }
            } else {
              return [target, source];
            }
            return target;
          }
          if (!target || typeof target !== "object") {
            return [target].concat(source);
          }
          var mergeTarget = target;
          if (isArray2(target) && !isArray2(source)) {
            mergeTarget = arrayToObject(target, options);
          }
          if (isArray2(target) && isArray2(source)) {
            source.forEach(function(item, i) {
              if (has2.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
                  target[i] = merge2(targetItem, item, options);
                } else {
                  target.push(item);
                }
              } else {
                target[i] = item;
              }
            });
            return target;
          }
          return Object.keys(source).reduce(function(acc, key) {
            var value = source[key];
            if (has2.call(acc, key)) {
              acc[key] = merge2(acc[key], value, options);
            } else {
              acc[key] = value;
            }
            return acc;
          }, mergeTarget);
        };
        var assign2 = function assignSingleSource(target, source) {
          return Object.keys(source).reduce(function(acc, key) {
            acc[key] = source[key];
            return acc;
          }, target);
        };
        var decode2 = function(str, decoder, charset) {
          var strWithoutPlus = str.replace(/\+/g, " ");
          if (charset === "iso-8859-1") {
            return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
          }
          try {
            return decodeURIComponent(strWithoutPlus);
          } catch (e2) {
            return strWithoutPlus;
          }
        };
        var encode3 = function encode4(str, defaultEncoder, charset, kind, format) {
          if (str.length === 0) {
            return str;
          }
          var string2 = str;
          if (typeof str === "symbol") {
            string2 = Symbol.prototype.toString.call(str);
          } else if (typeof str !== "string") {
            string2 = String(str);
          }
          if (charset === "iso-8859-1") {
            return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
              return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
            });
          }
          var out = "";
          for (var i = 0; i < string2.length; ++i) {
            var c = string2.charCodeAt(i);
            if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
              out += string2.charAt(i);
              continue;
            }
            if (c < 128) {
              out = out + hexTable[c];
              continue;
            }
            if (c < 2048) {
              out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
              continue;
            }
            if (c < 55296 || c >= 57344) {
              out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
              continue;
            }
            i += 1;
            c = 65536 + ((c & 1023) << 10 | string2.charCodeAt(i) & 1023);
            out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          }
          return out;
        };
        var compact = function compact2(value) {
          var queue2 = [{ obj: { o: value }, prop: "o" }];
          var refs = [];
          for (var i = 0; i < queue2.length; ++i) {
            var item = queue2[i];
            var obj = item.obj[item.prop];
            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; ++j) {
              var key = keys[j];
              var val = obj[key];
              if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
                queue2.push({ obj, prop: key });
                refs.push(val);
              }
            }
          }
          compactQueue(queue2);
          return value;
        };
        var isRegExp = function isRegExp2(obj) {
          return Object.prototype.toString.call(obj) === "[object RegExp]";
        };
        var isBuffer = function isBuffer2(obj) {
          if (!obj || typeof obj !== "object") {
            return false;
          }
          return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
        };
        var combine = function combine2(a2, b) {
          return [].concat(a2, b);
        };
        var maybeMap = function maybeMap2(val, fn) {
          if (isArray2(val)) {
            var mapped = [];
            for (var i = 0; i < val.length; i += 1) {
              mapped.push(fn(val[i]));
            }
            return mapped;
          }
          return fn(val);
        };
        module3.exports = {
          arrayToObject,
          assign: assign2,
          combine,
          compact,
          decode: decode2,
          encode: encode3,
          isBuffer,
          isRegExp,
          maybeMap,
          merge
        };
      }, { "./formats": 444 }], 449: [function(require2, module3, exports3) {
        function hasOwnProperty2(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module3.exports = function(qs2, sep, eq, options) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};
          if (typeof qs2 !== "string" || qs2.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs2 = qs2.split(sep);
          var maxKeys = 1e3;
          if (options && typeof options.maxKeys === "number") {
            maxKeys = options.maxKeys;
          }
          var len = qs2.length;
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs2[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = "";
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty2(obj, k)) {
              obj[k] = v;
            } else if (isArray2(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }
          return obj;
        };
        var isArray2 = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
      }, {}], 450: [function(require2, module3, exports3) {
        var stringifyPrimitive = function(v) {
          switch (typeof v) {
            case "string":
              return v;
            case "boolean":
              return v ? "true" : "false";
            case "number":
              return isFinite(v) ? v : "";
            default:
              return "";
          }
        };
        module3.exports = function(obj, sep, eq, name) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = void 0;
          }
          if (typeof obj === "object") {
            return map(objectKeys2(obj), function(k) {
              var ks2 = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray2(obj[k])) {
                return map(obj[k], function(v) {
                  return ks2 + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks2 + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }
          if (!name)
            return "";
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray2 = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
        function map(xs, f2) {
          if (xs.map)
            return xs.map(f2);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f2(xs[i], i));
          }
          return res;
        }
        var objectKeys2 = Object.keys || function(obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              res.push(key);
          }
          return res;
        };
      }, {}], 451: [function(require2, module3, exports3) {
        exports3.decode = exports3.parse = require2("./decode");
        exports3.encode = exports3.stringify = require2("./encode");
      }, { "./decode": 449, "./encode": 450 }], 452: [function(require2, module3, exports3) {
        var pna = require2("process-nextick-args");
        var objectKeys2 = Object.keys || function(obj) {
          var keys2 = [];
          for (var key in obj) {
            keys2.push(key);
          }
          return keys2;
        };
        module3.exports = Duplex;
        var util = Object.create(require2("core-util-is"));
        util.inherits = require2("inherits");
        var Readable = require2("./_stream_readable");
        var Writable = require2("./_stream_writable");
        util.inherits(Duplex, Readable);
        {
          var keys = objectKeys2(Writable.prototype);
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
        }
        function Duplex(options) {
          if (!(this instanceof Duplex))
            return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          if (options && options.readable === false)
            this.readable = false;
          if (options && options.writable === false)
            this.writable = false;
          this.allowHalfOpen = true;
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false;
          this.once("end", onend);
        }
        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._writableState.highWaterMark;
          }
        });
        function onend() {
          if (this.allowHalfOpen || this._writableState.ended)
            return;
          pna.nextTick(onEndNT, this);
        }
        function onEndNT(self2) {
          self2.end();
        }
        Object.defineProperty(Duplex.prototype, "destroyed", {
          get: function() {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function(value) {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return;
            }
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        });
        Duplex.prototype._destroy = function(err, cb) {
          this.push(null);
          this.end();
          pna.nextTick(cb, err);
        };
      }, { "./_stream_readable": 454, "./_stream_writable": 456, "core-util-is": 382, "inherits": 407, "process-nextick-args": 441 }], 453: [function(require2, module3, exports3) {
        module3.exports = PassThrough;
        var Transform = require2("./_stream_transform");
        var util = Object.create(require2("core-util-is"));
        util.inherits = require2("inherits");
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, { "./_stream_transform": 455, "core-util-is": 382, "inherits": 407 }], 454: [function(require2, module3, exports3) {
        (function(process, global3) {
          (function() {
            var pna = require2("process-nextick-args");
            module3.exports = Readable;
            var isArray2 = require2("isarray");
            var Duplex;
            Readable.ReadableState = ReadableState;
            require2("events").EventEmitter;
            var EElistenerCount = function(emitter, type) {
              return emitter.listeners(type).length;
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer2 = require2("safe-buffer").Buffer;
            var OurUint8Array = (typeof global3 !== "undefined" ? global3 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var util = Object.create(require2("core-util-is"));
            util.inherits = require2("inherits");
            var debugUtil = require2("util");
            var debug = void 0;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function() {
              };
            }
            var BufferList = require2("./internal/streams/BufferList");
            var destroyImpl = require2("./internal/streams/destroy");
            var StringDecoder;
            util.inherits(Readable, Stream);
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === "function")
                return emitter.prependListener(event, fn);
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (isArray2(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [fn, emitter._events[event]];
            }
            function ReadableState(options, stream) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              var isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;
              var hwm = options.highWaterMark;
              var readableHwm = options.readableHighWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              if (hwm || hwm === 0)
                this.highWaterMark = hwm;
              else if (isDuplex && (readableHwm || readableHwm === 0))
                this.highWaterMark = readableHwm;
              else
                this.highWaterMark = defaultHwm;
              this.highWaterMark = Math.floor(this.highWaterMark);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.destroyed = false;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = require2("string_decoder/").StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              if (!(this instanceof Readable))
                return new Readable(options);
              this._readableState = new ReadableState(options, this);
              this.readable = true;
              if (options) {
                if (typeof options.read === "function")
                  this._read = options.read;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, "destroyed", {
              get: function() {
                if (this._readableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed;
              },
              set: function(value) {
                if (!this._readableState) {
                  return;
                }
                this._readableState.destroyed = value;
              }
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err, cb) {
              this.push(null);
              cb(err);
            };
            Readable.prototype.push = function(chunk, encoding) {
              var state = this._readableState;
              var skipChunkCheck;
              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding = encoding || state.defaultEncoding;
                  if (encoding !== state.encoding) {
                    chunk = Buffer2.from(chunk, encoding);
                    encoding = "";
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            };
            Readable.prototype.unshift = function(chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };
            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
              var state = stream._readableState;
              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck)
                  er = chunkInvalid(state, chunk);
                if (er) {
                  stream.emit("error", er);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                  if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (addToFront) {
                    if (state.endEmitted)
                      stream.emit("error", new Error("stream.unshift() after end event"));
                    else
                      addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    stream.emit("error", new Error("stream.push() after EOF"));
                  } else {
                    state.reading = false;
                    if (state.decoder && !encoding) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                      else
                        maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                }
              }
              return needMoreData(state);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
              var er;
              if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new TypeError("Invalid non-string/buffer chunk");
              }
              return er;
            }
            function needMoreData(state) {
              return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              this._readableState.decoder = new StringDecoder(enc);
              this._readableState.encoding = enc;
              return this;
            };
            var MAX_HWM = 8388608;
            function computeNewHighWaterMark(n2) {
              if (n2 >= MAX_HWM) {
                n2 = MAX_HWM;
              } else {
                n2--;
                n2 |= n2 >>> 1;
                n2 |= n2 >>> 2;
                n2 |= n2 >>> 4;
                n2 |= n2 >>> 8;
                n2 |= n2 >>> 16;
                n2++;
              }
              return n2;
            }
            function howMuchToRead(n2, state) {
              if (n2 <= 0 || state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return 1;
              if (n2 !== n2) {
                if (state.flowing && state.length)
                  return state.buffer.head.data.length;
                else
                  return state.length;
              }
              if (n2 > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n2);
              if (n2 <= state.length)
                return n2;
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }
            Readable.prototype.read = function(n2) {
              debug("read", n2);
              n2 = parseInt(n2, 10);
              var state = this._readableState;
              var nOrig = n2;
              if (n2 !== 0)
                state.emittedReadable = false;
              if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n2 = howMuchToRead(n2, state);
              if (n2 === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug("need readable", doRead);
              if (state.length === 0 || state.length - n2 < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading)
                  n2 = howMuchToRead(nOrig, state);
              }
              var ret;
              if (n2 > 0)
                ret = fromList(n2, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = true;
                n2 = 0;
              } else {
                state.length -= n2;
              }
              if (state.length === 0) {
                if (!state.ended)
                  state.needReadable = true;
                if (nOrig !== n2 && state.ended)
                  endReadable(this);
              }
              if (ret !== null)
                this.emit("data", ret);
              return ret;
            };
            function onEofChunk(stream, state) {
              if (state.ended)
                return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              emitReadable(stream);
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                if (state.sync)
                  pna.nextTick(emitReadable_, stream);
                else
                  emitReadable_(stream);
              }
            }
            function emitReadable_(stream) {
              debug("emit readable");
              stream.emit("readable");
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                pna.nextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              var len = state.length;
              while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  break;
                else
                  len = state.length;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n2) {
              this.emit("error", new Error("_read() is not implemented"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted)
                pna.nextTick(endFn);
              else
                src.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on("drain", ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              var increasedAwaitDrain = false;
              src.on("data", ondata);
              function ondata(chunk) {
                debug("ondata");
                increasedAwaitDrain = false;
                var ret = dest.write(chunk);
                if (false === ret && !increasedAwaitDrain) {
                  if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                    debug("false write response, pause", state.awaitDrain);
                    state.awaitDrain++;
                    increasedAwaitDrain = true;
                  }
                  src.pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0)
                  dest.emit("error", er);
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
              }
              dest.emit("pipe", src);
              if (!state.flowing) {
                debug("pipe resume");
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain)
                  state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              var unpipeInfo = { hasUnpiped: false };
              if (state.pipesCount === 0)
                return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes)
                  return this;
                if (!dest)
                  dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                  dest.emit("unpipe", this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++) {
                  dests[i].emit("unpipe", this, { hasUnpiped: false });
                }
                return this;
              }
              var index2 = indexOf(state.pipes, dest);
              if (index2 === -1)
                return this;
              state.pipes.splice(index2, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1)
                state.pipes = state.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              if (ev === "data") {
                if (this._readableState.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                var state = this._readableState;
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.emittedReadable = false;
                  if (!state.reading) {
                    pna.nextTick(nReadingNextTick, this);
                  } else if (state.length) {
                    emitReadable(this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug("resume");
                state.flowing = true;
                resume(this, state);
              }
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                pna.nextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              if (!state.reading) {
                debug("resume read 0");
                stream.read(0);
              }
              state.resumeScheduled = false;
              state.awaitDrain = 0;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (false !== this._readableState.flowing) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug("flow", state.flowing);
              while (state.flowing && stream.read() !== null) {
              }
            }
            Readable.prototype.wrap = function(stream) {
              var _this = this;
              var state = this._readableState;
              var paused = false;
              stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length)
                    _this.push(chunk);
                }
                _this.push(null);
              });
              stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder)
                  chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === void 0))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                  return;
                var ret = _this.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i in stream) {
                if (this[i] === void 0 && typeof stream[i] === "function") {
                  this[i] = /* @__PURE__ */ function(method) {
                    return function() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i);
                }
              }
              for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
                stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
              }
              this._read = function(n3) {
                debug("wrapped _read", n3);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return this;
            };
            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function() {
                return this._readableState.highWaterMark;
              }
            });
            Readable._fromList = fromList;
            function fromList(n2, state) {
              if (state.length === 0)
                return null;
              var ret;
              if (state.objectMode)
                ret = state.buffer.shift();
              else if (!n2 || n2 >= state.length) {
                if (state.decoder)
                  ret = state.buffer.join("");
                else if (state.buffer.length === 1)
                  ret = state.buffer.head.data;
                else
                  ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = fromListPartial(n2, state.buffer, state.decoder);
              }
              return ret;
            }
            function fromListPartial(n2, list2, hasStrings) {
              var ret;
              if (n2 < list2.head.data.length) {
                ret = list2.head.data.slice(0, n2);
                list2.head.data = list2.head.data.slice(n2);
              } else if (n2 === list2.head.data.length) {
                ret = list2.shift();
              } else {
                ret = hasStrings ? copyFromBufferString(n2, list2) : copyFromBuffer(n2, list2);
              }
              return ret;
            }
            function copyFromBufferString(n2, list2) {
              var p2 = list2.head;
              var c = 1;
              var ret = p2.data;
              n2 -= ret.length;
              while (p2 = p2.next) {
                var str = p2.data;
                var nb = n2 > str.length ? str.length : n2;
                if (nb === str.length)
                  ret += str;
                else
                  ret += str.slice(0, n2);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === str.length) {
                    ++c;
                    if (p2.next)
                      list2.head = p2.next;
                    else
                      list2.head = list2.tail = null;
                  } else {
                    list2.head = p2;
                    p2.data = str.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              list2.length -= c;
              return ret;
            }
            function copyFromBuffer(n2, list2) {
              var ret = Buffer2.allocUnsafe(n2);
              var p2 = list2.head;
              var c = 1;
              p2.data.copy(ret);
              n2 -= p2.data.length;
              while (p2 = p2.next) {
                var buf = p2.data;
                var nb = n2 > buf.length ? buf.length : n2;
                buf.copy(ret, ret.length - n2, 0, nb);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === buf.length) {
                    ++c;
                    if (p2.next)
                      list2.head = p2.next;
                    else
                      list2.head = list2.tail = null;
                  } else {
                    list2.head = p2;
                    p2.data = buf.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              list2.length -= c;
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              if (state.length > 0)
                throw new Error('"endReadable()" called on non-empty stream');
              if (!state.endEmitted) {
                state.ended = true;
                pna.nextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
              }
            }
            function indexOf(xs, x) {
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x)
                  return i;
              }
              return -1;
            }
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./_stream_duplex": 452, "./internal/streams/BufferList": 457, "./internal/streams/destroy": 458, "./internal/streams/stream": 459, "_process": 538, "core-util-is": 382, "events": 386, "inherits": 407, "isarray": 460, "process-nextick-args": 441, "safe-buffer": 461, "string_decoder/": 462, "util": 102 }], 455: [function(require2, module3, exports3) {
        module3.exports = Transform;
        var Duplex = require2("./_stream_duplex");
        var util = Object.create(require2("core-util-is"));
        util.inherits = require2("inherits");
        util.inherits(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb) {
            return this.emit("error", new Error("write callback called multiple times"));
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function") {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error("_transform() is not implemented");
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n2) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err, cb) {
          var _this2 = this;
          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
            _this2.emit("close");
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new Error("Calling transform done when ws.length != 0");
          if (stream._transformState.transforming)
            throw new Error("Calling transform done when still transforming");
          return stream.push(null);
        }
      }, { "./_stream_duplex": 452, "core-util-is": 382, "inherits": 407 }], 456: [function(require2, module3, exports3) {
        (function(process, global3, setImmediate) {
          (function() {
            var pna = require2("process-nextick-args");
            module3.exports = Writable;
            function CorkedRequest(state) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state);
              };
            }
            var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
            var Duplex;
            Writable.WritableState = WritableState;
            var util = Object.create(require2("core-util-is"));
            util.inherits = require2("inherits");
            var internalUtil = {
              deprecate: require2("util-deprecate")
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer2 = require2("safe-buffer").Buffer;
            var OurUint8Array = (typeof global3 !== "undefined" ? global3 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = require2("./internal/streams/destroy");
            util.inherits(Writable, Stream);
            function nop() {
            }
            function WritableState(options, stream) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              var isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.writableObjectMode;
              var hwm = options.highWaterMark;
              var writableHwm = options.writableHighWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              if (hwm || hwm === 0)
                this.highWaterMark = hwm;
              else if (isDuplex && (writableHwm || writableHwm === 0))
                this.highWaterMark = writableHwm;
              else
                this.highWaterMark = defaultHwm;
              this.highWaterMark = Math.floor(this.highWaterMark);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                  get: internalUtil.deprecate(function() {
                    return this.getBuffer();
                  }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
              } catch (_) {
              }
            })();
            var realHasInstance;
            if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function(object2) {
                  if (realHasInstance.call(this, object2))
                    return true;
                  if (this !== Writable)
                    return false;
                  return object2 && object2._writableState instanceof WritableState;
                }
              });
            } else {
              realHasInstance = function(object2) {
                return object2 instanceof this;
              };
            }
            function Writable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
                return new Writable(options);
              }
              this._writableState = new WritableState(options, this);
              this.writable = true;
              if (options) {
                if (typeof options.write === "function")
                  this._write = options.write;
                if (typeof options.writev === "function")
                  this._writev = options.writev;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.final === "function")
                  this._final = options.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              this.emit("error", new Error("Cannot pipe, not readable"));
            };
            function writeAfterEnd(stream, cb) {
              var er = new Error("write after end");
              stream.emit("error", er);
              pna.nextTick(cb, er);
            }
            function validChunk(stream, state, chunk, cb) {
              var valid = true;
              var er = false;
              if (chunk === null) {
                er = new TypeError("May not write null values to stream");
              } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new TypeError("Invalid non-string/buffer chunk");
              }
              if (er) {
                stream.emit("error", er);
                pna.nextTick(cb, er);
                valid = false;
              }
              return valid;
            }
            Writable.prototype.write = function(chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;
              var isBuf = !state.objectMode && _isUint8Array(chunk);
              if (isBuf && !Buffer2.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (isBuf)
                encoding = "buffer";
              else if (!encoding)
                encoding = state.defaultEncoding;
              if (typeof cb !== "function")
                cb = nop;
              if (state.ended)
                writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              var state = this._writableState;
              state.corked++;
            };
            Writable.prototype.uncork = function() {
              var state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              if (typeof encoding === "string")
                encoding = encoding.toLowerCase();
              if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                throw new TypeError("Unknown encoding: " + encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };
            function decodeChunk(state, chunk, encoding) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer2.from(chunk, encoding);
              }
              return chunk;
            }
            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function() {
                return this._writableState.highWaterMark;
              }
            });
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding = "buffer";
                  chunk = newChunk;
                }
              }
              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark;
              if (!ret)
                state.needDrain = true;
              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                  chunk,
                  encoding,
                  isBuf,
                  callback: cb,
                  next: null
                };
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }
              return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (writev)
                stream._writev(chunk, state.onwrite);
              else
                stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) {
                pna.nextTick(cb, er);
                pna.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
                finishMaybe(stream, state);
              }
            }
            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }
            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              onwriteStateUpdate(state);
              if (er)
                onwriteError(stream, state, sync, er, cb);
              else {
                var finished = needFinish(state);
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  asyncWrite(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }
            function afterWrite(stream, state, finished, cb) {
              if (!finished)
                onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
            }
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l = state.bufferedRequestCount;
                var buffer2 = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer2[count] = entry;
                  if (!entry.isBuf)
                    allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer2.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
                state.bufferedRequestCount = 0;
              } else {
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  state.bufferedRequestCount--;
                  if (state.writing) {
                    break;
                  }
                }
                if (entry === null)
                  state.lastBufferedRequest = null;
              }
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding, cb) {
              cb(new Error("_write() is not implemented"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding, cb) {
              var state = this._writableState;
              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (chunk !== null && chunk !== void 0)
                this.write(chunk, encoding);
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (!state.ending)
                endWritable(this, state, cb);
            };
            function needFinish(state) {
              return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }
            function callFinal(stream, state) {
              stream._final(function(err) {
                state.pendingcb--;
                if (err) {
                  stream.emit("error", err);
                }
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
              });
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function") {
                  state.pendingcb++;
                  state.finalCalled = true;
                  pna.nextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit("finish");
                }
              }
              return need;
            }
            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished)
                  pna.nextTick(cb);
                else
                  stream.once("finish", cb);
              }
              state.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
              }
              state.corkedRequestsFree.next = corkReq;
            }
            Object.defineProperty(Writable.prototype, "destroyed", {
              get: function() {
                if (this._writableState === void 0) {
                  return false;
                }
                return this._writableState.destroyed;
              },
              set: function(value) {
                if (!this._writableState) {
                  return;
                }
                this._writableState.destroyed = value;
              }
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err, cb) {
              this.end();
              cb(err);
            };
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("timers").setImmediate);
      }, { "./_stream_duplex": 452, "./internal/streams/destroy": 458, "./internal/streams/stream": 459, "_process": 538, "core-util-is": 382, "inherits": 407, "process-nextick-args": 441, "safe-buffer": 461, "timers": 484, "util-deprecate": 486 }], 457: [function(require2, module3, exports3) {
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var Buffer2 = require2("safe-buffer").Buffer;
        var util = require2("util");
        function copyBuffer(src, target, offset) {
          src.copy(target, offset);
        }
        module3.exports = function() {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          BufferList.prototype.push = function push(v) {
            var entry = { data: v, next: null };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          };
          BufferList.prototype.unshift = function unshift(v) {
            var entry = { data: v, next: this.head };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          };
          BufferList.prototype.shift = function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          };
          BufferList.prototype.clear = function clear2() {
            this.head = this.tail = null;
            this.length = 0;
          };
          BufferList.prototype.join = function join(s2) {
            if (this.length === 0)
              return "";
            var p2 = this.head;
            var ret = "" + p2.data;
            while (p2 = p2.next) {
              ret += s2 + p2.data;
            }
            return ret;
          };
          BufferList.prototype.concat = function concat(n2) {
            if (this.length === 0)
              return Buffer2.alloc(0);
            var ret = Buffer2.allocUnsafe(n2 >>> 0);
            var p2 = this.head;
            var i = 0;
            while (p2) {
              copyBuffer(p2.data, ret, i);
              i += p2.data.length;
              p2 = p2.next;
            }
            return ret;
          };
          return BufferList;
        }();
        if (util && util.inspect && util.inspect.custom) {
          module3.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({ length: this.length });
            return this.constructor.name + " " + obj;
          };
        }
      }, { "safe-buffer": 461, "util": 102 }], 458: [function(require2, module3, exports3) {
        var pna = require2("process-nextick-args");
        function destroy(err, cb) {
          var _this = this;
          var readableDestroyed = this._readableState && this._readableState.destroyed;
          var writableDestroyed = this._writableState && this._writableState.destroyed;
          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err);
            } else if (err) {
              if (!this._writableState) {
                pna.nextTick(emitErrorNT, this, err);
              } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, this, err);
              }
            }
            return this;
          }
          if (this._readableState) {
            this._readableState.destroyed = true;
          }
          if (this._writableState) {
            this._writableState.destroyed = true;
          }
          this._destroy(err || null, function(err2) {
            if (!cb && err2) {
              if (!_this._writableState) {
                pna.nextTick(emitErrorNT, _this, err2);
              } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, _this, err2);
              }
            } else if (cb) {
              cb(err2);
            }
          });
          return this;
        }
        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
          }
          if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finalCalled = false;
            this._writableState.prefinished = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
          }
        }
        function emitErrorNT(self2, err) {
          self2.emit("error", err);
        }
        module3.exports = {
          destroy,
          undestroy
        };
      }, { "process-nextick-args": 441 }], 459: [function(require2, module3, exports3) {
        module3.exports = require2("events").EventEmitter;
      }, { "events": 386 }], 460: [function(require2, module3, exports3) {
        var toString2 = {}.toString;
        module3.exports = Array.isArray || function(arr) {
          return toString2.call(arr) == "[object Array]";
        };
      }, {}], 461: [function(require2, module3, exports3) {
        var buffer2 = require2("buffer");
        var Buffer2 = buffer2.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
          module3.exports = buffer2;
        } else {
          copyProps(buffer2, exports3);
          exports3.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer2(arg, encodingOrOffset, length);
        }
        copyProps(Buffer2, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer2(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size2, fill, encoding) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer2(size2);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size2) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer2(size2);
        };
        SafeBuffer.allocUnsafeSlow = function(size2) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer2.SlowBuffer(size2);
        };
      }, { "buffer": 103 }], 462: [function(require2, module3, exports3) {
        var Buffer2 = require2("safe-buffer").Buffer;
        var isEncoding = Buffer2.isEncoding || function(encoding) {
          encoding = "" + encoding;
          switch (encoding && encoding.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function _normalizeEncoding(enc) {
          if (!enc)
            return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried)
                  return;
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }
        exports3.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer2.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0)
            return "";
          var r;
          var i;
          if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === void 0)
              return "";
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i);
          return r || "";
        };
        StringDecoder.prototype.end = utf8End;
        StringDecoder.prototype.text = utf8Text;
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };
        function utf8CheckByte(byte2) {
          if (byte2 <= 127)
            return 0;
          else if (byte2 >> 5 === 6)
            return 2;
          else if (byte2 >> 4 === 14)
            return 3;
          else if (byte2 >> 3 === 30)
            return 4;
          return byte2 >> 6 === 2 ? -1 : -2;
        }
        function utf8CheckIncomplete(self2, buf, i) {
          var j = buf.length - 1;
          if (j < i)
            return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2)
                nb = 0;
              else
                self2.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }
        function utf8CheckExtraBytes(self2, buf, p2) {
          if ((buf[0] & 192) !== 128) {
            self2.lastNeed = 0;
            return "";
          }
          if (self2.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
              self2.lastNeed = 1;
              return "";
            }
            if (self2.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 192) !== 128) {
                self2.lastNeed = 2;
                return "";
              }
            }
          }
        }
        function utf8FillLast(buf) {
          var p2 = this.lastTotal - this.lastNeed;
          var r = utf8CheckExtraBytes(this, buf);
          if (r !== void 0)
            return r;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p2, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p2, 0, buf.length);
          this.lastNeed -= buf.length;
        }
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed)
            return buf.toString("utf8", i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i, end);
        }
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + "";
          return r;
        }
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
              var c = r.charCodeAt(r.length - 1);
              if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
              }
            }
            return r;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i, buf.length - 1);
        }
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
          }
          return r;
        }
        function base64Text(buf, i) {
          var n2 = (buf.length - i) % 3;
          if (n2 === 0)
            return buf.toString("base64", i);
          this.lastNeed = 3 - n2;
          this.lastTotal = 3;
          if (n2 === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i, buf.length - n2);
        }
        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r;
        }
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      }, { "safe-buffer": 461 }], 463: [function(require2, module3, exports3) {
        exports3 = module3.exports = require2("./lib/_stream_readable.js");
        exports3.Stream = exports3;
        exports3.Readable = exports3;
        exports3.Writable = require2("./lib/_stream_writable.js");
        exports3.Duplex = require2("./lib/_stream_duplex.js");
        exports3.Transform = require2("./lib/_stream_transform.js");
        exports3.PassThrough = require2("./lib/_stream_passthrough.js");
      }, { "./lib/_stream_duplex.js": 452, "./lib/_stream_passthrough.js": 453, "./lib/_stream_readable.js": 454, "./lib/_stream_transform.js": 455, "./lib/_stream_writable.js": 456 }], 464: [function(require2, module3, exports3) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
        var buffer2 = require2("buffer");
        var Buffer2 = buffer2.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
          module3.exports = buffer2;
        } else {
          copyProps(buffer2, exports3);
          exports3.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer2(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer2.prototype);
        copyProps(Buffer2, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer2(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size2, fill, encoding) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer2(size2);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size2) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer2(size2);
        };
        SafeBuffer.allocUnsafeSlow = function(size2) {
          if (typeof size2 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer2.SlowBuffer(size2);
        };
      }, { "buffer": 103 }], 465: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            (function(sax) {
              sax.parser = function(strict, opt) {
                return new SAXParser(strict, opt);
              };
              sax.SAXParser = SAXParser;
              sax.SAXStream = SAXStream;
              sax.createStream = createStream;
              sax.MAX_BUFFER_LENGTH = 64 * 1024;
              var buffers = [
                "comment",
                "sgmlDecl",
                "textNode",
                "tagName",
                "doctype",
                "procInstName",
                "procInstBody",
                "entity",
                "attribName",
                "attribValue",
                "cdata",
                "script"
              ];
              sax.EVENTS = [
                "text",
                "processinginstruction",
                "sgmldeclaration",
                "doctype",
                "comment",
                "opentagstart",
                "attribute",
                "opentag",
                "closetag",
                "opencdata",
                "cdata",
                "closecdata",
                "error",
                "end",
                "ready",
                "script",
                "opennamespace",
                "closenamespace"
              ];
              function SAXParser(strict, opt) {
                if (!(this instanceof SAXParser)) {
                  return new SAXParser(strict, opt);
                }
                var parser = this;
                clearBuffers(parser);
                parser.q = parser.c = "";
                parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
                parser.opt = opt || {};
                parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
                parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
                parser.tags = [];
                parser.closed = parser.closedRoot = parser.sawRoot = false;
                parser.tag = parser.error = null;
                parser.strict = !!strict;
                parser.noscript = !!(strict || parser.opt.noscript);
                parser.state = S.BEGIN;
                parser.strictEntities = parser.opt.strictEntities;
                parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
                parser.attribList = [];
                if (parser.opt.xmlns) {
                  parser.ns = Object.create(rootNS);
                }
                parser.trackPosition = parser.opt.position !== false;
                if (parser.trackPosition) {
                  parser.position = parser.line = parser.column = 0;
                }
                emit2(parser, "onready");
              }
              if (!Object.create) {
                Object.create = function(o2) {
                  function F2() {
                  }
                  F2.prototype = o2;
                  var newf = new F2();
                  return newf;
                };
              }
              if (!Object.keys) {
                Object.keys = function(o2) {
                  var a2 = [];
                  for (var i in o2)
                    if (o2.hasOwnProperty(i))
                      a2.push(i);
                  return a2;
                };
              }
              function checkBufferLength(parser) {
                var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
                var maxActual = 0;
                for (var i = 0, l = buffers.length; i < l; i++) {
                  var len = parser[buffers[i]].length;
                  if (len > maxAllowed) {
                    switch (buffers[i]) {
                      case "textNode":
                        closeText(parser);
                        break;
                      case "cdata":
                        emitNode(parser, "oncdata", parser.cdata);
                        parser.cdata = "";
                        break;
                      case "script":
                        emitNode(parser, "onscript", parser.script);
                        parser.script = "";
                        break;
                      default:
                        error2(parser, "Max buffer length exceeded: " + buffers[i]);
                    }
                  }
                  maxActual = Math.max(maxActual, len);
                }
                var m = sax.MAX_BUFFER_LENGTH - maxActual;
                parser.bufferCheckPosition = m + parser.position;
              }
              function clearBuffers(parser) {
                for (var i = 0, l = buffers.length; i < l; i++) {
                  parser[buffers[i]] = "";
                }
              }
              function flushBuffers(parser) {
                closeText(parser);
                if (parser.cdata !== "") {
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                }
                if (parser.script !== "") {
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                }
              }
              SAXParser.prototype = {
                end: function() {
                  end(this);
                },
                write: write3,
                resume: function() {
                  this.error = null;
                  return this;
                },
                close: function() {
                  return this.write(null);
                },
                flush: function() {
                  flushBuffers(this);
                }
              };
              var Stream;
              try {
                Stream = require2("stream").Stream;
              } catch (ex) {
                Stream = function() {
                };
              }
              if (!Stream)
                Stream = function() {
                };
              var streamWraps = sax.EVENTS.filter(function(ev) {
                return ev !== "error" && ev !== "end";
              });
              function createStream(strict, opt) {
                return new SAXStream(strict, opt);
              }
              function SAXStream(strict, opt) {
                if (!(this instanceof SAXStream)) {
                  return new SAXStream(strict, opt);
                }
                Stream.apply(this);
                this._parser = new SAXParser(strict, opt);
                this.writable = true;
                this.readable = true;
                var me = this;
                this._parser.onend = function() {
                  me.emit("end");
                };
                this._parser.onerror = function(er) {
                  me.emit("error", er);
                  me._parser.error = null;
                };
                this._decoder = null;
                streamWraps.forEach(function(ev) {
                  Object.defineProperty(me, "on" + ev, {
                    get: function() {
                      return me._parser["on" + ev];
                    },
                    set: function(h) {
                      if (!h) {
                        me.removeAllListeners(ev);
                        me._parser["on" + ev] = h;
                        return h;
                      }
                      me.on(ev, h);
                    },
                    enumerable: true,
                    configurable: false
                  });
                });
              }
              SAXStream.prototype = Object.create(Stream.prototype, {
                constructor: {
                  value: SAXStream
                }
              });
              SAXStream.prototype.write = function(data) {
                if (typeof Buffer2 === "function" && typeof Buffer2.isBuffer === "function" && Buffer2.isBuffer(data)) {
                  if (!this._decoder) {
                    var SD = require2("string_decoder").StringDecoder;
                    this._decoder = new SD("utf8");
                  }
                  data = this._decoder.write(data);
                }
                this._parser.write(data.toString());
                this.emit("data", data);
                return true;
              };
              SAXStream.prototype.end = function(chunk) {
                if (chunk && chunk.length) {
                  this.write(chunk);
                }
                this._parser.end();
                return true;
              };
              SAXStream.prototype.on = function(ev, handler) {
                var me = this;
                if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
                  me._parser["on" + ev] = function() {
                    var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                    args.splice(0, 0, ev);
                    me.emit.apply(me, args);
                  };
                }
                return Stream.prototype.on.call(me, ev, handler);
              };
              var CDATA = "[CDATA[";
              var DOCTYPE = "DOCTYPE";
              var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
              var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
              var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
              var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
              var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
              var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
              var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
              function isWhitespace(c) {
                return c === " " || c === "\n" || c === "\r" || c === "	";
              }
              function isQuote(c) {
                return c === '"' || c === "'";
              }
              function isAttribEnd(c) {
                return c === ">" || isWhitespace(c);
              }
              function isMatch(regex2, c) {
                return regex2.test(c);
              }
              function notMatch(regex2, c) {
                return !isMatch(regex2, c);
              }
              var S = 0;
              sax.STATE = {
                BEGIN: S++,
                // leading byte order mark or whitespace
                BEGIN_WHITESPACE: S++,
                // leading whitespace
                TEXT: S++,
                // general stuff
                TEXT_ENTITY: S++,
                // &amp and such.
                OPEN_WAKA: S++,
                // <
                SGML_DECL: S++,
                // <!BLARG
                SGML_DECL_QUOTED: S++,
                // <!BLARG foo "bar
                DOCTYPE: S++,
                // <!DOCTYPE
                DOCTYPE_QUOTED: S++,
                // <!DOCTYPE "//blah
                DOCTYPE_DTD: S++,
                // <!DOCTYPE "//blah" [ ...
                DOCTYPE_DTD_QUOTED: S++,
                // <!DOCTYPE "//blah" [ "foo
                COMMENT_STARTING: S++,
                // <!-
                COMMENT: S++,
                // <!--
                COMMENT_ENDING: S++,
                // <!-- blah -
                COMMENT_ENDED: S++,
                // <!-- blah --
                CDATA: S++,
                // <![CDATA[ something
                CDATA_ENDING: S++,
                // ]
                CDATA_ENDING_2: S++,
                // ]]
                PROC_INST: S++,
                // <?hi
                PROC_INST_BODY: S++,
                // <?hi there
                PROC_INST_ENDING: S++,
                // <?hi "there" ?
                OPEN_TAG: S++,
                // <strong
                OPEN_TAG_SLASH: S++,
                // <strong /
                ATTRIB: S++,
                // <a
                ATTRIB_NAME: S++,
                // <a foo
                ATTRIB_NAME_SAW_WHITE: S++,
                // <a foo _
                ATTRIB_VALUE: S++,
                // <a foo=
                ATTRIB_VALUE_QUOTED: S++,
                // <a foo="bar
                ATTRIB_VALUE_CLOSED: S++,
                // <a foo="bar"
                ATTRIB_VALUE_UNQUOTED: S++,
                // <a foo=bar
                ATTRIB_VALUE_ENTITY_Q: S++,
                // <foo bar="&quot;"
                ATTRIB_VALUE_ENTITY_U: S++,
                // <foo bar=&quot
                CLOSE_TAG: S++,
                // </a
                CLOSE_TAG_SAW_WHITE: S++,
                // </a   >
                SCRIPT: S++,
                // <script> ...
                SCRIPT_ENDING: S++
                // <script> ... <
              };
              sax.XML_ENTITIES = {
                "amp": "&",
                "gt": ">",
                "lt": "<",
                "quot": '"',
                "apos": "'"
              };
              sax.ENTITIES = {
                "amp": "&",
                "gt": ">",
                "lt": "<",
                "quot": '"',
                "apos": "'",
                "AElig": 198,
                "Aacute": 193,
                "Acirc": 194,
                "Agrave": 192,
                "Aring": 197,
                "Atilde": 195,
                "Auml": 196,
                "Ccedil": 199,
                "ETH": 208,
                "Eacute": 201,
                "Ecirc": 202,
                "Egrave": 200,
                "Euml": 203,
                "Iacute": 205,
                "Icirc": 206,
                "Igrave": 204,
                "Iuml": 207,
                "Ntilde": 209,
                "Oacute": 211,
                "Ocirc": 212,
                "Ograve": 210,
                "Oslash": 216,
                "Otilde": 213,
                "Ouml": 214,
                "THORN": 222,
                "Uacute": 218,
                "Ucirc": 219,
                "Ugrave": 217,
                "Uuml": 220,
                "Yacute": 221,
                "aacute": 225,
                "acirc": 226,
                "aelig": 230,
                "agrave": 224,
                "aring": 229,
                "atilde": 227,
                "auml": 228,
                "ccedil": 231,
                "eacute": 233,
                "ecirc": 234,
                "egrave": 232,
                "eth": 240,
                "euml": 235,
                "iacute": 237,
                "icirc": 238,
                "igrave": 236,
                "iuml": 239,
                "ntilde": 241,
                "oacute": 243,
                "ocirc": 244,
                "ograve": 242,
                "oslash": 248,
                "otilde": 245,
                "ouml": 246,
                "szlig": 223,
                "thorn": 254,
                "uacute": 250,
                "ucirc": 251,
                "ugrave": 249,
                "uuml": 252,
                "yacute": 253,
                "yuml": 255,
                "copy": 169,
                "reg": 174,
                "nbsp": 160,
                "iexcl": 161,
                "cent": 162,
                "pound": 163,
                "curren": 164,
                "yen": 165,
                "brvbar": 166,
                "sect": 167,
                "uml": 168,
                "ordf": 170,
                "laquo": 171,
                "not": 172,
                "shy": 173,
                "macr": 175,
                "deg": 176,
                "plusmn": 177,
                "sup1": 185,
                "sup2": 178,
                "sup3": 179,
                "acute": 180,
                "micro": 181,
                "para": 182,
                "middot": 183,
                "cedil": 184,
                "ordm": 186,
                "raquo": 187,
                "frac14": 188,
                "frac12": 189,
                "frac34": 190,
                "iquest": 191,
                "times": 215,
                "divide": 247,
                "OElig": 338,
                "oelig": 339,
                "Scaron": 352,
                "scaron": 353,
                "Yuml": 376,
                "fnof": 402,
                "circ": 710,
                "tilde": 732,
                "Alpha": 913,
                "Beta": 914,
                "Gamma": 915,
                "Delta": 916,
                "Epsilon": 917,
                "Zeta": 918,
                "Eta": 919,
                "Theta": 920,
                "Iota": 921,
                "Kappa": 922,
                "Lambda": 923,
                "Mu": 924,
                "Nu": 925,
                "Xi": 926,
                "Omicron": 927,
                "Pi": 928,
                "Rho": 929,
                "Sigma": 931,
                "Tau": 932,
                "Upsilon": 933,
                "Phi": 934,
                "Chi": 935,
                "Psi": 936,
                "Omega": 937,
                "alpha": 945,
                "beta": 946,
                "gamma": 947,
                "delta": 948,
                "epsilon": 949,
                "zeta": 950,
                "eta": 951,
                "theta": 952,
                "iota": 953,
                "kappa": 954,
                "lambda": 955,
                "mu": 956,
                "nu": 957,
                "xi": 958,
                "omicron": 959,
                "pi": 960,
                "rho": 961,
                "sigmaf": 962,
                "sigma": 963,
                "tau": 964,
                "upsilon": 965,
                "phi": 966,
                "chi": 967,
                "psi": 968,
                "omega": 969,
                "thetasym": 977,
                "upsih": 978,
                "piv": 982,
                "ensp": 8194,
                "emsp": 8195,
                "thinsp": 8201,
                "zwnj": 8204,
                "zwj": 8205,
                "lrm": 8206,
                "rlm": 8207,
                "ndash": 8211,
                "mdash": 8212,
                "lsquo": 8216,
                "rsquo": 8217,
                "sbquo": 8218,
                "ldquo": 8220,
                "rdquo": 8221,
                "bdquo": 8222,
                "dagger": 8224,
                "Dagger": 8225,
                "bull": 8226,
                "hellip": 8230,
                "permil": 8240,
                "prime": 8242,
                "Prime": 8243,
                "lsaquo": 8249,
                "rsaquo": 8250,
                "oline": 8254,
                "frasl": 8260,
                "euro": 8364,
                "image": 8465,
                "weierp": 8472,
                "real": 8476,
                "trade": 8482,
                "alefsym": 8501,
                "larr": 8592,
                "uarr": 8593,
                "rarr": 8594,
                "darr": 8595,
                "harr": 8596,
                "crarr": 8629,
                "lArr": 8656,
                "uArr": 8657,
                "rArr": 8658,
                "dArr": 8659,
                "hArr": 8660,
                "forall": 8704,
                "part": 8706,
                "exist": 8707,
                "empty": 8709,
                "nabla": 8711,
                "isin": 8712,
                "notin": 8713,
                "ni": 8715,
                "prod": 8719,
                "sum": 8721,
                "minus": 8722,
                "lowast": 8727,
                "radic": 8730,
                "prop": 8733,
                "infin": 8734,
                "ang": 8736,
                "and": 8743,
                "or": 8744,
                "cap": 8745,
                "cup": 8746,
                "int": 8747,
                "there4": 8756,
                "sim": 8764,
                "cong": 8773,
                "asymp": 8776,
                "ne": 8800,
                "equiv": 8801,
                "le": 8804,
                "ge": 8805,
                "sub": 8834,
                "sup": 8835,
                "nsub": 8836,
                "sube": 8838,
                "supe": 8839,
                "oplus": 8853,
                "otimes": 8855,
                "perp": 8869,
                "sdot": 8901,
                "lceil": 8968,
                "rceil": 8969,
                "lfloor": 8970,
                "rfloor": 8971,
                "lang": 9001,
                "rang": 9002,
                "loz": 9674,
                "spades": 9824,
                "clubs": 9827,
                "hearts": 9829,
                "diams": 9830
              };
              Object.keys(sax.ENTITIES).forEach(function(key) {
                var e2 = sax.ENTITIES[key];
                var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
                sax.ENTITIES[key] = s3;
              });
              for (var s2 in sax.STATE) {
                sax.STATE[sax.STATE[s2]] = s2;
              }
              S = sax.STATE;
              function emit2(parser, event, data) {
                parser[event] && parser[event](data);
              }
              function emitNode(parser, nodeType, data) {
                if (parser.textNode)
                  closeText(parser);
                emit2(parser, nodeType, data);
              }
              function closeText(parser) {
                parser.textNode = textopts(parser.opt, parser.textNode);
                if (parser.textNode)
                  emit2(parser, "ontext", parser.textNode);
                parser.textNode = "";
              }
              function textopts(opt, text2) {
                if (opt.trim)
                  text2 = text2.trim();
                if (opt.normalize)
                  text2 = text2.replace(/\s+/g, " ");
                return text2;
              }
              function error2(parser, er) {
                closeText(parser);
                if (parser.trackPosition) {
                  er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
                }
                er = new Error(er);
                parser.error = er;
                emit2(parser, "onerror", er);
                return parser;
              }
              function end(parser) {
                if (parser.sawRoot && !parser.closedRoot)
                  strictFail(parser, "Unclosed root tag");
                if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
                  error2(parser, "Unexpected end");
                }
                closeText(parser);
                parser.c = "";
                parser.closed = true;
                emit2(parser, "onend");
                SAXParser.call(parser, parser.strict, parser.opt);
                return parser;
              }
              function strictFail(parser, message) {
                if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
                  throw new Error("bad call to strictFail");
                }
                if (parser.strict) {
                  error2(parser, message);
                }
              }
              function newTag(parser) {
                if (!parser.strict)
                  parser.tagName = parser.tagName[parser.looseCase]();
                var parent = parser.tags[parser.tags.length - 1] || parser;
                var tag2 = parser.tag = { name: parser.tagName, attributes: {} };
                if (parser.opt.xmlns) {
                  tag2.ns = parent.ns;
                }
                parser.attribList.length = 0;
                emitNode(parser, "onopentagstart", tag2);
              }
              function qname(name, attribute) {
                var i = name.indexOf(":");
                var qualName = i < 0 ? ["", name] : name.split(":");
                var prefix = qualName[0];
                var local = qualName[1];
                if (attribute && name === "xmlns") {
                  prefix = "xmlns";
                  local = "";
                }
                return { prefix, local };
              }
              function attrib(parser) {
                if (!parser.strict) {
                  parser.attribName = parser.attribName[parser.looseCase]();
                }
                if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                  parser.attribName = parser.attribValue = "";
                  return;
                }
                if (parser.opt.xmlns) {
                  var qn = qname(parser.attribName, true);
                  var prefix = qn.prefix;
                  var local = qn.local;
                  if (prefix === "xmlns") {
                    if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                      strictFail(
                        parser,
                        "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
                      );
                    } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                      strictFail(
                        parser,
                        "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
                      );
                    } else {
                      var tag2 = parser.tag;
                      var parent = parser.tags[parser.tags.length - 1] || parser;
                      if (tag2.ns === parent.ns) {
                        tag2.ns = Object.create(parent.ns);
                      }
                      tag2.ns[local] = parser.attribValue;
                    }
                  }
                  parser.attribList.push([parser.attribName, parser.attribValue]);
                } else {
                  parser.tag.attributes[parser.attribName] = parser.attribValue;
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: parser.attribValue
                  });
                }
                parser.attribName = parser.attribValue = "";
              }
              function openTag(parser, selfClosing) {
                if (parser.opt.xmlns) {
                  var tag2 = parser.tag;
                  var qn = qname(parser.tagName);
                  tag2.prefix = qn.prefix;
                  tag2.local = qn.local;
                  tag2.uri = tag2.ns[qn.prefix] || "";
                  if (tag2.prefix && !tag2.uri) {
                    strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
                    tag2.uri = qn.prefix;
                  }
                  var parent = parser.tags[parser.tags.length - 1] || parser;
                  if (tag2.ns && parent.ns !== tag2.ns) {
                    Object.keys(tag2.ns).forEach(function(p2) {
                      emitNode(parser, "onopennamespace", {
                        prefix: p2,
                        uri: tag2.ns[p2]
                      });
                    });
                  }
                  for (var i = 0, l = parser.attribList.length; i < l; i++) {
                    var nv = parser.attribList[i];
                    var name = nv[0];
                    var value = nv[1];
                    var qualName = qname(name, true);
                    var prefix = qualName.prefix;
                    var local = qualName.local;
                    var uri = prefix === "" ? "" : tag2.ns[prefix] || "";
                    var a2 = {
                      name,
                      value,
                      prefix,
                      local,
                      uri
                    };
                    if (prefix && prefix !== "xmlns" && !uri) {
                      strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                      a2.uri = prefix;
                    }
                    parser.tag.attributes[name] = a2;
                    emitNode(parser, "onattribute", a2);
                  }
                  parser.attribList.length = 0;
                }
                parser.tag.isSelfClosing = !!selfClosing;
                parser.sawRoot = true;
                parser.tags.push(parser.tag);
                emitNode(parser, "onopentag", parser.tag);
                if (!selfClosing) {
                  if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
                    parser.state = S.SCRIPT;
                  } else {
                    parser.state = S.TEXT;
                  }
                  parser.tag = null;
                  parser.tagName = "";
                }
                parser.attribName = parser.attribValue = "";
                parser.attribList.length = 0;
              }
              function closeTag(parser) {
                if (!parser.tagName) {
                  strictFail(parser, "Weird empty close tag.");
                  parser.textNode += "</>";
                  parser.state = S.TEXT;
                  return;
                }
                if (parser.script) {
                  if (parser.tagName !== "script") {
                    parser.script += "</" + parser.tagName + ">";
                    parser.tagName = "";
                    parser.state = S.SCRIPT;
                    return;
                  }
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                }
                var t2 = parser.tags.length;
                var tagName = parser.tagName;
                if (!parser.strict) {
                  tagName = tagName[parser.looseCase]();
                }
                var closeTo = tagName;
                while (t2--) {
                  var close = parser.tags[t2];
                  if (close.name !== closeTo) {
                    strictFail(parser, "Unexpected close tag");
                  } else {
                    break;
                  }
                }
                if (t2 < 0) {
                  strictFail(parser, "Unmatched closing tag: " + parser.tagName);
                  parser.textNode += "</" + parser.tagName + ">";
                  parser.state = S.TEXT;
                  return;
                }
                parser.tagName = tagName;
                var s3 = parser.tags.length;
                while (s3-- > t2) {
                  var tag2 = parser.tag = parser.tags.pop();
                  parser.tagName = parser.tag.name;
                  emitNode(parser, "onclosetag", parser.tagName);
                  var x = {};
                  for (var i in tag2.ns) {
                    x[i] = tag2.ns[i];
                  }
                  var parent = parser.tags[parser.tags.length - 1] || parser;
                  if (parser.opt.xmlns && tag2.ns !== parent.ns) {
                    Object.keys(tag2.ns).forEach(function(p2) {
                      var n2 = tag2.ns[p2];
                      emitNode(parser, "onclosenamespace", { prefix: p2, uri: n2 });
                    });
                  }
                }
                if (t2 === 0)
                  parser.closedRoot = true;
                parser.tagName = parser.attribValue = parser.attribName = "";
                parser.attribList.length = 0;
                parser.state = S.TEXT;
              }
              function parseEntity(parser) {
                var entity = parser.entity;
                var entityLC = entity.toLowerCase();
                var num;
                var numStr = "";
                if (parser.ENTITIES[entity]) {
                  return parser.ENTITIES[entity];
                }
                if (parser.ENTITIES[entityLC]) {
                  return parser.ENTITIES[entityLC];
                }
                entity = entityLC;
                if (entity.charAt(0) === "#") {
                  if (entity.charAt(1) === "x") {
                    entity = entity.slice(2);
                    num = parseInt(entity, 16);
                    numStr = num.toString(16);
                  } else {
                    entity = entity.slice(1);
                    num = parseInt(entity, 10);
                    numStr = num.toString(10);
                  }
                }
                entity = entity.replace(/^0+/, "");
                if (isNaN(num) || numStr.toLowerCase() !== entity) {
                  strictFail(parser, "Invalid character entity");
                  return "&" + parser.entity + ";";
                }
                return String.fromCodePoint(num);
              }
              function beginWhiteSpace(parser, c) {
                if (c === "<") {
                  parser.state = S.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else if (!isWhitespace(c)) {
                  strictFail(parser, "Non-whitespace before first tag.");
                  parser.textNode = c;
                  parser.state = S.TEXT;
                }
              }
              function charAt(chunk, i) {
                var result = "";
                if (i < chunk.length) {
                  result = chunk.charAt(i);
                }
                return result;
              }
              function write3(chunk) {
                var parser = this;
                if (this.error) {
                  throw this.error;
                }
                if (parser.closed) {
                  return error2(
                    parser,
                    "Cannot write after close. Assign an onready handler."
                  );
                }
                if (chunk === null) {
                  return end(parser);
                }
                if (typeof chunk === "object") {
                  chunk = chunk.toString();
                }
                var i = 0;
                var c = "";
                while (true) {
                  c = charAt(chunk, i++);
                  parser.c = c;
                  if (!c) {
                    break;
                  }
                  if (parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                  switch (parser.state) {
                    case S.BEGIN:
                      parser.state = S.BEGIN_WHITESPACE;
                      if (c === "\uFEFF") {
                        continue;
                      }
                      beginWhiteSpace(parser, c);
                      continue;
                    case S.BEGIN_WHITESPACE:
                      beginWhiteSpace(parser, c);
                      continue;
                    case S.TEXT:
                      if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i - 1;
                        while (c && c !== "<" && c !== "&") {
                          c = charAt(chunk, i++);
                          if (c && parser.trackPosition) {
                            parser.position++;
                            if (c === "\n") {
                              parser.line++;
                              parser.column = 0;
                            } else {
                              parser.column++;
                            }
                          }
                        }
                        parser.textNode += chunk.substring(starti, i - 1);
                      }
                      if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                      } else {
                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                          strictFail(parser, "Text data outside of root node.");
                        }
                        if (c === "&") {
                          parser.state = S.TEXT_ENTITY;
                        } else {
                          parser.textNode += c;
                        }
                      }
                      continue;
                    case S.SCRIPT:
                      if (c === "<") {
                        parser.state = S.SCRIPT_ENDING;
                      } else {
                        parser.script += c;
                      }
                      continue;
                    case S.SCRIPT_ENDING:
                      if (c === "/") {
                        parser.state = S.CLOSE_TAG;
                      } else {
                        parser.script += "<" + c;
                        parser.state = S.SCRIPT;
                      }
                      continue;
                    case S.OPEN_WAKA:
                      if (c === "!") {
                        parser.state = S.SGML_DECL;
                        parser.sgmlDecl = "";
                      } else if (isWhitespace(c))
                        ;
                      else if (isMatch(nameStart, c)) {
                        parser.state = S.OPEN_TAG;
                        parser.tagName = c;
                      } else if (c === "/") {
                        parser.state = S.CLOSE_TAG;
                        parser.tagName = "";
                      } else if (c === "?") {
                        parser.state = S.PROC_INST;
                        parser.procInstName = parser.procInstBody = "";
                      } else {
                        strictFail(parser, "Unencoded <");
                        if (parser.startTagPosition + 1 < parser.position) {
                          var pad2 = parser.position - parser.startTagPosition;
                          c = new Array(pad2).join(" ") + c;
                        }
                        parser.textNode += "<" + c;
                        parser.state = S.TEXT;
                      }
                      continue;
                    case S.SGML_DECL:
                      if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                        emitNode(parser, "onopencdata");
                        parser.state = S.CDATA;
                        parser.sgmlDecl = "";
                        parser.cdata = "";
                      } else if (parser.sgmlDecl + c === "--") {
                        parser.state = S.COMMENT;
                        parser.comment = "";
                        parser.sgmlDecl = "";
                      } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) {
                          strictFail(
                            parser,
                            "Inappropriately located doctype declaration"
                          );
                        }
                        parser.doctype = "";
                        parser.sgmlDecl = "";
                      } else if (c === ">") {
                        emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                        parser.sgmlDecl = "";
                        parser.state = S.TEXT;
                      } else if (isQuote(c)) {
                        parser.state = S.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c;
                      } else {
                        parser.sgmlDecl += c;
                      }
                      continue;
                    case S.SGML_DECL_QUOTED:
                      if (c === parser.q) {
                        parser.state = S.SGML_DECL;
                        parser.q = "";
                      }
                      parser.sgmlDecl += c;
                      continue;
                    case S.DOCTYPE:
                      if (c === ">") {
                        parser.state = S.TEXT;
                        emitNode(parser, "ondoctype", parser.doctype);
                        parser.doctype = true;
                      } else {
                        parser.doctype += c;
                        if (c === "[") {
                          parser.state = S.DOCTYPE_DTD;
                        } else if (isQuote(c)) {
                          parser.state = S.DOCTYPE_QUOTED;
                          parser.q = c;
                        }
                      }
                      continue;
                    case S.DOCTYPE_QUOTED:
                      parser.doctype += c;
                      if (c === parser.q) {
                        parser.q = "";
                        parser.state = S.DOCTYPE;
                      }
                      continue;
                    case S.DOCTYPE_DTD:
                      parser.doctype += c;
                      if (c === "]") {
                        parser.state = S.DOCTYPE;
                      } else if (isQuote(c)) {
                        parser.state = S.DOCTYPE_DTD_QUOTED;
                        parser.q = c;
                      }
                      continue;
                    case S.DOCTYPE_DTD_QUOTED:
                      parser.doctype += c;
                      if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.q = "";
                      }
                      continue;
                    case S.COMMENT:
                      if (c === "-") {
                        parser.state = S.COMMENT_ENDING;
                      } else {
                        parser.comment += c;
                      }
                      continue;
                    case S.COMMENT_ENDING:
                      if (c === "-") {
                        parser.state = S.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) {
                          emitNode(parser, "oncomment", parser.comment);
                        }
                        parser.comment = "";
                      } else {
                        parser.comment += "-" + c;
                        parser.state = S.COMMENT;
                      }
                      continue;
                    case S.COMMENT_ENDED:
                      if (c !== ">") {
                        strictFail(parser, "Malformed comment");
                        parser.comment += "--" + c;
                        parser.state = S.COMMENT;
                      } else {
                        parser.state = S.TEXT;
                      }
                      continue;
                    case S.CDATA:
                      if (c === "]") {
                        parser.state = S.CDATA_ENDING;
                      } else {
                        parser.cdata += c;
                      }
                      continue;
                    case S.CDATA_ENDING:
                      if (c === "]") {
                        parser.state = S.CDATA_ENDING_2;
                      } else {
                        parser.cdata += "]" + c;
                        parser.state = S.CDATA;
                      }
                      continue;
                    case S.CDATA_ENDING_2:
                      if (c === ">") {
                        if (parser.cdata) {
                          emitNode(parser, "oncdata", parser.cdata);
                        }
                        emitNode(parser, "onclosecdata");
                        parser.cdata = "";
                        parser.state = S.TEXT;
                      } else if (c === "]") {
                        parser.cdata += "]";
                      } else {
                        parser.cdata += "]]" + c;
                        parser.state = S.CDATA;
                      }
                      continue;
                    case S.PROC_INST:
                      if (c === "?") {
                        parser.state = S.PROC_INST_ENDING;
                      } else if (isWhitespace(c)) {
                        parser.state = S.PROC_INST_BODY;
                      } else {
                        parser.procInstName += c;
                      }
                      continue;
                    case S.PROC_INST_BODY:
                      if (!parser.procInstBody && isWhitespace(c)) {
                        continue;
                      } else if (c === "?") {
                        parser.state = S.PROC_INST_ENDING;
                      } else {
                        parser.procInstBody += c;
                      }
                      continue;
                    case S.PROC_INST_ENDING:
                      if (c === ">") {
                        emitNode(parser, "onprocessinginstruction", {
                          name: parser.procInstName,
                          body: parser.procInstBody
                        });
                        parser.procInstName = parser.procInstBody = "";
                        parser.state = S.TEXT;
                      } else {
                        parser.procInstBody += "?" + c;
                        parser.state = S.PROC_INST_BODY;
                      }
                      continue;
                    case S.OPEN_TAG:
                      if (isMatch(nameBody, c)) {
                        parser.tagName += c;
                      } else {
                        newTag(parser);
                        if (c === ">") {
                          openTag(parser);
                        } else if (c === "/") {
                          parser.state = S.OPEN_TAG_SLASH;
                        } else {
                          if (!isWhitespace(c)) {
                            strictFail(parser, "Invalid character in tag name");
                          }
                          parser.state = S.ATTRIB;
                        }
                      }
                      continue;
                    case S.OPEN_TAG_SLASH:
                      if (c === ">") {
                        openTag(parser, true);
                        closeTag(parser);
                      } else {
                        strictFail(parser, "Forward-slash in opening tag not followed by >");
                        parser.state = S.ATTRIB;
                      }
                      continue;
                    case S.ATTRIB:
                      if (isWhitespace(c)) {
                        continue;
                      } else if (c === ">") {
                        openTag(parser);
                      } else if (c === "/") {
                        parser.state = S.OPEN_TAG_SLASH;
                      } else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.attribValue = "";
                        parser.state = S.ATTRIB_NAME;
                      } else {
                        strictFail(parser, "Invalid attribute name");
                      }
                      continue;
                    case S.ATTRIB_NAME:
                      if (c === "=") {
                        parser.state = S.ATTRIB_VALUE;
                      } else if (c === ">") {
                        strictFail(parser, "Attribute without value");
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                      } else if (isWhitespace(c)) {
                        parser.state = S.ATTRIB_NAME_SAW_WHITE;
                      } else if (isMatch(nameBody, c)) {
                        parser.attribName += c;
                      } else {
                        strictFail(parser, "Invalid attribute name");
                      }
                      continue;
                    case S.ATTRIB_NAME_SAW_WHITE:
                      if (c === "=") {
                        parser.state = S.ATTRIB_VALUE;
                      } else if (isWhitespace(c)) {
                        continue;
                      } else {
                        strictFail(parser, "Attribute without value");
                        parser.tag.attributes[parser.attribName] = "";
                        parser.attribValue = "";
                        emitNode(parser, "onattribute", {
                          name: parser.attribName,
                          value: ""
                        });
                        parser.attribName = "";
                        if (c === ">") {
                          openTag(parser);
                        } else if (isMatch(nameStart, c)) {
                          parser.attribName = c;
                          parser.state = S.ATTRIB_NAME;
                        } else {
                          strictFail(parser, "Invalid attribute name");
                          parser.state = S.ATTRIB;
                        }
                      }
                      continue;
                    case S.ATTRIB_VALUE:
                      if (isWhitespace(c)) {
                        continue;
                      } else if (isQuote(c)) {
                        parser.q = c;
                        parser.state = S.ATTRIB_VALUE_QUOTED;
                      } else {
                        strictFail(parser, "Unquoted attribute value");
                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c;
                      }
                      continue;
                    case S.ATTRIB_VALUE_QUOTED:
                      if (c !== parser.q) {
                        if (c === "&") {
                          parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                        } else {
                          parser.attribValue += c;
                        }
                        continue;
                      }
                      attrib(parser);
                      parser.q = "";
                      parser.state = S.ATTRIB_VALUE_CLOSED;
                      continue;
                    case S.ATTRIB_VALUE_CLOSED:
                      if (isWhitespace(c)) {
                        parser.state = S.ATTRIB;
                      } else if (c === ">") {
                        openTag(parser);
                      } else if (c === "/") {
                        parser.state = S.OPEN_TAG_SLASH;
                      } else if (isMatch(nameStart, c)) {
                        strictFail(parser, "No whitespace between attributes");
                        parser.attribName = c;
                        parser.attribValue = "";
                        parser.state = S.ATTRIB_NAME;
                      } else {
                        strictFail(parser, "Invalid attribute name");
                      }
                      continue;
                    case S.ATTRIB_VALUE_UNQUOTED:
                      if (!isAttribEnd(c)) {
                        if (c === "&") {
                          parser.state = S.ATTRIB_VALUE_ENTITY_U;
                        } else {
                          parser.attribValue += c;
                        }
                        continue;
                      }
                      attrib(parser);
                      if (c === ">") {
                        openTag(parser);
                      } else {
                        parser.state = S.ATTRIB;
                      }
                      continue;
                    case S.CLOSE_TAG:
                      if (!parser.tagName) {
                        if (isWhitespace(c)) {
                          continue;
                        } else if (notMatch(nameStart, c)) {
                          if (parser.script) {
                            parser.script += "</" + c;
                            parser.state = S.SCRIPT;
                          } else {
                            strictFail(parser, "Invalid tagname in closing tag.");
                          }
                        } else {
                          parser.tagName = c;
                        }
                      } else if (c === ">") {
                        closeTag(parser);
                      } else if (isMatch(nameBody, c)) {
                        parser.tagName += c;
                      } else if (parser.script) {
                        parser.script += "</" + parser.tagName;
                        parser.tagName = "";
                        parser.state = S.SCRIPT;
                      } else {
                        if (!isWhitespace(c)) {
                          strictFail(parser, "Invalid tagname in closing tag");
                        }
                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                      }
                      continue;
                    case S.CLOSE_TAG_SAW_WHITE:
                      if (isWhitespace(c)) {
                        continue;
                      }
                      if (c === ">") {
                        closeTag(parser);
                      } else {
                        strictFail(parser, "Invalid characters in closing tag");
                      }
                      continue;
                    case S.TEXT_ENTITY:
                    case S.ATTRIB_VALUE_ENTITY_Q:
                    case S.ATTRIB_VALUE_ENTITY_U:
                      var returnState;
                      var buffer2;
                      switch (parser.state) {
                        case S.TEXT_ENTITY:
                          returnState = S.TEXT;
                          buffer2 = "textNode";
                          break;
                        case S.ATTRIB_VALUE_ENTITY_Q:
                          returnState = S.ATTRIB_VALUE_QUOTED;
                          buffer2 = "attribValue";
                          break;
                        case S.ATTRIB_VALUE_ENTITY_U:
                          returnState = S.ATTRIB_VALUE_UNQUOTED;
                          buffer2 = "attribValue";
                          break;
                      }
                      if (c === ";") {
                        if (parser.opt.unparsedEntities) {
                          var parsedEntity = parseEntity(parser);
                          parser.entity = "";
                          parser.state = returnState;
                          parser.write(parsedEntity);
                        } else {
                          parser[buffer2] += parseEntity(parser);
                          parser.entity = "";
                          parser.state = returnState;
                        }
                      } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                        parser.entity += c;
                      } else {
                        strictFail(parser, "Invalid character in entity name");
                        parser[buffer2] += "&" + parser.entity + c;
                        parser.entity = "";
                        parser.state = returnState;
                      }
                      continue;
                    default: {
                      throw new Error(parser, "Unknown state: " + parser.state);
                    }
                  }
                }
                if (parser.position >= parser.bufferCheckPosition) {
                  checkBufferLength(parser);
                }
                return parser;
              }
              /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
              if (!String.fromCodePoint) {
                (function() {
                  var stringFromCharCode = String.fromCharCode;
                  var floor = Math.floor;
                  var fromCodePoint2 = function() {
                    var MAX_SIZE = 16384;
                    var codeUnits = [];
                    var highSurrogate;
                    var lowSurrogate;
                    var index2 = -1;
                    var length = arguments.length;
                    if (!length) {
                      return "";
                    }
                    var result = "";
                    while (++index2 < length) {
                      var codePoint = Number(arguments[index2]);
                      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                      codePoint < 0 || // not a valid Unicode code point
                      codePoint > 1114111 || // not a valid Unicode code point
                      floor(codePoint) !== codePoint) {
                        throw RangeError("Invalid code point: " + codePoint);
                      }
                      if (codePoint <= 65535) {
                        codeUnits.push(codePoint);
                      } else {
                        codePoint -= 65536;
                        highSurrogate = (codePoint >> 10) + 55296;
                        lowSurrogate = codePoint % 1024 + 56320;
                        codeUnits.push(highSurrogate, lowSurrogate);
                      }
                      if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits);
                        codeUnits.length = 0;
                      }
                    }
                    return result;
                  };
                  if (Object.defineProperty) {
                    Object.defineProperty(String, "fromCodePoint", {
                      value: fromCodePoint2,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    String.fromCodePoint = fromCodePoint2;
                  }
                })();
              }
            })(typeof exports3 === "undefined" ? this.sax = {} : exports3);
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 103, "stream": 468, "string_decoder": 483 }], 466: [function(require2, module3, exports3) {
        var GetIntrinsic = require2("get-intrinsic");
        var define = require2("define-data-property");
        var hasDescriptors = require2("has-property-descriptors")();
        var gOPD = require2("gopd");
        var $TypeError = GetIntrinsic("%TypeError%");
        var $floor = GetIntrinsic("%Math.floor%");
        module3.exports = function setFunctionLength(fn, length) {
          if (typeof fn !== "function") {
            throw new $TypeError("`fn` is not a function");
          }
          if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
            throw new $TypeError("`length` must be a positive 32-bit integer");
          }
          var loose = arguments.length > 2 && !!arguments[2];
          var functionLengthIsConfigurable = true;
          var functionLengthIsWritable = true;
          if ("length" in fn && gOPD) {
            var desc = gOPD(fn, "length");
            if (desc && !desc.configurable) {
              functionLengthIsConfigurable = false;
            }
            if (desc && !desc.writable) {
              functionLengthIsWritable = false;
            }
          }
          if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
            if (hasDescriptors) {
              define(
                /** @type {Parameters<define>[0]} */
                fn,
                "length",
                length,
                true,
                true
              );
            } else {
              define(
                /** @type {Parameters<define>[0]} */
                fn,
                "length",
                length
              );
            }
          }
          return fn;
        };
      }, { "define-data-property": 384, "get-intrinsic": 390, "gopd": 391, "has-property-descriptors": 392 }], 467: [function(require2, module3, exports3) {
        var GetIntrinsic = require2("get-intrinsic");
        var callBound = require2("call-bind/callBound");
        var inspect = require2("object-inspect");
        var $TypeError = GetIntrinsic("%TypeError%");
        var $WeakMap = GetIntrinsic("%WeakMap%", true);
        var $Map = GetIntrinsic("%Map%", true);
        var $weakMapGet = callBound("WeakMap.prototype.get", true);
        var $weakMapSet = callBound("WeakMap.prototype.set", true);
        var $weakMapHas = callBound("WeakMap.prototype.has", true);
        var $mapGet = callBound("Map.prototype.get", true);
        var $mapSet = callBound("Map.prototype.set", true);
        var $mapHas = callBound("Map.prototype.has", true);
        var listGetNode = function(list2, key) {
          for (var prev = list2, curr; (curr = prev.next) !== null; prev = curr) {
            if (curr.key === key) {
              prev.next = curr.next;
              curr.next = list2.next;
              list2.next = curr;
              return curr;
            }
          }
        };
        var listGet = function(objects, key) {
          var node = listGetNode(objects, key);
          return node && node.value;
        };
        var listSet = function(objects, key, value) {
          var node = listGetNode(objects, key);
          if (node) {
            node.value = value;
          } else {
            objects.next = {
              // eslint-disable-line no-param-reassign
              key,
              next: objects.next,
              value
            };
          }
        };
        var listHas = function(objects, key) {
          return !!listGetNode(objects, key);
        };
        module3.exports = function getSideChannel() {
          var $wm;
          var $m;
          var $o;
          var channel = {
            assert: function(key) {
              if (!channel.has(key)) {
                throw new $TypeError("Side channel does not contain " + inspect(key));
              }
            },
            get: function(key) {
              if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                if ($wm) {
                  return $weakMapGet($wm, key);
                }
              } else if ($Map) {
                if ($m) {
                  return $mapGet($m, key);
                }
              } else {
                if ($o) {
                  return listGet($o, key);
                }
              }
            },
            has: function(key) {
              if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                if ($wm) {
                  return $weakMapHas($wm, key);
                }
              } else if ($Map) {
                if ($m) {
                  return $mapHas($m, key);
                }
              } else {
                if ($o) {
                  return listHas($o, key);
                }
              }
              return false;
            },
            set: function(key, value) {
              if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
                if (!$wm) {
                  $wm = new $WeakMap();
                }
                $weakMapSet($wm, key, value);
              } else if ($Map) {
                if (!$m) {
                  $m = new $Map();
                }
                $mapSet($m, key, value);
              } else {
                if (!$o) {
                  $o = { key: {}, next: null };
                }
                listSet($o, key, value);
              }
            }
          };
          return channel;
        };
      }, { "call-bind/callBound": 105, "get-intrinsic": 390, "object-inspect": 433 }], 468: [function(require2, module3, exports3) {
        module3.exports = Stream;
        var EE = require2("events").EventEmitter;
        var inherits = require2("inherits");
        inherits(Stream, EE);
        Stream.Readable = require2("readable-stream/lib/_stream_readable.js");
        Stream.Writable = require2("readable-stream/lib/_stream_writable.js");
        Stream.Duplex = require2("readable-stream/lib/_stream_duplex.js");
        Stream.Transform = require2("readable-stream/lib/_stream_transform.js");
        Stream.PassThrough = require2("readable-stream/lib/_stream_passthrough.js");
        Stream.finished = require2("readable-stream/lib/internal/streams/end-of-stream.js");
        Stream.pipeline = require2("readable-stream/lib/internal/streams/pipeline.js");
        Stream.Stream = Stream;
        function Stream() {
          EE.call(this);
        }
        Stream.prototype.pipe = function(dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on("data", ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on("drain", ondrain);
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on("end", onend);
            source.on("close", onclose);
          }
          var didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === "function")
              dest.destroy();
          }
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, "error") === 0) {
              throw er;
            }
          }
          source.on("error", onerror);
          dest.on("error", onerror);
          function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);
            source.removeListener("end", onend);
            source.removeListener("close", onclose);
            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);
            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);
            dest.removeListener("close", cleanup);
          }
          source.on("end", cleanup);
          source.on("close", cleanup);
          dest.on("close", cleanup);
          dest.emit("pipe", source);
          return dest;
        };
      }, { "events": 386, "inherits": 407, "readable-stream/lib/_stream_duplex.js": 470, "readable-stream/lib/_stream_passthrough.js": 471, "readable-stream/lib/_stream_readable.js": 472, "readable-stream/lib/_stream_transform.js": 473, "readable-stream/lib/_stream_writable.js": 474, "readable-stream/lib/internal/streams/end-of-stream.js": 478, "readable-stream/lib/internal/streams/pipeline.js": 480 }], 469: [function(require2, module3, exports3) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var codes = {};
        function createErrorType(code2, message, Base) {
          if (!Base) {
            Base = Error;
          }
          function getMessage(arg1, arg2, arg3) {
            if (typeof message === "string") {
              return message;
            } else {
              return message(arg1, arg2, arg3);
            }
          }
          var NodeError = /* @__PURE__ */ function(_Base) {
            _inheritsLoose(NodeError2, _Base);
            function NodeError2(arg1, arg2, arg3) {
              return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
            }
            return NodeError2;
          }(Base);
          NodeError.prototype.name = Base.name;
          NodeError.prototype.code = code2;
          codes[code2] = NodeError;
        }
        function oneOf(expected, thing) {
          if (Array.isArray(expected)) {
            var len = expected.length;
            expected = expected.map(function(i) {
              return String(i);
            });
            if (len > 2) {
              return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
            } else if (len === 2) {
              return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
            } else {
              return "of ".concat(thing, " ").concat(expected[0]);
            }
          } else {
            return "of ".concat(thing, " ").concat(String(expected));
          }
        }
        function startsWith2(str, search2, pos) {
          return str.substr(!pos || pos < 0 ? 0 : +pos, search2.length) === search2;
        }
        function endsWith(str, search2, this_len) {
          if (this_len === void 0 || this_len > str.length) {
            this_len = str.length;
          }
          return str.substring(this_len - search2.length, this_len) === search2;
        }
        function includes(str, search2, start) {
          if (typeof start !== "number") {
            start = 0;
          }
          if (start + search2.length > str.length) {
            return false;
          } else {
            return str.indexOf(search2, start) !== -1;
          }
        }
        createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
          return 'The value "' + value + '" is invalid for option "' + name + '"';
        }, TypeError);
        createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
          var determiner;
          if (typeof expected === "string" && startsWith2(expected, "not ")) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          var msg;
          if (endsWith(name, " argument")) {
            msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          } else {
            var type = includes(name, ".") ? "property" : "argument";
            msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          }
          msg += ". Received type ".concat(typeof actual);
          return msg;
        }, TypeError);
        createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
        createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
          return "The " + name + " method is not implemented";
        });
        createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
        createErrorType("ERR_STREAM_DESTROYED", function(name) {
          return "Cannot call " + name + " after a stream was destroyed";
        });
        createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
        createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
        createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
        createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
        createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
          return "Unknown encoding: " + arg;
        }, TypeError);
        createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
        module3.exports.codes = codes;
      }, {}], 470: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            var objectKeys2 = Object.keys || function(obj) {
              var keys2 = [];
              for (var key in obj)
                keys2.push(key);
              return keys2;
            };
            module3.exports = Duplex;
            var Readable = require2("./_stream_readable");
            var Writable = require2("./_stream_writable");
            require2("inherits")(Duplex, Readable);
            {
              var keys = objectKeys2(Writable.prototype);
              for (var v = 0; v < keys.length; v++) {
                var method = keys[v];
                if (!Duplex.prototype[method])
                  Duplex.prototype[method] = Writable.prototype[method];
              }
            }
            function Duplex(options) {
              if (!(this instanceof Duplex))
                return new Duplex(options);
              Readable.call(this, options);
              Writable.call(this, options);
              this.allowHalfOpen = true;
              if (options) {
                if (options.readable === false)
                  this.readable = false;
                if (options.writable === false)
                  this.writable = false;
                if (options.allowHalfOpen === false) {
                  this.allowHalfOpen = false;
                  this.once("end", onend);
                }
              }
            }
            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState.highWaterMark;
              }
            });
            Object.defineProperty(Duplex.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            Object.defineProperty(Duplex.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState.length;
              }
            });
            function onend() {
              if (this._writableState.ended)
                return;
              process.nextTick(onEndNT, this);
            }
            function onEndNT(self2) {
              self2.end();
            }
            Object.defineProperty(Duplex.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function set2(value) {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return;
                }
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
              }
            });
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./_stream_readable": 472, "./_stream_writable": 474, "_process": 538, "inherits": 407 }], 471: [function(require2, module3, exports3) {
        module3.exports = PassThrough;
        var Transform = require2("./_stream_transform");
        require2("inherits")(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, { "./_stream_transform": 473, "inherits": 407 }], 472: [function(require2, module3, exports3) {
        (function(process, global3) {
          (function() {
            module3.exports = Readable;
            var Duplex;
            Readable.ReadableState = ReadableState;
            require2("events").EventEmitter;
            var EElistenerCount = function EElistenerCount2(emitter, type) {
              return emitter.listeners(type).length;
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer2 = require2("buffer").Buffer;
            var OurUint8Array = (typeof global3 !== "undefined" ? global3 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var debugUtil = require2("util");
            var debug;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function debug2() {
              };
            }
            var BufferList = require2("./internal/streams/buffer_list");
            var destroyImpl = require2("./internal/streams/destroy");
            var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            var StringDecoder;
            var createReadableStreamAsyncIterator;
            var from;
            require2("inherits")(Readable, Stream);
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === "function")
                return emitter.prependListener(event, fn);
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (Array.isArray(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [fn, emitter._events[event]];
            }
            function ReadableState(options, stream, isDuplex) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.paused = true;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.destroyed = false;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = require2("string_decoder/").StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              if (!(this instanceof Readable))
                return new Readable(options);
              var isDuplex = this instanceof Duplex;
              this._readableState = new ReadableState(options, this, isDuplex);
              this.readable = true;
              if (options) {
                if (typeof options.read === "function")
                  this._read = options.read;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                if (this._readableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed;
              },
              set: function set2(value) {
                if (!this._readableState) {
                  return;
                }
                this._readableState.destroyed = value;
              }
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err, cb) {
              cb(err);
            };
            Readable.prototype.push = function(chunk, encoding) {
              var state = this._readableState;
              var skipChunkCheck;
              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding = encoding || state.defaultEncoding;
                  if (encoding !== state.encoding) {
                    chunk = Buffer2.from(chunk, encoding);
                    encoding = "";
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            };
            Readable.prototype.unshift = function(chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };
            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
              debug("readableAddChunk", chunk);
              var state = stream._readableState;
              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck)
                  er = chunkInvalid(state, chunk);
                if (er) {
                  errorOrDestroy(stream, er);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                  if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (addToFront) {
                    if (state.endEmitted)
                      errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                    else
                      addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                  } else if (state.destroyed) {
                    return false;
                  } else {
                    state.reading = false;
                    if (state.decoder && !encoding) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                      else
                        maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                  maybeReadMore(stream, state);
                }
              }
              return !state.ended && (state.length < state.highWaterMark || state.length === 0);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                state.awaitDrain = 0;
                stream.emit("data", chunk);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
              var er;
              if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
              }
              return er;
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              var decoder = new StringDecoder(enc);
              this._readableState.decoder = decoder;
              this._readableState.encoding = this._readableState.decoder.encoding;
              var p2 = this._readableState.buffer.head;
              var content2 = "";
              while (p2 !== null) {
                content2 += decoder.write(p2.data);
                p2 = p2.next;
              }
              this._readableState.buffer.clear();
              if (content2 !== "")
                this._readableState.buffer.push(content2);
              this._readableState.length = content2.length;
              return this;
            };
            var MAX_HWM = 1073741824;
            function computeNewHighWaterMark(n2) {
              if (n2 >= MAX_HWM) {
                n2 = MAX_HWM;
              } else {
                n2--;
                n2 |= n2 >>> 1;
                n2 |= n2 >>> 2;
                n2 |= n2 >>> 4;
                n2 |= n2 >>> 8;
                n2 |= n2 >>> 16;
                n2++;
              }
              return n2;
            }
            function howMuchToRead(n2, state) {
              if (n2 <= 0 || state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return 1;
              if (n2 !== n2) {
                if (state.flowing && state.length)
                  return state.buffer.head.data.length;
                else
                  return state.length;
              }
              if (n2 > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n2);
              if (n2 <= state.length)
                return n2;
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }
            Readable.prototype.read = function(n2) {
              debug("read", n2);
              n2 = parseInt(n2, 10);
              var state = this._readableState;
              var nOrig = n2;
              if (n2 !== 0)
                state.emittedReadable = false;
              if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n2 = howMuchToRead(n2, state);
              if (n2 === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug("need readable", doRead);
              if (state.length === 0 || state.length - n2 < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading)
                  n2 = howMuchToRead(nOrig, state);
              }
              var ret;
              if (n2 > 0)
                ret = fromList(n2, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = state.length <= state.highWaterMark;
                n2 = 0;
              } else {
                state.length -= n2;
                state.awaitDrain = 0;
              }
              if (state.length === 0) {
                if (!state.ended)
                  state.needReadable = true;
                if (nOrig !== n2 && state.ended)
                  endReadable(this);
              }
              if (ret !== null)
                this.emit("data", ret);
              return ret;
            };
            function onEofChunk(stream, state) {
              debug("onEofChunk");
              if (state.ended)
                return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              if (state.sync) {
                emitReadable(stream);
              } else {
                state.needReadable = false;
                if (!state.emittedReadable) {
                  state.emittedReadable = true;
                  emitReadable_(stream);
                }
              }
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              debug("emitReadable", state.needReadable, state.emittedReadable);
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                process.nextTick(emitReadable_, stream);
              }
            }
            function emitReadable_(stream) {
              var state = stream._readableState;
              debug("emitReadable_", state.destroyed, state.length, state.ended);
              if (!state.destroyed && (state.length || state.ended)) {
                stream.emit("readable");
                state.emittedReadable = false;
              }
              state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                process.nextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                var len = state.length;
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  break;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n2) {
              errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted)
                process.nextTick(endFn);
              else
                src.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on("drain", ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              src.on("data", ondata);
              function ondata(chunk) {
                debug("ondata");
                var ret = dest.write(chunk);
                debug("dest.write", ret);
                if (ret === false) {
                  if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                    debug("false write response, pause", state.awaitDrain);
                    state.awaitDrain++;
                  }
                  src.pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0)
                  errorOrDestroy(dest, er);
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
              }
              dest.emit("pipe", src);
              if (!state.flowing) {
                debug("pipe resume");
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function pipeOnDrainFunctionResult() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain)
                  state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              var unpipeInfo = {
                hasUnpiped: false
              };
              if (state.pipesCount === 0)
                return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes)
                  return this;
                if (!dest)
                  dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                  dest.emit("unpipe", this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++)
                  dests[i].emit("unpipe", this, {
                    hasUnpiped: false
                  });
                return this;
              }
              var index2 = indexOf(state.pipes, dest);
              if (index2 === -1)
                return this;
              state.pipes.splice(index2, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1)
                state.pipes = state.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              var state = this._readableState;
              if (ev === "data") {
                state.readableListening = this.listenerCount("readable") > 0;
                if (state.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.flowing = false;
                  state.emittedReadable = false;
                  debug("on readable", state.length, state.reading);
                  if (state.length) {
                    emitReadable(this);
                  } else if (!state.reading) {
                    process.nextTick(nReadingNextTick, this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.removeListener = function(ev, fn) {
              var res = Stream.prototype.removeListener.call(this, ev, fn);
              if (ev === "readable") {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            Readable.prototype.removeAllListeners = function(ev) {
              var res = Stream.prototype.removeAllListeners.apply(this, arguments);
              if (ev === "readable" || ev === void 0) {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            function updateReadableListening(self2) {
              var state = self2._readableState;
              state.readableListening = self2.listenerCount("readable") > 0;
              if (state.resumeScheduled && !state.paused) {
                state.flowing = true;
              } else if (self2.listenerCount("data") > 0) {
                self2.resume();
              }
            }
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug("resume");
                state.flowing = !state.readableListening;
                resume(this, state);
              }
              state.paused = false;
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                process.nextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              debug("resume", state.reading);
              if (!state.reading) {
                stream.read(0);
              }
              state.resumeScheduled = false;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (this._readableState.flowing !== false) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              this._readableState.paused = true;
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug("flow", state.flowing);
              while (state.flowing && stream.read() !== null)
                ;
            }
            Readable.prototype.wrap = function(stream) {
              var _this = this;
              var state = this._readableState;
              var paused = false;
              stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length)
                    _this.push(chunk);
                }
                _this.push(null);
              });
              stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder)
                  chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === void 0))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                  return;
                var ret = _this.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i in stream) {
                if (this[i] === void 0 && typeof stream[i] === "function") {
                  this[i] = /* @__PURE__ */ function methodWrap(method) {
                    return function methodWrapReturnFunction() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i);
                }
              }
              for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
                stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
              }
              this._read = function(n3) {
                debug("wrapped _read", n3);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return this;
            };
            if (typeof Symbol === "function") {
              Readable.prototype[Symbol.asyncIterator] = function() {
                if (createReadableStreamAsyncIterator === void 0) {
                  createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
                }
                return createReadableStreamAsyncIterator(this);
              };
            }
            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._readableState.highWaterMark;
              }
            });
            Object.defineProperty(Readable.prototype, "readableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._readableState && this._readableState.buffer;
              }
            });
            Object.defineProperty(Readable.prototype, "readableFlowing", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._readableState.flowing;
              },
              set: function set2(state) {
                if (this._readableState) {
                  this._readableState.flowing = state;
                }
              }
            });
            Readable._fromList = fromList;
            Object.defineProperty(Readable.prototype, "readableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._readableState.length;
              }
            });
            function fromList(n2, state) {
              if (state.length === 0)
                return null;
              var ret;
              if (state.objectMode)
                ret = state.buffer.shift();
              else if (!n2 || n2 >= state.length) {
                if (state.decoder)
                  ret = state.buffer.join("");
                else if (state.buffer.length === 1)
                  ret = state.buffer.first();
                else
                  ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = state.buffer.consume(n2, state.decoder);
              }
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              debug("endReadable", state.endEmitted);
              if (!state.endEmitted) {
                state.ended = true;
                process.nextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              debug("endReadableNT", state.endEmitted, state.length);
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
                if (state.autoDestroy) {
                  var wState = stream._writableState;
                  if (!wState || wState.autoDestroy && wState.finished) {
                    stream.destroy();
                  }
                }
              }
            }
            if (typeof Symbol === "function") {
              Readable.from = function(iterable, opts) {
                if (from === void 0) {
                  from = require2("./internal/streams/from");
                }
                return from(Readable, iterable, opts);
              };
            }
            function indexOf(xs, x) {
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x)
                  return i;
              }
              return -1;
            }
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 469, "./_stream_duplex": 470, "./internal/streams/async_iterator": 475, "./internal/streams/buffer_list": 476, "./internal/streams/destroy": 477, "./internal/streams/from": 479, "./internal/streams/state": 481, "./internal/streams/stream": 482, "_process": 538, "buffer": 103, "events": 386, "inherits": 407, "string_decoder/": 483, "util": 102 }], 473: [function(require2, module3, exports3) {
        module3.exports = Transform;
        var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
        var Duplex = require2("./_stream_duplex");
        require2("inherits")(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (cb === null) {
            return this.emit("error", new ERR_MULTIPLE_CALLBACK());
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function" && !this._readableState.destroyed) {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n2) {
          var ts = this._transformState;
          if (ts.writechunk !== null && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err, cb) {
          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new ERR_TRANSFORM_WITH_LENGTH_0();
          if (stream._transformState.transforming)
            throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
          return stream.push(null);
        }
      }, { "../errors": 469, "./_stream_duplex": 470, "inherits": 407 }], 474: [function(require2, module3, exports3) {
        (function(process, global3) {
          (function() {
            module3.exports = Writable;
            function CorkedRequest(state) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state);
              };
            }
            var Duplex;
            Writable.WritableState = WritableState;
            var internalUtil = {
              deprecate: require2("util-deprecate")
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer2 = require2("buffer").Buffer;
            var OurUint8Array = (typeof global3 !== "undefined" ? global3 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer2.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = require2("./internal/streams/destroy");
            var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            require2("inherits")(Writable, Stream);
            function nop() {
            }
            function WritableState(options, stream, isDuplex) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.writableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                  get: internalUtil.deprecate(function writableStateBufferGetter() {
                    return this.getBuffer();
                  }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
              } catch (_) {
              }
            })();
            var realHasInstance;
            if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function value(object2) {
                  if (realHasInstance.call(this, object2))
                    return true;
                  if (this !== Writable)
                    return false;
                  return object2 && object2._writableState instanceof WritableState;
                }
              });
            } else {
              realHasInstance = function realHasInstance2(object2) {
                return object2 instanceof this;
              };
            }
            function Writable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              var isDuplex = this instanceof Duplex;
              if (!isDuplex && !realHasInstance.call(Writable, this))
                return new Writable(options);
              this._writableState = new WritableState(options, this, isDuplex);
              this.writable = true;
              if (options) {
                if (typeof options.write === "function")
                  this._write = options.write;
                if (typeof options.writev === "function")
                  this._writev = options.writev;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.final === "function")
                  this._final = options.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
            };
            function writeAfterEnd(stream, cb) {
              var er = new ERR_STREAM_WRITE_AFTER_END();
              errorOrDestroy(stream, er);
              process.nextTick(cb, er);
            }
            function validChunk(stream, state, chunk, cb) {
              var er;
              if (chunk === null) {
                er = new ERR_STREAM_NULL_VALUES();
              } else if (typeof chunk !== "string" && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
              }
              if (er) {
                errorOrDestroy(stream, er);
                process.nextTick(cb, er);
                return false;
              }
              return true;
            }
            Writable.prototype.write = function(chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;
              var isBuf = !state.objectMode && _isUint8Array(chunk);
              if (isBuf && !Buffer2.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (isBuf)
                encoding = "buffer";
              else if (!encoding)
                encoding = state.defaultEncoding;
              if (typeof cb !== "function")
                cb = nop;
              if (state.ending)
                writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              this._writableState.corked++;
            };
            Writable.prototype.uncork = function() {
              var state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              if (typeof encoding === "string")
                encoding = encoding.toLowerCase();
              if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                throw new ERR_UNKNOWN_ENCODING(encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            function decodeChunk(state, chunk, encoding) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer2.from(chunk, encoding);
              }
              return chunk;
            }
            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState.highWaterMark;
              }
            });
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding = "buffer";
                  chunk = newChunk;
                }
              }
              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark;
              if (!ret)
                state.needDrain = true;
              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                  chunk,
                  encoding,
                  isBuf,
                  callback: cb,
                  next: null
                };
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }
              return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (state.destroyed)
                state.onwrite(new ERR_STREAM_DESTROYED("write"));
              else if (writev)
                stream._writev(chunk, state.onwrite);
              else
                stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) {
                process.nextTick(cb, er);
                process.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
                finishMaybe(stream, state);
              }
            }
            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }
            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              if (typeof cb !== "function")
                throw new ERR_MULTIPLE_CALLBACK();
              onwriteStateUpdate(state);
              if (er)
                onwriteError(stream, state, sync, er, cb);
              else {
                var finished = needFinish(state) || stream.destroyed;
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  process.nextTick(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }
            function afterWrite(stream, state, finished, cb) {
              if (!finished)
                onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
            }
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l = state.bufferedRequestCount;
                var buffer2 = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer2[count] = entry;
                  if (!entry.isBuf)
                    allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer2.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
                state.bufferedRequestCount = 0;
              } else {
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  state.bufferedRequestCount--;
                  if (state.writing) {
                    break;
                  }
                }
                if (entry === null)
                  state.lastBufferedRequest = null;
              }
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding, cb) {
              cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding, cb) {
              var state = this._writableState;
              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (chunk !== null && chunk !== void 0)
                this.write(chunk, encoding);
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (!state.ending)
                endWritable(this, state, cb);
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState.length;
              }
            });
            function needFinish(state) {
              return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }
            function callFinal(stream, state) {
              stream._final(function(err) {
                state.pendingcb--;
                if (err) {
                  errorOrDestroy(stream, err);
                }
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
              });
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function" && !state.destroyed) {
                  state.pendingcb++;
                  state.finalCalled = true;
                  process.nextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit("finish");
                  if (state.autoDestroy) {
                    var rState = stream._readableState;
                    if (!rState || rState.autoDestroy && rState.endEmitted) {
                      stream.destroy();
                    }
                  }
                }
              }
              return need;
            }
            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished)
                  process.nextTick(cb);
                else
                  stream.once("finish", cb);
              }
              state.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
              }
              state.corkedRequestsFree.next = corkReq;
            }
            Object.defineProperty(Writable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                if (this._writableState === void 0) {
                  return false;
                }
                return this._writableState.destroyed;
              },
              set: function set2(value) {
                if (!this._writableState) {
                  return;
                }
                this._writableState.destroyed = value;
              }
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err, cb) {
              cb(err);
            };
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 469, "./_stream_duplex": 470, "./internal/streams/destroy": 477, "./internal/streams/state": 481, "./internal/streams/stream": 482, "_process": 538, "buffer": 103, "inherits": 407, "util-deprecate": 486 }], 475: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            var _Object$setPrototypeO;
            function _defineProperty(obj, key, value) {
              key = _toPropertyKey(key);
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _toPropertyKey(arg) {
              var key = _toPrimitive(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _toPrimitive(input2, hint) {
              if (typeof input2 !== "object" || input2 === null)
                return input2;
              var prim = input2[Symbol.toPrimitive];
              if (prim !== void 0) {
                var res = prim.call(input2, hint || "default");
                if (typeof res !== "object")
                  return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (hint === "string" ? String : Number)(input2);
            }
            var finished = require2("./end-of-stream");
            var kLastResolve = Symbol("lastResolve");
            var kLastReject = Symbol("lastReject");
            var kError = Symbol("error");
            var kEnded = Symbol("ended");
            var kLastPromise = Symbol("lastPromise");
            var kHandlePromise = Symbol("handlePromise");
            var kStream = Symbol("stream");
            function createIterResult(value, done) {
              return {
                value,
                done
              };
            }
            function readAndResolve(iter) {
              var resolve2 = iter[kLastResolve];
              if (resolve2 !== null) {
                var data = iter[kStream].read();
                if (data !== null) {
                  iter[kLastPromise] = null;
                  iter[kLastResolve] = null;
                  iter[kLastReject] = null;
                  resolve2(createIterResult(data, false));
                }
              }
            }
            function onReadable(iter) {
              process.nextTick(readAndResolve, iter);
            }
            function wrapForNext(lastPromise, iter) {
              return function(resolve2, reject) {
                lastPromise.then(function() {
                  if (iter[kEnded]) {
                    resolve2(createIterResult(void 0, true));
                    return;
                  }
                  iter[kHandlePromise](resolve2, reject);
                }, reject);
              };
            }
            var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
            });
            var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
              get stream() {
                return this[kStream];
              },
              next: function next() {
                var _this = this;
                var error2 = this[kError];
                if (error2 !== null) {
                  return Promise.reject(error2);
                }
                if (this[kEnded]) {
                  return Promise.resolve(createIterResult(void 0, true));
                }
                if (this[kStream].destroyed) {
                  return new Promise(function(resolve2, reject) {
                    process.nextTick(function() {
                      if (_this[kError]) {
                        reject(_this[kError]);
                      } else {
                        resolve2(createIterResult(void 0, true));
                      }
                    });
                  });
                }
                var lastPromise = this[kLastPromise];
                var promise2;
                if (lastPromise) {
                  promise2 = new Promise(wrapForNext(lastPromise, this));
                } else {
                  var data = this[kStream].read();
                  if (data !== null) {
                    return Promise.resolve(createIterResult(data, false));
                  }
                  promise2 = new Promise(this[kHandlePromise]);
                }
                this[kLastPromise] = promise2;
                return promise2;
              }
            }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
              return this;
            }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
              var _this2 = this;
              return new Promise(function(resolve2, reject) {
                _this2[kStream].destroy(null, function(err) {
                  if (err) {
                    reject(err);
                    return;
                  }
                  resolve2(createIterResult(void 0, true));
                });
              });
            }), _Object$setPrototypeO), AsyncIteratorPrototype);
            var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
              var _Object$create;
              var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                value: stream,
                writable: true
              }), _defineProperty(_Object$create, kLastResolve, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kLastReject, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kError, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kEnded, {
                value: stream._readableState.endEmitted,
                writable: true
              }), _defineProperty(_Object$create, kHandlePromise, {
                value: function value(resolve2, reject) {
                  var data = iterator[kStream].read();
                  if (data) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    resolve2(createIterResult(data, false));
                  } else {
                    iterator[kLastResolve] = resolve2;
                    iterator[kLastReject] = reject;
                  }
                },
                writable: true
              }), _Object$create));
              iterator[kLastPromise] = null;
              finished(stream, function(err) {
                if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                  var reject = iterator[kLastReject];
                  if (reject !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    reject(err);
                  }
                  iterator[kError] = err;
                  return;
                }
                var resolve2 = iterator[kLastResolve];
                if (resolve2 !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve2(createIterResult(void 0, true));
                }
                iterator[kEnded] = true;
              });
              stream.on("readable", onReadable.bind(null, iterator));
              return iterator;
            };
            module3.exports = createReadableStreamAsyncIterator;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./end-of-stream": 478, "_process": 538 }], 476: [function(require2, module3, exports3) {
        function ownKeys(object2, enumerableOnly) {
          var keys = Object.keys(object2);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object2);
            enumerableOnly && (symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props2) {
          for (var i = 0; i < props2.length; i++) {
            var descriptor = props2[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", { writable: false });
          return Constructor;
        }
        function _toPropertyKey(arg) {
          var key = _toPrimitive(arg, "string");
          return typeof key === "symbol" ? key : String(key);
        }
        function _toPrimitive(input2, hint) {
          if (typeof input2 !== "object" || input2 === null)
            return input2;
          var prim = input2[Symbol.toPrimitive];
          if (prim !== void 0) {
            var res = prim.call(input2, hint || "default");
            if (typeof res !== "object")
              return res;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (hint === "string" ? String : Number)(input2);
        }
        var _require = require2("buffer"), Buffer2 = _require.Buffer;
        var _require2 = require2("util"), inspect = _require2.inspect;
        var custom = inspect && inspect.custom || "inspect";
        function copyBuffer(src, target, offset) {
          Buffer2.prototype.copy.call(src, target, offset);
        }
        module3.exports = /* @__PURE__ */ function() {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          _createClass(BufferList, [{
            key: "push",
            value: function push(v) {
              var entry = {
                data: v,
                next: null
              };
              if (this.length > 0)
                this.tail.next = entry;
              else
                this.head = entry;
              this.tail = entry;
              ++this.length;
            }
          }, {
            key: "unshift",
            value: function unshift(v) {
              var entry = {
                data: v,
                next: this.head
              };
              if (this.length === 0)
                this.tail = entry;
              this.head = entry;
              ++this.length;
            }
          }, {
            key: "shift",
            value: function shift() {
              if (this.length === 0)
                return;
              var ret = this.head.data;
              if (this.length === 1)
                this.head = this.tail = null;
              else
                this.head = this.head.next;
              --this.length;
              return ret;
            }
          }, {
            key: "clear",
            value: function clear2() {
              this.head = this.tail = null;
              this.length = 0;
            }
          }, {
            key: "join",
            value: function join(s2) {
              if (this.length === 0)
                return "";
              var p2 = this.head;
              var ret = "" + p2.data;
              while (p2 = p2.next)
                ret += s2 + p2.data;
              return ret;
            }
          }, {
            key: "concat",
            value: function concat(n2) {
              if (this.length === 0)
                return Buffer2.alloc(0);
              var ret = Buffer2.allocUnsafe(n2 >>> 0);
              var p2 = this.head;
              var i = 0;
              while (p2) {
                copyBuffer(p2.data, ret, i);
                i += p2.data.length;
                p2 = p2.next;
              }
              return ret;
            }
            // Consumes a specified amount of bytes or characters from the buffered data.
          }, {
            key: "consume",
            value: function consume(n2, hasStrings) {
              var ret;
              if (n2 < this.head.data.length) {
                ret = this.head.data.slice(0, n2);
                this.head.data = this.head.data.slice(n2);
              } else if (n2 === this.head.data.length) {
                ret = this.shift();
              } else {
                ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
              }
              return ret;
            }
          }, {
            key: "first",
            value: function first() {
              return this.head.data;
            }
            // Consumes a specified amount of characters from the buffered data.
          }, {
            key: "_getString",
            value: function _getString(n2) {
              var p2 = this.head;
              var c = 1;
              var ret = p2.data;
              n2 -= ret.length;
              while (p2 = p2.next) {
                var str = p2.data;
                var nb = n2 > str.length ? str.length : n2;
                if (nb === str.length)
                  ret += str;
                else
                  ret += str.slice(0, n2);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === str.length) {
                    ++c;
                    if (p2.next)
                      this.head = p2.next;
                    else
                      this.head = this.tail = null;
                  } else {
                    this.head = p2;
                    p2.data = str.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              this.length -= c;
              return ret;
            }
            // Consumes a specified amount of bytes from the buffered data.
          }, {
            key: "_getBuffer",
            value: function _getBuffer(n2) {
              var ret = Buffer2.allocUnsafe(n2);
              var p2 = this.head;
              var c = 1;
              p2.data.copy(ret);
              n2 -= p2.data.length;
              while (p2 = p2.next) {
                var buf = p2.data;
                var nb = n2 > buf.length ? buf.length : n2;
                buf.copy(ret, ret.length - n2, 0, nb);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === buf.length) {
                    ++c;
                    if (p2.next)
                      this.head = p2.next;
                    else
                      this.head = this.tail = null;
                  } else {
                    this.head = p2;
                    p2.data = buf.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              this.length -= c;
              return ret;
            }
            // Make sure the linked list only shows the minimal necessary information.
          }, {
            key: custom,
            value: function value(_, options) {
              return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                // Only inspect one level.
                depth: 0,
                // It should not recurse.
                customInspect: false
              }));
            }
          }]);
          return BufferList;
        }();
      }, { "buffer": 103, "util": 102 }], 477: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            function destroy(err, cb) {
              var _this = this;
              var readableDestroyed = this._readableState && this._readableState.destroyed;
              var writableDestroyed = this._writableState && this._writableState.destroyed;
              if (readableDestroyed || writableDestroyed) {
                if (cb) {
                  cb(err);
                } else if (err) {
                  if (!this._writableState) {
                    process.nextTick(emitErrorNT, this, err);
                  } else if (!this._writableState.errorEmitted) {
                    this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorNT, this, err);
                  }
                }
                return this;
              }
              if (this._readableState) {
                this._readableState.destroyed = true;
              }
              if (this._writableState) {
                this._writableState.destroyed = true;
              }
              this._destroy(err || null, function(err2) {
                if (!cb && err2) {
                  if (!_this._writableState) {
                    process.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else if (!_this._writableState.errorEmitted) {
                    _this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else {
                    process.nextTick(emitCloseNT, _this);
                  }
                } else if (cb) {
                  process.nextTick(emitCloseNT, _this);
                  cb(err2);
                } else {
                  process.nextTick(emitCloseNT, _this);
                }
              });
              return this;
            }
            function emitErrorAndCloseNT(self2, err) {
              emitErrorNT(self2, err);
              emitCloseNT(self2);
            }
            function emitCloseNT(self2) {
              if (self2._writableState && !self2._writableState.emitClose)
                return;
              if (self2._readableState && !self2._readableState.emitClose)
                return;
              self2.emit("close");
            }
            function undestroy() {
              if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
              }
              if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finalCalled = false;
                this._writableState.prefinished = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
              }
            }
            function emitErrorNT(self2, err) {
              self2.emit("error", err);
            }
            function errorOrDestroy(stream, err) {
              var rState = stream._readableState;
              var wState = stream._writableState;
              if (rState && rState.autoDestroy || wState && wState.autoDestroy)
                stream.destroy(err);
              else
                stream.emit("error", err);
            }
            module3.exports = {
              destroy,
              undestroy,
              errorOrDestroy
            };
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 538 }], 478: [function(require2, module3, exports3) {
        var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function once2(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            callback.apply(this, args);
          };
        }
        function noop2() {
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function eos(stream, opts, callback) {
          if (typeof opts === "function")
            return eos(stream, null, opts);
          if (!opts)
            opts = {};
          callback = once2(callback || noop2);
          var readable = opts.readable || opts.readable !== false && stream.readable;
          var writable = opts.writable || opts.writable !== false && stream.writable;
          var onlegacyfinish = function onlegacyfinish2() {
            if (!stream.writable)
              onfinish();
          };
          var writableEnded = stream._writableState && stream._writableState.finished;
          var onfinish = function onfinish2() {
            writable = false;
            writableEnded = true;
            if (!readable)
              callback.call(stream);
          };
          var readableEnded = stream._readableState && stream._readableState.endEmitted;
          var onend = function onend2() {
            readable = false;
            readableEnded = true;
            if (!writable)
              callback.call(stream);
          };
          var onerror = function onerror2(err) {
            callback.call(stream, err);
          };
          var onclose = function onclose2() {
            var err;
            if (readable && !readableEnded) {
              if (!stream._readableState || !stream._readableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
            if (writable && !writableEnded) {
              if (!stream._writableState || !stream._writableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
          };
          var onrequest = function onrequest2() {
            stream.req.on("finish", onfinish);
          };
          if (isRequest(stream)) {
            stream.on("complete", onfinish);
            stream.on("abort", onclose);
            if (stream.req)
              onrequest();
            else
              stream.on("request", onrequest);
          } else if (writable && !stream._writableState) {
            stream.on("end", onlegacyfinish);
            stream.on("close", onlegacyfinish);
          }
          stream.on("end", onend);
          stream.on("finish", onfinish);
          if (opts.error !== false)
            stream.on("error", onerror);
          stream.on("close", onclose);
          return function() {
            stream.removeListener("complete", onfinish);
            stream.removeListener("abort", onclose);
            stream.removeListener("request", onrequest);
            if (stream.req)
              stream.req.removeListener("finish", onfinish);
            stream.removeListener("end", onlegacyfinish);
            stream.removeListener("close", onlegacyfinish);
            stream.removeListener("finish", onfinish);
            stream.removeListener("end", onend);
            stream.removeListener("error", onerror);
            stream.removeListener("close", onclose);
          };
        }
        module3.exports = eos;
      }, { "../../../errors": 469 }], 479: [function(require2, module3, exports3) {
        module3.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 480: [function(require2, module3, exports3) {
        var eos;
        function once2(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            callback.apply(void 0, arguments);
          };
        }
        var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
        function noop2(err) {
          if (err)
            throw err;
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function destroyer(stream, reading, writing, callback) {
          callback = once2(callback);
          var closed = false;
          stream.on("close", function() {
            closed = true;
          });
          if (eos === void 0)
            eos = require2("./end-of-stream");
          eos(stream, {
            readable: reading,
            writable: writing
          }, function(err) {
            if (err)
              return callback(err);
            closed = true;
            callback();
          });
          var destroyed = false;
          return function(err) {
            if (closed)
              return;
            if (destroyed)
              return;
            destroyed = true;
            if (isRequest(stream))
              return stream.abort();
            if (typeof stream.destroy === "function")
              return stream.destroy();
            callback(err || new ERR_STREAM_DESTROYED("pipe"));
          };
        }
        function call(fn) {
          fn();
        }
        function pipe(from, to) {
          return from.pipe(to);
        }
        function popCallback(streams) {
          if (!streams.length)
            return noop2;
          if (typeof streams[streams.length - 1] !== "function")
            return noop2;
          return streams.pop();
        }
        function pipeline() {
          for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
            streams[_key] = arguments[_key];
          }
          var callback = popCallback(streams);
          if (Array.isArray(streams[0]))
            streams = streams[0];
          if (streams.length < 2) {
            throw new ERR_MISSING_ARGS("streams");
          }
          var error2;
          var destroys = streams.map(function(stream, i) {
            var reading = i < streams.length - 1;
            var writing = i > 0;
            return destroyer(stream, reading, writing, function(err) {
              if (!error2)
                error2 = err;
              if (err)
                destroys.forEach(call);
              if (reading)
                return;
              destroys.forEach(call);
              callback(error2);
            });
          });
          return streams.reduce(pipe);
        }
        module3.exports = pipeline;
      }, { "../../../errors": 469, "./end-of-stream": 478 }], 481: [function(require2, module3, exports3) {
        var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function highWaterMarkFrom(options, isDuplex, duplexKey) {
          return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
        }
        function getHighWaterMark(state, options, duplexKey, isDuplex) {
          var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
          if (hwm != null) {
            if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
              var name = isDuplex ? duplexKey : "highWaterMark";
              throw new ERR_INVALID_OPT_VALUE(name, hwm);
            }
            return Math.floor(hwm);
          }
          return state.objectMode ? 16 : 16 * 1024;
        }
        module3.exports = {
          getHighWaterMark
        };
      }, { "../../../errors": 469 }], 482: [function(require2, module3, exports3) {
        arguments[4][459][0].apply(exports3, arguments);
      }, { "dup": 459, "events": 386 }], 483: [function(require2, module3, exports3) {
        arguments[4][462][0].apply(exports3, arguments);
      }, { "dup": 462, "safe-buffer": 464 }], 484: [function(require2, module3, exports3) {
        (function(setImmediate, clearImmediate) {
          (function() {
            var nextTick2 = require2("process/browser.js").nextTick;
            var apply = Function.prototype.apply;
            var slice = Array.prototype.slice;
            var immediateIds = {};
            var nextImmediateId = 0;
            exports3.setTimeout = function() {
              return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
            };
            exports3.setInterval = function() {
              return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
            };
            exports3.clearTimeout = exports3.clearInterval = function(timeout2) {
              timeout2.close();
            };
            function Timeout(id, clearFn) {
              this._id = id;
              this._clearFn = clearFn;
            }
            Timeout.prototype.unref = Timeout.prototype.ref = function() {
            };
            Timeout.prototype.close = function() {
              this._clearFn.call(window, this._id);
            };
            exports3.enroll = function(item, msecs) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = msecs;
            };
            exports3.unenroll = function(item) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = -1;
            };
            exports3._unrefActive = exports3.active = function(item) {
              clearTimeout(item._idleTimeoutId);
              var msecs = item._idleTimeout;
              if (msecs >= 0) {
                item._idleTimeoutId = setTimeout(function onTimeout() {
                  if (item._onTimeout)
                    item._onTimeout();
                }, msecs);
              }
            };
            exports3.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
              var id = nextImmediateId++;
              var args = arguments.length < 2 ? false : slice.call(arguments, 1);
              immediateIds[id] = true;
              nextTick2(function onNextTick() {
                if (immediateIds[id]) {
                  if (args) {
                    fn.apply(null, args);
                  } else {
                    fn.call(null);
                  }
                  exports3.clearImmediate(id);
                }
              });
              return id;
            };
            exports3.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
              delete immediateIds[id];
            };
          }).call(this);
        }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
      }, { "process/browser.js": 442, "timers": 484 }], 485: [function(require2, module3, exports3) {
        var Buffer2 = require2("buffer").Buffer;
        module3.exports = function(buf) {
          if (buf instanceof Uint8Array) {
            if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
              return buf.buffer;
            } else if (typeof buf.buffer.slice === "function") {
              return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
            }
          }
          if (Buffer2.isBuffer(buf)) {
            var arrayCopy = new Uint8Array(buf.length);
            var len = buf.length;
            for (var i = 0; i < len; i++) {
              arrayCopy[i] = buf[i];
            }
            return arrayCopy.buffer;
          } else {
            throw new Error("Argument must be a Buffer");
          }
        };
      }, { "buffer": 103 }], 486: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            module3.exports = deprecate;
            function deprecate(fn, msg) {
              if (config2("noDeprecation")) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config2("throwDeprecation")) {
                    throw new Error(msg);
                  } else if (config2("traceDeprecation")) {
                    console.trace(msg);
                  } else {
                    index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:35516", msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            }
            function config2(name) {
              try {
                if (!global3.localStorage)
                  return false;
              } catch (_) {
                return false;
              }
              var val = global3.localStorage[name];
              if (null == val)
                return false;
              return String(val).toLowerCase() === "true";
            }
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 487: [function(require2, module3, exports3) {
        arguments[4][97][0].apply(exports3, arguments);
      }, { "dup": 97 }], 488: [function(require2, module3, exports3) {
        var isArgumentsObject = require2("is-arguments");
        var isGeneratorFunction = require2("is-generator-function");
        var whichTypedArray = require2("which-typed-array");
        var isTypedArray = require2("is-typed-array");
        function uncurryThis(f2) {
          return f2.call.bind(f2);
        }
        var BigIntSupported = typeof BigInt !== "undefined";
        var SymbolSupported = typeof Symbol !== "undefined";
        var ObjectToString = uncurryThis(Object.prototype.toString);
        var numberValue = uncurryThis(Number.prototype.valueOf);
        var stringValue = uncurryThis(String.prototype.valueOf);
        var booleanValue = uncurryThis(Boolean.prototype.valueOf);
        if (BigIntSupported) {
          var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
        }
        if (SymbolSupported) {
          var symbolValue = uncurryThis(Symbol.prototype.valueOf);
        }
        function checkBoxedPrimitive(value, prototypeValueOf) {
          if (typeof value !== "object") {
            return false;
          }
          try {
            prototypeValueOf(value);
            return true;
          } catch (e2) {
            return false;
          }
        }
        exports3.isArgumentsObject = isArgumentsObject;
        exports3.isGeneratorFunction = isGeneratorFunction;
        exports3.isTypedArray = isTypedArray;
        function isPromise2(input2) {
          return typeof Promise !== "undefined" && input2 instanceof Promise || input2 !== null && typeof input2 === "object" && typeof input2.then === "function" && typeof input2.catch === "function";
        }
        exports3.isPromise = isPromise2;
        function isArrayBufferView(value) {
          if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
            return ArrayBuffer.isView(value);
          }
          return isTypedArray(value) || isDataView(value);
        }
        exports3.isArrayBufferView = isArrayBufferView;
        function isUint8Array(value) {
          return whichTypedArray(value) === "Uint8Array";
        }
        exports3.isUint8Array = isUint8Array;
        function isUint8ClampedArray(value) {
          return whichTypedArray(value) === "Uint8ClampedArray";
        }
        exports3.isUint8ClampedArray = isUint8ClampedArray;
        function isUint16Array(value) {
          return whichTypedArray(value) === "Uint16Array";
        }
        exports3.isUint16Array = isUint16Array;
        function isUint32Array(value) {
          return whichTypedArray(value) === "Uint32Array";
        }
        exports3.isUint32Array = isUint32Array;
        function isInt8Array(value) {
          return whichTypedArray(value) === "Int8Array";
        }
        exports3.isInt8Array = isInt8Array;
        function isInt16Array(value) {
          return whichTypedArray(value) === "Int16Array";
        }
        exports3.isInt16Array = isInt16Array;
        function isInt32Array(value) {
          return whichTypedArray(value) === "Int32Array";
        }
        exports3.isInt32Array = isInt32Array;
        function isFloat32Array(value) {
          return whichTypedArray(value) === "Float32Array";
        }
        exports3.isFloat32Array = isFloat32Array;
        function isFloat64Array(value) {
          return whichTypedArray(value) === "Float64Array";
        }
        exports3.isFloat64Array = isFloat64Array;
        function isBigInt64Array(value) {
          return whichTypedArray(value) === "BigInt64Array";
        }
        exports3.isBigInt64Array = isBigInt64Array;
        function isBigUint64Array(value) {
          return whichTypedArray(value) === "BigUint64Array";
        }
        exports3.isBigUint64Array = isBigUint64Array;
        function isMapToString(value) {
          return ObjectToString(value) === "[object Map]";
        }
        isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
        function isMap2(value) {
          if (typeof Map === "undefined") {
            return false;
          }
          return isMapToString.working ? isMapToString(value) : value instanceof Map;
        }
        exports3.isMap = isMap2;
        function isSetToString(value) {
          return ObjectToString(value) === "[object Set]";
        }
        isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
        function isSet2(value) {
          if (typeof Set === "undefined") {
            return false;
          }
          return isSetToString.working ? isSetToString(value) : value instanceof Set;
        }
        exports3.isSet = isSet2;
        function isWeakMapToString(value) {
          return ObjectToString(value) === "[object WeakMap]";
        }
        isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
        function isWeakMap(value) {
          if (typeof WeakMap === "undefined") {
            return false;
          }
          return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
        }
        exports3.isWeakMap = isWeakMap;
        function isWeakSetToString(value) {
          return ObjectToString(value) === "[object WeakSet]";
        }
        isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
        function isWeakSet(value) {
          return isWeakSetToString(value);
        }
        exports3.isWeakSet = isWeakSet;
        function isArrayBufferToString(value) {
          return ObjectToString(value) === "[object ArrayBuffer]";
        }
        isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
        function isArrayBuffer(value) {
          if (typeof ArrayBuffer === "undefined") {
            return false;
          }
          return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
        }
        exports3.isArrayBuffer = isArrayBuffer;
        function isDataViewToString(value) {
          return ObjectToString(value) === "[object DataView]";
        }
        isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
        function isDataView(value) {
          if (typeof DataView === "undefined") {
            return false;
          }
          return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
        }
        exports3.isDataView = isDataView;
        var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
        function isSharedArrayBufferToString(value) {
          return ObjectToString(value) === "[object SharedArrayBuffer]";
        }
        function isSharedArrayBuffer(value) {
          if (typeof SharedArrayBufferCopy === "undefined") {
            return false;
          }
          if (typeof isSharedArrayBufferToString.working === "undefined") {
            isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
          }
          return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
        }
        exports3.isSharedArrayBuffer = isSharedArrayBuffer;
        function isAsyncFunction(value) {
          return ObjectToString(value) === "[object AsyncFunction]";
        }
        exports3.isAsyncFunction = isAsyncFunction;
        function isMapIterator(value) {
          return ObjectToString(value) === "[object Map Iterator]";
        }
        exports3.isMapIterator = isMapIterator;
        function isSetIterator(value) {
          return ObjectToString(value) === "[object Set Iterator]";
        }
        exports3.isSetIterator = isSetIterator;
        function isGeneratorObject(value) {
          return ObjectToString(value) === "[object Generator]";
        }
        exports3.isGeneratorObject = isGeneratorObject;
        function isWebAssemblyCompiledModule(value) {
          return ObjectToString(value) === "[object WebAssembly.Module]";
        }
        exports3.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
        function isNumberObject(value) {
          return checkBoxedPrimitive(value, numberValue);
        }
        exports3.isNumberObject = isNumberObject;
        function isStringObject(value) {
          return checkBoxedPrimitive(value, stringValue);
        }
        exports3.isStringObject = isStringObject;
        function isBooleanObject(value) {
          return checkBoxedPrimitive(value, booleanValue);
        }
        exports3.isBooleanObject = isBooleanObject;
        function isBigIntObject(value) {
          return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
        }
        exports3.isBigIntObject = isBigIntObject;
        function isSymbolObject(value) {
          return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
        }
        exports3.isSymbolObject = isSymbolObject;
        function isBoxedPrimitive(value) {
          return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
        }
        exports3.isBoxedPrimitive = isBoxedPrimitive;
        function isAnyArrayBuffer(value) {
          return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
        }
        exports3.isAnyArrayBuffer = isAnyArrayBuffer;
        ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
          Object.defineProperty(exports3, method, {
            enumerable: false,
            value: function() {
              throw new Error(method + " is not supported in userland");
            }
          });
        });
      }, { "is-arguments": 408, "is-generator-function": 411, "is-typed-array": 412, "which-typed-array": 490 }], 489: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
              var keys = Object.keys(obj);
              var descriptors = {};
              for (var i = 0; i < keys.length; i++) {
                descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
              }
              return descriptors;
            };
            var formatRegExp = /%[sdj%]/g;
            exports3.format = function(f2) {
              if (!isString2(f2)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(" ");
              }
              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f2).replace(formatRegExp, function(x2) {
                if (x2 === "%%")
                  return "%";
                if (i >= len)
                  return x2;
                switch (x2) {
                  case "%s":
                    return String(args[i++]);
                  case "%d":
                    return Number(args[i++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x2;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject2(x)) {
                  str += " " + x;
                } else {
                  str += " " + inspect(x);
                }
              }
              return str;
            };
            exports3.deprecate = function(fn, msg) {
              if (typeof process !== "undefined" && process.noDeprecation === true) {
                return fn;
              }
              if (typeof process === "undefined") {
                return function() {
                  return exports3.deprecate(fn, msg).apply(this, arguments);
                };
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    index$2.__f__("error", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:35981", msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnvRegex = /^$/;
            if (process.env.NODE_DEBUG) {
              var debugEnv = process.env.NODE_DEBUG;
              debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
              debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
            }
            exports3.debuglog = function(set2) {
              set2 = set2.toUpperCase();
              if (!debugs[set2]) {
                if (debugEnvRegex.test(set2)) {
                  var pid = process.pid;
                  debugs[set2] = function() {
                    var msg = exports3.format.apply(exports3, arguments);
                    index$2.__f__("error", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:36010", "%s %d: %s", set2, pid, msg);
                  };
                } else {
                  debugs[set2] = function() {
                  };
                }
              }
              return debugs[set2];
            };
            function inspect(obj, opts) {
              var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
              if (arguments.length >= 3)
                ctx.depth = arguments[2];
              if (arguments.length >= 4)
                ctx.colors = arguments[3];
              if (isBoolean2(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports3._extend(ctx, opts);
              }
              if (isUndefined2(ctx.showHidden))
                ctx.showHidden = false;
              if (isUndefined2(ctx.depth))
                ctx.depth = 2;
              if (isUndefined2(ctx.colors))
                ctx.colors = false;
              if (isUndefined2(ctx.customInspect))
                ctx.customInspect = true;
              if (ctx.colors)
                ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports3.inspect = inspect;
            inspect.colors = {
              "bold": [1, 22],
              "italic": [3, 23],
              "underline": [4, 24],
              "inverse": [7, 27],
              "white": [37, 39],
              "grey": [90, 39],
              "black": [30, 39],
              "blue": [34, 39],
              "cyan": [36, 39],
              "green": [32, 39],
              "magenta": [35, 39],
              "red": [31, 39],
              "yellow": [33, 39]
            };
            inspect.styles = {
              "special": "cyan",
              "number": "yellow",
              "boolean": "yellow",
              "undefined": "grey",
              "null": "bold",
              "string": "green",
              "date": "magenta",
              // "name": intentionally not styling
              "regexp": "red"
            };
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              if (style) {
                return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array2) {
              var hash = {};
              array2.forEach(function(val, idx) {
                hash[val] = true;
              });
              return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
              value.inspect !== exports3.inspect && // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString2(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction2(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                }
                if (isDate2(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = "", array2 = false, braces = ["{", "}"];
              if (isArray2(value)) {
                array2 = true;
                braces = ["[", "]"];
              }
              if (isFunction2(value)) {
                var n2 = value.name ? ": " + value.name : "";
                base = " [Function" + n2 + "]";
              }
              if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }
              if (isDate2(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = " " + formatError(value);
              }
              if (keys.length === 0 && (!array2 || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }
              ctx.seen.push(value);
              var output;
              if (array2) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2);
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined2(value))
                return ctx.stylize("undefined", "undefined");
              if (isString2(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber(value))
                return ctx.stylize("" + value, "number");
              if (isBoolean2(value))
                return ctx.stylize("" + value, "boolean");
              if (isNull(value))
                return ctx.stylize("null", "null");
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty2(value, String(i))) {
                  output.push(formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    String(i),
                    true
                  ));
                } else {
                  output.push("");
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    true
                  ));
                }
              });
              return output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty2(visibleKeys, key)) {
                name = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array2) {
                      str = str.split("\n").map(function(line2) {
                        return "  " + line2;
                      }).join("\n").slice(2);
                    } else {
                      str = "\n" + str.split("\n").map(function(line2) {
                        return "   " + line2;
                      }).join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined2(name)) {
                if (array2 && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.slice(1, -1);
                  name = ctx.stylize(name, "name");
                } else {
                  name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, "string");
                }
              }
              return name + ": " + str;
            }
            function reduceToSingleString(output, base, braces) {
              var length = output.reduce(function(prev, cur) {
                if (cur.indexOf("\n") >= 0)
                  ;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              if (length > 60) {
                return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
              }
              return braces[0] + base + " " + output.join(", ") + " " + braces[1];
            }
            exports3.types = require2("./support/types");
            function isArray2(ar) {
              return Array.isArray(ar);
            }
            exports3.isArray = isArray2;
            function isBoolean2(arg) {
              return typeof arg === "boolean";
            }
            exports3.isBoolean = isBoolean2;
            function isNull(arg) {
              return arg === null;
            }
            exports3.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports3.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === "number";
            }
            exports3.isNumber = isNumber;
            function isString2(arg) {
              return typeof arg === "string";
            }
            exports3.isString = isString2;
            function isSymbol2(arg) {
              return typeof arg === "symbol";
            }
            exports3.isSymbol = isSymbol2;
            function isUndefined2(arg) {
              return arg === void 0;
            }
            exports3.isUndefined = isUndefined2;
            function isRegExp(re) {
              return isObject2(re) && objectToString2(re) === "[object RegExp]";
            }
            exports3.isRegExp = isRegExp;
            exports3.types.isRegExp = isRegExp;
            function isObject2(arg) {
              return typeof arg === "object" && arg !== null;
            }
            exports3.isObject = isObject2;
            function isDate2(d) {
              return isObject2(d) && objectToString2(d) === "[object Date]";
            }
            exports3.isDate = isDate2;
            exports3.types.isDate = isDate2;
            function isError(e2) {
              return isObject2(e2) && (objectToString2(e2) === "[object Error]" || e2 instanceof Error);
            }
            exports3.isError = isError;
            exports3.types.isNativeError = isError;
            function isFunction2(arg) {
              return typeof arg === "function";
            }
            exports3.isFunction = isFunction2;
            function isPrimitive(arg) {
              return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined";
            }
            exports3.isPrimitive = isPrimitive;
            exports3.isBuffer = require2("./support/isBuffer");
            function objectToString2(o2) {
              return Object.prototype.toString.call(o2);
            }
            function pad2(n2) {
              return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
            }
            var months = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ];
            function timestamp() {
              var d = /* @__PURE__ */ new Date();
              var time2 = [
                pad2(d.getHours()),
                pad2(d.getMinutes()),
                pad2(d.getSeconds())
              ].join(":");
              return [d.getDate(), months[d.getMonth()], time2].join(" ");
            }
            exports3.log = function() {
              index$2.__f__("log", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:36461", "%s - %s", timestamp(), exports3.format.apply(exports3, arguments));
            };
            exports3.inherits = require2("inherits");
            exports3._extend = function(origin, add2) {
              if (!add2 || !isObject2(add2))
                return origin;
              var keys = Object.keys(add2);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add2[keys[i]];
              }
              return origin;
            };
            function hasOwnProperty2(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
            exports3.promisify = function promisify2(original) {
              if (typeof original !== "function")
                throw new TypeError('The "original" argument must be of type Function');
              if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                var fn = original[kCustomPromisifiedSymbol];
                if (typeof fn !== "function") {
                  throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                }
                Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true
                });
                return fn;
              }
              function fn() {
                var promiseResolve, promiseReject;
                var promise2 = new Promise(function(resolve2, reject) {
                  promiseResolve = resolve2;
                  promiseReject = reject;
                });
                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                args.push(function(err, value) {
                  if (err) {
                    promiseReject(err);
                  } else {
                    promiseResolve(value);
                  }
                });
                try {
                  original.apply(this, args);
                } catch (err) {
                  promiseReject(err);
                }
                return promise2;
              }
              Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
              if (kCustomPromisifiedSymbol)
                Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true
                });
              return Object.defineProperties(
                fn,
                getOwnPropertyDescriptors(original)
              );
            };
            exports3.promisify.custom = kCustomPromisifiedSymbol;
            function callbackifyOnRejected(reason, cb) {
              if (!reason) {
                var newReason = new Error("Promise was rejected with a falsy value");
                newReason.reason = reason;
                reason = newReason;
              }
              return cb(reason);
            }
            function callbackify(original) {
              if (typeof original !== "function") {
                throw new TypeError('The "original" argument must be of type Function');
              }
              function callbackified() {
                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                var maybeCb = args.pop();
                if (typeof maybeCb !== "function") {
                  throw new TypeError("The last argument must be of type Function");
                }
                var self2 = this;
                var cb = function() {
                  return maybeCb.apply(self2, arguments);
                };
                original.apply(this, args).then(
                  function(ret) {
                    process.nextTick(cb.bind(null, null, ret));
                  },
                  function(rej) {
                    process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                  }
                );
              }
              Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
              Object.defineProperties(
                callbackified,
                getOwnPropertyDescriptors(original)
              );
              return callbackified;
            }
            exports3.callbackify = callbackify;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./support/isBuffer": 487, "./support/types": 488, "_process": 538, "inherits": 407 }], 490: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            var forEach3 = require2("for-each");
            var availableTypedArrays = require2("available-typed-arrays");
            var callBind = require2("call-bind");
            var callBound = require2("call-bind/callBound");
            var gOPD = require2("gopd");
            var $toString = callBound("Object.prototype.toString");
            var hasToStringTag = require2("has-tostringtag/shams")();
            var g = typeof globalThis === "undefined" ? global3 : globalThis;
            var typedArrays = availableTypedArrays();
            var $slice = callBound("String.prototype.slice");
            var getPrototypeOf = Object.getPrototypeOf;
            var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array2, value) {
              for (var i = 0; i < array2.length; i += 1) {
                if (array2[i] === value) {
                  return i;
                }
              }
              return -1;
            };
            var cache = { __proto__: null };
            if (hasToStringTag && gOPD && getPrototypeOf) {
              forEach3(typedArrays, function(typedArray) {
                var arr = new g[typedArray]();
                if (Symbol.toStringTag in arr) {
                  var proto = getPrototypeOf(arr);
                  var descriptor = gOPD(proto, Symbol.toStringTag);
                  if (!descriptor) {
                    var superProto = getPrototypeOf(proto);
                    descriptor = gOPD(superProto, Symbol.toStringTag);
                  }
                  cache["$" + typedArray] = callBind(descriptor.get);
                }
              });
            } else {
              forEach3(typedArrays, function(typedArray) {
                var arr = new g[typedArray]();
                var fn = arr.slice || arr.set;
                if (fn) {
                  cache["$" + typedArray] = callBind(fn);
                }
              });
            }
            var tryTypedArrays = function tryAllTypedArrays(value) {
              var found = false;
              forEach3(cache, function(getter, typedArray) {
                if (!found) {
                  try {
                    if ("$" + getter(value) === typedArray) {
                      found = $slice(typedArray, 1);
                    }
                  } catch (e2) {
                  }
                }
              });
              return found;
            };
            var trySlices = function tryAllSlices(value) {
              var found = false;
              forEach3(cache, function(getter, name) {
                if (!found) {
                  try {
                    getter(value);
                    found = $slice(name, 1);
                  } catch (e2) {
                  }
                }
              });
              return found;
            };
            module3.exports = function whichTypedArray(value) {
              if (!value || typeof value !== "object") {
                return false;
              }
              if (!hasToStringTag) {
                var tag2 = $slice($toString(value), 8, -1);
                if ($indexOf(typedArrays, tag2) > -1) {
                  return tag2;
                }
                if (tag2 !== "Object") {
                  return false;
                }
                return trySlices(value);
              }
              if (!gOPD) {
                return null;
              }
              return tryTypedArrays(value);
            };
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "available-typed-arrays": 99, "call-bind": 106, "call-bind/callBound": 105, "for-each": 387, "gopd": 391, "has-tostringtag/shams": 396 }], 491: [function(require2, module3, exports3) {
        (function() {
          exports3.stripBOM = function(str) {
            if (str[0] === "\uFEFF") {
              return str.substring(1);
            } else {
              return str;
            }
          };
        }).call(this);
      }, {}], 492: [function(require2, module3, exports3) {
        (function() {
          var builder, defaults2, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
          builder = require2("xmlbuilder");
          defaults2 = require2("./defaults").defaults;
          requiresCDATA = function(entry) {
            return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
          };
          wrapCDATA = function(entry) {
            return "<![CDATA[" + escapeCDATA(entry) + "]]>";
          };
          escapeCDATA = function(entry) {
            return entry.replace("]]>", "]]]]><![CDATA[>");
          };
          exports3.Builder = function() {
            function Builder(opts) {
              var key, ref2, value;
              this.options = {};
              ref2 = defaults2["0.2"];
              for (key in ref2) {
                if (!hasProp.call(ref2, key))
                  continue;
                value = ref2[key];
                this.options[key] = value;
              }
              for (key in opts) {
                if (!hasProp.call(opts, key))
                  continue;
                value = opts[key];
                this.options[key] = value;
              }
            }
            Builder.prototype.buildObject = function(rootObj) {
              var attrkey, charkey, render2, rootElement, rootName;
              attrkey = this.options.attrkey;
              charkey = this.options.charkey;
              if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults2["0.2"].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
              } else {
                rootName = this.options.rootName;
              }
              render2 = /* @__PURE__ */ function(_this) {
                return function(element, obj) {
                  var attr, child, entry, index2, key, value;
                  if (typeof obj !== "object") {
                    if (_this.options.cdata && requiresCDATA(obj)) {
                      element.raw(wrapCDATA(obj));
                    } else {
                      element.txt(obj);
                    }
                  } else if (Array.isArray(obj)) {
                    for (index2 in obj) {
                      if (!hasProp.call(obj, index2))
                        continue;
                      child = obj[index2];
                      for (key in child) {
                        entry = child[key];
                        element = render2(element.ele(key), entry).up();
                      }
                    }
                  } else {
                    for (key in obj) {
                      if (!hasProp.call(obj, key))
                        continue;
                      child = obj[key];
                      if (key === attrkey) {
                        if (typeof child === "object") {
                          for (attr in child) {
                            value = child[attr];
                            element = element.att(attr, value);
                          }
                        }
                      } else if (key === charkey) {
                        if (_this.options.cdata && requiresCDATA(child)) {
                          element = element.raw(wrapCDATA(child));
                        } else {
                          element = element.txt(child);
                        }
                      } else if (Array.isArray(child)) {
                        for (index2 in child) {
                          if (!hasProp.call(child, index2))
                            continue;
                          entry = child[index2];
                          if (typeof entry === "string") {
                            if (_this.options.cdata && requiresCDATA(entry)) {
                              element = element.ele(key).raw(wrapCDATA(entry)).up();
                            } else {
                              element = element.ele(key, entry).up();
                            }
                          } else {
                            element = render2(element.ele(key), entry).up();
                          }
                        }
                      } else if (typeof child === "object") {
                        element = render2(element.ele(key), child).up();
                      } else {
                        if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                          element = element.ele(key).raw(wrapCDATA(child)).up();
                        } else {
                          if (child == null) {
                            child = "";
                          }
                          element = element.ele(key, child.toString()).up();
                        }
                      }
                    }
                  }
                  return element;
                };
              }(this);
              rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
              });
              return render2(rootElement, rootObj).end(this.options.renderOpts);
            };
            return Builder;
          }();
        }).call(this);
      }, { "./defaults": 493, "xmlbuilder": 529 }], 493: [function(require2, module3, exports3) {
        (function() {
          exports3.defaults = {
            "0.1": {
              explicitCharkey: false,
              trim: true,
              normalize: true,
              normalizeTags: false,
              attrkey: "@",
              charkey: "#",
              explicitArray: false,
              ignoreAttrs: false,
              mergeAttrs: false,
              explicitRoot: false,
              validator: null,
              xmlns: false,
              explicitChildren: false,
              childkey: "@@",
              charsAsChildren: false,
              includeWhiteChars: false,
              async: false,
              strict: true,
              attrNameProcessors: null,
              attrValueProcessors: null,
              tagNameProcessors: null,
              valueProcessors: null,
              emptyTag: ""
            },
            "0.2": {
              explicitCharkey: false,
              trim: false,
              normalize: false,
              normalizeTags: false,
              attrkey: "$",
              charkey: "_",
              explicitArray: true,
              ignoreAttrs: false,
              mergeAttrs: false,
              explicitRoot: true,
              validator: null,
              xmlns: false,
              explicitChildren: false,
              preserveChildrenOrder: false,
              childkey: "$$",
              charsAsChildren: false,
              includeWhiteChars: false,
              async: false,
              strict: true,
              attrNameProcessors: null,
              attrValueProcessors: null,
              tagNameProcessors: null,
              valueProcessors: null,
              rootName: "root",
              xmldec: {
                "version": "1.0",
                "encoding": "UTF-8",
                "standalone": true
              },
              doctype: null,
              renderOpts: {
                "pretty": true,
                "indent": "  ",
                "newline": "\n"
              },
              headless: false,
              chunkSize: 1e4,
              emptyTag: "",
              cdata: false
            }
          };
        }).call(this);
      }, {}], 494: [function(require2, module3, exports3) {
        (function() {
          var bom, defaults2, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
            return function() {
              return fn.apply(me, arguments);
            };
          }, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          sax = require2("sax");
          events = require2("events");
          bom = require2("./bom");
          processors = require2("./processors");
          setImmediate = require2("timers").setImmediate;
          defaults2 = require2("./defaults").defaults;
          isEmpty = function(thing) {
            return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
          };
          processItem = function(processors2, item, key) {
            var i, len, process;
            for (i = 0, len = processors2.length; i < len; i++) {
              process = processors2[i];
              item = process(item, key);
            }
            return item;
          };
          defineProperty = function(obj, key, value) {
            var descriptor;
            descriptor = /* @__PURE__ */ Object.create(null);
            descriptor.value = value;
            descriptor.writable = true;
            descriptor.enumerable = true;
            descriptor.configurable = true;
            return Object.defineProperty(obj, key, descriptor);
          };
          exports3.Parser = function(superClass) {
            extend2(Parser2, superClass);
            function Parser2(opts) {
              this.parseStringPromise = bind(this.parseStringPromise, this);
              this.parseString = bind(this.parseString, this);
              this.reset = bind(this.reset, this);
              this.assignOrPush = bind(this.assignOrPush, this);
              this.processAsync = bind(this.processAsync, this);
              var key, ref2, value;
              if (!(this instanceof exports3.Parser)) {
                return new exports3.Parser(opts);
              }
              this.options = {};
              ref2 = defaults2["0.2"];
              for (key in ref2) {
                if (!hasProp.call(ref2, key))
                  continue;
                value = ref2[key];
                this.options[key] = value;
              }
              for (key in opts) {
                if (!hasProp.call(opts, key))
                  continue;
                value = opts[key];
                this.options[key] = value;
              }
              if (this.options.xmlns) {
                this.options.xmlnskey = this.options.attrkey + "ns";
              }
              if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) {
                  this.options.tagNameProcessors = [];
                }
                this.options.tagNameProcessors.unshift(processors.normalize);
              }
              this.reset();
            }
            Parser2.prototype.processAsync = function() {
              var chunk, err;
              try {
                if (this.remaining.length <= this.options.chunkSize) {
                  chunk = this.remaining;
                  this.remaining = "";
                  this.saxParser = this.saxParser.write(chunk);
                  return this.saxParser.close();
                } else {
                  chunk = this.remaining.substr(0, this.options.chunkSize);
                  this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                  this.saxParser = this.saxParser.write(chunk);
                  return setImmediate(this.processAsync);
                }
              } catch (error1) {
                err = error1;
                if (!this.saxParser.errThrown) {
                  this.saxParser.errThrown = true;
                  return this.emit(err);
                }
              }
            };
            Parser2.prototype.assignOrPush = function(obj, key, newValue) {
              if (!(key in obj)) {
                if (!this.options.explicitArray) {
                  return defineProperty(obj, key, newValue);
                } else {
                  return defineProperty(obj, key, [newValue]);
                }
              } else {
                if (!(obj[key] instanceof Array)) {
                  defineProperty(obj, key, [obj[key]]);
                }
                return obj[key].push(newValue);
              }
            };
            Parser2.prototype.reset = function() {
              var attrkey, charkey, ontext, stack2;
              this.removeAllListeners();
              this.saxParser = sax.parser(this.options.strict, {
                trim: false,
                normalize: false,
                xmlns: this.options.xmlns
              });
              this.saxParser.errThrown = false;
              this.saxParser.onerror = /* @__PURE__ */ function(_this) {
                return function(error2) {
                  _this.saxParser.resume();
                  if (!_this.saxParser.errThrown) {
                    _this.saxParser.errThrown = true;
                    return _this.emit("error", error2);
                  }
                };
              }(this);
              this.saxParser.onend = /* @__PURE__ */ function(_this) {
                return function() {
                  if (!_this.saxParser.ended) {
                    _this.saxParser.ended = true;
                    return _this.emit("end", _this.resultObject);
                  }
                };
              }(this);
              this.saxParser.ended = false;
              this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
              this.resultObject = null;
              stack2 = [];
              attrkey = this.options.attrkey;
              charkey = this.options.charkey;
              this.saxParser.onopentag = /* @__PURE__ */ function(_this) {
                return function(node) {
                  var key, newValue, obj, processedKey, ref2;
                  obj = {};
                  obj[charkey] = "";
                  if (!_this.options.ignoreAttrs) {
                    ref2 = node.attributes;
                    for (key in ref2) {
                      if (!hasProp.call(ref2, key))
                        continue;
                      if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                        obj[attrkey] = {};
                      }
                      newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                      processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                      if (_this.options.mergeAttrs) {
                        _this.assignOrPush(obj, processedKey, newValue);
                      } else {
                        defineProperty(obj[attrkey], processedKey, newValue);
                      }
                    }
                  }
                  obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                  if (_this.options.xmlns) {
                    obj[_this.options.xmlnskey] = {
                      uri: node.uri,
                      local: node.local
                    };
                  }
                  return stack2.push(obj);
                };
              }(this);
              this.saxParser.onclosetag = /* @__PURE__ */ function(_this) {
                return function() {
                  var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s2, xpath;
                  obj = stack2.pop();
                  nodeName = obj["#name"];
                  if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                    delete obj["#name"];
                  }
                  if (obj.cdata === true) {
                    cdata = obj.cdata;
                    delete obj.cdata;
                  }
                  s2 = stack2[stack2.length - 1];
                  if (obj[charkey].match(/^\s*$/) && !cdata) {
                    emptyStr = obj[charkey];
                    delete obj[charkey];
                  } else {
                    if (_this.options.trim) {
                      obj[charkey] = obj[charkey].trim();
                    }
                    if (_this.options.normalize) {
                      obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                    }
                    obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                      obj = obj[charkey];
                    }
                  }
                  if (isEmpty(obj)) {
                    if (typeof _this.options.emptyTag === "function") {
                      obj = _this.options.emptyTag();
                    } else {
                      obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                    }
                  }
                  if (_this.options.validator != null) {
                    xpath = "/" + function() {
                      var i, len, results;
                      results = [];
                      for (i = 0, len = stack2.length; i < len; i++) {
                        node = stack2[i];
                        results.push(node["#name"]);
                      }
                      return results;
                    }().concat(nodeName).join("/");
                    (function() {
                      var err;
                      try {
                        return obj = _this.options.validator(xpath, s2 && s2[nodeName], obj);
                      } catch (error1) {
                        err = error1;
                        return _this.emit("error", err);
                      }
                    })();
                  }
                  if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                    if (!_this.options.preserveChildrenOrder) {
                      node = {};
                      if (_this.options.attrkey in obj) {
                        node[_this.options.attrkey] = obj[_this.options.attrkey];
                        delete obj[_this.options.attrkey];
                      }
                      if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                        node[_this.options.charkey] = obj[_this.options.charkey];
                        delete obj[_this.options.charkey];
                      }
                      if (Object.getOwnPropertyNames(obj).length > 0) {
                        node[_this.options.childkey] = obj;
                      }
                      obj = node;
                    } else if (s2) {
                      s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                      objClone = {};
                      for (key in obj) {
                        if (!hasProp.call(obj, key))
                          continue;
                        defineProperty(objClone, key, obj[key]);
                      }
                      s2[_this.options.childkey].push(objClone);
                      delete obj["#name"];
                      if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                        obj = obj[charkey];
                      }
                    }
                  }
                  if (stack2.length > 0) {
                    return _this.assignOrPush(s2, nodeName, obj);
                  } else {
                    if (_this.options.explicitRoot) {
                      old = obj;
                      obj = {};
                      defineProperty(obj, nodeName, old);
                    }
                    _this.resultObject = obj;
                    _this.saxParser.ended = true;
                    return _this.emit("end", _this.resultObject);
                  }
                };
              }(this);
              ontext = /* @__PURE__ */ function(_this) {
                return function(text2) {
                  var charChild, s2;
                  s2 = stack2[stack2.length - 1];
                  if (s2) {
                    s2[charkey] += text2;
                    if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text2.replace(/\\n/g, "").trim() !== "")) {
                      s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                      charChild = {
                        "#name": "__text__"
                      };
                      charChild[charkey] = text2;
                      if (_this.options.normalize) {
                        charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                      }
                      s2[_this.options.childkey].push(charChild);
                    }
                    return s2;
                  }
                };
              }(this);
              this.saxParser.ontext = ontext;
              return this.saxParser.oncdata = /* @__PURE__ */ function(_this) {
                return function(text2) {
                  var s2;
                  s2 = ontext(text2);
                  if (s2) {
                    return s2.cdata = true;
                  }
                };
              }();
            };
            Parser2.prototype.parseString = function(str, cb) {
              var err;
              if (cb != null && typeof cb === "function") {
                this.on("end", function(result) {
                  this.reset();
                  return cb(null, result);
                });
                this.on("error", function(err2) {
                  this.reset();
                  return cb(err2);
                });
              }
              try {
                str = str.toString();
                if (str.trim() === "") {
                  this.emit("end", null);
                  return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                  this.remaining = str;
                  setImmediate(this.processAsync);
                  return this.saxParser;
                }
                return this.saxParser.write(str).close();
              } catch (error1) {
                err = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                  this.emit("error", err);
                  return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) {
                  throw err;
                }
              }
            };
            Parser2.prototype.parseStringPromise = function(str) {
              return new Promise(/* @__PURE__ */ function(_this) {
                return function(resolve2, reject) {
                  return _this.parseString(str, function(err, value) {
                    if (err) {
                      return reject(err);
                    } else {
                      return resolve2(value);
                    }
                  });
                };
              }(this));
            };
            return Parser2;
          }(events);
          exports3.parseString = function(str, a2, b) {
            var cb, options, parser;
            if (b != null) {
              if (typeof b === "function") {
                cb = b;
              }
              if (typeof a2 === "object") {
                options = a2;
              }
            } else {
              if (typeof a2 === "function") {
                cb = a2;
              }
              options = {};
            }
            parser = new exports3.Parser(options);
            return parser.parseString(str, cb);
          };
          exports3.parseStringPromise = function(str, a2) {
            var options, parser;
            if (typeof a2 === "object") {
              options = a2;
            }
            parser = new exports3.Parser(options);
            return parser.parseStringPromise(str);
          };
        }).call(this);
      }, { "./bom": 491, "./defaults": 493, "./processors": 495, "events": 386, "sax": 465, "timers": 484 }], 495: [function(require2, module3, exports3) {
        (function() {
          var prefixMatch;
          prefixMatch = new RegExp(/(?!xmlns)^.*:/);
          exports3.normalize = function(str) {
            return str.toLowerCase();
          };
          exports3.firstCharLowerCase = function(str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
          };
          exports3.stripPrefix = function(str) {
            return str.replace(prefixMatch, "");
          };
          exports3.parseNumbers = function(str) {
            if (!isNaN(str)) {
              str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
            }
            return str;
          };
          exports3.parseBooleans = function(str) {
            if (/^(?:true|false)$/i.test(str)) {
              str = str.toLowerCase() === "true";
            }
            return str;
          };
        }).call(this);
      }, {}], 496: [function(require2, module3, exports3) {
        (function() {
          var builder, defaults2, parser, processors, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          defaults2 = require2("./defaults");
          builder = require2("./builder");
          parser = require2("./parser");
          processors = require2("./processors");
          exports3.defaults = defaults2.defaults;
          exports3.processors = processors;
          exports3.ValidationError = function(superClass) {
            extend2(ValidationError, superClass);
            function ValidationError(message) {
              this.message = message;
            }
            return ValidationError;
          }(Error);
          exports3.Builder = builder.Builder;
          exports3.Parser = parser.Parser;
          exports3.parseString = parser.parseString;
          exports3.parseStringPromise = parser.parseStringPromise;
        }).call(this);
      }, { "./builder": 492, "./defaults": 493, "./parser": 494, "./processors": 495 }], 497: [function(require2, module3, exports3) {
        (function() {
          module3.exports = {
            Disconnected: 1,
            Preceding: 2,
            Following: 4,
            Contains: 8,
            ContainedBy: 16,
            ImplementationSpecific: 32
          };
        }).call(this);
      }, {}], 498: [function(require2, module3, exports3) {
        (function() {
          module3.exports = {
            Element: 1,
            Attribute: 2,
            Text: 3,
            CData: 4,
            EntityReference: 5,
            EntityDeclaration: 6,
            ProcessingInstruction: 7,
            Comment: 8,
            Document: 9,
            DocType: 10,
            DocumentFragment: 11,
            NotationDeclaration: 12,
            Declaration: 201,
            Raw: 202,
            AttributeDeclaration: 203,
            ElementDeclaration: 204,
            Dummy: 205
          };
        }).call(this);
      }, {}], 499: [function(require2, module3, exports3) {
        (function() {
          var assign2, getValue, isArray2, isEmpty, isFunction2, isObject2, isPlainObject2, slice = [].slice, hasProp = {}.hasOwnProperty;
          assign2 = function() {
            var i, key, len, source, sources, target;
            target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            if (isFunction2(Object.assign)) {
              Object.assign.apply(null, arguments);
            } else {
              for (i = 0, len = sources.length; i < len; i++) {
                source = sources[i];
                if (source != null) {
                  for (key in source) {
                    if (!hasProp.call(source, key))
                      continue;
                    target[key] = source[key];
                  }
                }
              }
            }
            return target;
          };
          isFunction2 = function(val) {
            return !!val && Object.prototype.toString.call(val) === "[object Function]";
          };
          isObject2 = function(val) {
            var ref2;
            return !!val && ((ref2 = typeof val) === "function" || ref2 === "object");
          };
          isArray2 = function(val) {
            if (isFunction2(Array.isArray)) {
              return Array.isArray(val);
            } else {
              return Object.prototype.toString.call(val) === "[object Array]";
            }
          };
          isEmpty = function(val) {
            var key;
            if (isArray2(val)) {
              return !val.length;
            } else {
              for (key in val) {
                if (!hasProp.call(val, key))
                  continue;
                return false;
              }
              return true;
            }
          };
          isPlainObject2 = function(val) {
            var ctor, proto;
            return isObject2(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
          };
          getValue = function(obj) {
            if (isFunction2(obj.valueOf)) {
              return obj.valueOf();
            } else {
              return obj;
            }
          };
          module3.exports.assign = assign2;
          module3.exports.isFunction = isFunction2;
          module3.exports.isObject = isObject2;
          module3.exports.isArray = isArray2;
          module3.exports.isEmpty = isEmpty;
          module3.exports.isPlainObject = isPlainObject2;
          module3.exports.getValue = getValue;
        }).call(this);
      }, {}], 500: [function(require2, module3, exports3) {
        (function() {
          module3.exports = {
            None: 0,
            OpenTag: 1,
            InsideTag: 2,
            CloseTag: 3
          };
        }).call(this);
      }, {}], 501: [function(require2, module3, exports3) {
        (function() {
          var NodeType;
          NodeType = require2("./NodeType");
          require2("./XMLNode");
          module3.exports = function() {
            function XMLAttribute(parent, name, value) {
              this.parent = parent;
              if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
              }
              if (name == null) {
                throw new Error("Missing attribute name. " + this.debugInfo(name));
              }
              this.name = this.stringify.name(name);
              this.value = this.stringify.attValue(value);
              this.type = NodeType.Attribute;
              this.isId = false;
              this.schemaTypeInfo = null;
            }
            Object.defineProperty(XMLAttribute.prototype, "nodeType", {
              get: function() {
                return this.type;
              }
            });
            Object.defineProperty(XMLAttribute.prototype, "ownerElement", {
              get: function() {
                return this.parent;
              }
            });
            Object.defineProperty(XMLAttribute.prototype, "textContent", {
              get: function() {
                return this.value;
              },
              set: function(value) {
                return this.value = value || "";
              }
            });
            Object.defineProperty(XMLAttribute.prototype, "namespaceURI", {
              get: function() {
                return "";
              }
            });
            Object.defineProperty(XMLAttribute.prototype, "prefix", {
              get: function() {
                return "";
              }
            });
            Object.defineProperty(XMLAttribute.prototype, "localName", {
              get: function() {
                return this.name;
              }
            });
            Object.defineProperty(XMLAttribute.prototype, "specified", {
              get: function() {
                return true;
              }
            });
            XMLAttribute.prototype.clone = function() {
              return Object.create(this);
            };
            XMLAttribute.prototype.toString = function(options) {
              return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
            };
            XMLAttribute.prototype.debugInfo = function(name) {
              name = name || this.name;
              if (name == null) {
                return "parent: <" + this.parent.name + ">";
              } else {
                return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
              }
            };
            XMLAttribute.prototype.isEqualNode = function(node) {
              if (node.namespaceURI !== this.namespaceURI) {
                return false;
              }
              if (node.prefix !== this.prefix) {
                return false;
              }
              if (node.localName !== this.localName) {
                return false;
              }
              if (node.value !== this.value) {
                return false;
              }
              return true;
            };
            return XMLAttribute;
          }();
        }).call(this);
      }, { "./NodeType": 498, "./XMLNode": 520 }], 502: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLCharacterData, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLCharacterData = require2("./XMLCharacterData");
          module3.exports = function(superClass) {
            extend2(XMLCData, superClass);
            function XMLCData(parent, text2) {
              XMLCData.__super__.constructor.call(this, parent);
              if (text2 == null) {
                throw new Error("Missing CDATA text. " + this.debugInfo());
              }
              this.name = "#cdata-section";
              this.type = NodeType.CData;
              this.value = this.stringify.cdata(text2);
            }
            XMLCData.prototype.clone = function() {
              return Object.create(this);
            };
            XMLCData.prototype.toString = function(options) {
              return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
            };
            return XMLCData;
          }(XMLCharacterData);
        }).call(this);
      }, { "./NodeType": 498, "./XMLCharacterData": 503 }], 503: [function(require2, module3, exports3) {
        (function() {
          var XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          module3.exports = function(superClass) {
            extend2(XMLCharacterData, superClass);
            function XMLCharacterData(parent) {
              XMLCharacterData.__super__.constructor.call(this, parent);
              this.value = "";
            }
            Object.defineProperty(XMLCharacterData.prototype, "data", {
              get: function() {
                return this.value;
              },
              set: function(value) {
                return this.value = value || "";
              }
            });
            Object.defineProperty(XMLCharacterData.prototype, "length", {
              get: function() {
                return this.value.length;
              }
            });
            Object.defineProperty(XMLCharacterData.prototype, "textContent", {
              get: function() {
                return this.value;
              },
              set: function(value) {
                return this.value = value || "";
              }
            });
            XMLCharacterData.prototype.clone = function() {
              return Object.create(this);
            };
            XMLCharacterData.prototype.substringData = function(offset, count) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.appendData = function(arg) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.insertData = function(offset, arg) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.deleteData = function(offset, count) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.replaceData = function(offset, count, arg) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLCharacterData.prototype.isEqualNode = function(node) {
              if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
                return false;
              }
              if (node.data !== this.data) {
                return false;
              }
              return true;
            };
            return XMLCharacterData;
          }(XMLNode);
        }).call(this);
      }, { "./XMLNode": 520 }], 504: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLCharacterData, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLCharacterData = require2("./XMLCharacterData");
          module3.exports = function(superClass) {
            extend2(XMLComment, superClass);
            function XMLComment(parent, text2) {
              XMLComment.__super__.constructor.call(this, parent);
              if (text2 == null) {
                throw new Error("Missing comment text. " + this.debugInfo());
              }
              this.name = "#comment";
              this.type = NodeType.Comment;
              this.value = this.stringify.comment(text2);
            }
            XMLComment.prototype.clone = function() {
              return Object.create(this);
            };
            XMLComment.prototype.toString = function(options) {
              return this.options.writer.comment(this, this.options.writer.filterOptions(options));
            };
            return XMLComment;
          }(XMLCharacterData);
        }).call(this);
      }, { "./NodeType": 498, "./XMLCharacterData": 503 }], 505: [function(require2, module3, exports3) {
        (function() {
          var XMLDOMErrorHandler, XMLDOMStringList;
          XMLDOMErrorHandler = require2("./XMLDOMErrorHandler");
          XMLDOMStringList = require2("./XMLDOMStringList");
          module3.exports = function() {
            function XMLDOMConfiguration() {
              this.defaultParams = {
                "canonical-form": false,
                "cdata-sections": false,
                "comments": false,
                "datatype-normalization": false,
                "element-content-whitespace": true,
                "entities": true,
                "error-handler": new XMLDOMErrorHandler(),
                "infoset": true,
                "validate-if-schema": false,
                "namespaces": true,
                "namespace-declarations": true,
                "normalize-characters": false,
                "schema-location": "",
                "schema-type": "",
                "split-cdata-sections": true,
                "validate": false,
                "well-formed": true
              };
              this.params = Object.create(this.defaultParams);
            }
            Object.defineProperty(XMLDOMConfiguration.prototype, "parameterNames", {
              get: function() {
                return new XMLDOMStringList(Object.keys(this.defaultParams));
              }
            });
            XMLDOMConfiguration.prototype.getParameter = function(name) {
              if (this.params.hasOwnProperty(name)) {
                return this.params[name];
              } else {
                return null;
              }
            };
            XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {
              return true;
            };
            XMLDOMConfiguration.prototype.setParameter = function(name, value) {
              if (value != null) {
                return this.params[name] = value;
              } else {
                return delete this.params[name];
              }
            };
            return XMLDOMConfiguration;
          }();
        }).call(this);
      }, { "./XMLDOMErrorHandler": 506, "./XMLDOMStringList": 508 }], 506: [function(require2, module3, exports3) {
        (function() {
          module3.exports = function() {
            function XMLDOMErrorHandler() {
            }
            XMLDOMErrorHandler.prototype.handleError = function(error2) {
              throw new Error(error2);
            };
            return XMLDOMErrorHandler;
          }();
        }).call(this);
      }, {}], 507: [function(require2, module3, exports3) {
        (function() {
          module3.exports = function() {
            function XMLDOMImplementation() {
            }
            XMLDOMImplementation.prototype.hasFeature = function(feature, version2) {
              return true;
            };
            XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation.prototype.createHTMLDocument = function(title) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLDOMImplementation.prototype.getFeature = function(feature, version2) {
              throw new Error("This DOM method is not implemented.");
            };
            return XMLDOMImplementation;
          }();
        }).call(this);
      }, {}], 508: [function(require2, module3, exports3) {
        (function() {
          module3.exports = function() {
            function XMLDOMStringList(arr) {
              this.arr = arr || [];
            }
            Object.defineProperty(XMLDOMStringList.prototype, "length", {
              get: function() {
                return this.arr.length;
              }
            });
            XMLDOMStringList.prototype.item = function(index2) {
              return this.arr[index2] || null;
            };
            XMLDOMStringList.prototype.contains = function(str) {
              return this.arr.indexOf(str) !== -1;
            };
            return XMLDOMStringList;
          }();
        }).call(this);
      }, {}], 509: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module3.exports = function(superClass) {
            extend2(XMLDTDAttList, superClass);
            function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              XMLDTDAttList.__super__.constructor.call(this, parent);
              if (elementName == null) {
                throw new Error("Missing DTD element name. " + this.debugInfo());
              }
              if (attributeName == null) {
                throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
              }
              if (!attributeType) {
                throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
              }
              if (!defaultValueType) {
                throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
              }
              if (defaultValueType.indexOf("#") !== 0) {
                defaultValueType = "#" + defaultValueType;
              }
              if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
                throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
              }
              if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
                throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
              }
              this.elementName = this.stringify.name(elementName);
              this.type = NodeType.AttributeDeclaration;
              this.attributeName = this.stringify.name(attributeName);
              this.attributeType = this.stringify.dtdAttType(attributeType);
              if (defaultValue) {
                this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
              }
              this.defaultValueType = defaultValueType;
            }
            XMLDTDAttList.prototype.toString = function(options) {
              return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
            };
            return XMLDTDAttList;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./XMLNode": 520 }], 510: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module3.exports = function(superClass) {
            extend2(XMLDTDElement, superClass);
            function XMLDTDElement(parent, name, value) {
              XMLDTDElement.__super__.constructor.call(this, parent);
              if (name == null) {
                throw new Error("Missing DTD element name. " + this.debugInfo());
              }
              if (!value) {
                value = "(#PCDATA)";
              }
              if (Array.isArray(value)) {
                value = "(" + value.join(",") + ")";
              }
              this.name = this.stringify.name(name);
              this.type = NodeType.ElementDeclaration;
              this.value = this.stringify.dtdElementValue(value);
            }
            XMLDTDElement.prototype.toString = function(options) {
              return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
            };
            return XMLDTDElement;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./XMLNode": 520 }], 511: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLNode, isObject2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          isObject2 = require2("./Utility").isObject;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module3.exports = function(superClass) {
            extend2(XMLDTDEntity, superClass);
            function XMLDTDEntity(parent, pe, name, value) {
              XMLDTDEntity.__super__.constructor.call(this, parent);
              if (name == null) {
                throw new Error("Missing DTD entity name. " + this.debugInfo(name));
              }
              if (value == null) {
                throw new Error("Missing DTD entity value. " + this.debugInfo(name));
              }
              this.pe = !!pe;
              this.name = this.stringify.name(name);
              this.type = NodeType.EntityDeclaration;
              if (!isObject2(value)) {
                this.value = this.stringify.dtdEntityValue(value);
                this.internal = true;
              } else {
                if (!value.pubID && !value.sysID) {
                  throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
                }
                if (value.pubID && !value.sysID) {
                  throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
                }
                this.internal = false;
                if (value.pubID != null) {
                  this.pubID = this.stringify.dtdPubID(value.pubID);
                }
                if (value.sysID != null) {
                  this.sysID = this.stringify.dtdSysID(value.sysID);
                }
                if (value.nData != null) {
                  this.nData = this.stringify.dtdNData(value.nData);
                }
                if (this.pe && this.nData) {
                  throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
                }
              }
            }
            Object.defineProperty(XMLDTDEntity.prototype, "publicId", {
              get: function() {
                return this.pubID;
              }
            });
            Object.defineProperty(XMLDTDEntity.prototype, "systemId", {
              get: function() {
                return this.sysID;
              }
            });
            Object.defineProperty(XMLDTDEntity.prototype, "notationName", {
              get: function() {
                return this.nData || null;
              }
            });
            Object.defineProperty(XMLDTDEntity.prototype, "inputEncoding", {
              get: function() {
                return null;
              }
            });
            Object.defineProperty(XMLDTDEntity.prototype, "xmlEncoding", {
              get: function() {
                return null;
              }
            });
            Object.defineProperty(XMLDTDEntity.prototype, "xmlVersion", {
              get: function() {
                return null;
              }
            });
            XMLDTDEntity.prototype.toString = function(options) {
              return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
            };
            return XMLDTDEntity;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./Utility": 499, "./XMLNode": 520 }], 512: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module3.exports = function(superClass) {
            extend2(XMLDTDNotation, superClass);
            function XMLDTDNotation(parent, name, value) {
              XMLDTDNotation.__super__.constructor.call(this, parent);
              if (name == null) {
                throw new Error("Missing DTD notation name. " + this.debugInfo(name));
              }
              if (!value.pubID && !value.sysID) {
                throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
              }
              this.name = this.stringify.name(name);
              this.type = NodeType.NotationDeclaration;
              if (value.pubID != null) {
                this.pubID = this.stringify.dtdPubID(value.pubID);
              }
              if (value.sysID != null) {
                this.sysID = this.stringify.dtdSysID(value.sysID);
              }
            }
            Object.defineProperty(XMLDTDNotation.prototype, "publicId", {
              get: function() {
                return this.pubID;
              }
            });
            Object.defineProperty(XMLDTDNotation.prototype, "systemId", {
              get: function() {
                return this.sysID;
              }
            });
            XMLDTDNotation.prototype.toString = function(options) {
              return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
            };
            return XMLDTDNotation;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./XMLNode": 520 }], 513: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLNode, isObject2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          isObject2 = require2("./Utility").isObject;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module3.exports = function(superClass) {
            extend2(XMLDeclaration, superClass);
            function XMLDeclaration(parent, version2, encoding, standalone) {
              var ref2;
              XMLDeclaration.__super__.constructor.call(this, parent);
              if (isObject2(version2)) {
                ref2 = version2, version2 = ref2.version, encoding = ref2.encoding, standalone = ref2.standalone;
              }
              if (!version2) {
                version2 = "1.0";
              }
              this.type = NodeType.Declaration;
              this.version = this.stringify.xmlVersion(version2);
              if (encoding != null) {
                this.encoding = this.stringify.xmlEncoding(encoding);
              }
              if (standalone != null) {
                this.standalone = this.stringify.xmlStandalone(standalone);
              }
            }
            XMLDeclaration.prototype.toString = function(options) {
              return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
            };
            return XMLDeclaration;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./Utility": 499, "./XMLNode": 520 }], 514: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLNamedNodeMap, XMLNode, isObject2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          isObject2 = require2("./Utility").isObject;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          XMLDTDAttList = require2("./XMLDTDAttList");
          XMLDTDEntity = require2("./XMLDTDEntity");
          XMLDTDElement = require2("./XMLDTDElement");
          XMLDTDNotation = require2("./XMLDTDNotation");
          XMLNamedNodeMap = require2("./XMLNamedNodeMap");
          module3.exports = function(superClass) {
            extend2(XMLDocType, superClass);
            function XMLDocType(parent, pubID, sysID) {
              var child, i, len, ref2, ref1, ref22;
              XMLDocType.__super__.constructor.call(this, parent);
              this.type = NodeType.DocType;
              if (parent.children) {
                ref2 = parent.children;
                for (i = 0, len = ref2.length; i < len; i++) {
                  child = ref2[i];
                  if (child.type === NodeType.Element) {
                    this.name = child.name;
                    break;
                  }
                }
              }
              this.documentObject = parent;
              if (isObject2(pubID)) {
                ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
              }
              if (sysID == null) {
                ref22 = [pubID, sysID], sysID = ref22[0], pubID = ref22[1];
              }
              if (pubID != null) {
                this.pubID = this.stringify.dtdPubID(pubID);
              }
              if (sysID != null) {
                this.sysID = this.stringify.dtdSysID(sysID);
              }
            }
            Object.defineProperty(XMLDocType.prototype, "entities", {
              get: function() {
                var child, i, len, nodes, ref2;
                nodes = {};
                ref2 = this.children;
                for (i = 0, len = ref2.length; i < len; i++) {
                  child = ref2[i];
                  if (child.type === NodeType.EntityDeclaration && !child.pe) {
                    nodes[child.name] = child;
                  }
                }
                return new XMLNamedNodeMap(nodes);
              }
            });
            Object.defineProperty(XMLDocType.prototype, "notations", {
              get: function() {
                var child, i, len, nodes, ref2;
                nodes = {};
                ref2 = this.children;
                for (i = 0, len = ref2.length; i < len; i++) {
                  child = ref2[i];
                  if (child.type === NodeType.NotationDeclaration) {
                    nodes[child.name] = child;
                  }
                }
                return new XMLNamedNodeMap(nodes);
              }
            });
            Object.defineProperty(XMLDocType.prototype, "publicId", {
              get: function() {
                return this.pubID;
              }
            });
            Object.defineProperty(XMLDocType.prototype, "systemId", {
              get: function() {
                return this.sysID;
              }
            });
            Object.defineProperty(XMLDocType.prototype, "internalSubset", {
              get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
              }
            });
            XMLDocType.prototype.element = function(name, value) {
              var child;
              child = new XMLDTDElement(this, name, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              var child;
              child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.entity = function(name, value) {
              var child;
              child = new XMLDTDEntity(this, false, name, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.pEntity = function(name, value) {
              var child;
              child = new XMLDTDEntity(this, true, name, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.notation = function(name, value) {
              var child;
              child = new XMLDTDNotation(this, name, value);
              this.children.push(child);
              return this;
            };
            XMLDocType.prototype.toString = function(options) {
              return this.options.writer.docType(this, this.options.writer.filterOptions(options));
            };
            XMLDocType.prototype.ele = function(name, value) {
              return this.element(name, value);
            };
            XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
            };
            XMLDocType.prototype.ent = function(name, value) {
              return this.entity(name, value);
            };
            XMLDocType.prototype.pent = function(name, value) {
              return this.pEntity(name, value);
            };
            XMLDocType.prototype.not = function(name, value) {
              return this.notation(name, value);
            };
            XMLDocType.prototype.up = function() {
              return this.root() || this.documentObject;
            };
            XMLDocType.prototype.isEqualNode = function(node) {
              if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
                return false;
              }
              if (node.name !== this.name) {
                return false;
              }
              if (node.publicId !== this.publicId) {
                return false;
              }
              if (node.systemId !== this.systemId) {
                return false;
              }
              return true;
            };
            return XMLDocType;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./Utility": 499, "./XMLDTDAttList": 509, "./XMLDTDElement": 510, "./XMLDTDEntity": 511, "./XMLDTDNotation": 512, "./XMLNamedNodeMap": 519, "./XMLNode": 520 }], 515: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          isPlainObject2 = require2("./Utility").isPlainObject;
          XMLDOMImplementation = require2("./XMLDOMImplementation");
          XMLDOMConfiguration = require2("./XMLDOMConfiguration");
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          XMLStringifier = require2("./XMLStringifier");
          XMLStringWriter = require2("./XMLStringWriter");
          module3.exports = function(superClass) {
            extend2(XMLDocument, superClass);
            function XMLDocument(options) {
              XMLDocument.__super__.constructor.call(this, null);
              this.name = "#document";
              this.type = NodeType.Document;
              this.documentURI = null;
              this.domConfig = new XMLDOMConfiguration();
              options || (options = {});
              if (!options.writer) {
                options.writer = new XMLStringWriter();
              }
              this.options = options;
              this.stringify = new XMLStringifier(options);
            }
            Object.defineProperty(XMLDocument.prototype, "implementation", {
              value: new XMLDOMImplementation()
            });
            Object.defineProperty(XMLDocument.prototype, "doctype", {
              get: function() {
                var child, i, len, ref2;
                ref2 = this.children;
                for (i = 0, len = ref2.length; i < len; i++) {
                  child = ref2[i];
                  if (child.type === NodeType.DocType) {
                    return child;
                  }
                }
                return null;
              }
            });
            Object.defineProperty(XMLDocument.prototype, "documentElement", {
              get: function() {
                return this.rootObject || null;
              }
            });
            Object.defineProperty(XMLDocument.prototype, "inputEncoding", {
              get: function() {
                return null;
              }
            });
            Object.defineProperty(XMLDocument.prototype, "strictErrorChecking", {
              get: function() {
                return false;
              }
            });
            Object.defineProperty(XMLDocument.prototype, "xmlEncoding", {
              get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                  return this.children[0].encoding;
                } else {
                  return null;
                }
              }
            });
            Object.defineProperty(XMLDocument.prototype, "xmlStandalone", {
              get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                  return this.children[0].standalone === "yes";
                } else {
                  return false;
                }
              }
            });
            Object.defineProperty(XMLDocument.prototype, "xmlVersion", {
              get: function() {
                if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                  return this.children[0].version;
                } else {
                  return "1.0";
                }
              }
            });
            Object.defineProperty(XMLDocument.prototype, "URL", {
              get: function() {
                return this.documentURI;
              }
            });
            Object.defineProperty(XMLDocument.prototype, "origin", {
              get: function() {
                return null;
              }
            });
            Object.defineProperty(XMLDocument.prototype, "compatMode", {
              get: function() {
                return null;
              }
            });
            Object.defineProperty(XMLDocument.prototype, "characterSet", {
              get: function() {
                return null;
              }
            });
            Object.defineProperty(XMLDocument.prototype, "contentType", {
              get: function() {
                return null;
              }
            });
            XMLDocument.prototype.end = function(writer) {
              var writerOptions;
              writerOptions = {};
              if (!writer) {
                writer = this.options.writer;
              } else if (isPlainObject2(writer)) {
                writerOptions = writer;
                writer = this.options.writer;
              }
              return writer.document(this, writer.filterOptions(writerOptions));
            };
            XMLDocument.prototype.toString = function(options) {
              return this.options.writer.document(this, this.options.writer.filterOptions(options));
            };
            XMLDocument.prototype.createElement = function(tagName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createDocumentFragment = function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createTextNode = function(data) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createComment = function(data) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createCDATASection = function(data) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createProcessingInstruction = function(target, data) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createAttribute = function(name) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createEntityReference = function(name) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.getElementsByTagName = function(tagname) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.importNode = function(importedNode, deep) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.getElementById = function(elementId) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.adoptNode = function(source) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.normalizeDocument = function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.getElementsByClassName = function(classNames) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createEvent = function(eventInterface) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createRange = function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            return XMLDocument;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./Utility": 499, "./XMLDOMConfiguration": 505, "./XMLDOMImplementation": 507, "./XMLNode": 520, "./XMLStringWriter": 525, "./XMLStringifier": 526 }], 516: [function(require2, module3, exports3) {
        (function() {
          var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction2, isObject2, isPlainObject2, ref2, hasProp = {}.hasOwnProperty;
          ref2 = require2("./Utility"), isObject2 = ref2.isObject, isFunction2 = ref2.isFunction, isPlainObject2 = ref2.isPlainObject, getValue = ref2.getValue;
          NodeType = require2("./NodeType");
          XMLDocument = require2("./XMLDocument");
          XMLElement = require2("./XMLElement");
          XMLCData = require2("./XMLCData");
          XMLComment = require2("./XMLComment");
          XMLRaw = require2("./XMLRaw");
          XMLText = require2("./XMLText");
          XMLProcessingInstruction = require2("./XMLProcessingInstruction");
          XMLDeclaration = require2("./XMLDeclaration");
          XMLDocType = require2("./XMLDocType");
          XMLDTDAttList = require2("./XMLDTDAttList");
          XMLDTDEntity = require2("./XMLDTDEntity");
          XMLDTDElement = require2("./XMLDTDElement");
          XMLDTDNotation = require2("./XMLDTDNotation");
          XMLAttribute = require2("./XMLAttribute");
          XMLStringifier = require2("./XMLStringifier");
          XMLStringWriter = require2("./XMLStringWriter");
          WriterState = require2("./WriterState");
          module3.exports = function() {
            function XMLDocumentCB(options, onData, onEnd) {
              var writerOptions;
              this.name = "?xml";
              this.type = NodeType.Document;
              options || (options = {});
              writerOptions = {};
              if (!options.writer) {
                options.writer = new XMLStringWriter();
              } else if (isPlainObject2(options.writer)) {
                writerOptions = options.writer;
                options.writer = new XMLStringWriter();
              }
              this.options = options;
              this.writer = options.writer;
              this.writerOptions = this.writer.filterOptions(writerOptions);
              this.stringify = new XMLStringifier(options);
              this.onDataCallback = onData || function() {
              };
              this.onEndCallback = onEnd || function() {
              };
              this.currentNode = null;
              this.currentLevel = -1;
              this.openTags = {};
              this.documentStarted = false;
              this.documentCompleted = false;
              this.root = null;
            }
            XMLDocumentCB.prototype.createChildNode = function(node) {
              var att, attName, attributes, child, i, len, ref1, ref22;
              switch (node.type) {
                case NodeType.CData:
                  this.cdata(node.value);
                  break;
                case NodeType.Comment:
                  this.comment(node.value);
                  break;
                case NodeType.Element:
                  attributes = {};
                  ref1 = node.attribs;
                  for (attName in ref1) {
                    if (!hasProp.call(ref1, attName))
                      continue;
                    att = ref1[attName];
                    attributes[attName] = att.value;
                  }
                  this.node(node.name, attributes);
                  break;
                case NodeType.Dummy:
                  this.dummy();
                  break;
                case NodeType.Raw:
                  this.raw(node.value);
                  break;
                case NodeType.Text:
                  this.text(node.value);
                  break;
                case NodeType.ProcessingInstruction:
                  this.instruction(node.target, node.value);
                  break;
                default:
                  throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
              }
              ref22 = node.children;
              for (i = 0, len = ref22.length; i < len; i++) {
                child = ref22[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
              return this;
            };
            XMLDocumentCB.prototype.dummy = function() {
              return this;
            };
            XMLDocumentCB.prototype.node = function(name, attributes, text2) {
              var ref1;
              if (name == null) {
                throw new Error("Missing node name.");
              }
              if (this.root && this.currentLevel === -1) {
                throw new Error("Document can only have one root node. " + this.debugInfo(name));
              }
              this.openCurrent();
              name = getValue(name);
              if (attributes == null) {
                attributes = {};
              }
              attributes = getValue(attributes);
              if (!isObject2(attributes)) {
                ref1 = [attributes, text2], text2 = ref1[0], attributes = ref1[1];
              }
              this.currentNode = new XMLElement(this, name, attributes);
              this.currentNode.children = false;
              this.currentLevel++;
              this.openTags[this.currentLevel] = this.currentNode;
              if (text2 != null) {
                this.text(text2);
              }
              return this;
            };
            XMLDocumentCB.prototype.element = function(name, attributes, text2) {
              var child, i, len, oldValidationFlag, ref1, root;
              if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                this.dtdElement.apply(this, arguments);
              } else {
                if (Array.isArray(name) || isObject2(name) || isFunction2(name)) {
                  oldValidationFlag = this.options.noValidation;
                  this.options.noValidation = true;
                  root = new XMLDocument(this.options).element("TEMP_ROOT");
                  root.element(name);
                  this.options.noValidation = oldValidationFlag;
                  ref1 = root.children;
                  for (i = 0, len = ref1.length; i < len; i++) {
                    child = ref1[i];
                    this.createChildNode(child);
                    if (child.type === NodeType.Element) {
                      this.up();
                    }
                  }
                } else {
                  this.node(name, attributes, text2);
                }
              }
              return this;
            };
            XMLDocumentCB.prototype.attribute = function(name, value) {
              var attName, attValue;
              if (!this.currentNode || this.currentNode.children) {
                throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
              }
              if (name != null) {
                name = getValue(name);
              }
              if (isObject2(name)) {
                for (attName in name) {
                  if (!hasProp.call(name, attName))
                    continue;
                  attValue = name[attName];
                  this.attribute(attName, attValue);
                }
              } else {
                if (isFunction2(value)) {
                  value = value.apply();
                }
                if (this.options.keepNullAttributes && value == null) {
                  this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
                } else if (value != null) {
                  this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
                }
              }
              return this;
            };
            XMLDocumentCB.prototype.text = function(value) {
              var node;
              this.openCurrent();
              node = new XMLText(this, value);
              this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.cdata = function(value) {
              var node;
              this.openCurrent();
              node = new XMLCData(this, value);
              this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.comment = function(value) {
              var node;
              this.openCurrent();
              node = new XMLComment(this, value);
              this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.raw = function(value) {
              var node;
              this.openCurrent();
              node = new XMLRaw(this, value);
              this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.instruction = function(target, value) {
              var i, insTarget, insValue, len, node;
              this.openCurrent();
              if (target != null) {
                target = getValue(target);
              }
              if (value != null) {
                value = getValue(value);
              }
              if (Array.isArray(target)) {
                for (i = 0, len = target.length; i < len; i++) {
                  insTarget = target[i];
                  this.instruction(insTarget);
                }
              } else if (isObject2(target)) {
                for (insTarget in target) {
                  if (!hasProp.call(target, insTarget))
                    continue;
                  insValue = target[insTarget];
                  this.instruction(insTarget, insValue);
                }
              } else {
                if (isFunction2(value)) {
                  value = value.apply();
                }
                node = new XMLProcessingInstruction(this, target, value);
                this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              }
              return this;
            };
            XMLDocumentCB.prototype.declaration = function(version2, encoding, standalone) {
              var node;
              this.openCurrent();
              if (this.documentStarted) {
                throw new Error("declaration() must be the first node.");
              }
              node = new XMLDeclaration(this, version2, encoding, standalone);
              this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
              this.openCurrent();
              if (root == null) {
                throw new Error("Missing root node name.");
              }
              if (this.root) {
                throw new Error("dtd() must come before the root node.");
              }
              this.currentNode = new XMLDocType(this, pubID, sysID);
              this.currentNode.rootNodeName = root;
              this.currentNode.children = false;
              this.currentLevel++;
              this.openTags[this.currentLevel] = this.currentNode;
              return this;
            };
            XMLDocumentCB.prototype.dtdElement = function(name, value) {
              var node;
              this.openCurrent();
              node = new XMLDTDElement(this, name, value);
              this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
              var node;
              this.openCurrent();
              node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
              this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.entity = function(name, value) {
              var node;
              this.openCurrent();
              node = new XMLDTDEntity(this, false, name, value);
              this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.pEntity = function(name, value) {
              var node;
              this.openCurrent();
              node = new XMLDTDEntity(this, true, name, value);
              this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.notation = function(name, value) {
              var node;
              this.openCurrent();
              node = new XMLDTDNotation(this, name, value);
              this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
              return this;
            };
            XMLDocumentCB.prototype.up = function() {
              if (this.currentLevel < 0) {
                throw new Error("The document node has no parent.");
              }
              if (this.currentNode) {
                if (this.currentNode.children) {
                  this.closeNode(this.currentNode);
                } else {
                  this.openNode(this.currentNode);
                }
                this.currentNode = null;
              } else {
                this.closeNode(this.openTags[this.currentLevel]);
              }
              delete this.openTags[this.currentLevel];
              this.currentLevel--;
              return this;
            };
            XMLDocumentCB.prototype.end = function() {
              while (this.currentLevel >= 0) {
                this.up();
              }
              return this.onEnd();
            };
            XMLDocumentCB.prototype.openCurrent = function() {
              if (this.currentNode) {
                this.currentNode.children = true;
                return this.openNode(this.currentNode);
              }
            };
            XMLDocumentCB.prototype.openNode = function(node) {
              var att, chunk, name, ref1;
              if (!node.isOpen) {
                if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
                  this.root = node;
                }
                chunk = "";
                if (node.type === NodeType.Element) {
                  this.writerOptions.state = WriterState.OpenTag;
                  chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
                  ref1 = node.attribs;
                  for (name in ref1) {
                    if (!hasProp.call(ref1, name))
                      continue;
                    att = ref1[name];
                    chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                  }
                  chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
                  this.writerOptions.state = WriterState.InsideTag;
                } else {
                  this.writerOptions.state = WriterState.OpenTag;
                  chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
                  if (node.pubID && node.sysID) {
                    chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                  } else if (node.sysID) {
                    chunk += ' SYSTEM "' + node.sysID + '"';
                  }
                  if (node.children) {
                    chunk += " [";
                    this.writerOptions.state = WriterState.InsideTag;
                  } else {
                    this.writerOptions.state = WriterState.CloseTag;
                    chunk += ">";
                  }
                  chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
                }
                this.onData(chunk, this.currentLevel);
                return node.isOpen = true;
              }
            };
            XMLDocumentCB.prototype.closeNode = function(node) {
              var chunk;
              if (!node.isClosed) {
                chunk = "";
                this.writerOptions.state = WriterState.CloseTag;
                if (node.type === NodeType.Element) {
                  chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
                } else {
                  chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
                }
                this.writerOptions.state = WriterState.None;
                this.onData(chunk, this.currentLevel);
                return node.isClosed = true;
              }
            };
            XMLDocumentCB.prototype.onData = function(chunk, level) {
              this.documentStarted = true;
              return this.onDataCallback(chunk, level + 1);
            };
            XMLDocumentCB.prototype.onEnd = function() {
              this.documentCompleted = true;
              return this.onEndCallback();
            };
            XMLDocumentCB.prototype.debugInfo = function(name) {
              if (name == null) {
                return "";
              } else {
                return "node: <" + name + ">";
              }
            };
            XMLDocumentCB.prototype.ele = function() {
              return this.element.apply(this, arguments);
            };
            XMLDocumentCB.prototype.nod = function(name, attributes, text2) {
              return this.node(name, attributes, text2);
            };
            XMLDocumentCB.prototype.txt = function(value) {
              return this.text(value);
            };
            XMLDocumentCB.prototype.dat = function(value) {
              return this.cdata(value);
            };
            XMLDocumentCB.prototype.com = function(value) {
              return this.comment(value);
            };
            XMLDocumentCB.prototype.ins = function(target, value) {
              return this.instruction(target, value);
            };
            XMLDocumentCB.prototype.dec = function(version2, encoding, standalone) {
              return this.declaration(version2, encoding, standalone);
            };
            XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
              return this.doctype(root, pubID, sysID);
            };
            XMLDocumentCB.prototype.e = function(name, attributes, text2) {
              return this.element(name, attributes, text2);
            };
            XMLDocumentCB.prototype.n = function(name, attributes, text2) {
              return this.node(name, attributes, text2);
            };
            XMLDocumentCB.prototype.t = function(value) {
              return this.text(value);
            };
            XMLDocumentCB.prototype.d = function(value) {
              return this.cdata(value);
            };
            XMLDocumentCB.prototype.c = function(value) {
              return this.comment(value);
            };
            XMLDocumentCB.prototype.r = function(value) {
              return this.raw(value);
            };
            XMLDocumentCB.prototype.i = function(target, value) {
              return this.instruction(target, value);
            };
            XMLDocumentCB.prototype.att = function() {
              if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                return this.attList.apply(this, arguments);
              } else {
                return this.attribute.apply(this, arguments);
              }
            };
            XMLDocumentCB.prototype.a = function() {
              if (this.currentNode && this.currentNode.type === NodeType.DocType) {
                return this.attList.apply(this, arguments);
              } else {
                return this.attribute.apply(this, arguments);
              }
            };
            XMLDocumentCB.prototype.ent = function(name, value) {
              return this.entity(name, value);
            };
            XMLDocumentCB.prototype.pent = function(name, value) {
              return this.pEntity(name, value);
            };
            XMLDocumentCB.prototype.not = function(name, value) {
              return this.notation(name, value);
            };
            return XMLDocumentCB;
          }();
        }).call(this);
      }, { "./NodeType": 498, "./Utility": 499, "./WriterState": 500, "./XMLAttribute": 501, "./XMLCData": 502, "./XMLComment": 504, "./XMLDTDAttList": 509, "./XMLDTDElement": 510, "./XMLDTDEntity": 511, "./XMLDTDNotation": 512, "./XMLDeclaration": 513, "./XMLDocType": 514, "./XMLDocument": 515, "./XMLElement": 518, "./XMLProcessingInstruction": 522, "./XMLRaw": 523, "./XMLStringWriter": 525, "./XMLStringifier": 526, "./XMLText": 527 }], 517: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          module3.exports = function(superClass) {
            extend2(XMLDummy, superClass);
            function XMLDummy(parent) {
              XMLDummy.__super__.constructor.call(this, parent);
              this.type = NodeType.Dummy;
            }
            XMLDummy.prototype.clone = function() {
              return Object.create(this);
            };
            XMLDummy.prototype.toString = function(options) {
              return "";
            };
            return XMLDummy;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./XMLNode": 520 }], 518: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLAttribute, XMLNamedNodeMap, XMLNode, getValue, isFunction2, isObject2, ref2, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          ref2 = require2("./Utility"), isObject2 = ref2.isObject, isFunction2 = ref2.isFunction, getValue = ref2.getValue;
          XMLNode = require2("./XMLNode");
          NodeType = require2("./NodeType");
          XMLAttribute = require2("./XMLAttribute");
          XMLNamedNodeMap = require2("./XMLNamedNodeMap");
          module3.exports = function(superClass) {
            extend2(XMLElement, superClass);
            function XMLElement(parent, name, attributes) {
              var child, j, len, ref1;
              XMLElement.__super__.constructor.call(this, parent);
              if (name == null) {
                throw new Error("Missing element name. " + this.debugInfo());
              }
              this.name = this.stringify.name(name);
              this.type = NodeType.Element;
              this.attribs = {};
              this.schemaTypeInfo = null;
              if (attributes != null) {
                this.attribute(attributes);
              }
              if (parent.type === NodeType.Document) {
                this.isRoot = true;
                this.documentObject = parent;
                parent.rootObject = this;
                if (parent.children) {
                  ref1 = parent.children;
                  for (j = 0, len = ref1.length; j < len; j++) {
                    child = ref1[j];
                    if (child.type === NodeType.DocType) {
                      child.name = this.name;
                      break;
                    }
                  }
                }
              }
            }
            Object.defineProperty(XMLElement.prototype, "tagName", {
              get: function() {
                return this.name;
              }
            });
            Object.defineProperty(XMLElement.prototype, "namespaceURI", {
              get: function() {
                return "";
              }
            });
            Object.defineProperty(XMLElement.prototype, "prefix", {
              get: function() {
                return "";
              }
            });
            Object.defineProperty(XMLElement.prototype, "localName", {
              get: function() {
                return this.name;
              }
            });
            Object.defineProperty(XMLElement.prototype, "id", {
              get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
              }
            });
            Object.defineProperty(XMLElement.prototype, "className", {
              get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
              }
            });
            Object.defineProperty(XMLElement.prototype, "classList", {
              get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
              }
            });
            Object.defineProperty(XMLElement.prototype, "attributes", {
              get: function() {
                if (!this.attributeMap || !this.attributeMap.nodes) {
                  this.attributeMap = new XMLNamedNodeMap(this.attribs);
                }
                return this.attributeMap;
              }
            });
            XMLElement.prototype.clone = function() {
              var att, attName, clonedSelf, ref1;
              clonedSelf = Object.create(this);
              if (clonedSelf.isRoot) {
                clonedSelf.documentObject = null;
              }
              clonedSelf.attribs = {};
              ref1 = this.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName))
                  continue;
                att = ref1[attName];
                clonedSelf.attribs[attName] = att.clone();
              }
              clonedSelf.children = [];
              this.children.forEach(function(child) {
                var clonedChild;
                clonedChild = child.clone();
                clonedChild.parent = clonedSelf;
                return clonedSelf.children.push(clonedChild);
              });
              return clonedSelf;
            };
            XMLElement.prototype.attribute = function(name, value) {
              var attName, attValue;
              if (name != null) {
                name = getValue(name);
              }
              if (isObject2(name)) {
                for (attName in name) {
                  if (!hasProp.call(name, attName))
                    continue;
                  attValue = name[attName];
                  this.attribute(attName, attValue);
                }
              } else {
                if (isFunction2(value)) {
                  value = value.apply();
                }
                if (this.options.keepNullAttributes && value == null) {
                  this.attribs[name] = new XMLAttribute(this, name, "");
                } else if (value != null) {
                  this.attribs[name] = new XMLAttribute(this, name, value);
                }
              }
              return this;
            };
            XMLElement.prototype.removeAttribute = function(name) {
              var attName, j, len;
              if (name == null) {
                throw new Error("Missing attribute name. " + this.debugInfo());
              }
              name = getValue(name);
              if (Array.isArray(name)) {
                for (j = 0, len = name.length; j < len; j++) {
                  attName = name[j];
                  delete this.attribs[attName];
                }
              } else {
                delete this.attribs[name];
              }
              return this;
            };
            XMLElement.prototype.toString = function(options) {
              return this.options.writer.element(this, this.options.writer.filterOptions(options));
            };
            XMLElement.prototype.att = function(name, value) {
              return this.attribute(name, value);
            };
            XMLElement.prototype.a = function(name, value) {
              return this.attribute(name, value);
            };
            XMLElement.prototype.getAttribute = function(name) {
              if (this.attribs.hasOwnProperty(name)) {
                return this.attribs[name].value;
              } else {
                return null;
              }
            };
            XMLElement.prototype.setAttribute = function(name, value) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getAttributeNode = function(name) {
              if (this.attribs.hasOwnProperty(name)) {
                return this.attribs[name];
              } else {
                return null;
              }
            };
            XMLElement.prototype.setAttributeNode = function(newAttr) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.removeAttributeNode = function(oldAttr) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByTagName = function(name) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.setAttributeNodeNS = function(newAttr) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.hasAttribute = function(name) {
              return this.attribs.hasOwnProperty(name);
            };
            XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.setIdAttribute = function(name, isId) {
              if (this.attribs.hasOwnProperty(name)) {
                return this.attribs[name].isId;
              } else {
                return isId;
              }
            };
            XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByTagName = function(tagname) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.getElementsByClassName = function(classNames) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLElement.prototype.isEqualNode = function(node) {
              var i, j, ref1;
              if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
                return false;
              }
              if (node.namespaceURI !== this.namespaceURI) {
                return false;
              }
              if (node.prefix !== this.prefix) {
                return false;
              }
              if (node.localName !== this.localName) {
                return false;
              }
              if (node.attribs.length !== this.attribs.length) {
                return false;
              }
              for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
                if (!this.attribs[i].isEqualNode(node.attribs[i])) {
                  return false;
                }
              }
              return true;
            };
            return XMLElement;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./Utility": 499, "./XMLAttribute": 501, "./XMLNamedNodeMap": 519, "./XMLNode": 520 }], 519: [function(require2, module3, exports3) {
        (function() {
          module3.exports = function() {
            function XMLNamedNodeMap(nodes) {
              this.nodes = nodes;
            }
            Object.defineProperty(XMLNamedNodeMap.prototype, "length", {
              get: function() {
                return Object.keys(this.nodes).length || 0;
              }
            });
            XMLNamedNodeMap.prototype.clone = function() {
              return this.nodes = null;
            };
            XMLNamedNodeMap.prototype.getNamedItem = function(name) {
              return this.nodes[name];
            };
            XMLNamedNodeMap.prototype.setNamedItem = function(node) {
              var oldNode;
              oldNode = this.nodes[node.nodeName];
              this.nodes[node.nodeName] = node;
              return oldNode || null;
            };
            XMLNamedNodeMap.prototype.removeNamedItem = function(name) {
              var oldNode;
              oldNode = this.nodes[name];
              delete this.nodes[name];
              return oldNode || null;
            };
            XMLNamedNodeMap.prototype.item = function(index2) {
              return this.nodes[Object.keys(this.nodes)[index2]] || null;
            };
            XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {
              throw new Error("This DOM method is not implemented.");
            };
            XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {
              throw new Error("This DOM method is not implemented.");
            };
            return XMLNamedNodeMap;
          }();
        }).call(this);
      }, {}], 520: [function(require2, module3, exports3) {
        (function() {
          var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction2, isObject2, ref1, hasProp = {}.hasOwnProperty;
          ref1 = require2("./Utility"), isObject2 = ref1.isObject, isFunction2 = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
          XMLElement = null;
          XMLCData = null;
          XMLComment = null;
          XMLDeclaration = null;
          XMLDocType = null;
          XMLRaw = null;
          XMLText = null;
          XMLProcessingInstruction = null;
          XMLDummy = null;
          NodeType = null;
          XMLNodeList = null;
          DocumentPosition = null;
          module3.exports = function() {
            function XMLNode(parent1) {
              this.parent = parent1;
              if (this.parent) {
                this.options = this.parent.options;
                this.stringify = this.parent.stringify;
              }
              this.value = null;
              this.children = [];
              this.baseURI = null;
              if (!XMLElement) {
                XMLElement = require2("./XMLElement");
                XMLCData = require2("./XMLCData");
                XMLComment = require2("./XMLComment");
                XMLDeclaration = require2("./XMLDeclaration");
                XMLDocType = require2("./XMLDocType");
                XMLRaw = require2("./XMLRaw");
                XMLText = require2("./XMLText");
                XMLProcessingInstruction = require2("./XMLProcessingInstruction");
                XMLDummy = require2("./XMLDummy");
                NodeType = require2("./NodeType");
                XMLNodeList = require2("./XMLNodeList");
                require2("./XMLNamedNodeMap");
                DocumentPosition = require2("./DocumentPosition");
              }
            }
            Object.defineProperty(XMLNode.prototype, "nodeName", {
              get: function() {
                return this.name;
              }
            });
            Object.defineProperty(XMLNode.prototype, "nodeType", {
              get: function() {
                return this.type;
              }
            });
            Object.defineProperty(XMLNode.prototype, "nodeValue", {
              get: function() {
                return this.value;
              }
            });
            Object.defineProperty(XMLNode.prototype, "parentNode", {
              get: function() {
                return this.parent;
              }
            });
            Object.defineProperty(XMLNode.prototype, "childNodes", {
              get: function() {
                if (!this.childNodeList || !this.childNodeList.nodes) {
                  this.childNodeList = new XMLNodeList(this.children);
                }
                return this.childNodeList;
              }
            });
            Object.defineProperty(XMLNode.prototype, "firstChild", {
              get: function() {
                return this.children[0] || null;
              }
            });
            Object.defineProperty(XMLNode.prototype, "lastChild", {
              get: function() {
                return this.children[this.children.length - 1] || null;
              }
            });
            Object.defineProperty(XMLNode.prototype, "previousSibling", {
              get: function() {
                var i;
                i = this.parent.children.indexOf(this);
                return this.parent.children[i - 1] || null;
              }
            });
            Object.defineProperty(XMLNode.prototype, "nextSibling", {
              get: function() {
                var i;
                i = this.parent.children.indexOf(this);
                return this.parent.children[i + 1] || null;
              }
            });
            Object.defineProperty(XMLNode.prototype, "ownerDocument", {
              get: function() {
                return this.document() || null;
              }
            });
            Object.defineProperty(XMLNode.prototype, "textContent", {
              get: function() {
                var child, j, len, ref2, str;
                if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
                  str = "";
                  ref2 = this.children;
                  for (j = 0, len = ref2.length; j < len; j++) {
                    child = ref2[j];
                    if (child.textContent) {
                      str += child.textContent;
                    }
                  }
                  return str;
                } else {
                  return null;
                }
              },
              set: function(value) {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
              }
            });
            XMLNode.prototype.setParent = function(parent) {
              var child, j, len, ref2, results;
              this.parent = parent;
              if (parent) {
                this.options = parent.options;
                this.stringify = parent.stringify;
              }
              ref2 = this.children;
              results = [];
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                results.push(child.setParent(this));
              }
              return results;
            };
            XMLNode.prototype.element = function(name, attributes, text2) {
              var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
              lastChild = null;
              if (attributes === null && text2 == null) {
                ref2 = [{}, null], attributes = ref2[0], text2 = ref2[1];
              }
              if (attributes == null) {
                attributes = {};
              }
              attributes = getValue(attributes);
              if (!isObject2(attributes)) {
                ref3 = [attributes, text2], text2 = ref3[0], attributes = ref3[1];
              }
              if (name != null) {
                name = getValue(name);
              }
              if (Array.isArray(name)) {
                for (j = 0, len = name.length; j < len; j++) {
                  item = name[j];
                  lastChild = this.element(item);
                }
              } else if (isFunction2(name)) {
                lastChild = this.element(name.apply());
              } else if (isObject2(name)) {
                for (key in name) {
                  if (!hasProp.call(name, key))
                    continue;
                  val = name[key];
                  if (isFunction2(val)) {
                    val = val.apply();
                  }
                  if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                    lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                  } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                    lastChild = this.dummy();
                  } else if (isObject2(val) && isEmpty(val)) {
                    lastChild = this.element(key);
                  } else if (!this.options.keepNullNodes && val == null) {
                    lastChild = this.dummy();
                  } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                    for (k = 0, len1 = val.length; k < len1; k++) {
                      item = val[k];
                      childNode = {};
                      childNode[key] = item;
                      lastChild = this.element(childNode);
                    }
                  } else if (isObject2(val)) {
                    if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                      lastChild = this.element(val);
                    } else {
                      lastChild = this.element(key);
                      lastChild.element(val);
                    }
                  } else {
                    lastChild = this.element(key, val);
                  }
                }
              } else if (!this.options.keepNullNodes && text2 === null) {
                lastChild = this.dummy();
              } else {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.text(text2);
                } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
                  lastChild = this.cdata(text2);
                } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
                  lastChild = this.comment(text2);
                } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
                  lastChild = this.raw(text2);
                } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
                  lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text2);
                } else {
                  lastChild = this.node(name, attributes, text2);
                }
              }
              if (lastChild == null) {
                throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
              }
              return lastChild;
            };
            XMLNode.prototype.insertBefore = function(name, attributes, text2) {
              var child, i, newChild, refChild, removed;
              if (name != null ? name.type : void 0) {
                newChild = name;
                refChild = attributes;
                newChild.setParent(this);
                if (refChild) {
                  i = children.indexOf(refChild);
                  removed = children.splice(i);
                  children.push(newChild);
                  Array.prototype.push.apply(children, removed);
                } else {
                  children.push(newChild);
                }
                return newChild;
              } else {
                if (this.isRoot) {
                  throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
                }
                i = this.parent.children.indexOf(this);
                removed = this.parent.children.splice(i);
                child = this.parent.element(name, attributes, text2);
                Array.prototype.push.apply(this.parent.children, removed);
                return child;
              }
            };
            XMLNode.prototype.insertAfter = function(name, attributes, text2) {
              var child, i, removed;
              if (this.isRoot) {
                throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
              }
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i + 1);
              child = this.parent.element(name, attributes, text2);
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            };
            XMLNode.prototype.remove = function() {
              var i;
              if (this.isRoot) {
                throw new Error("Cannot remove the root element. " + this.debugInfo());
              }
              i = this.parent.children.indexOf(this);
              [].splice.apply(this.parent.children, [i, i - i + 1].concat([]));
              return this.parent;
            };
            XMLNode.prototype.node = function(name, attributes, text2) {
              var child, ref2;
              if (name != null) {
                name = getValue(name);
              }
              attributes || (attributes = {});
              attributes = getValue(attributes);
              if (!isObject2(attributes)) {
                ref2 = [attributes, text2], text2 = ref2[0], attributes = ref2[1];
              }
              child = new XMLElement(this, name, attributes);
              if (text2 != null) {
                child.text(text2);
              }
              this.children.push(child);
              return child;
            };
            XMLNode.prototype.text = function(value) {
              var child;
              if (isObject2(value)) {
                this.element(value);
              }
              child = new XMLText(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.cdata = function(value) {
              var child;
              child = new XMLCData(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.comment = function(value) {
              var child;
              child = new XMLComment(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.commentBefore = function(value) {
              var i, removed;
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i);
              this.parent.comment(value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.commentAfter = function(value) {
              var i, removed;
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i + 1);
              this.parent.comment(value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.raw = function(value) {
              var child;
              child = new XMLRaw(this, value);
              this.children.push(child);
              return this;
            };
            XMLNode.prototype.dummy = function() {
              var child;
              child = new XMLDummy(this);
              return child;
            };
            XMLNode.prototype.instruction = function(target, value) {
              var insTarget, insValue, instruction, j, len;
              if (target != null) {
                target = getValue(target);
              }
              if (value != null) {
                value = getValue(value);
              }
              if (Array.isArray(target)) {
                for (j = 0, len = target.length; j < len; j++) {
                  insTarget = target[j];
                  this.instruction(insTarget);
                }
              } else if (isObject2(target)) {
                for (insTarget in target) {
                  if (!hasProp.call(target, insTarget))
                    continue;
                  insValue = target[insTarget];
                  this.instruction(insTarget, insValue);
                }
              } else {
                if (isFunction2(value)) {
                  value = value.apply();
                }
                instruction = new XMLProcessingInstruction(this, target, value);
                this.children.push(instruction);
              }
              return this;
            };
            XMLNode.prototype.instructionBefore = function(target, value) {
              var i, removed;
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i);
              this.parent.instruction(target, value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.instructionAfter = function(target, value) {
              var i, removed;
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i + 1);
              this.parent.instruction(target, value);
              Array.prototype.push.apply(this.parent.children, removed);
              return this;
            };
            XMLNode.prototype.declaration = function(version2, encoding, standalone) {
              var doc, xmldec;
              doc = this.document();
              xmldec = new XMLDeclaration(doc, version2, encoding, standalone);
              if (doc.children.length === 0) {
                doc.children.unshift(xmldec);
              } else if (doc.children[0].type === NodeType.Declaration) {
                doc.children[0] = xmldec;
              } else {
                doc.children.unshift(xmldec);
              }
              return doc.root() || doc;
            };
            XMLNode.prototype.dtd = function(pubID, sysID) {
              var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
              doc = this.document();
              doctype = new XMLDocType(doc, pubID, sysID);
              ref2 = doc.children;
              for (i = j = 0, len = ref2.length; j < len; i = ++j) {
                child = ref2[i];
                if (child.type === NodeType.DocType) {
                  doc.children[i] = doctype;
                  return doctype;
                }
              }
              ref3 = doc.children;
              for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
                child = ref3[i];
                if (child.isRoot) {
                  doc.children.splice(i, 0, doctype);
                  return doctype;
                }
              }
              doc.children.push(doctype);
              return doctype;
            };
            XMLNode.prototype.up = function() {
              if (this.isRoot) {
                throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
              }
              return this.parent;
            };
            XMLNode.prototype.root = function() {
              var node;
              node = this;
              while (node) {
                if (node.type === NodeType.Document) {
                  return node.rootObject;
                } else if (node.isRoot) {
                  return node;
                } else {
                  node = node.parent;
                }
              }
            };
            XMLNode.prototype.document = function() {
              var node;
              node = this;
              while (node) {
                if (node.type === NodeType.Document) {
                  return node;
                } else {
                  node = node.parent;
                }
              }
            };
            XMLNode.prototype.end = function(options) {
              return this.document().end(options);
            };
            XMLNode.prototype.prev = function() {
              var i;
              i = this.parent.children.indexOf(this);
              if (i < 1) {
                throw new Error("Already at the first node. " + this.debugInfo());
              }
              return this.parent.children[i - 1];
            };
            XMLNode.prototype.next = function() {
              var i;
              i = this.parent.children.indexOf(this);
              if (i === -1 || i === this.parent.children.length - 1) {
                throw new Error("Already at the last node. " + this.debugInfo());
              }
              return this.parent.children[i + 1];
            };
            XMLNode.prototype.importDocument = function(doc) {
              var clonedRoot;
              clonedRoot = doc.root().clone();
              clonedRoot.parent = this;
              clonedRoot.isRoot = false;
              this.children.push(clonedRoot);
              return this;
            };
            XMLNode.prototype.debugInfo = function(name) {
              var ref2, ref3;
              name = name || this.name;
              if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
                return "";
              } else if (name == null) {
                return "parent: <" + this.parent.name + ">";
              } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
                return "node: <" + name + ">";
              } else {
                return "node: <" + name + ">, parent: <" + this.parent.name + ">";
              }
            };
            XMLNode.prototype.ele = function(name, attributes, text2) {
              return this.element(name, attributes, text2);
            };
            XMLNode.prototype.nod = function(name, attributes, text2) {
              return this.node(name, attributes, text2);
            };
            XMLNode.prototype.txt = function(value) {
              return this.text(value);
            };
            XMLNode.prototype.dat = function(value) {
              return this.cdata(value);
            };
            XMLNode.prototype.com = function(value) {
              return this.comment(value);
            };
            XMLNode.prototype.ins = function(target, value) {
              return this.instruction(target, value);
            };
            XMLNode.prototype.doc = function() {
              return this.document();
            };
            XMLNode.prototype.dec = function(version2, encoding, standalone) {
              return this.declaration(version2, encoding, standalone);
            };
            XMLNode.prototype.e = function(name, attributes, text2) {
              return this.element(name, attributes, text2);
            };
            XMLNode.prototype.n = function(name, attributes, text2) {
              return this.node(name, attributes, text2);
            };
            XMLNode.prototype.t = function(value) {
              return this.text(value);
            };
            XMLNode.prototype.d = function(value) {
              return this.cdata(value);
            };
            XMLNode.prototype.c = function(value) {
              return this.comment(value);
            };
            XMLNode.prototype.r = function(value) {
              return this.raw(value);
            };
            XMLNode.prototype.i = function(target, value) {
              return this.instruction(target, value);
            };
            XMLNode.prototype.u = function() {
              return this.up();
            };
            XMLNode.prototype.importXMLBuilder = function(doc) {
              return this.importDocument(doc);
            };
            XMLNode.prototype.replaceChild = function(newChild, oldChild) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.removeChild = function(oldChild) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.appendChild = function(newChild) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.hasChildNodes = function() {
              return this.children.length !== 0;
            };
            XMLNode.prototype.cloneNode = function(deep) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.normalize = function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.isSupported = function(feature, version2) {
              return true;
            };
            XMLNode.prototype.hasAttributes = function() {
              return this.attribs.length !== 0;
            };
            XMLNode.prototype.compareDocumentPosition = function(other) {
              var ref2, res;
              ref2 = this;
              if (ref2 === other) {
                return 0;
              } else if (this.document() !== other.document()) {
                res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
                if (Math.random() < 0.5) {
                  res |= DocumentPosition.Preceding;
                } else {
                  res |= DocumentPosition.Following;
                }
                return res;
              } else if (ref2.isAncestor(other)) {
                return DocumentPosition.Contains | DocumentPosition.Preceding;
              } else if (ref2.isDescendant(other)) {
                return DocumentPosition.Contains | DocumentPosition.Following;
              } else if (ref2.isPreceding(other)) {
                return DocumentPosition.Preceding;
              } else {
                return DocumentPosition.Following;
              }
            };
            XMLNode.prototype.isSameNode = function(other) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.lookupPrefix = function(namespaceURI) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.lookupNamespaceURI = function(prefix) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.isEqualNode = function(node) {
              var i, j, ref2;
              if (node.nodeType !== this.nodeType) {
                return false;
              }
              if (node.children.length !== this.children.length) {
                return false;
              }
              for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
                if (!this.children[i].isEqualNode(node.children[i])) {
                  return false;
                }
              }
              return true;
            };
            XMLNode.prototype.getFeature = function(feature, version2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.setUserData = function(key, data, handler) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.getUserData = function(key) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLNode.prototype.contains = function(other) {
              if (!other) {
                return false;
              }
              return other === this || this.isDescendant(other);
            };
            XMLNode.prototype.isDescendant = function(node) {
              var child, isDescendantChild, j, len, ref2;
              ref2 = this.children;
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                if (node === child) {
                  return true;
                }
                isDescendantChild = child.isDescendant(node);
                if (isDescendantChild) {
                  return true;
                }
              }
              return false;
            };
            XMLNode.prototype.isAncestor = function(node) {
              return node.isDescendant(this);
            };
            XMLNode.prototype.isPreceding = function(node) {
              var nodePos, thisPos;
              nodePos = this.treePosition(node);
              thisPos = this.treePosition(this);
              if (nodePos === -1 || thisPos === -1) {
                return false;
              } else {
                return nodePos < thisPos;
              }
            };
            XMLNode.prototype.isFollowing = function(node) {
              var nodePos, thisPos;
              nodePos = this.treePosition(node);
              thisPos = this.treePosition(this);
              if (nodePos === -1 || thisPos === -1) {
                return false;
              } else {
                return nodePos > thisPos;
              }
            };
            XMLNode.prototype.treePosition = function(node) {
              var found, pos;
              pos = 0;
              found = false;
              this.foreachTreeNode(this.document(), function(childNode) {
                pos++;
                if (!found && childNode === node) {
                  return found = true;
                }
              });
              if (found) {
                return pos;
              } else {
                return -1;
              }
            };
            XMLNode.prototype.foreachTreeNode = function(node, func2) {
              var child, j, len, ref2, res;
              node || (node = this.document());
              ref2 = node.children;
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                if (res = func2(child)) {
                  return res;
                } else {
                  res = this.foreachTreeNode(child, func2);
                  if (res) {
                    return res;
                  }
                }
              }
            };
            return XMLNode;
          }();
        }).call(this);
      }, { "./DocumentPosition": 497, "./NodeType": 498, "./Utility": 499, "./XMLCData": 502, "./XMLComment": 504, "./XMLDeclaration": 513, "./XMLDocType": 514, "./XMLDummy": 517, "./XMLElement": 518, "./XMLNamedNodeMap": 519, "./XMLNodeList": 521, "./XMLProcessingInstruction": 522, "./XMLRaw": 523, "./XMLText": 527 }], 521: [function(require2, module3, exports3) {
        (function() {
          module3.exports = function() {
            function XMLNodeList(nodes) {
              this.nodes = nodes;
            }
            Object.defineProperty(XMLNodeList.prototype, "length", {
              get: function() {
                return this.nodes.length || 0;
              }
            });
            XMLNodeList.prototype.clone = function() {
              return this.nodes = null;
            };
            XMLNodeList.prototype.item = function(index2) {
              return this.nodes[index2] || null;
            };
            return XMLNodeList;
          }();
        }).call(this);
      }, {}], 522: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLCharacterData, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLCharacterData = require2("./XMLCharacterData");
          module3.exports = function(superClass) {
            extend2(XMLProcessingInstruction, superClass);
            function XMLProcessingInstruction(parent, target, value) {
              XMLProcessingInstruction.__super__.constructor.call(this, parent);
              if (target == null) {
                throw new Error("Missing instruction target. " + this.debugInfo());
              }
              this.type = NodeType.ProcessingInstruction;
              this.target = this.stringify.insTarget(target);
              this.name = this.target;
              if (value) {
                this.value = this.stringify.insValue(value);
              }
            }
            XMLProcessingInstruction.prototype.clone = function() {
              return Object.create(this);
            };
            XMLProcessingInstruction.prototype.toString = function(options) {
              return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
            };
            XMLProcessingInstruction.prototype.isEqualNode = function(node) {
              if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
                return false;
              }
              if (node.target !== this.target) {
                return false;
              }
              return true;
            };
            return XMLProcessingInstruction;
          }(XMLCharacterData);
        }).call(this);
      }, { "./NodeType": 498, "./XMLCharacterData": 503 }], 523: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLNode, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLNode = require2("./XMLNode");
          module3.exports = function(superClass) {
            extend2(XMLRaw, superClass);
            function XMLRaw(parent, text2) {
              XMLRaw.__super__.constructor.call(this, parent);
              if (text2 == null) {
                throw new Error("Missing raw text. " + this.debugInfo());
              }
              this.type = NodeType.Raw;
              this.value = this.stringify.raw(text2);
            }
            XMLRaw.prototype.clone = function() {
              return Object.create(this);
            };
            XMLRaw.prototype.toString = function(options) {
              return this.options.writer.raw(this, this.options.writer.filterOptions(options));
            };
            return XMLRaw;
          }(XMLNode);
        }).call(this);
      }, { "./NodeType": 498, "./XMLNode": 520 }], 524: [function(require2, module3, exports3) {
        (function() {
          var NodeType, WriterState, XMLWriterBase, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLWriterBase = require2("./XMLWriterBase");
          WriterState = require2("./WriterState");
          module3.exports = function(superClass) {
            extend2(XMLStreamWriter, superClass);
            function XMLStreamWriter(stream, options) {
              this.stream = stream;
              XMLStreamWriter.__super__.constructor.call(this, options);
            }
            XMLStreamWriter.prototype.endline = function(node, options, level) {
              if (node.isLastRootNode && options.state === WriterState.CloseTag) {
                return "";
              } else {
                return XMLStreamWriter.__super__.endline.call(this, node, options, level);
              }
            };
            XMLStreamWriter.prototype.document = function(doc, options) {
              var child, i, j, k, len, len1, ref2, ref1, results;
              ref2 = doc.children;
              for (i = j = 0, len = ref2.length; j < len; i = ++j) {
                child = ref2[i];
                child.isLastRootNode = i === doc.children.length - 1;
              }
              options = this.filterOptions(options);
              ref1 = doc.children;
              results = [];
              for (k = 0, len1 = ref1.length; k < len1; k++) {
                child = ref1[k];
                results.push(this.writeChildNode(child, options, 0));
              }
              return results;
            };
            XMLStreamWriter.prototype.attribute = function(att, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
            };
            XMLStreamWriter.prototype.cdata = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.comment = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.declaration = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.docType = function(node, options, level) {
              var child, j, len, ref2;
              level || (level = 0);
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              this.stream.write(this.indent(node, options, level));
              this.stream.write("<!DOCTYPE " + node.root().name);
              if (node.pubID && node.sysID) {
                this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
              } else if (node.sysID) {
                this.stream.write(' SYSTEM "' + node.sysID + '"');
              }
              if (node.children.length > 0) {
                this.stream.write(" [");
                this.stream.write(this.endline(node, options, level));
                options.state = WriterState.InsideTag;
                ref2 = node.children;
                for (j = 0, len = ref2.length; j < len; j++) {
                  child = ref2[j];
                  this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write("]");
              }
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + ">");
              this.stream.write(this.endline(node, options, level));
              options.state = WriterState.None;
              return this.closeNode(node, options, level);
            };
            XMLStreamWriter.prototype.element = function(node, options, level) {
              var att, child, childNodeCount, firstChildNode, j, len, name, ref2, ref1;
              level || (level = 0);
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              this.stream.write(this.indent(node, options, level) + "<" + node.name);
              ref2 = node.attribs;
              for (name in ref2) {
                if (!hasProp.call(ref2, name))
                  continue;
                att = ref2[name];
                this.attribute(att, options, level);
              }
              childNodeCount = node.children.length;
              firstChildNode = childNodeCount === 0 ? null : node.children[0];
              if (childNodeCount === 0 || node.children.every(function(e2) {
                return (e2.type === NodeType.Text || e2.type === NodeType.Raw) && e2.value === "";
              })) {
                if (options.allowEmpty) {
                  this.stream.write(">");
                  options.state = WriterState.CloseTag;
                  this.stream.write("</" + node.name + ">");
                } else {
                  options.state = WriterState.CloseTag;
                  this.stream.write(options.spaceBeforeSlash + "/>");
                }
              } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                this.stream.write(">");
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                options.state = WriterState.CloseTag;
                this.stream.write("</" + node.name + ">");
              } else {
                this.stream.write(">" + this.endline(node, options, level));
                options.state = WriterState.InsideTag;
                ref1 = node.children;
                for (j = 0, len = ref1.length; j < len; j++) {
                  child = ref1[j];
                  this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
              }
              this.stream.write(this.endline(node, options, level));
              options.state = WriterState.None;
              return this.closeNode(node, options, level);
            };
            XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.raw = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.text = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.dtdElement = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
            };
            XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {
              return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
            };
            return XMLStreamWriter;
          }(XMLWriterBase);
        }).call(this);
      }, { "./NodeType": 498, "./WriterState": 500, "./XMLWriterBase": 528 }], 525: [function(require2, module3, exports3) {
        (function() {
          var XMLWriterBase, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          XMLWriterBase = require2("./XMLWriterBase");
          module3.exports = function(superClass) {
            extend2(XMLStringWriter, superClass);
            function XMLStringWriter(options) {
              XMLStringWriter.__super__.constructor.call(this, options);
            }
            XMLStringWriter.prototype.document = function(doc, options) {
              var child, i, len, r, ref2;
              options = this.filterOptions(options);
              r = "";
              ref2 = doc.children;
              for (i = 0, len = ref2.length; i < len; i++) {
                child = ref2[i];
                r += this.writeChildNode(child, options, 0);
              }
              if (options.pretty && r.slice(-options.newline.length) === options.newline) {
                r = r.slice(0, -options.newline.length);
              }
              return r;
            };
            return XMLStringWriter;
          }(XMLWriterBase);
        }).call(this);
      }, { "./XMLWriterBase": 528 }], 526: [function(require2, module3, exports3) {
        (function() {
          var bind = function(fn, me) {
            return function() {
              return fn.apply(me, arguments);
            };
          }, hasProp = {}.hasOwnProperty;
          module3.exports = function() {
            function XMLStringifier(options) {
              this.assertLegalName = bind(this.assertLegalName, this);
              this.assertLegalChar = bind(this.assertLegalChar, this);
              var key, ref2, value;
              options || (options = {});
              this.options = options;
              if (!this.options.version) {
                this.options.version = "1.0";
              }
              ref2 = options.stringify || {};
              for (key in ref2) {
                if (!hasProp.call(ref2, key))
                  continue;
                value = ref2[key];
                this[key] = value;
              }
            }
            XMLStringifier.prototype.name = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalName("" + val || "");
            };
            XMLStringifier.prototype.text = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar(this.textEscape("" + val || ""));
            };
            XMLStringifier.prototype.cdata = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              val = val.replace("]]>", "]]]]><![CDATA[>");
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.comment = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              if (val.match(/--/)) {
                throw new Error("Comment text cannot contain double-hypen: " + val);
              }
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.raw = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return "" + val || "";
            };
            XMLStringifier.prototype.attValue = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar(this.attEscape(val = "" + val || ""));
            };
            XMLStringifier.prototype.insTarget = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.insValue = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              if (val.match(/\?>/)) {
                throw new Error("Invalid processing instruction value: " + val);
              }
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.xmlVersion = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              if (!val.match(/1\.[0-9]+/)) {
                throw new Error("Invalid version number: " + val);
              }
              return val;
            };
            XMLStringifier.prototype.xmlEncoding = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              val = "" + val || "";
              if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
                throw new Error("Invalid encoding: " + val);
              }
              return this.assertLegalChar(val);
            };
            XMLStringifier.prototype.xmlStandalone = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              if (val) {
                return "yes";
              } else {
                return "no";
              }
            };
            XMLStringifier.prototype.dtdPubID = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdSysID = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdElementValue = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdAttType = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdAttDefault = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdEntityValue = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.dtdNData = function(val) {
              if (this.options.noValidation) {
                return val;
              }
              return this.assertLegalChar("" + val || "");
            };
            XMLStringifier.prototype.convertAttKey = "@";
            XMLStringifier.prototype.convertPIKey = "?";
            XMLStringifier.prototype.convertTextKey = "#text";
            XMLStringifier.prototype.convertCDataKey = "#cdata";
            XMLStringifier.prototype.convertCommentKey = "#comment";
            XMLStringifier.prototype.convertRawKey = "#raw";
            XMLStringifier.prototype.assertLegalChar = function(str) {
              var regex2, res;
              if (this.options.noValidation) {
                return str;
              }
              regex2 = "";
              if (this.options.version === "1.0") {
                regex2 = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex2)) {
                  throw new Error("Invalid character in string: " + str + " at index " + res.index);
                }
              } else if (this.options.version === "1.1") {
                regex2 = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                if (res = str.match(regex2)) {
                  throw new Error("Invalid character in string: " + str + " at index " + res.index);
                }
              }
              return str;
            };
            XMLStringifier.prototype.assertLegalName = function(str) {
              var regex2;
              if (this.options.noValidation) {
                return str;
              }
              this.assertLegalChar(str);
              regex2 = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
              if (!str.match(regex2)) {
                throw new Error("Invalid character in name");
              }
              return str;
            };
            XMLStringifier.prototype.textEscape = function(str) {
              var ampregex;
              if (this.options.noValidation) {
                return str;
              }
              ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
              return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
            };
            XMLStringifier.prototype.attEscape = function(str) {
              var ampregex;
              if (this.options.noValidation) {
                return str;
              }
              ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
              return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
            };
            return XMLStringifier;
          }();
        }).call(this);
      }, {}], 527: [function(require2, module3, exports3) {
        (function() {
          var NodeType, XMLCharacterData, extend2 = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          }, hasProp = {}.hasOwnProperty;
          NodeType = require2("./NodeType");
          XMLCharacterData = require2("./XMLCharacterData");
          module3.exports = function(superClass) {
            extend2(XMLText, superClass);
            function XMLText(parent, text2) {
              XMLText.__super__.constructor.call(this, parent);
              if (text2 == null) {
                throw new Error("Missing element text. " + this.debugInfo());
              }
              this.name = "#text";
              this.type = NodeType.Text;
              this.value = this.stringify.text(text2);
            }
            Object.defineProperty(XMLText.prototype, "isElementContentWhitespace", {
              get: function() {
                throw new Error("This DOM method is not implemented." + this.debugInfo());
              }
            });
            Object.defineProperty(XMLText.prototype, "wholeText", {
              get: function() {
                var next, prev, str;
                str = "";
                prev = this.previousSibling;
                while (prev) {
                  str = prev.data + str;
                  prev = prev.previousSibling;
                }
                str += this.data;
                next = this.nextSibling;
                while (next) {
                  str = str + next.data;
                  next = next.nextSibling;
                }
                return str;
              }
            });
            XMLText.prototype.clone = function() {
              return Object.create(this);
            };
            XMLText.prototype.toString = function(options) {
              return this.options.writer.text(this, this.options.writer.filterOptions(options));
            };
            XMLText.prototype.splitText = function(offset) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            XMLText.prototype.replaceWholeText = function(content2) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            };
            return XMLText;
          }(XMLCharacterData);
        }).call(this);
      }, { "./NodeType": 498, "./XMLCharacterData": 503 }], 528: [function(require2, module3, exports3) {
        (function() {
          var NodeType, WriterState, assign2, hasProp = {}.hasOwnProperty;
          assign2 = require2("./Utility").assign;
          NodeType = require2("./NodeType");
          require2("./XMLDeclaration");
          require2("./XMLDocType");
          require2("./XMLCData");
          require2("./XMLComment");
          require2("./XMLElement");
          require2("./XMLRaw");
          require2("./XMLText");
          require2("./XMLProcessingInstruction");
          require2("./XMLDummy");
          require2("./XMLDTDAttList");
          require2("./XMLDTDElement");
          require2("./XMLDTDEntity");
          require2("./XMLDTDNotation");
          WriterState = require2("./WriterState");
          module3.exports = function() {
            function XMLWriterBase(options) {
              var key, ref2, value;
              options || (options = {});
              this.options = options;
              ref2 = options.writer || {};
              for (key in ref2) {
                if (!hasProp.call(ref2, key))
                  continue;
                value = ref2[key];
                this["_" + key] = this[key];
                this[key] = value;
              }
            }
            XMLWriterBase.prototype.filterOptions = function(options) {
              var filteredOptions, ref2, ref1, ref22, ref3, ref4, ref5, ref6;
              options || (options = {});
              options = assign2({}, this.options, options);
              filteredOptions = {
                writer: this
              };
              filteredOptions.pretty = options.pretty || false;
              filteredOptions.allowEmpty = options.allowEmpty || false;
              filteredOptions.indent = (ref2 = options.indent) != null ? ref2 : "  ";
              filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
              filteredOptions.offset = (ref22 = options.offset) != null ? ref22 : 0;
              filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
              filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
              if (filteredOptions.spaceBeforeSlash === true) {
                filteredOptions.spaceBeforeSlash = " ";
              }
              filteredOptions.suppressPrettyCount = 0;
              filteredOptions.user = {};
              filteredOptions.state = WriterState.None;
              return filteredOptions;
            };
            XMLWriterBase.prototype.indent = function(node, options, level) {
              var indentLevel;
              if (!options.pretty || options.suppressPrettyCount) {
                return "";
              } else if (options.pretty) {
                indentLevel = (level || 0) + options.offset + 1;
                if (indentLevel > 0) {
                  return new Array(indentLevel).join(options.indent);
                }
              }
              return "";
            };
            XMLWriterBase.prototype.endline = function(node, options, level) {
              if (!options.pretty || options.suppressPrettyCount) {
                return "";
              } else {
                return options.newline;
              }
            };
            XMLWriterBase.prototype.attribute = function(att, options, level) {
              var r;
              this.openAttribute(att, options, level);
              r = " " + att.name + '="' + att.value + '"';
              this.closeAttribute(att, options, level);
              return r;
            };
            XMLWriterBase.prototype.cdata = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level) + "<![CDATA[";
              options.state = WriterState.InsideTag;
              r += node.value;
              options.state = WriterState.CloseTag;
              r += "]]>" + this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.comment = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level) + "<!-- ";
              options.state = WriterState.InsideTag;
              r += node.value;
              options.state = WriterState.CloseTag;
              r += " -->" + this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.declaration = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level) + "<?xml";
              options.state = WriterState.InsideTag;
              r += ' version="' + node.version + '"';
              if (node.encoding != null) {
                r += ' encoding="' + node.encoding + '"';
              }
              if (node.standalone != null) {
                r += ' standalone="' + node.standalone + '"';
              }
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + "?>";
              r += this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.docType = function(node, options, level) {
              var child, i, len, r, ref2;
              level || (level = 0);
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level);
              r += "<!DOCTYPE " + node.root().name;
              if (node.pubID && node.sysID) {
                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                r += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children.length > 0) {
                r += " [";
                r += this.endline(node, options, level);
                options.state = WriterState.InsideTag;
                ref2 = node.children;
                for (i = 0, len = ref2.length; i < len; i++) {
                  child = ref2[i];
                  r += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r += "]";
              }
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + ">";
              r += this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.element = function(node, options, level) {
              var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref2, ref1, ref22;
              level || (level = 0);
              prettySuppressed = false;
              r = "";
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r += this.indent(node, options, level) + "<" + node.name;
              ref2 = node.attribs;
              for (name in ref2) {
                if (!hasProp.call(ref2, name))
                  continue;
                att = ref2[name];
                r += this.attribute(att, options, level);
              }
              childNodeCount = node.children.length;
              firstChildNode = childNodeCount === 0 ? null : node.children[0];
              if (childNodeCount === 0 || node.children.every(function(e2) {
                return (e2.type === NodeType.Text || e2.type === NodeType.Raw) && e2.value === "";
              })) {
                if (options.allowEmpty) {
                  r += ">";
                  options.state = WriterState.CloseTag;
                  r += "</" + node.name + ">" + this.endline(node, options, level);
                } else {
                  options.state = WriterState.CloseTag;
                  r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
                }
              } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
                r += ">";
                options.state = WriterState.InsideTag;
                options.suppressPrettyCount++;
                prettySuppressed = true;
                r += this.writeChildNode(firstChildNode, options, level + 1);
                options.suppressPrettyCount--;
                prettySuppressed = false;
                options.state = WriterState.CloseTag;
                r += "</" + node.name + ">" + this.endline(node, options, level);
              } else {
                if (options.dontPrettyTextNodes) {
                  ref1 = node.children;
                  for (i = 0, len = ref1.length; i < len; i++) {
                    child = ref1[i];
                    if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                      options.suppressPrettyCount++;
                      prettySuppressed = true;
                      break;
                    }
                  }
                }
                r += ">" + this.endline(node, options, level);
                options.state = WriterState.InsideTag;
                ref22 = node.children;
                for (j = 0, len1 = ref22.length; j < len1; j++) {
                  child = ref22[j];
                  r += this.writeChildNode(child, options, level + 1);
                }
                options.state = WriterState.CloseTag;
                r += this.indent(node, options, level) + "</" + node.name + ">";
                if (prettySuppressed) {
                  options.suppressPrettyCount--;
                }
                r += this.endline(node, options, level);
                options.state = WriterState.None;
              }
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.writeChildNode = function(node, options, level) {
              switch (node.type) {
                case NodeType.CData:
                  return this.cdata(node, options, level);
                case NodeType.Comment:
                  return this.comment(node, options, level);
                case NodeType.Element:
                  return this.element(node, options, level);
                case NodeType.Raw:
                  return this.raw(node, options, level);
                case NodeType.Text:
                  return this.text(node, options, level);
                case NodeType.ProcessingInstruction:
                  return this.processingInstruction(node, options, level);
                case NodeType.Dummy:
                  return "";
                case NodeType.Declaration:
                  return this.declaration(node, options, level);
                case NodeType.DocType:
                  return this.docType(node, options, level);
                case NodeType.AttributeDeclaration:
                  return this.dtdAttList(node, options, level);
                case NodeType.ElementDeclaration:
                  return this.dtdElement(node, options, level);
                case NodeType.EntityDeclaration:
                  return this.dtdEntity(node, options, level);
                case NodeType.NotationDeclaration:
                  return this.dtdNotation(node, options, level);
                default:
                  throw new Error("Unknown XML node type: " + node.constructor.name);
              }
            };
            XMLWriterBase.prototype.processingInstruction = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level) + "<?";
              options.state = WriterState.InsideTag;
              r += node.target;
              if (node.value) {
                r += " " + node.value;
              }
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + "?>";
              r += this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.raw = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level);
              options.state = WriterState.InsideTag;
              r += node.value;
              options.state = WriterState.CloseTag;
              r += this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.text = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level);
              options.state = WriterState.InsideTag;
              r += node.value;
              options.state = WriterState.CloseTag;
              r += this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.dtdAttList = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level) + "<!ATTLIST";
              options.state = WriterState.InsideTag;
              r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
              if (node.defaultValueType !== "#DEFAULT") {
                r += " " + node.defaultValueType;
              }
              if (node.defaultValue) {
                r += ' "' + node.defaultValue + '"';
              }
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.dtdElement = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level) + "<!ELEMENT";
              options.state = WriterState.InsideTag;
              r += " " + node.name + " " + node.value;
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.dtdEntity = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level) + "<!ENTITY";
              options.state = WriterState.InsideTag;
              if (node.pe) {
                r += " %";
              }
              r += " " + node.name;
              if (node.value) {
                r += ' "' + node.value + '"';
              } else {
                if (node.pubID && node.sysID) {
                  r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                } else if (node.sysID) {
                  r += ' SYSTEM "' + node.sysID + '"';
                }
                if (node.nData) {
                  r += " NDATA " + node.nData;
                }
              }
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.dtdNotation = function(node, options, level) {
              var r;
              this.openNode(node, options, level);
              options.state = WriterState.OpenTag;
              r = this.indent(node, options, level) + "<!NOTATION";
              options.state = WriterState.InsideTag;
              r += " " + node.name;
              if (node.pubID && node.sysID) {
                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.pubID) {
                r += ' PUBLIC "' + node.pubID + '"';
              } else if (node.sysID) {
                r += ' SYSTEM "' + node.sysID + '"';
              }
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
              options.state = WriterState.None;
              this.closeNode(node, options, level);
              return r;
            };
            XMLWriterBase.prototype.openNode = function(node, options, level) {
            };
            XMLWriterBase.prototype.closeNode = function(node, options, level) {
            };
            XMLWriterBase.prototype.openAttribute = function(att, options, level) {
            };
            XMLWriterBase.prototype.closeAttribute = function(att, options, level) {
            };
            return XMLWriterBase;
          }();
        }).call(this);
      }, { "./NodeType": 498, "./Utility": 499, "./WriterState": 500, "./XMLCData": 502, "./XMLComment": 504, "./XMLDTDAttList": 509, "./XMLDTDElement": 510, "./XMLDTDEntity": 511, "./XMLDTDNotation": 512, "./XMLDeclaration": 513, "./XMLDocType": 514, "./XMLDummy": 517, "./XMLElement": 518, "./XMLProcessingInstruction": 522, "./XMLRaw": 523, "./XMLText": 527 }], 529: [function(require2, module3, exports3) {
        (function() {
          var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign2, isFunction2, ref2;
          ref2 = require2("./Utility"), assign2 = ref2.assign, isFunction2 = ref2.isFunction;
          XMLDOMImplementation = require2("./XMLDOMImplementation");
          XMLDocument = require2("./XMLDocument");
          XMLDocumentCB = require2("./XMLDocumentCB");
          XMLStringWriter = require2("./XMLStringWriter");
          XMLStreamWriter = require2("./XMLStreamWriter");
          NodeType = require2("./NodeType");
          WriterState = require2("./WriterState");
          module3.exports.create = function(name, xmldec, doctype, options) {
            var doc, root;
            if (name == null) {
              throw new Error("Root element needs a name.");
            }
            options = assign2({}, xmldec, doctype, options);
            doc = new XMLDocument(options);
            root = doc.element(name);
            if (!options.headless) {
              doc.declaration(options);
              if (options.pubID != null || options.sysID != null) {
                doc.dtd(options);
              }
            }
            return root;
          };
          module3.exports.begin = function(options, onData, onEnd) {
            var ref1;
            if (isFunction2(options)) {
              ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
              options = {};
            }
            if (onData) {
              return new XMLDocumentCB(options, onData, onEnd);
            } else {
              return new XMLDocument(options);
            }
          };
          module3.exports.stringWriter = function(options) {
            return new XMLStringWriter(options);
          };
          module3.exports.streamWriter = function(stream, options) {
            return new XMLStreamWriter(stream, options);
          };
          module3.exports.implementation = new XMLDOMImplementation();
          module3.exports.nodeType = NodeType;
          module3.exports.writerState = WriterState;
        }).call(this);
      }, { "./NodeType": 498, "./Utility": 499, "./WriterState": 500, "./XMLDOMImplementation": 507, "./XMLDocument": 515, "./XMLDocumentCB": 516, "./XMLStreamWriter": 524, "./XMLStringWriter": 525 }], 530: [function(require2, module3, exports3) {
        module3.exports = extend2;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        function extend2() {
          var target = {};
          for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        }
      }, {}], 531: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.fill.js");
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.object.to-string.js");
        require2("core-js/modules/es.regexp.to-string.js");
        require2("core-js/modules/es.array.join.js");
        require2("core-js/modules/es.array.slice.js");
        var Buffer2 = require2("buffer").Buffer;
        var sha = require2("./sha");
        var sha256 = require2("./sha256");
        var md5 = require2("./md5");
        var algorithms = {
          sha1: sha,
          sha256,
          md5
        };
        var blocksize = 64;
        var zeroBuffer = Buffer2.alloc(blocksize);
        zeroBuffer.fill(0);
        function hmac(fn, key, data) {
          if (!Buffer2.isBuffer(key))
            key = Buffer2.from(key);
          if (!Buffer2.isBuffer(data))
            data = Buffer2.from(data);
          if (key.length > blocksize) {
            key = fn(key);
          } else if (key.length < blocksize) {
            key = Buffer2.concat([key, zeroBuffer], blocksize);
          }
          var ipad = Buffer2.alloc(blocksize), opad = Buffer2.alloc(blocksize);
          for (var i = 0; i < blocksize; i++) {
            ipad[i] = key[i] ^ 54;
            opad[i] = key[i] ^ 92;
          }
          var hash2 = fn(Buffer2.concat([ipad, data]));
          return fn(Buffer2.concat([opad, hash2]));
        }
        function hash(alg, key) {
          alg = alg || "sha1";
          var fn = algorithms[alg];
          var bufs = [];
          var length = 0;
          if (!fn)
            error2("algorithm:", alg, "is not yet supported");
          return {
            update: function update3(data) {
              if (!Buffer2.isBuffer(data))
                data = Buffer2.from(data);
              bufs.push(data);
              length += data.length;
              return this;
            },
            digest: function digest(enc) {
              var buf = Buffer2.concat(bufs);
              var r = key ? hmac(fn, key, buf) : fn(buf);
              bufs = null;
              return enc ? r.toString(enc) : r;
            }
          };
        }
        function error2() {
          var m = [].slice.call(arguments).join(" ");
          throw new Error([m, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
        }
        exports3.createHash = function(alg) {
          return hash(alg);
        };
        exports3.createHmac = function(alg, key) {
          return hash(alg, key);
        };
        exports3.createCredentials = function() {
          error2("sorry,createCredentials is not implemented yet");
        };
        exports3.createCipher = function() {
          error2("sorry,createCipher is not implemented yet");
        };
        exports3.createCipheriv = function() {
          error2("sorry,createCipheriv is not implemented yet");
        };
        exports3.createDecipher = function() {
          error2("sorry,createDecipher is not implemented yet");
        };
        exports3.createDecipheriv = function() {
          error2("sorry,createDecipheriv is not implemented yet");
        };
        exports3.createSign = function() {
          error2("sorry,createSign is not implemented yet");
        };
        exports3.createVerify = function() {
          error2("sorry,createVerify is not implemented yet");
        };
        exports3.createDiffieHellman = function() {
          error2("sorry,createDiffieHellman is not implemented yet");
        };
        exports3.pbkdf2 = function() {
          error2("sorry,pbkdf2 is not implemented yet");
        };
      }, { "./md5": 533, "./sha": 534, "./sha256": 535, "buffer": 103, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.fill.js": 311, "core-js/modules/es.array.join.js": 317, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.regexp.to-string.js": 339 }], 532: [function(require2, module3, exports3) {
        require2("core-js/modules/es.array.fill.js");
        require2("core-js/modules/es.array.concat.js");
        var Buffer2 = require2("buffer").Buffer;
        var intSize = 4;
        var zeroBuffer = Buffer2.alloc(intSize);
        zeroBuffer.fill(0);
        var chrsz = 8;
        function toArray(buf, bigEndian) {
          if (buf.length % intSize !== 0) {
            var len = buf.length + (intSize - buf.length % intSize);
            buf = Buffer2.concat([buf, zeroBuffer], len);
          }
          var arr = [];
          var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
          for (var i = 0; i < buf.length; i += intSize) {
            arr.push(fn.call(buf, i));
          }
          return arr;
        }
        function toBuffer(arr, size2, bigEndian) {
          var buf = Buffer2.alloc(size2);
          var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
          for (var i = 0; i < arr.length; i++) {
            fn.call(buf, arr[i], i * 4, true);
          }
          return buf;
        }
        function hash(buf, fn, hashSize, bigEndian) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
          return toBuffer(arr, hashSize, bigEndian);
        }
        module3.exports = {
          hash
        };
      }, { "buffer": 103, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.fill.js": 311 }], 533: [function(require2, module3, exports3) {
        var helpers = require2("./helpers");
        function core_md5(x, len) {
          x[len >> 5] |= 128 << len % 32;
          x[(len + 64 >>> 9 << 4) + 14] = len;
          var a2 = 1732584193;
          var b = -271733879;
          var c = -1732584194;
          var d = 271733878;
          for (var i = 0; i < x.length; i += 16) {
            var olda = a2;
            var oldb = b;
            var oldc = c;
            var oldd = d;
            a2 = md5_ff(a2, b, c, d, x[i + 0], 7, -680876936);
            d = md5_ff(d, a2, b, c, x[i + 1], 12, -389564586);
            c = md5_ff(c, d, a2, b, x[i + 2], 17, 606105819);
            b = md5_ff(b, c, d, a2, x[i + 3], 22, -1044525330);
            a2 = md5_ff(a2, b, c, d, x[i + 4], 7, -176418897);
            d = md5_ff(d, a2, b, c, x[i + 5], 12, 1200080426);
            c = md5_ff(c, d, a2, b, x[i + 6], 17, -1473231341);
            b = md5_ff(b, c, d, a2, x[i + 7], 22, -45705983);
            a2 = md5_ff(a2, b, c, d, x[i + 8], 7, 1770035416);
            d = md5_ff(d, a2, b, c, x[i + 9], 12, -1958414417);
            c = md5_ff(c, d, a2, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a2, x[i + 11], 22, -1990404162);
            a2 = md5_ff(a2, b, c, d, x[i + 12], 7, 1804603682);
            d = md5_ff(d, a2, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a2, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a2, x[i + 15], 22, 1236535329);
            a2 = md5_gg(a2, b, c, d, x[i + 1], 5, -165796510);
            d = md5_gg(d, a2, b, c, x[i + 6], 9, -1069501632);
            c = md5_gg(c, d, a2, b, x[i + 11], 14, 643717713);
            b = md5_gg(b, c, d, a2, x[i + 0], 20, -373897302);
            a2 = md5_gg(a2, b, c, d, x[i + 5], 5, -701558691);
            d = md5_gg(d, a2, b, c, x[i + 10], 9, 38016083);
            c = md5_gg(c, d, a2, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a2, x[i + 4], 20, -405537848);
            a2 = md5_gg(a2, b, c, d, x[i + 9], 5, 568446438);
            d = md5_gg(d, a2, b, c, x[i + 14], 9, -1019803690);
            c = md5_gg(c, d, a2, b, x[i + 3], 14, -187363961);
            b = md5_gg(b, c, d, a2, x[i + 8], 20, 1163531501);
            a2 = md5_gg(a2, b, c, d, x[i + 13], 5, -1444681467);
            d = md5_gg(d, a2, b, c, x[i + 2], 9, -51403784);
            c = md5_gg(c, d, a2, b, x[i + 7], 14, 1735328473);
            b = md5_gg(b, c, d, a2, x[i + 12], 20, -1926607734);
            a2 = md5_hh(a2, b, c, d, x[i + 5], 4, -378558);
            d = md5_hh(d, a2, b, c, x[i + 8], 11, -2022574463);
            c = md5_hh(c, d, a2, b, x[i + 11], 16, 1839030562);
            b = md5_hh(b, c, d, a2, x[i + 14], 23, -35309556);
            a2 = md5_hh(a2, b, c, d, x[i + 1], 4, -1530992060);
            d = md5_hh(d, a2, b, c, x[i + 4], 11, 1272893353);
            c = md5_hh(c, d, a2, b, x[i + 7], 16, -155497632);
            b = md5_hh(b, c, d, a2, x[i + 10], 23, -1094730640);
            a2 = md5_hh(a2, b, c, d, x[i + 13], 4, 681279174);
            d = md5_hh(d, a2, b, c, x[i + 0], 11, -358537222);
            c = md5_hh(c, d, a2, b, x[i + 3], 16, -722521979);
            b = md5_hh(b, c, d, a2, x[i + 6], 23, 76029189);
            a2 = md5_hh(a2, b, c, d, x[i + 9], 4, -640364487);
            d = md5_hh(d, a2, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a2, b, x[i + 15], 16, 530742520);
            b = md5_hh(b, c, d, a2, x[i + 2], 23, -995338651);
            a2 = md5_ii(a2, b, c, d, x[i + 0], 6, -198630844);
            d = md5_ii(d, a2, b, c, x[i + 7], 10, 1126891415);
            c = md5_ii(c, d, a2, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a2, x[i + 5], 21, -57434055);
            a2 = md5_ii(a2, b, c, d, x[i + 12], 6, 1700485571);
            d = md5_ii(d, a2, b, c, x[i + 3], 10, -1894986606);
            c = md5_ii(c, d, a2, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a2, x[i + 1], 21, -2054922799);
            a2 = md5_ii(a2, b, c, d, x[i + 8], 6, 1873313359);
            d = md5_ii(d, a2, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a2, b, x[i + 6], 15, -1560198380);
            b = md5_ii(b, c, d, a2, x[i + 13], 21, 1309151649);
            a2 = md5_ii(a2, b, c, d, x[i + 4], 6, -145523070);
            d = md5_ii(d, a2, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a2, b, x[i + 2], 15, 718787259);
            b = md5_ii(b, c, d, a2, x[i + 9], 21, -343485551);
            a2 = safe_add(a2, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
          }
          return Array(a2, b, c, d);
        }
        function md5_cmn(q, a2, b, x, s2, t2) {
          return safe_add(bit_rol(safe_add(safe_add(a2, q), safe_add(x, t2)), s2), b);
        }
        function md5_ff(a2, b, c, d, x, s2, t2) {
          return md5_cmn(b & c | ~b & d, a2, b, x, s2, t2);
        }
        function md5_gg(a2, b, c, d, x, s2, t2) {
          return md5_cmn(b & d | c & ~d, a2, b, x, s2, t2);
        }
        function md5_hh(a2, b, c, d, x, s2, t2) {
          return md5_cmn(b ^ c ^ d, a2, b, x, s2, t2);
        }
        function md5_ii(a2, b, c, d, x, s2, t2) {
          return md5_cmn(c ^ (b | ~d), a2, b, x, s2, t2);
        }
        function safe_add(x, y) {
          var lsw = (x & 65535) + (y & 65535);
          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        }
        function bit_rol(num, cnt) {
          return num << cnt | num >>> 32 - cnt;
        }
        module3.exports = function md5(buf) {
          return helpers.hash(buf, core_md5, 16);
        };
      }, { "./helpers": 532 }], 534: [function(require2, module3, exports3) {
        var helpers = require2("./helpers");
        function core_sha1(x, len) {
          x[len >> 5] |= 128 << 24 - len % 32;
          x[(len + 64 >> 9 << 4) + 15] = len;
          var w = Array(80);
          var a2 = 1732584193;
          var b = -271733879;
          var c = -1732584194;
          var d = 271733878;
          var e2 = -1009589776;
          for (var i = 0; i < x.length; i += 16) {
            var olda = a2;
            var oldb = b;
            var oldc = c;
            var oldd = d;
            var olde = e2;
            for (var j = 0; j < 80; j++) {
              if (j < 16)
                w[j] = x[i + j];
              else
                w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
              var t2 = safe_add(safe_add(rol(a2, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e2, w[j]), sha1_kt(j)));
              e2 = d;
              d = c;
              c = rol(b, 30);
              b = a2;
              a2 = t2;
            }
            a2 = safe_add(a2, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
            e2 = safe_add(e2, olde);
          }
          return Array(a2, b, c, d, e2);
        }
        function sha1_ft(t2, b, c, d) {
          if (t2 < 20)
            return b & c | ~b & d;
          if (t2 < 40)
            return b ^ c ^ d;
          if (t2 < 60)
            return b & c | b & d | c & d;
          return b ^ c ^ d;
        }
        function sha1_kt(t2) {
          return t2 < 20 ? 1518500249 : t2 < 40 ? 1859775393 : t2 < 60 ? -1894007588 : -899497514;
        }
        function safe_add(x, y) {
          var lsw = (x & 65535) + (y & 65535);
          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        }
        function rol(num, cnt) {
          return num << cnt | num >>> 32 - cnt;
        }
        module3.exports = function sha1(buf) {
          return helpers.hash(buf, core_sha1, 20, true);
        };
      }, { "./helpers": 532 }], 535: [function(require2, module3, exports3) {
        var helpers = require2("./helpers");
        var safe_add = function safe_add2(x, y) {
          var lsw = (x & 65535) + (y & 65535);
          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        };
        var S = function S2(X, n2) {
          return X >>> n2 | X << 32 - n2;
        };
        var R = function R2(X, n2) {
          return X >>> n2;
        };
        var Ch = function Ch2(x, y, z2) {
          return x & y ^ ~x & z2;
        };
        var Maj = function Maj2(x, y, z2) {
          return x & y ^ x & z2 ^ y & z2;
        };
        var Sigma0256 = function Sigma02562(x) {
          return S(x, 2) ^ S(x, 13) ^ S(x, 22);
        };
        var Sigma1256 = function Sigma12562(x) {
          return S(x, 6) ^ S(x, 11) ^ S(x, 25);
        };
        var Gamma0256 = function Gamma02562(x) {
          return S(x, 7) ^ S(x, 18) ^ R(x, 3);
        };
        var Gamma1256 = function Gamma12562(x) {
          return S(x, 17) ^ S(x, 19) ^ R(x, 10);
        };
        var core_sha256 = function core_sha2562(m, l) {
          var K = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298);
          var HASH = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225);
          var W = new Array(64);
          var a2, b, c, d, e2, f2, g, h, i, j;
          var T1, T2;
          m[l >> 5] |= 128 << 24 - l % 32;
          m[(l + 64 >> 9 << 4) + 15] = l;
          for (var i = 0; i < m.length; i += 16) {
            a2 = HASH[0];
            b = HASH[1];
            c = HASH[2];
            d = HASH[3];
            e2 = HASH[4];
            f2 = HASH[5];
            g = HASH[6];
            h = HASH[7];
            for (var j = 0; j < 64; j++) {
              if (j < 16) {
                W[j] = m[j + i];
              } else {
                W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
              }
              T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e2)), Ch(e2, f2, g)), K[j]), W[j]);
              T2 = safe_add(Sigma0256(a2), Maj(a2, b, c));
              h = g;
              g = f2;
              f2 = e2;
              e2 = safe_add(d, T1);
              d = c;
              c = b;
              b = a2;
              a2 = safe_add(T1, T2);
            }
            HASH[0] = safe_add(a2, HASH[0]);
            HASH[1] = safe_add(b, HASH[1]);
            HASH[2] = safe_add(c, HASH[2]);
            HASH[3] = safe_add(d, HASH[3]);
            HASH[4] = safe_add(e2, HASH[4]);
            HASH[5] = safe_add(f2, HASH[5]);
            HASH[6] = safe_add(g, HASH[6]);
            HASH[7] = safe_add(h, HASH[7]);
          }
          return HASH;
        };
        module3.exports = function sha256(buf) {
          return helpers.hash(buf, core_sha256, 32, true);
        };
      }, { "./helpers": 532 }], 536: [function(require2, module3, exports3) {
        module3.exports = function() {
          return function() {
          };
        };
      }, {}], 537: [function(require2, module3, exports3) {
        (function(Buffer2) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
            var _require = require2("stream"), Stream = _require.Stream;
            var _require2 = require2("../lib/common/utils/isArray"), isArray2 = _require2.isArray;
            module3.exports.string = function isString2(obj) {
              return typeof obj === "string";
            };
            module3.exports.array = isArray2;
            module3.exports.buffer = Buffer2.isBuffer;
            function isStream(obj) {
              return obj instanceof Stream;
            }
            module3.exports.writableStream = function isWritableStream(obj) {
              return isStream(obj) && typeof obj._write === "function" && (0, _typeof2.default)(obj._writableState) === "object";
            };
          }).call(this);
        }).call(this, { "isBuffer": require2("../node_modules/is-buffer/index.js") });
      }, { "../lib/common/utils/isArray": 67, "../node_modules/is-buffer/index.js": 409, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/helpers/typeof": 91, "stream": 468 }], 538: [function(require2, module3, exports3) {
        var immediate = require2("immediate");
        var process = module3.exports = {};
        process.nextTick = immediate;
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop2() {
        }
        process.on = noop2;
        process.addListener = noop2;
        process.once = noop2;
        process.off = noop2;
        process.removeListener = noop2;
        process.removeAllListeners = noop2;
        process.emit = noop2;
        process.prependListener = noop2;
        process.prependOnceListener = noop2;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, { "immediate": 401 }], 539: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.search.js");
            var ClientRequest = require2("./lib/request");
            var response = require2("./lib/response");
            var extend2 = require2("xtend");
            var statusCodes = require2("builtin-status-codes");
            var url2 = require2("url");
            var http = exports3;
            http.request = function(opts, cb) {
              if (typeof opts === "string")
                opts = url2.parse(opts);
              else
                opts = extend2(opts);
              var defaultProtocol = global3.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
              var protocol = opts.protocol || defaultProtocol;
              var host2 = opts.hostname || opts.host;
              var port = opts.port;
              var path = opts.path || "/";
              if (host2 && host2.indexOf(":") !== -1)
                host2 = "[" + host2 + "]";
              opts.url = (host2 ? protocol + "//" + host2 : "") + (port ? ":" + port : "") + path;
              opts.method = (opts.method || "GET").toUpperCase();
              opts.headers = opts.headers || {};
              var req = new ClientRequest(opts);
              if (cb)
                req.on("response", cb);
              return req;
            };
            http.get = function get3(opts, cb) {
              var req = http.request(opts, cb);
              req.end();
              return req;
            };
            http.ClientRequest = ClientRequest;
            http.IncomingMessage = response.IncomingMessage;
            http.Agent = function() {
            };
            http.Agent.defaultMaxSockets = 4;
            http.globalAgent = new http.Agent();
            http.STATUS_CODES = statusCodes;
            http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./lib/request": 541, "./lib/response": 542, "builtin-status-codes": 104, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.search.js": 346, "url": 543, "xtend": 530 }], 540: [function(require2, module3, exports3) {
        (function(global3) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.array-buffer.constructor.js");
            require2("core-js/modules/es.array-buffer.slice.js");
            require2("core-js/modules/es.array.slice.js");
            exports3.fetch = isFunction2(global3.fetch) && isFunction2(global3.ReadableStream);
            exports3.writableStream = isFunction2(global3.WritableStream);
            exports3.abortController = isFunction2(global3.AbortController);
            exports3.blobConstructor = false;
            try {
              new Blob([new ArrayBuffer(1)]);
              exports3.blobConstructor = true;
            } catch (e2) {
            }
            var xhr;
            function getXHR() {
              if (xhr !== void 0)
                return xhr;
              if (global3.XMLHttpRequest) {
                xhr = new global3.XMLHttpRequest();
                try {
                  xhr.open("GET", global3.XDomainRequest ? "/" : "https://example.com");
                } catch (e2) {
                  xhr = null;
                }
              } else {
                xhr = null;
              }
              return xhr;
            }
            function checkTypeSupport(type) {
              var xhr2 = getXHR();
              if (!xhr2)
                return false;
              try {
                xhr2.responseType = type;
                return xhr2.responseType === type;
              } catch (e2) {
              }
              return false;
            }
            var haveArrayBuffer = typeof global3.ArrayBuffer !== "undefined";
            var haveSlice = haveArrayBuffer && isFunction2(global3.ArrayBuffer.prototype.slice);
            exports3.arraybuffer = exports3.fetch || haveArrayBuffer && checkTypeSupport("arraybuffer");
            exports3.msstream = !exports3.fetch && haveSlice && checkTypeSupport("ms-stream");
            exports3.mozchunkedarraybuffer = !exports3.fetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer");
            exports3.overrideMimeType = exports3.fetch || (getXHR() ? isFunction2(getXHR().overrideMimeType) : false);
            exports3.vbArray = isFunction2(global3.VBArray);
            function isFunction2(value) {
              return typeof value === "function";
            }
            xhr = null;
          }).call(this);
        }).call(this, typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "core-js/modules/es.array-buffer.constructor.js": 308, "core-js/modules/es.array-buffer.slice.js": 309, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333 }], 541: [function(require2, module3, exports3) {
        (function(process, global3, Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.regexp.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.object.keys.js");
            require2("core-js/modules/es.array.concat.js");
            require2("core-js/modules/es.array.map.js");
            require2("core-js/modules/es.function.name.js");
            require2("core-js/modules/es.promise.js");
            var capability = require2("./capability");
            var inherits = require2("inherits");
            var response = require2("./response");
            var stream = require2("readable-stream");
            var toArrayBuffer = require2("to-arraybuffer");
            var IncomingMessage = response.IncomingMessage;
            var rStates = response.readyStates;
            function decideMode(preferBinary, useFetch) {
              if (capability.fetch && useFetch) {
                return "fetch";
              } else if (capability.mozchunkedarraybuffer) {
                return "moz-chunked-arraybuffer";
              } else if (capability.msstream) {
                return "ms-stream";
              } else if (capability.arraybuffer && preferBinary) {
                return "arraybuffer";
              } else if (capability.vbArray && preferBinary) {
                return "text:vbarray";
              } else {
                return "text";
              }
            }
            var ClientRequest = module3.exports = function(opts) {
              var self2 = this;
              stream.Writable.call(self2);
              self2._opts = opts;
              self2._body = [];
              self2._headers = {};
              if (opts.auth)
                self2.setHeader("Authorization", "Basic " + new Buffer2(opts.auth).toString("base64"));
              Object.keys(opts.headers).forEach(function(name) {
                self2.setHeader(name, opts.headers[name]);
              });
              var preferBinary;
              var useFetch = true;
              if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
                useFetch = false;
                preferBinary = true;
              } else if (opts.mode === "prefer-streaming") {
                preferBinary = false;
              } else if (opts.mode === "allow-wrong-content-type") {
                preferBinary = !capability.overrideMimeType;
              } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
                preferBinary = true;
              } else {
                throw new Error("Invalid value for opts.mode");
              }
              self2._mode = decideMode(preferBinary, useFetch);
              self2._fetchTimer = null;
              self2.on("finish", function() {
                self2._onFinish();
              });
            };
            inherits(ClientRequest, stream.Writable);
            ClientRequest.prototype.setHeader = function(name, value) {
              var self2 = this;
              var lowerName = name.toLowerCase();
              if (unsafeHeaders.indexOf(lowerName) !== -1)
                return;
              self2._headers[lowerName] = {
                name,
                value
              };
            };
            ClientRequest.prototype.getHeader = function(name) {
              var header = this._headers[name.toLowerCase()];
              if (header)
                return header.value;
              return null;
            };
            ClientRequest.prototype.removeHeader = function(name) {
              var self2 = this;
              delete self2._headers[name.toLowerCase()];
            };
            ClientRequest.prototype._onFinish = function() {
              var self2 = this;
              if (self2._destroyed)
                return;
              var opts = self2._opts;
              var headersObj = self2._headers;
              var body = null;
              if (opts.method !== "GET" && opts.method !== "HEAD") {
                if (capability.arraybuffer) {
                  body = toArrayBuffer(Buffer2.concat(self2._body));
                } else if (capability.blobConstructor) {
                  body = new global3.Blob(self2._body.map(function(buffer2) {
                    return toArrayBuffer(buffer2);
                  }), {
                    type: (headersObj["content-type"] || {}).value || ""
                  });
                } else {
                  body = Buffer2.concat(self2._body).toString();
                }
              }
              var headersList = [];
              Object.keys(headersObj).forEach(function(keyName) {
                var name = headersObj[keyName].name;
                var value = headersObj[keyName].value;
                if (Array.isArray(value)) {
                  value.forEach(function(v) {
                    headersList.push([name, v]);
                  });
                } else {
                  headersList.push([name, value]);
                }
              });
              if (self2._mode === "fetch") {
                var signal = null;
                if (capability.abortController) {
                  var controller = new AbortController();
                  signal = controller.signal;
                  self2._fetchAbortController = controller;
                  if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
                    self2._fetchTimer = global3.setTimeout(function() {
                      self2.emit("requestTimeout");
                      if (self2._fetchAbortController)
                        self2._fetchAbortController.abort();
                    }, opts.requestTimeout);
                  }
                }
                global3.fetch(self2._opts.url, {
                  method: self2._opts.method,
                  headers: headersList,
                  body: body || void 0,
                  mode: "cors",
                  credentials: opts.withCredentials ? "include" : "same-origin",
                  signal
                }).then(function(response2) {
                  self2._fetchResponse = response2;
                  self2._connect();
                }, function(reason) {
                  global3.clearTimeout(self2._fetchTimer);
                  if (!self2._destroyed)
                    self2.emit("error", reason);
                });
              } else {
                var xhr = self2._xhr = new global3.XMLHttpRequest();
                try {
                  xhr.open(self2._opts.method, self2._opts.url, true);
                } catch (err) {
                  process.nextTick(function() {
                    self2.emit("error", err);
                  });
                  return;
                }
                if ("responseType" in xhr)
                  xhr.responseType = self2._mode.split(":")[0];
                if ("withCredentials" in xhr)
                  xhr.withCredentials = !!opts.withCredentials;
                if (self2._mode === "text" && "overrideMimeType" in xhr)
                  xhr.overrideMimeType("text/plain; charset=x-user-defined");
                if ("requestTimeout" in opts) {
                  xhr.timeout = opts.requestTimeout;
                  xhr.ontimeout = function() {
                    self2.emit("requestTimeout");
                  };
                }
                headersList.forEach(function(header) {
                  xhr.setRequestHeader(header[0], header[1]);
                });
                self2._response = null;
                xhr.onreadystatechange = function() {
                  switch (xhr.readyState) {
                    case rStates.LOADING:
                    case rStates.DONE:
                      self2._onXHRProgress();
                      break;
                  }
                };
                if (self2._mode === "moz-chunked-arraybuffer") {
                  xhr.onprogress = function() {
                    self2._onXHRProgress();
                  };
                }
                xhr.onerror = function() {
                  if (self2._destroyed)
                    return;
                  self2.emit("error", new Error("XHR error"));
                };
                try {
                  xhr.send(body);
                } catch (err) {
                  process.nextTick(function() {
                    self2.emit("error", err);
                  });
                  return;
                }
              }
            };
            function statusValid(xhr) {
              try {
                var status = xhr.status;
                return status !== null && status !== 0;
              } catch (e2) {
                return false;
              }
            }
            ClientRequest.prototype._onXHRProgress = function() {
              var self2 = this;
              if (!statusValid(self2._xhr) || self2._destroyed)
                return;
              if (!self2._response)
                self2._connect();
              self2._response._onXHRProgress();
            };
            ClientRequest.prototype._connect = function() {
              var self2 = this;
              if (self2._destroyed)
                return;
              self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._fetchTimer);
              self2._response.on("error", function(err) {
                self2.emit("error", err);
              });
              self2.emit("response", self2._response);
            };
            ClientRequest.prototype._write = function(chunk, encoding, cb) {
              var self2 = this;
              self2._body.push(chunk);
              cb();
            };
            ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
              var self2 = this;
              self2._destroyed = true;
              global3.clearTimeout(self2._fetchTimer);
              if (self2._response)
                self2._response._destroyed = true;
              if (self2._xhr)
                self2._xhr.abort();
              else if (self2._fetchAbortController)
                self2._fetchAbortController.abort();
            };
            ClientRequest.prototype.end = function(data, encoding, cb) {
              var self2 = this;
              if (typeof data === "function") {
                cb = data;
                data = void 0;
              }
              stream.Writable.prototype.end.call(self2, data, encoding, cb);
            };
            ClientRequest.prototype.flushHeaders = function() {
            };
            ClientRequest.prototype.setTimeout = function() {
            };
            ClientRequest.prototype.setNoDelay = function() {
            };
            ClientRequest.prototype.setSocketKeepAlive = function() {
            };
            var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
      }, { "./capability": 540, "./response": 542, "_process": 538, "buffer": 103, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.map.js": 318, "core-js/modules/es.function.name.js": 322, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333, "core-js/modules/es.regexp.to-string.js": 339, "core-js/modules/web.dom-collections.for-each.js": 380, "inherits": 407, "readable-stream": 463, "to-arraybuffer": 485 }], 542: [function(require2, module3, exports3) {
        (function(process, global3, Buffer2) {
          (function() {
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/web.dom-collections.for-each.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.string.split.js");
            require2("core-js/modules/es.string.match.js");
            require2("core-js/modules/es.array.iterator.js");
            require2("core-js/modules/es.array-buffer.slice.js");
            require2("core-js/modules/es.typed-array.uint8-array.js");
            require2("core-js/modules/es.typed-array.copy-within.js");
            require2("core-js/modules/es.typed-array.every.js");
            require2("core-js/modules/es.typed-array.fill.js");
            require2("core-js/modules/es.typed-array.filter.js");
            require2("core-js/modules/es.typed-array.find.js");
            require2("core-js/modules/es.typed-array.find-index.js");
            require2("core-js/modules/es.typed-array.for-each.js");
            require2("core-js/modules/es.typed-array.includes.js");
            require2("core-js/modules/es.typed-array.index-of.js");
            require2("core-js/modules/es.typed-array.iterator.js");
            require2("core-js/modules/es.typed-array.join.js");
            require2("core-js/modules/es.typed-array.last-index-of.js");
            require2("core-js/modules/es.typed-array.map.js");
            require2("core-js/modules/es.typed-array.reduce.js");
            require2("core-js/modules/es.typed-array.reduce-right.js");
            require2("core-js/modules/es.typed-array.reverse.js");
            require2("core-js/modules/es.typed-array.set.js");
            require2("core-js/modules/es.typed-array.slice.js");
            require2("core-js/modules/es.typed-array.some.js");
            require2("core-js/modules/es.typed-array.sort.js");
            require2("core-js/modules/es.typed-array.subarray.js");
            require2("core-js/modules/es.typed-array.to-locale-string.js");
            require2("core-js/modules/es.typed-array.to-string.js");
            require2("core-js/modules/es.array.slice.js");
            var capability = require2("./capability");
            var inherits = require2("inherits");
            var stream = require2("readable-stream");
            var rStates = exports3.readyStates = {
              UNSENT: 0,
              OPENED: 1,
              HEADERS_RECEIVED: 2,
              LOADING: 3,
              DONE: 4
            };
            var IncomingMessage = exports3.IncomingMessage = function(xhr, response, mode2, fetchTimer) {
              var self2 = this;
              stream.Readable.call(self2);
              self2._mode = mode2;
              self2.headers = {};
              self2.rawHeaders = [];
              self2.trailers = {};
              self2.rawTrailers = [];
              self2.on("end", function() {
                process.nextTick(function() {
                  self2.emit("close");
                });
              });
              if (mode2 === "fetch") {
                var read = function read2() {
                  reader.read().then(function(result) {
                    if (self2._destroyed)
                      return;
                    if (result.done) {
                      global3.clearTimeout(fetchTimer);
                      self2.push(null);
                      return;
                    }
                    self2.push(new Buffer2(result.value));
                    read2();
                  }).catch(function(err) {
                    global3.clearTimeout(fetchTimer);
                    if (!self2._destroyed)
                      self2.emit("error", err);
                  });
                };
                self2._fetchResponse = response;
                self2.url = response.url;
                self2.statusCode = response.status;
                self2.statusMessage = response.statusText;
                response.headers.forEach(function(header, key) {
                  self2.headers[key.toLowerCase()] = header;
                  self2.rawHeaders.push(key, header);
                });
                if (capability.writableStream) {
                  var writable = new WritableStream({
                    write: function write3(chunk) {
                      return new Promise(function(resolve2, reject) {
                        if (self2._destroyed) {
                          reject();
                        } else if (self2.push(new Buffer2(chunk))) {
                          resolve2();
                        } else {
                          self2._resumeFetch = resolve2;
                        }
                      });
                    },
                    close: function close() {
                      global3.clearTimeout(fetchTimer);
                      if (!self2._destroyed)
                        self2.push(null);
                    },
                    abort: function abort(err) {
                      if (!self2._destroyed)
                        self2.emit("error", err);
                    }
                  });
                  try {
                    response.body.pipeTo(writable).catch(function(err) {
                      global3.clearTimeout(fetchTimer);
                      if (!self2._destroyed)
                        self2.emit("error", err);
                    });
                    return;
                  } catch (e2) {
                  }
                }
                var reader = response.body.getReader();
                read();
              } else {
                self2._xhr = xhr;
                self2._pos = 0;
                self2.url = xhr.responseURL;
                self2.statusCode = xhr.status;
                self2.statusMessage = xhr.statusText;
                var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                headers.forEach(function(header) {
                  var matches = header.match(/^([^:]+):\s*(.*)/);
                  if (matches) {
                    var key = matches[1].toLowerCase();
                    if (key === "set-cookie") {
                      if (self2.headers[key] === void 0) {
                        self2.headers[key] = [];
                      }
                      self2.headers[key].push(matches[2]);
                    } else if (self2.headers[key] !== void 0) {
                      self2.headers[key] += ", " + matches[2];
                    } else {
                      self2.headers[key] = matches[2];
                    }
                    self2.rawHeaders.push(matches[1], matches[2]);
                  }
                });
                self2._charset = "x-user-defined";
                if (!capability.overrideMimeType) {
                  var mimeType = self2.rawHeaders["mime-type"];
                  if (mimeType) {
                    var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                    if (charsetMatch) {
                      self2._charset = charsetMatch[1].toLowerCase();
                    }
                  }
                  if (!self2._charset)
                    self2._charset = "utf-8";
                }
              }
            };
            inherits(IncomingMessage, stream.Readable);
            IncomingMessage.prototype._read = function() {
              var self2 = this;
              var resolve2 = self2._resumeFetch;
              if (resolve2) {
                self2._resumeFetch = null;
                resolve2();
              }
            };
            IncomingMessage.prototype._onXHRProgress = function() {
              var self2 = this;
              var xhr = self2._xhr;
              var response = null;
              switch (self2._mode) {
                case "text:vbarray":
                  if (xhr.readyState !== rStates.DONE)
                    break;
                  try {
                    response = new global3.VBArray(xhr.responseBody).toArray();
                  } catch (e2) {
                  }
                  if (response !== null) {
                    self2.push(new Buffer2(response));
                    break;
                  }
                case "text":
                  try {
                    response = xhr.responseText;
                  } catch (e2) {
                    self2._mode = "text:vbarray";
                    break;
                  }
                  if (response.length > self2._pos) {
                    var newData = response.substr(self2._pos);
                    if (self2._charset === "x-user-defined") {
                      var buffer2 = new Buffer2(newData.length);
                      for (var i = 0; i < newData.length; i++)
                        buffer2[i] = newData.charCodeAt(i) & 255;
                      self2.push(buffer2);
                    } else {
                      self2.push(newData, self2._charset);
                    }
                    self2._pos = response.length;
                  }
                  break;
                case "arraybuffer":
                  if (xhr.readyState !== rStates.DONE || !xhr.response)
                    break;
                  response = xhr.response;
                  self2.push(new Buffer2(new Uint8Array(response)));
                  break;
                case "moz-chunked-arraybuffer":
                  response = xhr.response;
                  if (xhr.readyState !== rStates.LOADING || !response)
                    break;
                  self2.push(new Buffer2(new Uint8Array(response)));
                  break;
                case "ms-stream":
                  response = xhr.response;
                  if (xhr.readyState !== rStates.LOADING)
                    break;
                  var reader = new global3.MSStreamReader();
                  reader.onprogress = function() {
                    if (reader.result.byteLength > self2._pos) {
                      self2.push(new Buffer2(new Uint8Array(reader.result.slice(self2._pos))));
                      self2._pos = reader.result.byteLength;
                    }
                  };
                  reader.onload = function() {
                    self2.push(null);
                  };
                  reader.readAsArrayBuffer(response);
                  break;
              }
              if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
                self2.push(null);
              }
            };
          }).call(this);
        }).call(this, require2("_process"), typeof global2 !== "undefined" ? global2 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
      }, { "./capability": 540, "_process": 538, "buffer": 103, "core-js/modules/es.array-buffer.slice.js": 309, "core-js/modules/es.array.iterator.js": 316, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.match.js": 344, "core-js/modules/es.string.split.js": 347, "core-js/modules/es.typed-array.copy-within.js": 356, "core-js/modules/es.typed-array.every.js": 357, "core-js/modules/es.typed-array.fill.js": 358, "core-js/modules/es.typed-array.filter.js": 359, "core-js/modules/es.typed-array.find-index.js": 360, "core-js/modules/es.typed-array.find.js": 361, "core-js/modules/es.typed-array.for-each.js": 362, "core-js/modules/es.typed-array.includes.js": 363, "core-js/modules/es.typed-array.index-of.js": 364, "core-js/modules/es.typed-array.iterator.js": 365, "core-js/modules/es.typed-array.join.js": 366, "core-js/modules/es.typed-array.last-index-of.js": 367, "core-js/modules/es.typed-array.map.js": 368, "core-js/modules/es.typed-array.reduce-right.js": 369, "core-js/modules/es.typed-array.reduce.js": 370, "core-js/modules/es.typed-array.reverse.js": 371, "core-js/modules/es.typed-array.set.js": 372, "core-js/modules/es.typed-array.slice.js": 373, "core-js/modules/es.typed-array.some.js": 374, "core-js/modules/es.typed-array.sort.js": 375, "core-js/modules/es.typed-array.subarray.js": 376, "core-js/modules/es.typed-array.to-locale-string.js": 377, "core-js/modules/es.typed-array.to-string.js": 378, "core-js/modules/es.typed-array.uint8-array.js": 379, "core-js/modules/web.dom-collections.for-each.js": 380, "inherits": 407, "readable-stream": 463 }], 543: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        require2("core-js/modules/es.regexp.exec.js");
        require2("core-js/modules/es.string.search.js");
        require2("core-js/modules/es.array.concat.js");
        require2("core-js/modules/es.string.split.js");
        require2("core-js/modules/es.string.replace.js");
        require2("core-js/modules/es.array.join.js");
        require2("core-js/modules/es.string.trim.js");
        require2("core-js/modules/es.string.match.js");
        require2("core-js/modules/es.array.slice.js");
        require2("core-js/modules/es.object.keys.js");
        require2("core-js/modules/es.array.splice.js");
        var punycode = require2("punycode");
        var util = require2("./util");
        exports3.parse = urlParse;
        exports3.resolve = urlResolve;
        exports3.resolveObject = urlResolveObject;
        exports3.format = urlFormat;
        exports3.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
          javascript: true,
          "javascript:": true
        }, hostlessProtocol = {
          javascript: true,
          "javascript:": true
        }, slashedProtocol = {
          http: true,
          https: true,
          ftp: true,
          gopher: true,
          file: true,
          "http:": true,
          "https:": true,
          "ftp:": true,
          "gopher:": true,
          "file:": true
        }, querystring2 = require2("querystring");
        function urlParse(url2, parseQueryString, slashesDenoteHost) {
          if (url2 && util.isObject(url2) && url2 instanceof Url)
            return url2;
          var u2 = new Url();
          u2.parse(url2, parseQueryString, slashesDenoteHost);
          return u2;
        }
        Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
          if (!util.isString(url2)) {
            throw new TypeError("Parameter 'url' must be a string, not " + (0, _typeof2.default)(url2));
          }
          var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, "/");
          url2 = uSplit.join(splitter);
          var rest = url2;
          rest = rest.trim();
          if (!slashesDenoteHost && url2.split("#").length === 1) {
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring2.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              return this;
            }
          }
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === "//";
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            var auth, atSign;
            if (hostEnd === -1) {
              atSign = rest.lastIndexOf("@");
            } else {
              atSign = rest.lastIndexOf("@", hostEnd);
            }
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            if (hostEnd === -1)
              hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            this.parseHost();
            this.hostname = this.hostname || "";
            var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(".");
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part)
                  continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = "";
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      newpart += "x";
                    } else {
                      newpart += part[j];
                    }
                  }
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = "/" + notHost.join(".") + rest;
                    }
                    this.hostname = validParts.join(".");
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = "";
            } else {
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              this.hostname = punycode.toASCII(this.hostname);
            }
            var p2 = this.port ? ":" + this.port : "";
            var h = this.hostname || "";
            this.host = h + p2;
            this.href += this.host;
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== "/") {
                rest = "/" + rest;
              }
            }
          }
          if (!unsafeProtocol[lowerProto]) {
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              if (rest.indexOf(ae) === -1)
                continue;
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }
          var hash = rest.indexOf("#");
          if (hash !== -1) {
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf("?");
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring2.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          if (rest)
            this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = "/";
          }
          if (this.pathname || this.search) {
            var p2 = this.pathname || "";
            var s2 = this.search || "";
            this.path = p2 + s2;
          }
          this.href = this.format();
          return this;
        };
        function urlFormat(obj) {
          if (util.isString(obj))
            obj = urlParse(obj);
          if (!(obj instanceof Url))
            return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function() {
          var auth = this.auth || "";
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ":");
            auth += "@";
          }
          var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host2 = false, query = "";
          if (this.host) {
            host2 = auth + this.host;
          } else if (this.hostname) {
            host2 = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
            if (this.port) {
              host2 += ":" + this.port;
            }
          }
          if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
            query = querystring2.stringify(this.query);
          }
          var search2 = this.search || query && "?" + query || "";
          if (protocol && protocol.substr(-1) !== ":")
            protocol += ":";
          if (this.slashes || (!protocol || slashedProtocol[protocol]) && host2 !== false) {
            host2 = "//" + (host2 || "");
            if (pathname && pathname.charAt(0) !== "/")
              pathname = "/" + pathname;
          } else if (!host2) {
            host2 = "";
          }
          if (hash && hash.charAt(0) !== "#")
            hash = "#" + hash;
          if (search2 && search2.charAt(0) !== "?")
            search2 = "?" + search2;
          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match);
          });
          search2 = search2.replace("#", "%23");
          return protocol + host2 + pathname + search2 + hash;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source)
            return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
          if (util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }
          result.hash = relative.hash;
          if (relative.href === "") {
            result.href = result.format();
            return result;
          }
          if (relative.slashes && !relative.protocol) {
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== "protocol")
                result[rkey] = relative[rkey];
            }
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
              }
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || "").split("/");
              while (relPath.length && !(relative.host = relPath.shift()))
                ;
              if (!relative.host)
                relative.host = "";
              if (!relative.hostname)
                relative.hostname = "";
              if (relPath[0] !== "")
                relPath.unshift("");
              if (relPath.length < 2)
                relPath.unshift("");
              result.pathname = relPath.join("/");
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
              var p2 = result.pathname || "";
              var s2 = result.search || "";
              result.path = p2 + s2;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
          if (psychotic) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
              if (srcPath[0] === "")
                srcPath[0] = result.host;
              else
                srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === "")
                  relPath[0] = relative.host;
                else
                  relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
          }
          if (isRelAbs) {
            result.host = relative.host || relative.host === "" ? relative.host : result.host;
            result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
          } else if (relPath.length) {
            if (!srcPath)
              srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util.isNullOrUndefined(relative.search)) {
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
              result.path = "/" + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === ".") {
              srcPath.splice(i, 1);
            } else if (last === "..") {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift("..");
            }
          }
          if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
          }
          if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
          }
          var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || result.host && srcPath.length;
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join("/");
          }
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function() {
          var host2 = this.host;
          var port = portPattern.exec(host2);
          if (port) {
            port = port[0];
            if (port !== ":") {
              this.port = port.substr(1);
            }
            host2 = host2.substr(0, host2.length - port.length);
          }
          if (host2)
            this.hostname = host2;
        };
      }, { "./util": 544, "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/helpers/typeof": 91, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.array.join.js": 317, "core-js/modules/es.array.slice.js": 319, "core-js/modules/es.array.splice.js": 321, "core-js/modules/es.object.keys.js": 328, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.match.js": 344, "core-js/modules/es.string.replace.js": 345, "core-js/modules/es.string.search.js": 346, "core-js/modules/es.string.split.js": 347, "core-js/modules/es.string.trim.js": 349, "punycode": 443, "querystring": 451 }], 544: [function(require2, module3, exports3) {
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        module3.exports = {
          isString: function isString2(arg) {
            return typeof arg === "string";
          },
          isObject: function isObject2(arg) {
            return (0, _typeof2.default)(arg) === "object" && arg !== null;
          },
          isNull: function isNull(arg) {
            return arg === null;
          },
          isNullOrUndefined: function isNullOrUndefined(arg) {
            return arg == null;
          }
        };
      }, { "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/helpers/typeof": 91 }], 545: [function(require2, module3, exports3) {
        require2("core-js/modules/es.number.constructor.js");
        exports3.encodeURIComponent = function(text2) {
          try {
            return encodeURIComponent(text2);
          } catch (e2) {
            return text2;
          }
        };
        exports3.escape = require2("escape-html");
        exports3.timestamp = function timestamp(t2) {
          if (t2) {
            var v = t2;
            if (typeof v === "string") {
              v = Number(v);
            }
            if (String(t2).length === 10) {
              v *= 1e3;
            }
            return new Date(v);
          }
          return Math.round(Date.now() / 1e3);
        };
      }, { "core-js/modules/es.number.constructor.js": 324, "escape-html": 385 }], 546: [function(require2, module3, exports3) {
        (function(process, Buffer2) {
          (function() {
            var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
            var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
            require2("core-js/modules/es.string.trim.js");
            require2("core-js/modules/es.object.to-string.js");
            require2("core-js/modules/es.promise.js");
            require2("core-js/modules/es.regexp.exec.js");
            require2("core-js/modules/es.function.name.js");
            require2("core-js/modules/es.array.concat.js");
            var util = require2("util");
            var urlutil = require2("url");
            var http = require2("http");
            var https = require2("https");
            var debug = require2("debug")("urllib");
            var ms = require2("humanize-ms");
            var REQUEST_ID = 0;
            var MAX_VALUE = Math.pow(2, 31) - 10;
            var PROTO_RE = /^https?:\/\//i;
            function getAgent(agent, defaultAgent) {
              return agent === void 0 ? defaultAgent : agent;
            }
            function parseContentType(str) {
              if (!str) {
                return "";
              }
              return str.split(";")[0].trim().toLowerCase();
            }
            function makeCallback(resolve2, reject) {
              return function(err, data, res) {
                if (err) {
                  return reject(err);
                }
                resolve2({
                  data,
                  status: res.statusCode,
                  headers: res.headers,
                  res
                });
              };
            }
            exports3.TIMEOUTS = [ms("300s"), ms("300s")];
            var TEXT_DATA_TYPES = ["json", "text"];
            exports3.request = function request(url2, args, callback) {
              if (arguments.length === 2 && typeof args === "function") {
                callback = args;
                args = null;
              }
              if (typeof callback === "function") {
                return exports3.requestWithCallback(url2, args, callback);
              }
              return new Promise(function(resolve2, reject) {
                exports3.requestWithCallback(url2, args, makeCallback(resolve2, reject));
              });
            };
            exports3.requestWithCallback = function requestWithCallback(url2, args, callback) {
              if (!url2 || typeof url2 !== "string" && (0, _typeof2.default)(url2) !== "object") {
                var msg = util.format("expect request url to be a string or a http request options, but got %j", url2);
                throw new Error(msg);
              }
              if (arguments.length === 2 && typeof args === "function") {
                callback = args;
                args = null;
              }
              args = args || {};
              if (REQUEST_ID >= MAX_VALUE) {
                REQUEST_ID = 0;
              }
              var reqId = ++REQUEST_ID;
              args.requestUrls = args.requestUrls || [];
              var reqMeta = {
                requestId: reqId,
                url: url2,
                args,
                ctx: args.ctx
              };
              if (args.emitter) {
                args.emitter.emit("request", reqMeta);
              }
              args.timeout = args.timeout || exports3.TIMEOUTS;
              args.maxRedirects = args.maxRedirects || 10;
              args.streaming = args.streaming || args.customResponse;
              var requestStartTime = Date.now();
              var parsedUrl;
              if (typeof url2 === "string") {
                if (!PROTO_RE.test(url2)) {
                  url2 = "https://" + url2;
                }
                parsedUrl = urlutil.parse(url2);
              } else {
                parsedUrl = url2;
              }
              var method = (args.type || args.method || parsedUrl.method || "GET").toUpperCase();
              var port = parsedUrl.port || 80;
              var httplib = http;
              var agent = getAgent(args.agent, exports3.agent);
              var fixJSONCtlChars = args.fixJSONCtlChars;
              if (parsedUrl.protocol === "https:") {
                httplib = https;
                agent = getAgent(args.httpsAgent, exports3.httpsAgent);
                if (!parsedUrl.port) {
                  port = 443;
                }
              }
              var options = {
                host: parsedUrl.hostname || parsedUrl.host || "localhost",
                path: parsedUrl.path || "/",
                method,
                port,
                agent,
                headers: args.headers || {},
                // default is dns.lookup
                // https://github.com/nodejs/node/blob/master/lib/net.js#L986
                // custom dnslookup require node >= 4.0.0
                // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952
                lookup: args.lookup
              };
              if (Array.isArray(args.timeout)) {
                options.requestTimeout = args.timeout[args.timeout.length - 1];
              } else if (typeof args.timeout !== "undefined") {
                options.requestTimeout = args.timeout;
              }
              var auth = args.auth || parsedUrl.auth;
              if (auth) {
                options.auth = auth;
              }
              var body = args.content || args.data;
              var dataAsQueryString = method === "GET" || method === "HEAD" || args.dataAsQueryString;
              if (!args.content) {
                if (body && !(typeof body === "string" || Buffer2.isBuffer(body))) {
                  if (dataAsQueryString) {
                    body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
                  } else {
                    var contentType = options.headers["Content-Type"] || options.headers["content-type"];
                    if (!contentType) {
                      if (args.contentType === "json") {
                        contentType = "application/json";
                      } else {
                        contentType = "application/x-www-form-urlencoded";
                      }
                      options.headers["Content-Type"] = contentType;
                    }
                    if (parseContentType(contentType) === "application/json") {
                      body = JSON.stringify(body);
                    } else {
                      body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
                    }
                  }
                }
              }
              if (dataAsQueryString && body) {
                options.path += (parsedUrl.query ? "&" : "?") + body;
                body = null;
              }
              var requestSize = 0;
              if (body) {
                var length = body.length;
                if (!Buffer2.isBuffer(body)) {
                  length = Buffer2.byteLength(body);
                }
                requestSize = options.headers["Content-Length"] = length;
              }
              if (args.dataType === "json") {
                options.headers.Accept = "application/json";
              }
              if (typeof args.beforeRequest === "function") {
                args.beforeRequest(options);
              }
              var connectTimer = null;
              var responseTimer = null;
              var __err = null;
              var connected = false;
              var keepAliveSocket = false;
              var responseSize = 0;
              var statusCode = -1;
              var responseAborted = false;
              var remoteAddress = "";
              var remotePort = "";
              var timing = null;
              if (args.timing) {
                timing = {
                  // socket assigned
                  queuing: 0,
                  // dns lookup time
                  dnslookup: 0,
                  // socket connected
                  connected: 0,
                  // request sent
                  requestSent: 0,
                  // Time to first byte (TTFB)
                  waiting: 0,
                  contentDownload: 0
                };
              }
              function cancelConnectTimer() {
                if (connectTimer) {
                  clearTimeout(connectTimer);
                  connectTimer = null;
                }
              }
              function cancelResponseTimer() {
                if (responseTimer) {
                  clearTimeout(responseTimer);
                  responseTimer = null;
                }
              }
              function done(err, data, res) {
                cancelResponseTimer();
                if (!callback) {
                  index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:43675", "[urllib:warn] [%s] [%s] [worker:%s] %s %s callback twice!!!", Date(), reqId, process.pid, options.method, url2);
                  if (err) {
                    index$2.__f__("warn", "at node_modules/ali-oss/dist/aliyun-oss-sdk.js:43678", "[urllib:warn] [%s] [%s] [worker:%s] %s: %s\nstack: %s", Date(), reqId, process.pid, err.name, err.message, err.stack);
                  }
                  return;
                }
                var cb = callback;
                callback = null;
                var headers = {};
                if (res) {
                  statusCode = res.statusCode;
                  headers = res.headers;
                }
                var requestUseTime = Date.now() - requestStartTime;
                if (timing) {
                  timing.contentDownload = requestUseTime;
                }
                debug("[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j", requestUseTime, responseSize, statusCode, options.method, options.host, options.path, keepAliveSocket, timing);
                var response = {
                  status: statusCode,
                  statusCode,
                  headers,
                  size: responseSize,
                  aborted: responseAborted,
                  rt: requestUseTime,
                  keepAliveSocket,
                  data,
                  requestUrls: args.requestUrls,
                  timing,
                  remoteAddress,
                  remotePort
                };
                if (err) {
                  var agentStatus = "";
                  if (agent && typeof agent.getCurrentStatus === "function") {
                    agentStatus = ", agent status: " + JSON.stringify(agent.getCurrentStatus());
                  }
                  err.message += ", " + options.method + " " + url2 + " " + statusCode + " (connected: " + connected + ", keepalive socket: " + keepAliveSocket + agentStatus + ")\nheaders: " + JSON.stringify(headers);
                  err.data = data;
                  err.path = options.path;
                  err.status = statusCode;
                  err.headers = headers;
                  err.res = response;
                }
                cb(err, data, args.streaming ? res : response);
                if (args.emitter) {
                  reqMeta.url = url2;
                  reqMeta.socket = req && req.connection;
                  reqMeta.options = options;
                  reqMeta.size = requestSize;
                  args.emitter.emit("response", {
                    requestId: reqId,
                    error: err,
                    ctx: args.ctx,
                    req: reqMeta,
                    res: response
                  });
                }
              }
              function handleRedirect(res) {
                var err = null;
                if (args.followRedirect && statuses.redirect[res.statusCode]) {
                  args._followRedirectCount = (args._followRedirectCount || 0) + 1;
                  var location2 = res.headers.location;
                  if (!location2) {
                    err = new Error("Got statusCode " + res.statusCode + " but cannot resolve next location from headers");
                    err.name = "FollowRedirectError";
                  } else if (args._followRedirectCount > args.maxRedirects) {
                    err = new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + url2);
                    err.name = "MaxRedirectError";
                  } else {
                    var newUrl = args.formatRedirectUrl ? args.formatRedirectUrl(url2, location2) : urlutil.resolve(url2, location2);
                    debug("Request#%d %s: `redirected` from %s to %s", reqId, options.path, url2, newUrl);
                    cancelResponseTimer();
                    if (args.headers && args.headers.Host && PROTO_RE.test(location2)) {
                      args.headers.Host = null;
                    }
                    var cb = callback;
                    callback = null;
                    exports3.requestWithCallback(newUrl, args, cb);
                    return {
                      redirect: true,
                      error: null
                    };
                  }
                }
                return {
                  redirect: false,
                  error: err
                };
              }
              if (args.gzip) {
                if (!options.headers["Accept-Encoding"] && !options.headers["accept-encoding"]) {
                  options.headers["Accept-Encoding"] = "gzip";
                }
              }
              function decodeContent(res, body2, cb) {
                var encoding = res.headers["content-encoding"];
                return cb(null, body2, encoding);
              }
              var writeStream = args.writeStream;
              debug("Request#%d %s %s with headers %j, options.path: %s", reqId, method, url2, options.headers, options.path);
              args.requestUrls.push(url2);
              function onResponse(res) {
                if (timing) {
                  timing.waiting = Date.now() - requestStartTime;
                }
                debug("Request#%d %s `req response` event emit: status %d, headers: %j", reqId, url2, res.statusCode, res.headers);
                if (args.streaming) {
                  var result = handleRedirect(res);
                  if (result.redirect) {
                    res.resume();
                    return;
                  }
                  if (result.error) {
                    res.resume();
                    return done(result.error, null, res);
                  }
                  return done(null, null, res);
                }
                res.on("close", function() {
                  debug("Request#%d %s: `res close` event emit, total size %d", reqId, url2, responseSize);
                });
                res.on("error", function() {
                  debug("Request#%d %s: `res error` event emit, total size %d", reqId, url2, responseSize);
                });
                res.on("aborted", function() {
                  responseAborted = true;
                  debug("Request#%d %s: `res aborted` event emit, total size %d", reqId, url2, responseSize);
                });
                if (writeStream) {
                  var _result = handleRedirect(res);
                  if (_result.redirect) {
                    res.resume();
                    return;
                  }
                  if (_result.error) {
                    res.resume();
                    writeStream.end();
                    return done(_result.error, null, res);
                  }
                  if (args.consumeWriteStream === false) {
                    res.on("end", done.bind(null, null, null, res));
                  } else {
                    {
                      writeStream.on("close", function() {
                        debug("Request#%d %s: writeStream close event emitted", reqId, url2);
                        done(__err || null, null, res);
                      });
                    }
                  }
                  return res.pipe(writeStream);
                }
                var chunks = [];
                res.on("data", function(chunk) {
                  debug("Request#%d %s: `res data` event emit, size %d", reqId, url2, chunk.length);
                  responseSize += chunk.length;
                  chunks.push(chunk);
                });
                res.on("end", function() {
                  var body2 = Buffer2.concat(chunks, responseSize);
                  debug("Request#%d %s: `res end` event emit, total size %d, _dumped: %s", reqId, url2, responseSize, res._dumped);
                  if (__err) {
                    return done(__err, body2, res);
                  }
                  var result2 = handleRedirect(res);
                  if (result2.error) {
                    return done(result2.error, body2, res);
                  }
                  if (result2.redirect) {
                    return;
                  }
                  decodeContent(res, body2, function(err, data, encoding) {
                    if (err) {
                      return done(err, body2, res);
                    }
                    if (!encoding && TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {
                      try {
                        data = decodeBodyByCharset(data, res);
                      } catch (e2) {
                        debug("decodeBodyByCharset error: %s", e2);
                        return done(null, data, res);
                      }
                      if (args.dataType === "json") {
                        if (responseSize === 0) {
                          data = null;
                        } else {
                          var r = parseJSON(data, fixJSONCtlChars);
                          if (r.error) {
                            err = r.error;
                          } else {
                            data = r.data;
                          }
                        }
                      }
                    }
                    if (responseAborted) {
                      debug("Request#%d %s: Remote socket was terminated before `response.end()` was called", reqId, url2);
                    }
                    done(err, data, res);
                  });
                });
              }
              var connectTimeout, responseTimeout;
              if (Array.isArray(args.timeout)) {
                connectTimeout = ms(args.timeout[0]);
                responseTimeout = ms(args.timeout[1]);
              } else {
                connectTimeout = responseTimeout = ms(args.timeout);
              }
              debug("ConnectTimeout: %d, ResponseTimeout: %d", connectTimeout, responseTimeout);
              function startConnectTimer() {
                debug("Connect timer ticking, timeout: %d", connectTimeout);
                connectTimer = setTimeout(function() {
                  connectTimer = null;
                  if (statusCode === -1) {
                    statusCode = -2;
                  }
                  var msg2 = "Connect timeout for " + connectTimeout + "ms";
                  var errorName = "ConnectionTimeoutError";
                  if (!req.socket) {
                    errorName = "SocketAssignTimeoutError";
                    msg2 += ", working sockets is full";
                  }
                  __err = new Error(msg2);
                  __err.name = errorName;
                  __err.requestId = reqId;
                  debug("ConnectTimeout: Request#%d %s %s: %s, connected: %s", reqId, url2, __err.name, msg2, connected);
                  abortRequest();
                }, connectTimeout);
              }
              function startResposneTimer() {
                debug("Response timer ticking, timeout: %d", responseTimeout);
                responseTimer = setTimeout(function() {
                  responseTimer = null;
                  var msg2 = "Response timeout for " + responseTimeout + "ms";
                  var errorName = "ResponseTimeoutError";
                  __err = new Error(msg2);
                  __err.name = errorName;
                  __err.requestId = reqId;
                  debug("ResponseTimeout: Request#%d %s %s: %s, connected: %s", reqId, url2, __err.name, msg2, connected);
                  abortRequest();
                }, responseTimeout);
              }
              var req;
              options.mode = args.mode ? args.mode : "";
              try {
                req = httplib.request(options, onResponse);
              } catch (err) {
                return done(err);
              }
              if (typeof window === "undefined") {
                startConnectTimer();
              } else {
                req.on("requestTimeout", function() {
                  if (statusCode === -1) {
                    statusCode = -2;
                  }
                  var msg2 = "Connect timeout for " + connectTimeout + "ms";
                  var errorName = "ConnectionTimeoutError";
                  __err = new Error(msg2);
                  __err.name = errorName;
                  __err.requestId = reqId;
                  abortRequest();
                });
              }
              function abortRequest() {
                debug("Request#%d %s abort, connected: %s", reqId, url2, connected);
                if (!req.socket) {
                  __err.noSocket = true;
                  done(__err);
                }
                req.abort();
              }
              if (timing) {
                req.on("finish", function() {
                  timing.requestSent = Date.now() - requestStartTime;
                });
              }
              req.once("socket", function(socket) {
                if (timing) {
                  timing.queuing = Date.now() - requestStartTime;
                }
                var readyState = socket.readyState;
                if (readyState === "opening") {
                  socket.once("lookup", function(err, ip, addressType) {
                    debug("Request#%d %s lookup: %s, %s, %s", reqId, url2, err, ip, addressType);
                    if (timing) {
                      timing.dnslookup = Date.now() - requestStartTime;
                    }
                    if (ip) {
                      remoteAddress = ip;
                    }
                  });
                  socket.once("connect", function() {
                    if (timing) {
                      timing.connected = Date.now() - requestStartTime;
                    }
                    cancelConnectTimer();
                    startResposneTimer();
                    debug("Request#%d %s new socket connected", reqId, url2);
                    connected = true;
                    if (!remoteAddress) {
                      remoteAddress = socket.remoteAddress;
                    }
                    remotePort = socket.remotePort;
                  });
                  return;
                }
                debug("Request#%d %s reuse socket connected, readyState: %s", reqId, url2, readyState);
                connected = true;
                keepAliveSocket = true;
                if (!remoteAddress) {
                  remoteAddress = socket.remoteAddress;
                }
                remotePort = socket.remotePort;
                cancelConnectTimer();
                startResposneTimer();
              });
              req.on("error", function(err) {
                if (err.name === "Error" || err.name === "TypeError") {
                  err.name = connected ? "ResponseError" : "RequestError";
                }
                err.message += ' (req "error")';
                debug("Request#%d %s `req error` event emit, %s: %s", reqId, url2, err.name, err.message);
                done(__err || err);
              });
              if (writeStream) {
                writeStream.once("error", function(err) {
                  err.message += ' (writeStream "error")';
                  __err = err;
                  debug("Request#%d %s `writeStream error` event emit, %s: %s", reqId, url2, err.name, err.message);
                  abortRequest();
                });
              }
              if (args.stream) {
                args.stream.pipe(req);
                args.stream.once("error", function(err) {
                  err.message += ' (stream "error")';
                  __err = err;
                  debug("Request#%d %s `readStream error` event emit, %s: %s", reqId, url2, err.name, err.message);
                  abortRequest();
                });
              } else {
                req.end(body);
              }
              req.requestId = reqId;
              return req;
            };
          }).call(this);
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 86, "@babel/runtime/helpers/typeof": 91, "_process": 538, "buffer": 103, "core-js/modules/es.array.concat.js": 310, "core-js/modules/es.function.name.js": 322, "core-js/modules/es.object.to-string.js": 329, "core-js/modules/es.promise.js": 333, "core-js/modules/es.regexp.exec.js": 338, "core-js/modules/es.string.trim.js": 349, "debug": 536, "http": 539, "https": 398, "humanize-ms": 399, "url": 543, "util": 489 }] }, {}, [1])(1);
    });
  })(window);
})(aliyunOssSdk$1);
var aliyunOssSdkExports = aliyunOssSdk$1.exports;
const OSS = /* @__PURE__ */ getDefaultExportFromCjs(aliyunOssSdkExports);
const aliyunOssSdk = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: OSS
}, [aliyunOssSdkExports]);
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size2 = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size2 |= 0));
  while (size2--) {
    id += urlAlphabet[bytes[size2] & 63];
  }
  return id;
};
var browser$1 = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode = {};
var utils$1 = {};
let toSJISFunction;
const CODEWORDS_COUNT = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$1.getSymbolSize = function getSymbolSize(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT[version2];
};
utils$1.getBCHDigit = function(data) {
  let digit = 0;
  while (data !== 0) {
    digit++;
    data >>>= 1;
  }
  return digit;
};
utils$1.setToSJISFunction = function setToSJISFunction(f2) {
  if (typeof f2 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f2;
};
utils$1.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
utils$1.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction(kanji2);
};
var errorCorrectionLevel = {};
(function(exports2) {
  exports2.L = { bit: 1 };
  exports2.M = { bit: 0 };
  exports2.Q = { bit: 3 };
  exports2.H = { bit: 2 };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports2.L;
      case "m":
      case "medium":
        return exports2.M;
      case "q":
      case "quartile":
        return exports2.Q;
      case "h":
      case "high":
        return exports2.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports2.isValid = function isValid2(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports2.from = function from(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    const bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit((num >>> length - i - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = new Uint8Array(size2 * size2);
  this.reservedBit = new Uint8Array(size2 * size2);
}
BitMatrix$1.prototype.set = function(row2, col2, value, reserved) {
  const index2 = row2 * this.size + col2;
  this.data[index2] = value;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row2, col2) {
  return this.data[row2 * this.size + col2];
};
BitMatrix$1.prototype.xor = function(row2, col2, value) {
  this.data[row2 * this.size + col2] ^= value;
};
BitMatrix$1.prototype.isReserved = function(row2, col2) {
  return this.reservedBit[row2 * this.size + col2];
};
var bitMatrix = BitMatrix$1;
var alignmentPattern = {};
(function(exports2) {
  const getSymbolSize3 = utils$1.getSymbolSize;
  exports2.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size2 = getSymbolSize3(version2);
    const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    const positions = [size2 - 7];
    for (let i = 1; i < posCount - 1; i++) {
      positions[i] = positions[i - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports2.getPositions = function getPositions2(version2) {
    const coords = [];
    const pos = exports2.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i = 0; i < posLength; i++) {
      for (let j = 0; j < posLength; j++) {
        if (i === 0 && j === 0 || // top-left
        i === 0 && j === posLength - 1 || // bottom-left
        i === posLength - 1 && j === 0) {
          continue;
        }
        coords.push([pos[i], pos[j]]);
      }
    }
    return coords;
  };
})(alignmentPattern);
var finderPattern = {};
const getSymbolSize2 = utils$1.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function getPositions(version2) {
  const size2 = getSymbolSize2(version2);
  return [
    // top-left
    [0, 0],
    // top-right
    [size2 - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(exports2) {
  exports2.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports2.isValid = function isValid2(mask) {
    return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
  };
  exports2.from = function from(value) {
    return exports2.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports2.getPenaltyN1 = function getPenaltyN1(data) {
    const size2 = data.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row2 = 0; row2 < size2; row2++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col2 = 0; col2 < size2; col2++) {
        let module2 = data.get(row2, col2);
        if (module2 === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module2;
          sameCountCol = 1;
        }
        module2 = data.get(col2, row2);
        if (module2 === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module2;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports2.getPenaltyN2 = function getPenaltyN2(data) {
    const size2 = data.size;
    let points = 0;
    for (let row2 = 0; row2 < size2 - 1; row2++) {
      for (let col2 = 0; col2 < size2 - 1; col2++) {
        const last = data.get(row2, col2) + data.get(row2, col2 + 1) + data.get(row2 + 1, col2) + data.get(row2 + 1, col2 + 1);
        if (last === 4 || last === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports2.getPenaltyN3 = function getPenaltyN3(data) {
    const size2 = data.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row2 = 0; row2 < size2; row2++) {
      bitsCol = bitsRow = 0;
      for (let col2 = 0; col2 < size2; col2++) {
        bitsCol = bitsCol << 1 & 2047 | data.get(row2, col2);
        if (col2 >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data.get(col2, row2);
        if (col2 >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports2.getPenaltyN4 = function getPenaltyN4(data) {
    let darkCount = 0;
    const modulesCount = data.data.length;
    for (let i = 0; i < modulesCount; i++)
      darkCount += data.data[i];
    const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i, j) {
    switch (maskPattern2) {
      case exports2.Patterns.PATTERN000:
        return (i + j) % 2 === 0;
      case exports2.Patterns.PATTERN001:
        return i % 2 === 0;
      case exports2.Patterns.PATTERN010:
        return j % 3 === 0;
      case exports2.Patterns.PATTERN011:
        return (i + j) % 3 === 0;
      case exports2.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
      case exports2.Patterns.PATTERN101:
        return i * j % 2 + i * j % 3 === 0;
      case exports2.Patterns.PATTERN110:
        return (i * j % 2 + i * j % 3) % 2 === 0;
      case exports2.Patterns.PATTERN111:
        return (i * j % 3 + (i + j) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports2.applyMask = function applyMask(pattern, data) {
    const size2 = data.size;
    for (let col2 = 0; col2 < size2; col2++) {
      for (let row2 = 0; row2 < size2; row2++) {
        if (data.isReserved(row2, col2))
          continue;
        data.xor(row2, col2, getMaskAt(pattern, row2, col2));
      }
    }
  };
  exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
    const numPatterns = Object.keys(exports2.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports2.applyMask(p2, data);
      const penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
      exports2.applyMask(p2, data);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel;
const EC_BLOCKS_TABLE = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial = {};
var galoisField = {};
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables() {
  let x = 1;
  for (let i = 0; i < 255; i++) {
    EXP_TABLE[i] = x;
    LOG_TABLE[x] = i;
    x <<= 1;
    if (x & 256) {
      x ^= 285;
    }
  }
  for (let i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255];
  }
})();
galoisField.log = function log(n2) {
  if (n2 < 1)
    throw new Error("log(" + n2 + ")");
  return LOG_TABLE[n2];
};
galoisField.exp = function exp(n2) {
  return EXP_TABLE[n2];
};
galoisField.mul = function mul(x, y) {
  if (x === 0 || y === 0)
    return 0;
  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
};
(function(exports2) {
  const GF = galoisField;
  exports2.mul = function mul2(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i = 0; i < p1.length; i++) {
      for (let j = 0; j < p2.length; j++) {
        coeff[i + j] ^= GF.mul(p1[i], p2[j]);
      }
    }
    return coeff;
  };
  exports2.mod = function mod(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i = 0; i < divisor.length; i++) {
        result[i] ^= GF.mul(divisor[i], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports2.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i = 0; i < degree; i++) {
      poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i)]));
    }
    return poly;
  };
})(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode2(data) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data.length + this.degree);
  paddedData.set(data);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
var version = {};
var mode = {};
var versionCheck = {};
versionCheck.isValid = function isValid(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex = {};
const numeric = "[0-9]+";
const alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function testKanji(str) {
  return TEST_KANJI.test(str);
};
regex.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC.test(str);
};
regex.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC.test(str);
};
(function(exports2) {
  const VersionCheck = versionCheck;
  const Regex = regex;
  exports2.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports2.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports2.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports2.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports2.MIXED = {
    bit: -1
  };
  exports2.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports2.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports2.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports2.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports2.KANJI;
    else
      return exports2.BYTE;
  };
  exports2.toString = function toString2(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports2.isValid = function isValid2(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports2.NUMERIC;
      case "alphanumeric":
        return exports2.ALPHANUMERIC;
      case "kanji":
        return exports2.KANJI;
      case "byte":
        return exports2.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports2.from = function from(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode);
(function(exports2) {
  const Utils2 = utils$1;
  const ECCode2 = errorCorrectionCode;
  const ECLevel2 = errorCorrectionLevel;
  const Mode2 = mode;
  const VersionCheck = versionCheck;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data) {
      const reservedBits = getReservedBitsCount(data.mode, version2);
      totalBits += reservedBits + data.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports2.from = function from(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports2.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data)) {
      if (data.length > 1) {
        return getBestVersionForMixedData(data, ecl);
      }
      if (data.length === 0) {
        return 1;
      }
      seg = data[0];
    } else {
      seg = data;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports2.getEncodedBits = function getEncodedBits2(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d = version2 << 12;
    while (Utils2.getBCHDigit(d) - G18_BCH >= 0) {
      d ^= G18 << Utils2.getBCHDigit(d) - G18_BCH;
    }
    return version2 << 12 | d;
  };
})(version);
var formatInfo = {};
const Utils$3 = utils$1;
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
  const data = errorCorrectionLevel2.bit << 3 | mask;
  let d = data << 10;
  while (Utils$3.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= G15 << Utils$3.getBCHDigit(d) - G15_BCH;
  }
  return (data << 10 | d) ^ G15_MASK;
};
var segments = {};
const Mode$4 = mode;
function NumericData(data) {
  this.mode = Mode$4.NUMERIC;
  this.data = data.toString();
}
NumericData.getBitsLength = function getBitsLength(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write(bitBuffer2) {
  let i, group, value;
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  const remainingNum = this.data.length - i;
  if (remainingNum > 0) {
    group = this.data.substr(i);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
const Mode$3 = mode;
const ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data;
}
AlphanumericData.getBitsLength = function getBitsLength3(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write2(bitBuffer2) {
  let i;
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
  }
};
var alphanumericData = AlphanumericData;
const Mode$2 = mode;
function ByteData(data) {
  this.mode = Mode$2.BYTE;
  if (typeof data === "string") {
    this.data = new TextEncoder().encode(data);
  } else {
    this.data = new Uint8Array(data);
  }
}
ByteData.getBitsLength = function getBitsLength5(length) {
  return length * 8;
};
ByteData.prototype.getLength = function getLength3() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (let i = 0, l = this.data.length; i < l; i++) {
    bitBuffer2.put(this.data[i], 8);
  }
};
var byteData = ByteData;
const Mode$1 = mode;
const Utils$2 = utils$1;
function KanjiData(data) {
  this.mode = Mode$1.KANJI;
  this.data = data;
}
KanjiData.getBitsLength = function getBitsLength7(length) {
  return length * 13;
};
KanjiData.prototype.getLength = function getLength4() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  let i;
  for (i = 0; i < this.data.length; i++) {
    let value = Utils$2.toSJIS(this.data[i]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error(
        "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
      );
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData = KanjiData;
var dijkstra = { exports: {} };
(function(module2) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s2, d) {
      var predecessors = {};
      var costs = {};
      costs[s2] = 0;
      var open = dijkstra2.PriorityQueue.make();
      open.push(s2, 0);
      var closest, u2, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v)) {
            cost_of_e = adjacent_nodes[v];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v];
            first_visit = typeof costs[v] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v] = u2;
            }
          }
        }
      }
      if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
        var msg = ["Could not find a path from ", s2, " to ", d, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d) {
      var nodes = [];
      var u2 = d;
      while (u2) {
        nodes.push(u2);
        predecessors[u2];
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s2, d) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s2, d);
      return dijkstra2.extract_shortest_path_from_predecessor_list(
        predecessors,
        d
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key;
        opts = opts || {};
        for (key in T2) {
          if (T2.hasOwnProperty(key)) {
            t2[key] = T2[key];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a2, b) {
        return a2.cost - b.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(value, cost) {
        var item = { value, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module2.exports = dijkstra2;
  }
})(dijkstra);
var dijkstraExports = dijkstra.exports;
(function(exports2) {
  const Mode2 = mode;
  const NumericData2 = numericData;
  const AlphanumericData2 = alphanumericData;
  const ByteData2 = byteData;
  const KanjiData2 = kanjiData;
  const Regex = regex;
  const Utils2 = utils$1;
  const dijkstra2 = dijkstraExports;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i = 0; i < segs.length; i++) {
      const seg = segs[i];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i = 0; i < nodes.length; i++) {
      const nodeGroup = nodes[i];
      const currentNodeIds = [];
      for (let j = 0; j < nodeGroup.length; j++) {
        const node = nodeGroup[j];
        const key = "" + i + j;
        currentNodeIds.push(key);
        table[key] = { node, lastCount: 0 };
        graph[key] = {};
        for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
          const prevNodeId = prevNodeIds[n2];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
            table[prevNodeId].lastCount += node.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node.length;
            graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode2.getCharCountIndicator(node.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
      graph[prevNodeIds[n2]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data);
      case Mode2.KANJI:
        return new KanjiData2(data);
      case Mode2.BYTE:
        return new ByteData2(data);
    }
  }
  exports2.fromArray = function fromArray(array2) {
    return array2.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports2.fromString = function fromString(data, version2) {
    const segs = getSegmentsFromString(data, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra2.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i = 1; i < path.length - 1; i++) {
      optimizedSegs.push(graph.table[path[i]].node);
    }
    return exports2.fromArray(mergeSegments(optimizedSegs));
  };
  exports2.rawSplit = function rawSplit(data) {
    return exports2.fromArray(
      getSegmentsFromString(data, Utils2.isKanjiModeEnabled())
    );
  };
})(segments);
const Utils$1 = utils$1;
const ECLevel = errorCorrectionLevel;
const BitBuffer = bitBuffer;
const BitMatrix = bitMatrix;
const AlignmentPattern = alignmentPattern;
const FinderPattern = finderPattern;
const MaskPattern = maskPattern;
const ECCode = errorCorrectionCode;
const ReedSolomonEncoder = reedSolomonEncoder;
const Version = version;
const FormatInfo = formatInfo;
const Mode = mode;
const Segments = segments;
function setupFinderPattern(matrix2, version2) {
  const size2 = matrix2.size;
  const pos = FinderPattern.getPositions(version2);
  for (let i = 0; i < pos.length; i++) {
    const row2 = pos[i][0];
    const col2 = pos[i][1];
    for (let r = -1; r <= 7; r++) {
      if (row2 + r <= -1 || size2 <= row2 + r)
        continue;
      for (let c = -1; c <= 7; c++) {
        if (col2 + c <= -1 || size2 <= col2 + c)
          continue;
        if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
          matrix2.set(row2 + r, col2 + c, true, true);
        } else {
          matrix2.set(row2 + r, col2 + c, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix2) {
  const size2 = matrix2.size;
  for (let r = 8; r < size2 - 8; r++) {
    const value = r % 2 === 0;
    matrix2.set(r, 6, value, true);
    matrix2.set(6, r, value, true);
  }
}
function setupAlignmentPattern(matrix2, version2) {
  const pos = AlignmentPattern.getPositions(version2);
  for (let i = 0; i < pos.length; i++) {
    const row2 = pos[i][0];
    const col2 = pos[i][1];
    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
          matrix2.set(row2 + r, col2 + c, true, true);
        } else {
          matrix2.set(row2 + r, col2 + c, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix2, version2) {
  const size2 = matrix2.size;
  const bits = Version.getEncodedBits(version2);
  let row2, col2, mod;
  for (let i = 0; i < 18; i++) {
    row2 = Math.floor(i / 3);
    col2 = i % 3 + size2 - 8 - 3;
    mod = (bits >> i & 1) === 1;
    matrix2.set(row2, col2, mod, true);
    matrix2.set(col2, row2, mod, true);
  }
}
function setupFormatInfo(matrix2, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix2.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i, mod;
  for (i = 0; i < 15; i++) {
    mod = (bits >> i & 1) === 1;
    if (i < 6) {
      matrix2.set(i, 8, mod, true);
    } else if (i < 8) {
      matrix2.set(i + 1, 8, mod, true);
    } else {
      matrix2.set(size2 - 15 + i, 8, mod, true);
    }
    if (i < 8) {
      matrix2.set(8, size2 - i - 1, mod, true);
    } else if (i < 9) {
      matrix2.set(8, 15 - i - 1 + 1, mod, true);
    } else {
      matrix2.set(8, 15 - i - 1, mod, true);
    }
  }
  matrix2.set(size2 - 8, 8, 1, true);
}
function setupData(matrix2, data) {
  const size2 = matrix2.size;
  let inc = -1;
  let row2 = size2 - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col2 = size2 - 1; col2 > 0; col2 -= 2) {
    if (col2 === 6)
      col2--;
    while (true) {
      for (let c = 0; c < 2; c++) {
        if (!matrix2.isReserved(row2, col2 - c)) {
          let dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix2.set(row2, col2 - c, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row2 += inc;
      if (row2 < 0 || size2 <= row2) {
        row2 -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer();
  segments2.forEach(function(data) {
    buffer2.put(data.mode.bit, 4);
    buffer2.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
    data.write(buffer2);
  });
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i = 0; i < remainingByte; i++) {
    buffer2.put(i % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs = new ReedSolomonEncoder(ecCount);
  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b = 0; b < ecTotalBlocks; b++) {
    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b] = buffer2.slice(offset, offset + dataSize);
    ecData[b] = rs.encode(dcData[b]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data = new Uint8Array(totalCodewords);
  let index2 = 0;
  let i, r;
  for (i = 0; i < maxDataSize; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      if (i < dcData[r].length) {
        data[index2++] = dcData[r][i];
      }
    }
  }
  for (i = 0; i < ecCount; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      data[index2++] = ecData[r][i];
    }
  }
  return data;
}
function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data)) {
    segments2 = Segments.fromArray(data);
  } else if (typeof data === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error(
      "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
    );
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$1.getSymbolSize(version2);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(
      modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
    );
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode.create = function create(data, options) {
  if (typeof data === "undefined" || data === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel.M;
  let version2;
  let mask;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data, version2, errorCorrectionLevel2, mask);
};
var canvas = {};
var utils = {};
(function(exports2) {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
        return [c, c];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue >> 24 & 255,
      g: hexValue >> 16 & 255,
      b: hexValue >> 8 & 255,
      a: hexValue & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports2.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : void 0;
    const scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports2.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports2.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports2.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size2 = qr.modules.size;
    const data = qr.modules.data;
    const scale = exports2.getScale(size2, opts);
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i = 0; i < symbolSize; i++) {
      for (let j = 0; j < symbolSize; j++) {
        let posDst = (i * symbolSize + j) * 4;
        let pxColor = opts.color.light;
        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i - scaledMargin) / scale);
          const jSrc = Math.floor((j - scaledMargin) / scale);
          pxColor = palette[data[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils);
(function(exports2) {
  const Utils2 = utils;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports2.render = function render2(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image2 = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image2.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image2, 0, 0);
    return canvasEl;
  };
  exports2.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports2.render(qrData, canvas2, opts);
    const type = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type, rendererOpts.quality);
  };
})(canvas);
var svgTag = {};
const Utils = utils;
function getColorAttrib(color2, attrib) {
  const alpha = color2.a / 255;
  const str = attrib + '="' + color2.hex + '"';
  return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x, y) {
  let str = cmd + x;
  if (typeof y !== "undefined")
    str += " " + y;
  return str;
}
function qrToPath(data, size2, margin) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i = 0; i < data.length; i++) {
    const col2 = Math.floor(i % size2);
    const row2 = Math.floor(i / size2);
    if (!col2 && !newRow)
      newRow = true;
    if (data[i]) {
      lineLength++;
      if (!(i > 0 && col2 > 0 && data[i - 1])) {
        path += newRow ? svgCmd("M", col2 + margin, 0.5 + row2 + margin) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col2 + 1 < size2 && data[i + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag.render = function render(qrData, options, cb) {
  const opts = Utils.getOptions(options);
  const size2 = qrData.modules.size;
  const data = qrData.modules.data;
  const qrcodesize = size2 + opts.margin * 2;
  const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size2, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
  if (typeof cb === "function") {
    cb(null, svgTag2);
  }
  return svgTag2;
};
const canPromise = canPromise$1;
const QRCode = qrcode;
const CanvasRenderer = canvas;
const SvgRenderer = svgTag;
function renderCanvas(renderFunc, canvas2, text2, opts, cb) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb = text2;
      text2 = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb === "undefined") {
        cb = opts;
        opts = void 0;
      } else {
        cb = opts;
        opts = text2;
        text2 = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text2 = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text2;
      text2 = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve2, reject) {
      try {
        const data = QRCode.create(text2, opts);
        resolve2(renderFunc(data, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    const data = QRCode.create(text2, opts);
    cb(null, renderFunc(data, canvas2, opts));
  } catch (e2) {
    cb(e2);
  }
}
var create2 = browser$1.create = QRCode.create;
var toCanvas = browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
var toDataURL = browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
var toString = browser$1.toString = renderCanvas.bind(null, function(data, _, opts) {
  return SvgRenderer.render(data, opts);
});
const browser = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  create: create2,
  default: browser$1,
  toCanvas,
  toDataURL,
  toString
}, [browser$1]);
exports.OSS = OSS;
exports.Pinia = Pinia;
exports._export_sfc = _export_sfc;
exports.aliyunOssSdk = aliyunOssSdk;
exports.browser = browser;
exports.computed = computed;
exports.createPinia = createPinia;
exports.createSSRApp = createSSRApp;
exports.defineComponent = defineComponent;
exports.defineStore = defineStore;
exports.e = e$1;
exports.f = f$1;
exports.getCurrentInstance = getCurrentInstance;
exports.html2canvas = html2canvas;
exports.index = index$2;
exports.index$1 = index$1;
exports.initVueI18n = initVueI18n;
exports.n = n;
exports.nanoid = nanoid;
exports.nextTick$1 = nextTick$1;
exports.o = o;
exports.onLoad = onLoad;
exports.onMounted = onMounted;
exports.onPullDownRefresh = onPullDownRefresh;
exports.onReachBottom = onReachBottom;
exports.onShareAppMessage = onShareAppMessage;
exports.onShareTimeline = onShareTimeline;
exports.onShow = onShow;
exports.onUnload = onUnload;
exports.onUnmounted = onUnmounted;
exports.p = p;
exports.reactive = reactive;
exports.ref = ref;
exports.resolveComponent = resolveComponent;
exports.s = s;
exports.sr = sr;
exports.t = t;
exports.unref = unref;
exports.watch = watch;
exports.wx$1 = wx$1;
//# sourceMappingURL=../../.sourcemap/mp-weixin/common/vendor.js.map
